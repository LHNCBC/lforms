/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  var toStringFunction = Function.prototype.toString;
  var create = Object.create,
      defineProperty = Object.defineProperty,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
      getOwnPropertyNames = Object.getOwnPropertyNames,
      getOwnPropertySymbols = Object.getOwnPropertySymbols,
      getPrototypeOf$1 = Object.getPrototypeOf;
  var _a = Object.prototype,
      hasOwnProperty = _a.hasOwnProperty,
      propertyIsEnumerable = _a.propertyIsEnumerable;
  var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';
  var WEAK_MAP = typeof WeakMap === 'function';
  /**
   * @function createCache
   *
   * @description
   * get a new cache object to prevent circular references
   *
   * @returns the new cache object
   */

  var createCache = function () {
    if (WEAK_MAP) {
      return function () {
        return new WeakMap();
      };
    }

    var Cache =
    /** @class */
    function () {
      function Cache() {
        this._keys = [];
        this._values = [];
      }

      Cache.prototype.has = function (key) {
        return !!~this._keys.indexOf(key);
      };

      Cache.prototype.get = function (key) {
        return this._values[this._keys.indexOf(key)];
      };

      Cache.prototype.set = function (key, value) {
        this._keys.push(key);

        this._values.push(value);
      };

      return Cache;
    }();

    return function () {
      return new Cache();
    };
  }();
  /**
   * @function getCleanClone
   *
   * @description
   * get an empty version of the object with the same prototype it has
   *
   * @param object the object to build a clean clone from
   * @param realm the realm the object resides in
   * @returns the empty cloned object
   */


  var getCleanClone = function (object, realm) {
    var prototype = object.__proto__ || getPrototypeOf$1(object);

    if (!prototype) {
      return create(null);
    }

    var Constructor = prototype.constructor;

    if (Constructor === realm.Object) {
      return prototype === realm.Object.prototype ? {} : create(prototype);
    }

    if (~toStringFunction.call(Constructor).indexOf('[native code]')) {
      try {
        return new Constructor();
      } catch (_a) {}
    }

    return create(prototype);
  };
  /**
   * @function getObjectCloneLoose
   *
   * @description
   * get a copy of the object based on loose rules, meaning all enumerable keys
   * and symbols are copied, but property descriptors are not considered
   *
   * @param object the object to clone
   * @param realm the realm the object resides in
   * @param handleCopy the function that handles copying the object
   * @returns the copied object
   */


  var getObjectCloneLoose = function (object, realm, handleCopy, cache) {
    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively

    cache.set(object, clone);

    for (var key in object) {
      if (hasOwnProperty.call(object, key)) {
        clone[key] = handleCopy(object[key], cache);
      }
    }

    if (SYMBOL_PROPERTIES) {
      var symbols = getOwnPropertySymbols(object);

      for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {
        symbol = symbols[index];

        if (propertyIsEnumerable.call(object, symbol)) {
          clone[symbol] = handleCopy(object[symbol], cache);
        }
      }
    }

    return clone;
  };
  /**
   * @function getObjectCloneStrict
   *
   * @description
   * get a copy of the object based on strict rules, meaning all keys and symbols
   * are copied based on the original property descriptors
   *
   * @param object the object to clone
   * @param realm the realm the object resides in
   * @param handleCopy the function that handles copying the object
   * @returns the copied object
   */


  var getObjectCloneStrict = function (object, realm, handleCopy, cache) {
    var clone = getCleanClone(object, realm); // set in the cache immediately to be able to reuse the object recursively

    cache.set(object, clone);
    var properties = SYMBOL_PROPERTIES ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object)) : getOwnPropertyNames(object);

    for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {
      property = properties[index];

      if (property !== 'callee' && property !== 'caller') {
        descriptor = getOwnPropertyDescriptor(object, property);

        if (descriptor) {
          // Only clone the value if actually a value, not a getter / setter.
          if (!descriptor.get && !descriptor.set) {
            descriptor.value = handleCopy(object[property], cache);
          }

          try {
            defineProperty(clone, property, descriptor);
          } catch (error) {
            // Tee above can fail on node in edge cases, so fall back to the loose assignment.
            clone[property] = descriptor.value;
          }
        } else {
          // In extra edge cases where the property descriptor cannot be retrived, fall back to
          // the loose assignment.
          clone[property] = handleCopy(object[property], cache);
        }
      }
    }

    return clone;
  };
  /**
   * @function getRegExpFlags
   *
   * @description
   * get the flags to apply to the copied regexp
   *
   * @param regExp the regexp to get the flags of
   * @returns the flags for the regexp
   */


  var getRegExpFlags = function (regExp) {
    var flags = '';

    if (regExp.global) {
      flags += 'g';
    }

    if (regExp.ignoreCase) {
      flags += 'i';
    }

    if (regExp.multiline) {
      flags += 'm';
    }

    if (regExp.unicode) {
      flags += 'u';
    }

    if (regExp.sticky) {
      flags += 'y';
    }

    return flags;
  }; // utils


  var isArray = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;

  var GLOBAL_THIS = function () {
    if (typeof globalThis !== 'undefined') {
      return globalThis;
    }

    if (typeof self !== 'undefined') {
      return self;
    }

    if (typeof window !== 'undefined') {
      return window;
    }

    if (typeof __webpack_require__.g !== 'undefined') {
      return __webpack_require__.g;
    }

    if (console && console.error) {
      console.error('Unable to locate global object, returning "this".');
    }

    return this;
  }();
  /**
   * @function copy
   *
   * @description
   * copy an value deeply as much as possible
   *
   * If `strict` is applied, then all properties (including non-enumerable ones)
   * are copied with their original property descriptors on both objects and arrays.
   *
   * The value is compared to the global constructors in the `realm` provided,
   * and the native constructor is always used to ensure that extensions of native
   * objects (allows in ES2015+) are maintained.
   *
   * @param value the value to copy
   * @param [options] the options for copying with
   * @param [options.isStrict] should the copy be strict
   * @param [options.realm] the realm (this) value the value is copied from
   * @returns the copied value
   */


  function copy(value, options) {
    // manually coalesced instead of default parameters for performance
    var isStrict = !!(options && options.isStrict);
    var realm = options && options.realm || GLOBAL_THIS;
    var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;
    /**
     * @function handleCopy
     *
     * @description
     * copy the value recursively based on its type
     *
     * @param value the value to copy
     * @returns the copied value
     */

    var handleCopy = function (value, cache) {
      if (!value || typeof value !== 'object') {
        return value;
      }

      if (cache.has(value)) {
        return cache.get(value);
      }

      var prototype = value.__proto__ || getPrototypeOf(value);
      var Constructor = prototype && prototype.constructor; // plain objects

      if (!Constructor || Constructor === realm.Object) {
        return getObjectClone(value, realm, handleCopy, cache);
      }

      var clone; // arrays

      if (isArray(value)) {
        // if strict, include non-standard properties
        if (isStrict) {
          return getObjectCloneStrict(value, realm, handleCopy, cache);
        }

        clone = new Constructor();
        cache.set(value, clone);

        for (var index = 0, length_1 = value.length; index < length_1; ++index) {
          clone[index] = handleCopy(value[index], cache);
        }

        return clone;
      } // dates


      if (value instanceof realm.Date) {
        return new Constructor(value.getTime());
      } // regexps


      if (value instanceof realm.RegExp) {
        clone = new Constructor(value.source, value.flags || getRegExpFlags(value));
        clone.lastIndex = value.lastIndex;
        return clone;
      } // maps


      if (realm.Map && value instanceof realm.Map) {
        clone = new Constructor();
        cache.set(value, clone);
        value.forEach(function (value, key) {
          clone.set(key, handleCopy(value, cache));
        });
        return clone;
      } // sets


      if (realm.Set && value instanceof realm.Set) {
        clone = new Constructor();
        cache.set(value, clone);
        value.forEach(function (value) {
          clone.add(handleCopy(value, cache));
        });
        return clone;
      } // blobs


      if (realm.Blob && value instanceof realm.Blob) {
        return value.slice(0, value.size, value.type);
      } // buffers (node-only)


      if (realm.Buffer && realm.Buffer.isBuffer(value)) {
        clone = realm.Buffer.allocUnsafe ? realm.Buffer.allocUnsafe(value.length) : new Constructor(value.length);
        cache.set(value, clone);
        value.copy(clone);
        return clone;
      } // arraybuffers / dataviews


      if (realm.ArrayBuffer) {
        // dataviews
        if (realm.ArrayBuffer.isView(value)) {
          clone = new Constructor(value.buffer.slice(0));
          cache.set(value, clone);
          return clone;
        } // arraybuffers


        if (value instanceof realm.ArrayBuffer) {
          clone = value.slice(0);
          cache.set(value, clone);
          return clone;
        }
      } // if the value cannot / should not be cloned, don't


      if ( // promise-like
      typeof value.then === 'function' || // errors
      value instanceof Error || // weakmaps
      realm.WeakMap && value instanceof realm.WeakMap || // weaksets
      realm.WeakSet && value instanceof realm.WeakSet) {
        return value;
      } // assume anything left is a custom constructor


      return getObjectClone(value, realm, handleCopy, cache);
    };

    return handleCopy(value, createCache());
  } // Adding reference to allow usage in CommonJS libraries compiled using TSC, which
  // expects there to be a default property on the exported value. See
  // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.


  copy.default = copy;
  /**
   * @function strictCopy
   *
   * @description
   * copy the value with `strict` option pre-applied
   *
   * @param value the value to copy
   * @param [options] the options for copying with
   * @param [options.realm] the realm (this) value the value is copied from
   * @returns the copied value
   */

  copy.strict = function strictCopy(value, options) {
    return copy(value, {
      isStrict: true,
      realm: options ? options.realm : void 0
    });
  };

  return copy;
});

/***/ }),
/* 2 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
let fhirVersion = 'R4B',
    sdcVersion = '3.0',
    fhirVersionNum = '4.3';
/* harmony default export */ __webpack_exports__["default"] = ({
  fhirVersion: fhirVersion,
  //Needed by lfData for fhirpath, etc.
  SDCVersion: sdcVersion,
  QProfile: 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire|' + sdcVersion,
  QRProfile: 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaireresponse|' + sdcVersion,
  stdQProfile: 'http://hl7.org/fhir/' + fhirVersionNum + '/StructureDefinition/Questionnaire',
  stdQRProfile: 'http://hl7.org/fhir/' + fhirVersionNum + '/StructureDefinition/QuestionnaireResponse'
});

/***/ }),
/* 3 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LOINC_URI": function() { return /* binding */ LOINC_URI; }
/* harmony export */ });
// Definitions for things needed by both importing and exporting.
let LOINC_URI = 'http://loinc.org';

/***/ }),
/* 4 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This is fhirpath interpreter
// everything starts at evaluate function,
// which is passed  fhirpath AST and resource.
//
// We reduce/eval recursively each node in AST
// passing the context and current data
//
// each AST node has eval function, which should be registered in evalTable
// and named after node type
// if node needs to eval father it's children it has to call `doEval` function
//
// most of nodes do function or operator invocation at the end
//
// For invocation's and operator's there is one lookup table -
// invocationTable and two helper functions doInvoke and infixInvoke for
// operators
// 1. operator or function is looked up in table
// 2. using signature (in  .arity property) unpack parameters
// 3. check params types
// 4. do call function
// 5. wrap result by util.arraify
//
// if function is nullable
// and one of parameters is empty/null - function will not be invoked and empty
// result returned
//
// Not solved problem is overloading functions by types - for example + operator defined
// for strings and numbers
// we can make dispatching params type dependent - let see
const {
  version
} = __webpack_require__(5);

const parser = __webpack_require__(6);

const util = __webpack_require__(55);

__webpack_require__(71);

const constants = __webpack_require__(72);

let engine = {}; // the object with all FHIRPath functions and operations

let existence = __webpack_require__(73);

let filtering = __webpack_require__(74);

let aggregate = __webpack_require__(77);

let combining = __webpack_require__(81);

let misc = __webpack_require__(76);

let equality = __webpack_require__(79);

let collections = __webpack_require__(82);

let math = __webpack_require__(78);

let strings = __webpack_require__(83);

let navigation = __webpack_require__(84);

let datetime = __webpack_require__(85);

let logic = __webpack_require__(86);

const types = __webpack_require__(56);

const {
  FP_Date,
  FP_DateTime,
  FP_Time,
  FP_Quantity,
  FP_Type,
  ResourceNode,
  TypeInfo
} = types;
let makeResNode = ResourceNode.makeResNode; // * fn: handler
// * arity: is index map with type signature
//   if type is in array (like [Boolean]) - this means
//   function accepts value of this type or empty value {}
// * nullable - means propagate empty result, i.e. instead
//   calling function if one of params is  empty return empty

engine.invocationTable = {
  empty: {
    fn: existence.emptyFn
  },
  not: {
    fn: existence.notFn
  },
  exists: {
    fn: existence.existsMacro,
    arity: {
      0: [],
      1: ["Expr"]
    }
  },
  all: {
    fn: existence.allMacro,
    arity: {
      1: ["Expr"]
    }
  },
  allTrue: {
    fn: existence.allTrueFn
  },
  anyTrue: {
    fn: existence.anyTrueFn
  },
  allFalse: {
    fn: existence.allFalseFn
  },
  anyFalse: {
    fn: existence.anyFalseFn
  },
  subsetOf: {
    fn: existence.subsetOfFn,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  supersetOf: {
    fn: existence.supersetOfFn,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  isDistinct: {
    fn: existence.isDistinctFn
  },
  distinct: {
    fn: filtering.distinctFn
  },
  count: {
    fn: aggregate.countFn
  },
  where: {
    fn: filtering.whereMacro,
    arity: {
      1: ["Expr"]
    }
  },
  extension: {
    fn: filtering.extension,
    arity: {
      1: ["String"]
    }
  },
  select: {
    fn: filtering.selectMacro,
    arity: {
      1: ["Expr"]
    }
  },
  aggregate: {
    fn: aggregate.aggregateMacro,
    arity: {
      1: ["Expr"],
      2: ["Expr", "Integer"]
    }
  },
  sum: {
    fn: aggregate.sumFn
  },
  min: {
    fn: aggregate.minFn
  },
  max: {
    fn: aggregate.maxFn
  },
  avg: {
    fn: aggregate.avgFn
  },
  single: {
    fn: filtering.singleFn
  },
  first: {
    fn: filtering.firstFn
  },
  last: {
    fn: filtering.lastFn
  },
  type: {
    fn: types.typeFn,
    arity: {
      0: []
    }
  },
  ofType: {
    fn: filtering.ofTypeFn,
    arity: {
      1: ["TypeSpecifier"]
    }
  },
  is: {
    fn: types.isFn,
    arity: {
      1: ["TypeSpecifier"]
    }
  },
  as: {
    fn: types.asFn,
    arity: {
      1: ["TypeSpecifier"]
    }
  },
  tail: {
    fn: filtering.tailFn
  },
  take: {
    fn: filtering.takeFn,
    arity: {
      1: ["Integer"]
    }
  },
  skip: {
    fn: filtering.skipFn,
    arity: {
      1: ["Integer"]
    }
  },
  combine: {
    fn: combining.combineFn,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  union: {
    fn: combining.union,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  intersect: {
    fn: combining.intersect,
    arity: {
      1: ["AnyAtRoot"]
    }
  },
  iif: {
    fn: misc.iifMacro,
    arity: {
      2: ["Expr", "Expr"],
      3: ["Expr", "Expr", "Expr"]
    }
  },
  trace: {
    fn: misc.traceFn,
    arity: {
      0: [],
      1: ["String"]
    }
  },
  toInteger: {
    fn: misc.toInteger
  },
  toDecimal: {
    fn: misc.toDecimal
  },
  toString: {
    fn: misc.toString
  },
  toDate: {
    fn: misc.toDate
  },
  toDateTime: {
    fn: misc.toDateTime
  },
  toTime: {
    fn: misc.toTime
  },
  toBoolean: {
    fn: misc.toBoolean
  },
  toQuantity: {
    fn: misc.toQuantity,
    arity: {
      0: [],
      1: ["String"]
    }
  },
  convertsToBoolean: {
    fn: misc.createConvertsToFn(misc.toBoolean, 'boolean')
  },
  convertsToInteger: {
    fn: misc.createConvertsToFn(misc.toInteger, 'number')
  },
  convertsToDecimal: {
    fn: misc.createConvertsToFn(misc.toDecimal, 'number')
  },
  convertsToString: {
    fn: misc.createConvertsToFn(misc.toString, 'string')
  },
  convertsToDate: {
    fn: misc.createConvertsToFn(misc.toDate, FP_Date)
  },
  convertsToDateTime: {
    fn: misc.createConvertsToFn(misc.toDateTime, FP_DateTime)
  },
  convertsToTime: {
    fn: misc.createConvertsToFn(misc.toTime, FP_Time)
  },
  convertsToQuantity: {
    fn: misc.createConvertsToFn(misc.toQuantity, FP_Quantity)
  },
  indexOf: {
    fn: strings.indexOf,
    arity: {
      1: ["String"]
    }
  },
  substring: {
    fn: strings.substring,
    arity: {
      1: ["Integer"],
      2: ["Integer", "Integer"]
    }
  },
  startsWith: {
    fn: strings.startsWith,
    arity: {
      1: ["String"]
    }
  },
  endsWith: {
    fn: strings.endsWith,
    arity: {
      1: ["String"]
    }
  },
  contains: {
    fn: strings.containsFn,
    arity: {
      1: ["String"]
    }
  },
  upper: {
    fn: strings.upper
  },
  lower: {
    fn: strings.lower
  },
  replace: {
    fn: strings.replace,
    arity: {
      2: ["String", "String"]
    }
  },
  matches: {
    fn: strings.matches,
    arity: {
      1: ["String"]
    }
  },
  replaceMatches: {
    fn: strings.replaceMatches,
    arity: {
      2: ["String", "String"]
    }
  },
  length: {
    fn: strings.length
  },
  toChars: {
    fn: strings.toChars
  },
  abs: {
    fn: math.abs
  },
  ceiling: {
    fn: math.ceiling
  },
  exp: {
    fn: math.exp
  },
  floor: {
    fn: math.floor
  },
  ln: {
    fn: math.ln
  },
  log: {
    fn: math.log,
    arity: {
      1: ["Number"]
    },
    nullable: true
  },
  power: {
    fn: math.power,
    arity: {
      1: ["Number"]
    },
    nullable: true
  },
  round: {
    fn: math.round,
    arity: {
      1: ["Number"]
    }
  },
  sqrt: {
    fn: math.sqrt
  },
  truncate: {
    fn: math.truncate
  },
  now: {
    fn: datetime.now
  },
  today: {
    fn: datetime.today
  },
  timeOfDay: {
    fn: datetime.timeOfDay
  },
  repeat: {
    fn: filtering.repeatMacro,
    arity: {
      1: ["Expr"]
    }
  },
  children: {
    fn: navigation.children
  },
  descendants: {
    fn: navigation.descendants
  },
  "|": {
    fn: combining.union,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "=": {
    fn: equality.equal,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "!=": {
    fn: equality.unequal,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "~": {
    fn: equality.equival,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "!~": {
    fn: equality.unequival,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "<": {
    fn: equality.lt,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  ">": {
    fn: equality.gt,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "<=": {
    fn: equality.lte,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  ">=": {
    fn: equality.gte,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "containsOp": {
    fn: collections.contains,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "inOp": {
    fn: collections.in,
    arity: {
      2: ["Any", "Any"]
    }
  },
  "isOp": {
    fn: types.isFn,
    arity: {
      2: ["Any", "TypeSpecifier"]
    }
  },
  "asOp": {
    fn: types.asFn,
    arity: {
      2: ["Any", "TypeSpecifier"]
    }
  },
  "&": {
    fn: math.amp,
    arity: {
      2: ["String", "String"]
    }
  },
  "+": {
    fn: math.plus,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "-": {
    fn: math.minus,
    arity: {
      2: ["Any", "Any"]
    },
    nullable: true
  },
  "*": {
    fn: math.mul,
    arity: {
      2: ["Number", "Number"]
    },
    nullable: true
  },
  "/": {
    fn: math.div,
    arity: {
      2: ["Number", "Number"]
    },
    nullable: true
  },
  "mod": {
    fn: math.mod,
    arity: {
      2: ["Number", "Number"]
    },
    nullable: true
  },
  "div": {
    fn: math.intdiv,
    arity: {
      2: ["Number", "Number"]
    },
    nullable: true
  },
  "or": {
    fn: logic.orOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  },
  "and": {
    fn: logic.andOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  },
  "xor": {
    fn: logic.xorOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  },
  "implies": {
    fn: logic.impliesOp,
    arity: {
      2: [["Boolean"], ["Boolean"]]
    }
  }
};

engine.InvocationExpression = function (ctx, parentData, node) {
  return node.children.reduce(function (acc, ch) {
    return engine.doEval(ctx, acc, ch);
  }, parentData);
};

engine.TermExpression = function (ctx, parentData, node) {
  if (parentData) {
    parentData = parentData.map(x => {
      if (x instanceof Object && x.resourceType) {
        return makeResNode(x, x.resourceType);
      }

      return x;
    });
  }

  return engine.doEval(ctx, parentData, node.children[0]);
};

engine.PolarityExpression = function (ctx, parentData, node) {
  var sign = node.terminalNodeText[0]; // either - or + per grammar

  var rtn = engine.doEval(ctx, parentData, node.children[0]);

  if (rtn.length !== 1) {
    // not yet in spec, but per Bryn Rhodes
    throw new Error('Unary ' + sign + ' can only be applied to an individual number.');
  }

  if (typeof rtn[0] != 'number' || isNaN(rtn[0])) throw new Error('Unary ' + sign + ' can only be applied to a number.');
  if (sign === '-') rtn[0] = -rtn[0];
  return rtn;
};

engine.TypeSpecifier = function (ctx, parentData, node) {
  let namespace, name;
  const identifiers = node.text.split('.').map(i => i.replace(/(^`|`$)/g, ""));

  switch (identifiers.length) {
    case 2:
      [namespace, name] = identifiers;
      break;

    case 1:
      [name] = identifiers;
      break;

    default:
      throw new Error("Expected TypeSpecifier node, got " + JSON.stringify(node));
  }

  return new TypeInfo({
    namespace,
    name
  });
};

engine.ExternalConstantTerm = function (ctx, parentData, node) {
  var extConstant = node.children[0];
  var identifier = extConstant.children[0];
  var varName = engine.Identifier(ctx, parentData, identifier)[0];
  var value = ctx.vars[varName];

  if (!(varName in ctx.vars)) {
    throw new Error("Attempting to access an undefined environment variable: " + varName);
  } // For convenience, we all variable values to be passed in without their array
  // wrapper.  However, when evaluating, we need to put the array back in.


  return value === undefined || value === null ? [] : value instanceof Array ? value : [value];
};

engine.LiteralTerm = function (ctx, parentData, node) {
  var term = node.children[0];

  if (term) {
    return engine.doEval(ctx, parentData, term);
  } else {
    return [node.text];
  }
};

engine.StringLiteral = function (ctx, parentData, node) {
  // Remove the beginning and ending quotes.
  var rtn = node.text.replace(/(^'|'$)/g, "");
  rtn = rtn.replace(/\\(u\d{4}|.)/g, function (match, submatch) {
    switch (match) {
      case '\\r':
        return '\r';

      case '\\n':
        return "\n";

      case '\\t':
        return '\t';

      case '\\f':
        return '\f';

      default:
        if (submatch.length > 1) return String.fromCharCode('0x' + submatch.slice(1));else return submatch;
    }
  });
  return [rtn];
};

engine.BooleanLiteral = function (ctx, parentData, node) {
  if (node.text === "true") {
    return [true];
  } else {
    return [false];
  }
};

engine.QuantityLiteral = function (ctx, parentData, node) {
  var valueNode = node.children[0];
  var value = Number(valueNode.terminalNodeText[0]);
  var unitNode = valueNode.children[0];
  var unit = unitNode.terminalNodeText[0]; // Sometimes the unit is in a child node of the child

  if (!unit && unitNode.children) unit = unitNode.children[0].terminalNodeText[0];
  return [new FP_Quantity(value, unit)];
};

engine.DateTimeLiteral = function (ctx, parentData, node) {
  var dateStr = node.text.slice(1); // Remove the @

  return [new FP_DateTime(dateStr)];
};

engine.TimeLiteral = function (ctx, parentData, node) {
  var timeStr = node.text.slice(1); // Remove the @

  return [new FP_Time(timeStr)];
};

engine.NumberLiteral = function (ctx, parentData, node) {
  return [Number(node.text)];
};

engine.Identifier = function (ctx, parentData, node) {
  return [node.text.replace(/(^`|`$)/g, "")];
};

engine.InvocationTerm = function (ctx, parentData, node) {
  return engine.doEval(ctx, parentData, node.children[0]);
};

engine.MemberInvocation = function (ctx, parentData, node) {
  const key = engine.doEval(ctx, parentData, node.children[0])[0];
  const model = ctx.model;

  if (parentData) {
    if (util.isCapitalized(key)) {
      return parentData.filter(x => x instanceof ResourceNode && x.path === key);
    } else {
      const path = parentData.path || parentData.__path__;
      return parentData.reduce(function (acc, res) {
        res = makeResNode(res, path);
        var childPath = res.path + '.' + key;

        if (model) {
          let defPath = model.pathsDefinedElsewhere[childPath];
          if (defPath) childPath = defPath;
        }

        let toAdd, _toAdd;

        let actualTypes = model && model.choiceTypePaths[childPath];

        if (actualTypes) {
          // Use actualTypes to find the field's value
          for (let t of actualTypes) {
            let field = key + t;
            toAdd = res.data?.[field];
            _toAdd = res.data?.['_' + field];

            if (toAdd !== undefined || _toAdd !== undefined) {
              childPath += t;
              break;
            }
          }
        } else {
          toAdd = res.data?.[key];
          _toAdd = res.data?.['_' + key];

          if (toAdd === undefined && _toAdd === undefined) {
            toAdd = res._data[key];
          }

          if (key === 'extension') {
            childPath = 'Extension';
          }
        }

        childPath = model && model.path2Type[childPath] || childPath;

        if (util.isSome(toAdd) || util.isSome(_toAdd)) {
          if (Array.isArray(toAdd)) {
            acc = acc.concat(toAdd.map((x, i) => makeResNode(x, childPath, _toAdd && _toAdd[i])));
          } else {
            acc.push(makeResNode(toAdd, childPath, _toAdd));
          }

          return acc;
        } else {
          return acc;
        }
      }, []);
    }
  } else {
    return [];
  }
};

engine.IndexerExpression = function (ctx, parentData, node) {
  const coll_node = node.children[0];
  const idx_node = node.children[1];
  var coll = engine.doEval(ctx, parentData, coll_node);
  var idx = engine.doEval(ctx, parentData, idx_node);

  if (util.isEmpty(idx)) {
    return [];
  }

  var idxNum = parseInt(idx[0]);

  if (coll && util.isSome(idxNum) && coll.length > idxNum && idxNum >= 0) {
    return [coll[idxNum]];
  } else {
    return [];
  }
};

engine.Functn = function (ctx, parentData, node) {
  return node.children.map(function (x) {
    return engine.doEval(ctx, parentData, x);
  });
};

engine.realizeParams = function (ctx, parentData, args) {
  if (args && args[0] && args[0].children) {
    return args[0].children.map(function (x) {
      return engine.doEval(ctx, parentData, x);
    });
  } else {
    return [];
  }
};

function makeParam(ctx, parentData, type, param) {
  if (type === "Expr") {
    return function (data) {
      ctx.$this = util.arraify(data);
      return engine.doEval(ctx, ctx.$this, param);
    };
  }

  if (type === "AnyAtRoot") {
    ctx.$this = ctx.$this || ctx.dataRoot;
    return engine.doEval(ctx, ctx.$this, param);
  }

  if (type === "Identifier") {
    if (param.type === "TermExpression") {
      return param.text;
    } else {
      throw new Error("Expected identifier node, got " + JSON.stringify(param));
    }
  }

  if (type === "TypeSpecifier") {
    return engine.TypeSpecifier(ctx, parentData, param);
  }

  ctx.$this = parentData;
  const res = engine.doEval(ctx, parentData, param);

  if (type === "Any") {
    return res;
  }

  if (Array.isArray(type)) {
    if (res.length === 0) {
      return [];
    } else {
      type = type[0];
    }
  }

  return misc.singleton(res, type);
}

function doInvoke(ctx, fnName, data, rawParams) {
  var invoc = engine.invocationTable[fnName];
  var res;

  if (invoc) {
    if (!invoc.arity) {
      if (!rawParams) {
        res = invoc.fn.call(ctx, util.arraify(data));
        return util.arraify(res);
      } else {
        throw new Error(fnName + " expects no params");
      }
    } else {
      var paramsNumber = rawParams ? rawParams.length : 0;
      var argTypes = invoc.arity[paramsNumber];

      if (argTypes) {
        var params = [];

        for (var i = 0; i < paramsNumber; i++) {
          var tp = argTypes[i];
          var pr = rawParams[i];
          params.push(makeParam(ctx, data, tp, pr));
        }

        params.unshift(data);

        if (invoc.nullable) {
          if (params.some(isNullable)) {
            return [];
          }
        }

        res = invoc.fn.apply(ctx, params);
        return util.arraify(res);
      } else {
        console.log(fnName + " wrong arity: got " + paramsNumber);
        return [];
      }
    }
  } else {
    throw new Error("Not implemented: " + fnName);
  }
}

function isNullable(x) {
  return x === null || x === undefined || util.isEmpty(x);
}

function infixInvoke(ctx, fnName, data, rawParams) {
  var invoc = engine.invocationTable[fnName];

  if (invoc && invoc.fn) {
    var paramsNumber = rawParams ? rawParams.length : 0;

    if (paramsNumber !== 2) {
      throw new Error("Infix invoke should have arity 2");
    }

    var argTypes = invoc.arity[paramsNumber];

    if (argTypes) {
      var params = [];

      for (var i = 0; i < paramsNumber; i++) {
        var tp = argTypes[i];
        var pr = rawParams[i];
        params.push(makeParam(ctx, data, tp, pr));
      }

      if (invoc.nullable) {
        if (params.some(isNullable)) {
          return [];
        }
      }

      var res = invoc.fn.apply(ctx, params);
      return util.arraify(res);
    } else {
      console.log(fnName + " wrong arity: got " + paramsNumber);
      return [];
    }
  } else {
    throw new Error("Not impl " + fnName);
  }
}

engine.FunctionInvocation = function (ctx, parentData, node) {
  var args = engine.doEval(ctx, parentData, node.children[0]);
  const fnName = args[0];
  args.shift();
  var rawParams = args && args[0] && args[0].children;
  return doInvoke(ctx, fnName, parentData, rawParams);
};

engine.ParamList = function (ctx, parentData, node) {
  // we do not eval param list because sometimes it should be passed as
  // lambda/macro (for example in case of where(...)
  return node;
};

engine.UnionExpression = function (ctx, parentData, node) {
  return infixInvoke(ctx, '|', parentData, node.children);
};

engine.ThisInvocation = function (ctx) {
  return ctx.$this;
};

engine.TotalInvocation = function (ctx) {
  return util.arraify(ctx.$total);
};

engine.IndexInvocation = function (ctx) {
  return util.arraify(ctx.$index);
};

engine.OpExpression = function (ctx, parentData, node) {
  var op = node.terminalNodeText[0];
  return infixInvoke(ctx, op, parentData, node.children);
};

engine.AliasOpExpression = function (map) {
  return function (ctx, parentData, node) {
    var op = node.terminalNodeText[0];
    var alias = map[op];

    if (!alias) {
      throw new Error("Do not know how to alias " + op + " by " + JSON.stringify(map));
    }

    return infixInvoke(ctx, alias, parentData, node.children);
  };
};

engine.NullLiteral = function () {
  return [];
};

engine.ParenthesizedTerm = function (ctx, parentData, node) {
  return engine.doEval(ctx, parentData, node.children[0]);
};

engine.evalTable = {
  // not every evaluator is listed if they are defined on engine
  BooleanLiteral: engine.BooleanLiteral,
  EqualityExpression: engine.OpExpression,
  FunctionInvocation: engine.FunctionInvocation,
  Functn: engine.Functn,
  Identifier: engine.Identifier,
  IndexerExpression: engine.IndexerExpression,
  InequalityExpression: engine.OpExpression,
  InvocationExpression: engine.InvocationExpression,
  AdditiveExpression: engine.OpExpression,
  MultiplicativeExpression: engine.OpExpression,
  TypeExpression: engine.AliasOpExpression({
    "is": "isOp",
    "as": "asOp"
  }),
  MembershipExpression: engine.AliasOpExpression({
    "contains": "containsOp",
    "in": "inOp"
  }),
  NullLiteral: engine.NullLiteral,
  EntireExpression: engine.InvocationTerm,
  InvocationTerm: engine.InvocationTerm,
  LiteralTerm: engine.LiteralTerm,
  MemberInvocation: engine.MemberInvocation,
  NumberLiteral: engine.NumberLiteral,
  ParamList: engine.ParamList,
  ParenthesizedTerm: engine.ParenthesizedTerm,
  StringLiteral: engine.StringLiteral,
  TermExpression: engine.TermExpression,
  ThisInvocation: engine.ThisInvocation,
  TotalInvocation: engine.TotalInvocation,
  IndexInvocation: engine.IndexInvocation,
  UnionExpression: engine.UnionExpression,
  OrExpression: engine.OpExpression,
  ImpliesExpression: engine.OpExpression,
  AndExpression: engine.OpExpression,
  XorExpression: engine.OpExpression
};

engine.doEval = function (ctx, parentData, node) {
  const evaluator = engine.evalTable[node.type] || engine[node.type];

  if (evaluator) {
    return evaluator.call(engine, ctx, parentData, node);
  } else {
    throw new Error("No " + node.type + " evaluator ");
  }
};

function parse(path) {
  return parser.parse(path);
}
/**
 *  Applies the given parsed FHIRPath expression to the given resource,
 *  returning the result of doEval.
 * @param {(object|object[])} resource -  FHIR resource, bundle as js object or array of resources
 *  This resource will be modified by this function to add type information.
 * @param {object} parsedPath - a special object created by the parser that describes the structure of a fhirpath expression.
 * @param {object} context - a hash of variable name/value pairs.
 * @param {object} model - The "model" data object specific to a domain, e.g. R4.
 *  For example, you could pass in the result of require("fhirpath/fhir-context/r4");
 * @param {object} [options] - additional options:
 * @param {boolean} [options.resolveInternalTypes] - whether values of internal
 *  types should be converted to strings, true by default.
 */


function applyParsedPath(resource, parsedPath, context, model, options) {
  constants.reset();
  let dataRoot = util.arraify(resource); // doEval takes a "ctx" object, and we store things in that as we parse, so we
  // need to put user-provided variable data in a sub-object, ctx.vars.
  // Set up default standard variables, and allow override from the variables.
  // However, we'll keep our own copy of dataRoot for internal processing.

  let vars = {
    context: resource,
    ucum: 'http://unitsofmeasure.org'
  }; // Restore the ResourceNodes for the top-level objects of the context
  // variables. The nested objects will be converted to ResourceNodes
  // in the MemberInvocation method.

  if (context) {
    context = Object.keys(context).reduce((restoredContext, key) => {
      const path = context[key]?.__path__;

      if (path) {
        if (Array.isArray(context[key])) {
          restoredContext[key] = context[key].map(i => makeResNode(i, path));
        } else {
          restoredContext[key] = makeResNode(context[key], path);
        }
      } else {
        restoredContext[key] = context[key];
      }

      return restoredContext;
    }, {});
  }

  let ctx = {
    dataRoot,
    vars: Object.assign(vars, context),
    model
  };
  let rtn = engine.doEval(ctx, dataRoot, parsedPath.children[0]);
  let firstRtn = Array.isArray(rtn) ? rtn[0] : rtn; // Path for the data extracted from the resource.

  let path = firstRtn instanceof ResourceNode ? firstRtn.path : null; // Resolve any internal "ResourceNode" instances to plain objects and if
  // options.resolveInternalTypes is true, resolve any internal "FP_Type"
  // instances to strings.

  rtn = function visit(n) {
    n = util.valData(n);

    if (Array.isArray(n)) {
      for (let i = 0, len = n.length; i < len; ++i) n[i] = visit(n[i]);
    } else if (n instanceof FP_Type) {
      if (options.resolveInternalTypes) {
        n = n.toString();
      }
    } else if (typeof n === 'object') {
      for (let k of Object.keys(n)) n[k] = visit(n[k]);
    }

    return n;
  }(rtn); // Add a hidden (non-enumerable) property with the path to the data extracted
  // from the resource.


  if (path && typeof rtn === 'object') {
    Object.defineProperty(rtn, '__path__', {
      value: path
    });
  }

  return rtn;
}
/**
 * Resolves any internal "FP_Type" instances in a result of FHIRPath expression
 * evaluation to standard JavaScript types.
 * @param {any} val - a result of FHIRPath expression evaluation
 * @returns {any} a new object with resolved values.
 */


function resolveInternalTypes(val) {
  if (Array.isArray(val)) {
    for (let i = 0, len = val.length; i < len; ++i) val[i] = resolveInternalTypes(val[i]);
  } else if (val instanceof FP_Type) {
    val = val.toString();
  } else if (typeof val === 'object') {
    for (let k of Object.keys(val)) val[k] = resolveInternalTypes(val[k]);
  }

  return val;
}
/**
 *  Evaluates the "path" FHIRPath expression on the given resource or part of the resource,
 *  using data from "context" for variables mentioned in the "path" expression.
 * @param {(object|object[])} fhirData -  FHIR resource, part of a resource (in this case
 *  path.base should be provided), bundle as js object or array of resources.
 *  This object/array will be modified by this function to add type information.
 * @param {string|object} path - string with FHIRPath expression, sample 'Patient.name.given',
 *  or object, if fhirData represents the part of the FHIR resource:
 * @param {string} path.base - base path in resource from which fhirData was extracted
 * @param {string} path.expression - FHIRPath expression relative to path.base
 * @param {object} context - a hash of variable name/value pairs.
 * @param {object} model - The "model" data object specific to a domain, e.g. R4.
 *  For example, you could pass in the result of require("fhirpath/fhir-context/r4");
 * @param {object} [options] - additional options:
 * @param {boolean} [options.resolveInternalTypes] - whether values of internal
 *  types should be converted to standard JavaScript types (true by default).
 *  If false is passed, this conversion can be done later by calling
 *  resolveInternalTypes().
 */


function evaluate(fhirData, path, context, model, options) {
  return compile(path, model, options)(fhirData, context);
}
/**
 *  Returns a function that takes a resource or part of the resource and an
 *  optional context hash (see "evaluate"), and returns the result of evaluating
 *  the given FHIRPath expression on that resource.  The advantage of this
 *  function over "evaluate" is that if you have multiple resources, the given
 *  FHIRPath expression will only be parsed once.
 * @param {string|object} path - string with FHIRPath expression to be parsed or object:
 * @param {string} path.base - base path in resource from which a part of
 *   the resource was extracted
 * @param {string} path.expression - FHIRPath expression relative to path.base
 * @param {object} model - The "model" data object specific to a domain, e.g. R4.
 *  For example, you could pass in the result of require("fhirpath/fhir-context/r4");
 * @param {object} [options] - additional options:
 * @param {boolean} [options.resolveInternalTypes] - whether values of internal
 *  types should be converted to strings, true by default.
 */


function compile(path, model, options) {
  options = {
    resolveInternalTypes: true,
    ...options
  };

  if (typeof path === 'object') {
    const node = parse(path.expression);
    return function (fhirData, context) {
      const inObjPath = fhirData && fhirData.__path__;
      const resource = makeResNode(fhirData, path.base || inObjPath); // Globally set model before applying parsed FHIRPath expression

      TypeInfo.model = model;
      return applyParsedPath(resource, node, context, model, options);
    };
  } else {
    const node = parse(path);
    return function (fhirData, context) {
      const inObjPath = fhirData && fhirData.__path__;
      const resource = inObjPath ? makeResNode(fhirData, inObjPath) : fhirData; // Globally set model before applying parsed FHIRPath expression

      TypeInfo.model = model;
      return applyParsedPath(resource, node, context, model, options);
    };
  }
}

module.exports = {
  version,
  parse,
  compile,
  evaluate,
  resolveInternalTypes,
  // Might as well export the UCUM library, since we are using it.
  ucumUtils: (__webpack_require__(62).UcumLhcUtils.getInstance)()
};

/***/ }),
/* 5 */
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"name":"fhirpath","version":"3.2.0","description":"A FHIRPath engine","main":"src/fhirpath.js","dependencies":{"@lhncbc/ucum-lhc":"^4.1.3","antlr4":"~4.9.3","commander":"^2.18.0","date-fns":"^1.30.1","js-yaml":"^3.13.1"},"devDependencies":{"@babel/core":"^7.17.5","@babel/eslint-parser":"^7.17.0","@babel/preset-env":"^7.16.11","babel-loader":"^8.2.3","benny":"^3.7.1","bestzip":"^2.2.0","copy-webpack-plugin":"^6.0.3","cypress":"^10.3.0","eslint":"^8.10.0","fhir":"^4.10.3","grunt":"^1.5.2","grunt-cli":"^1.4.3","grunt-text-replace":"^0.4.0","jasmine-spec-reporter":"^4.2.1","jest":"^27.3.1","jit-grunt":"^0.10.0","lodash":"^4.17.21","open":"^8.4.0","rimraf":"^3.0.0","tmp":"0.0.33","webpack":"^5.11.1","webpack-bundle-analyzer":"^4.4.2","webpack-cli":"^4.9.1","xml2js":"^0.4.19","yargs":"^15.1.0"},"engines":{"node":">=8.9.0"},"scripts":{"generateParser":"cd src/parser; rimraf ./generated/*; java -Xmx500M -cp \\"../../antlr-4.9.3-complete.jar:$CLASSPATH\\" org.antlr.v4.Tool -o generated -Dlanguage=JavaScript FHIRPath.g4; grunt updateParserRequirements","build":"cd browser-build && webpack && rimraf fhirpath.zip && bestzip fhirpath.zip LICENSE.md fhirpath.min.js fhirpath.r4.min.js fhirpath.stu3.min.js fhirpath.dstu2.min.js && rimraf  LICENSE.md","test:unit":"jest && TZ=America/New_York jest && TZ=Europe/Paris jest","test:unit:debug":"echo \'open chrome chrome://inspect/\' && node --inspect node_modules/.bin/jest --runInBand","build:demo":"npm run build && cd demo && npm run build","test:e2e":"npm run build:demo && cypress run","test":"npm run lint && npm run test:unit && npm run test:e2e && echo \\"For tests specific to IE 11, open browser-build/test/index.html in IE 11, and confirm that the tests on that page pass.\\"","lint":"eslint src/parser/index.js src/*.js converter/","compare-performance":"node ./test/benchmark.js"},"bin":{"fhirpath":"bin/fhirpath"},"repository":"github:HL7/fhirpath.js","license":"MIT"}');

/***/ }),
/* 6 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const antlr4 = __webpack_require__(7);

const Lexer = __webpack_require__(52);

const Parser = __webpack_require__(53);

const Listener = __webpack_require__(54);

class ErrorListener extends antlr4.error.ErrorListener {
  constructor(errors) {
    super();
    this.errors = errors;
  }

  syntaxError(rec, sym, line, col, msg, e) {
    this.errors.push([rec, sym, line, col, msg, e]);
  }

}

var parse = function (path) {
  var chars = new antlr4.InputStream(path);
  var lexer = new Lexer(chars);
  var tokens = new antlr4.CommonTokenStream(lexer);
  var parser = new Parser(tokens);
  parser.buildParseTrees = true;
  var errors = [];
  var listener = new ErrorListener(errors);
  lexer.removeErrorListeners();
  lexer.addErrorListener(listener);
  parser.removeErrorListeners();
  parser.addErrorListener(listener);
  var tree = parser.entireExpression();

  class PathListener extends Listener {
    constructor() {
      super();
    }

  }

  var ast = {};
  var node;
  var parentStack = [ast];

  for (let p of Object.getOwnPropertyNames(Listener.prototype)) {
    if (p.startsWith("enter")) {
      PathListener.prototype[p] = function (ctx) {
        let parentNode = parentStack[parentStack.length - 1];
        let nodeType = p.slice(5); // remove "enter"

        node = {
          type: nodeType
        };
        node.text = ctx.getText();
        if (!parentNode.children) parentNode.children = [];
        parentNode.children.push(node);
        parentStack.push(node); // Also collect this node's terminal nodes, if any.  Terminal nodes are
        // not walked with the rest of the tree, but include things like "+" and
        // "-", which we need.

        node.terminalNodeText = [];

        for (let c of ctx.children) {
          // Test for node type "TerminalNodeImpl".  Minimized code no longer
          // has the original function names, so we can't rely on
          // c.constructor.name.  It appears the TerminalNodeImpl is the only
          // node with a "symbol" property, so test for that.
          if (c.symbol) node.terminalNodeText.push(c.getText());
        }
      };
    } else if (p.startsWith("exit")) {
      PathListener.prototype[p] = function () {
        parentStack.pop();
      };
    }
  }

  var printer = new PathListener();
  antlr4.tree.ParseTreeWalker.DEFAULT.walk(printer, tree);

  if (errors.length > 0) {
    let errMsgs = [];

    for (let i = 0, len = errors.length; i < len; ++i) {
      let err = errors[i];
      let msg = "line: " + err[2] + "; column: " + err[3] + "; message: " + err[4];
      errMsgs.push(msg);
    }

    var e = new Error(errMsgs.join("\n"));
    e.errors = errors;
    throw e;
  }

  return ast;
};

module.exports = {
  parse: parse
};

/***/ }),
/* 7 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

// This is a modified version of antr4's index.js, in which
// the "require" statements of two unused classes are commented out
// to avoid introducing a dependency on Node.js' "fs" package.

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports.atn = __webpack_require__(8);
exports.codepointat = __webpack_require__(39);
exports.dfa = __webpack_require__(40);
exports.fromcodepoint = __webpack_require__(43);
exports.tree = __webpack_require__(44);
exports.error = __webpack_require__(45);
exports.Token = __webpack_require__(12).Token; // Commented out to avoid the problem with 'fs' during the webpack build
// exports.CharStreams = require('antlr4/src/antlr4/CharStreams');

exports.CommonToken = __webpack_require__(12).CommonToken;
exports.InputStream = __webpack_require__(48); // Commented out to avoid the problem with 'fs' during the webpack build
// exports.FileStream = require('antlr4/src/antlr4/FileStream');

exports.CommonTokenStream = __webpack_require__(49);
exports.Lexer = __webpack_require__(27);
exports.Parser = __webpack_require__(51);

var pc = __webpack_require__(18);

exports.PredictionContextCache = pc.PredictionContextCache;
exports.ParserRuleContext = __webpack_require__(38);
exports.Interval = __webpack_require__(16).Interval;
exports.IntervalSet = __webpack_require__(16).IntervalSet;
exports.Utils = __webpack_require__(11);
exports.LL1Analyzer = __webpack_require__(10).LL1Analyzer;

/***/ }),
/* 8 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports.ATN = __webpack_require__(9);
exports.ATNDeserializer = __webpack_require__(22);
exports.LexerATNSimulator = __webpack_require__(26);
exports.ParserATNSimulator = __webpack_require__(36);
exports.PredictionMode = __webpack_require__(37);

/***/ }),
/* 9 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LL1Analyzer = __webpack_require__(10);

const {
  IntervalSet
} = __webpack_require__(16);

const {
  Token
} = __webpack_require__(12);

class ATN {
  constructor(grammarType, maxTokenType) {
    /**
     * Used for runtime deserialization of ATNs from strings
     * The type of the ATN.
    */
    this.grammarType = grammarType; // The maximum value for any symbol recognized by a transition in the ATN.

    this.maxTokenType = maxTokenType;
    this.states = [];
    /**
     * Each subrule/rule is a decision point and we must track them so we
     * can go back later and build DFA predictors for them.  This includes
     * all the rules, subrules, optional blocks, ()+, ()* etc...
     */

    this.decisionToState = []; // Maps from rule index to starting state number.

    this.ruleToStartState = []; // Maps from rule index to stop state number.

    this.ruleToStopState = null;
    this.modeNameToStartState = {};
    /**
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the {@link ATNDeserializationOptions//isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is {@code null}
     */

    this.ruleToTokenType = null;
    /**
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN
     */

    this.lexerActions = null;
    this.modeToStartState = [];
  }
  /**
   * Compute the set of valid tokens that can occur starting in state {@code s}.
   * If {@code ctx} is null, the set of tokens will not include what can follow
   * the rule surrounding {@code s}. In other words, the set will be
   * restricted to tokens reachable staying within {@code s}'s rule
   */


  nextTokensInContext(s, ctx) {
    const anal = new LL1Analyzer(this);
    return anal.LOOK(s, null, ctx);
  }
  /**
   * Compute the set of valid tokens that can occur starting in {@code s} and
   * staying in same rule. {@link Token//EPSILON} is in set if we reach end of
   * rule
   */


  nextTokensNoContext(s) {
    if (s.nextTokenWithinRule !== null) {
      return s.nextTokenWithinRule;
    }

    s.nextTokenWithinRule = this.nextTokensInContext(s, null);
    s.nextTokenWithinRule.readOnly = true;
    return s.nextTokenWithinRule;
  }

  nextTokens(s, ctx) {
    if (ctx === undefined) {
      return this.nextTokensNoContext(s);
    } else {
      return this.nextTokensInContext(s, ctx);
    }
  }

  addState(state) {
    if (state !== null) {
      state.atn = this;
      state.stateNumber = this.states.length;
    }

    this.states.push(state);
  }

  removeState(state) {
    this.states[state.stateNumber] = null; // just free mem, don't shift states in list
  }

  defineDecisionState(s) {
    this.decisionToState.push(s);
    s.decision = this.decisionToState.length - 1;
    return s.decision;
  }

  getDecisionState(decision) {
    if (this.decisionToState.length === 0) {
      return null;
    } else {
      return this.decisionToState[decision];
    }
  }
  /**
   * Computes the set of input symbols which could follow ATN state number
   * {@code stateNumber} in the specified full {@code context}. This method
   * considers the complete parser context, but does not evaluate semantic
   * predicates (i.e. all predicates encountered during the calculation are
   * assumed true). If a path in the ATN exists from the starting state to the
   * {@link RuleStopState} of the outermost context without matching any
   * symbols, {@link Token//EOF} is added to the returned set.
   *
   * <p>If {@code context} is {@code null}, it is treated as
   * {@link ParserRuleContext//EMPTY}.</p>
   *
   * @param stateNumber the ATN state number
   * @param ctx the full parse context
   *
   * @return {IntervalSet} The set of potentially valid input symbols which could follow the
   * specified state in the specified context.
   *
   * @throws IllegalArgumentException if the ATN does not contain a state with
   * number {@code stateNumber}
   */


  getExpectedTokens(stateNumber, ctx) {
    if (stateNumber < 0 || stateNumber >= this.states.length) {
      throw "Invalid state number.";
    }

    const s = this.states[stateNumber];
    let following = this.nextTokens(s);

    if (!following.contains(Token.EPSILON)) {
      return following;
    }

    const expected = new IntervalSet();
    expected.addSet(following);
    expected.removeOne(Token.EPSILON);

    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = this.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = this.nextTokens(rt.followState);
      expected.addSet(following);
      expected.removeOne(Token.EPSILON);
      ctx = ctx.parentCtx;
    }

    if (following.contains(Token.EPSILON)) {
      expected.addOne(Token.EOF);
    }

    return expected;
  }

}

ATN.INVALID_ALT_NUMBER = 0;
module.exports = ATN;

/***/ }),
/* 10 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Set,
  BitSet
} = __webpack_require__(11);

const {
  Token
} = __webpack_require__(12);

const {
  ATNConfig
} = __webpack_require__(13);

const {
  IntervalSet
} = __webpack_require__(16);

const {
  RuleStopState
} = __webpack_require__(14);

const {
  RuleTransition,
  NotSetTransition,
  WildcardTransition,
  AbstractPredicateTransition
} = __webpack_require__(17);

const {
  predictionContextFromRuleContext,
  PredictionContext,
  SingletonPredictionContext
} = __webpack_require__(18);

class LL1Analyzer {
  constructor(atn) {
    this.atn = atn;
  }
  /**
   * Calculates the SLL(1) expected lookahead set for each outgoing transition
   * of an {@link ATNState}. The returned array has one element for each
   * outgoing transition in {@code s}. If the closure from transition
   * <em>i</em> leads to a semantic predicate before matching a symbol, the
   * element at index <em>i</em> of the result will be {@code null}.
   *
   * @param s the ATN state
   * @return the expected symbols for each outgoing transition of {@code s}.
   */


  getDecisionLookahead(s) {
    if (s === null) {
      return null;
    }

    const count = s.transitions.length;
    const look = [];

    for (let alt = 0; alt < count; alt++) {
      look[alt] = new IntervalSet();
      const lookBusy = new Set();
      const seeThruPreds = false; // fail to get lookahead upon pred

      this._LOOK(s.transition(alt).target, null, PredictionContext.EMPTY, look[alt], lookBusy, new BitSet(), seeThruPreds, false); // Wipe out lookahead for this alternative if we found nothing
      // or we had a predicate when we !seeThruPreds


      if (look[alt].length === 0 || look[alt].contains(LL1Analyzer.HIT_PRED)) {
        look[alt] = null;
      }
    }

    return look;
  }
  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and the end of the rule containing
   * {@code s} is reached, {@link Token//EPSILON} is added to the result set.
   * If {@code ctx} is not {@code null} and the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx the complete parser context, or {@code null} if the context
   * should be ignored
   *
   * @return The set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   */


  LOOK(s, stopState, ctx) {
    const r = new IntervalSet();
    const seeThruPreds = true; // ignore preds; get all lookahead

    ctx = ctx || null;
    const lookContext = ctx !== null ? predictionContextFromRuleContext(s.atn, ctx) : null;

    this._LOOK(s, stopState, lookContext, r, new Set(), new BitSet(), seeThruPreds, true);

    return r;
  }
  /**
   * Compute set of tokens that can follow {@code s} in the ATN in the
   * specified {@code ctx}.
   *
   * <p>If {@code ctx} is {@code null} and {@code stopState} or the end of the
   * rule containing {@code s} is reached, {@link Token//EPSILON} is added to
   * the result set. If {@code ctx} is not {@code null} and {@code addEOF} is
   * {@code true} and {@code stopState} or the end of the outermost rule is
   * reached, {@link Token//EOF} is added to the result set.</p>
   *
   * @param s the ATN state.
   * @param stopState the ATN state to stop at. This can be a
   * {@link BlockEndState} to detect epsilon paths through a closure.
   * @param ctx The outer context, or {@code null} if the outer context should
   * not be used.
   * @param look The result lookahead set.
   * @param lookBusy A set used for preventing epsilon closures in the ATN
   * from causing a stack overflow. Outside code should pass
   * {@code new Set<ATNConfig>} for this argument.
   * @param calledRuleStack A set used for preventing left recursion in the
   * ATN from causing a stack overflow. Outside code should pass
   * {@code new BitSet()} for this argument.
   * @param seeThruPreds {@code true} to true semantic predicates as
   * implicitly {@code true} and "see through them", otherwise {@code false}
   * to treat semantic predicates as opaque and add {@link //HIT_PRED} to the
   * result if one is encountered.
   * @param addEOF Add {@link Token//EOF} to the result if the end of the
   * outermost context is reached. This parameter has no effect if {@code ctx}
   * is {@code null}.
   */


  _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {
    const c = new ATNConfig({
      state: s,
      alt: 0,
      context: ctx
    }, null);

    if (lookBusy.contains(c)) {
      return;
    }

    lookBusy.add(c);

    if (s === stopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }
    }

    if (s instanceof RuleStopState) {
      if (ctx === null) {
        look.addOne(Token.EPSILON);
        return;
      } else if (ctx.isEmpty() && addEOF) {
        look.addOne(Token.EOF);
        return;
      }

      if (ctx !== PredictionContext.EMPTY) {
        const removed = calledRuleStack.contains(s.ruleIndex);

        try {
          calledRuleStack.remove(s.ruleIndex); // run thru all possible stack tops in ctx

          for (let i = 0; i < ctx.length; i++) {
            const returnState = this.atn.states[ctx.getReturnState(i)];

            this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
          }
        } finally {
          if (removed) {
            calledRuleStack.add(s.ruleIndex);
          }
        }

        return;
      }
    }

    for (let j = 0; j < s.transitions.length; j++) {
      const t = s.transitions[j];

      if (t.constructor === RuleTransition) {
        if (calledRuleStack.contains(t.target.ruleIndex)) {
          continue;
        }

        const newContext = SingletonPredictionContext.create(ctx, t.followState.stateNumber);

        try {
          calledRuleStack.add(t.target.ruleIndex);

          this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } finally {
          calledRuleStack.remove(t.target.ruleIndex);
        }
      } else if (t instanceof AbstractPredicateTransition) {
        if (seeThruPreds) {
          this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
        } else {
          look.addOne(LL1Analyzer.HIT_PRED);
        }
      } else if (t.isEpsilon) {
        this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);
      } else if (t.constructor === WildcardTransition) {
        look.addRange(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
      } else {
        let set = t.label;

        if (set !== null) {
          if (t instanceof NotSetTransition) {
            set = set.complement(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
          }

          look.addSet(set);
        }
      }
    }
  }

}
/**
 * Special value added to the lookahead sets to indicate that we hit
 * a predicate during analysis if {@code seeThruPreds==false}.
 */


LL1Analyzer.HIT_PRED = Token.INVALID_TYPE;
module.exports = LL1Analyzer;

/***/ }),
/* 11 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
function valueToString(v) {
  return v === null ? "null" : v;
}

function arrayToString(a) {
  return Array.isArray(a) ? "[" + a.map(valueToString).join(", ") + "]" : "null";
}

String.prototype.seed = String.prototype.seed || Math.round(Math.random() * Math.pow(2, 32));

String.prototype.hashCode = function () {
  const key = this.toString();
  let h1b, k1;
  const remainder = key.length & 3; // key.length % 4

  const bytes = key.length - remainder;
  let h1 = String.prototype.seed;
  const c1 = 0xcc9e2d51;
  const c2 = 0x1b873593;
  let i = 0;

  while (i < bytes) {
    k1 = key.charCodeAt(i) & 0xff | (key.charCodeAt(++i) & 0xff) << 8 | (key.charCodeAt(++i) & 0xff) << 16 | (key.charCodeAt(++i) & 0xff) << 24;
    ++i;
    k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
    k1 = k1 << 15 | k1 >>> 17;
    k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
    h1 ^= k1;
    h1 = h1 << 13 | h1 >>> 19;
    h1b = (h1 & 0xffff) * 5 + (((h1 >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
    h1 = (h1b & 0xffff) + 0x6b64 + (((h1b >>> 16) + 0xe654 & 0xffff) << 16);
  }

  k1 = 0;

  switch (remainder) {
    case 3:
      k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;

    case 2:
      k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;

    case 1:
      k1 ^= key.charCodeAt(i) & 0xff;
      k1 = (k1 & 0xffff) * c1 + (((k1 >>> 16) * c1 & 0xffff) << 16) & 0xffffffff;
      k1 = k1 << 15 | k1 >>> 17;
      k1 = (k1 & 0xffff) * c2 + (((k1 >>> 16) * c2 & 0xffff) << 16) & 0xffffffff;
      h1 ^= k1;
  }

  h1 ^= key.length;
  h1 ^= h1 >>> 16;
  h1 = (h1 & 0xffff) * 0x85ebca6b + (((h1 >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = (h1 & 0xffff) * 0xc2b2ae35 + (((h1 >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
  h1 ^= h1 >>> 16;
  return h1 >>> 0;
};

function standardEqualsFunction(a, b) {
  return a ? a.equals(b) : a == b;
}

function standardHashCodeFunction(a) {
  return a ? a.hashCode() : -1;
}

class Set {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }

  add(value) {
    const hash = this.hashFunction(value);
    const key = "hash_" + hash;

    if (key in this.data) {
      const values = this.data[key];

      for (let i = 0; i < values.length; i++) {
        if (this.equalsFunction(value, values[i])) {
          return values[i];
        }
      }

      values.push(value);
      return value;
    } else {
      this.data[key] = [value];
      return value;
    }
  }

  contains(value) {
    return this.get(value) != null;
  }

  get(value) {
    const hash = this.hashFunction(value);
    const key = "hash_" + hash;

    if (key in this.data) {
      const values = this.data[key];

      for (let i = 0; i < values.length; i++) {
        if (this.equalsFunction(value, values[i])) {
          return values[i];
        }
      }
    }

    return null;
  }

  values() {
    let l = [];

    for (const key in this.data) {
      if (key.indexOf("hash_") === 0) {
        l = l.concat(this.data[key]);
      }
    }

    return l;
  }

  toString() {
    return arrayToString(this.values());
  }

  get length() {
    let l = 0;

    for (const key in this.data) {
      if (key.indexOf("hash_") === 0) {
        l = l + this.data[key].length;
      }
    }

    return l;
  }

}

class BitSet {
  constructor() {
    this.data = [];
  }

  add(value) {
    this.data[value] = true;
  }

  or(set) {
    const bits = this;
    Object.keys(set.data).map(function (alt) {
      bits.add(alt);
    });
  }

  remove(value) {
    delete this.data[value];
  }

  contains(value) {
    return this.data[value] === true;
  }

  values() {
    return Object.keys(this.data);
  }

  minValue() {
    return Math.min.apply(null, this.values());
  }

  hashCode() {
    const hash = new Hash();
    hash.update(this.values());
    return hash.finish();
  }

  equals(other) {
    if (!(other instanceof BitSet)) {
      return false;
    }

    return this.hashCode() === other.hashCode();
  }

  toString() {
    return "{" + this.values().join(", ") + "}";
  }

  get length() {
    return this.values().length;
  }

}

class Map {
  constructor(hashFunction, equalsFunction) {
    this.data = {};
    this.hashFunction = hashFunction || standardHashCodeFunction;
    this.equalsFunction = equalsFunction || standardEqualsFunction;
  }

  put(key, value) {
    const hashKey = "hash_" + this.hashFunction(key);

    if (hashKey in this.data) {
      const entries = this.data[hashKey];

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];

        if (this.equalsFunction(key, entry.key)) {
          const oldValue = entry.value;
          entry.value = value;
          return oldValue;
        }
      }

      entries.push({
        key: key,
        value: value
      });
      return value;
    } else {
      this.data[hashKey] = [{
        key: key,
        value: value
      }];
      return value;
    }
  }

  containsKey(key) {
    const hashKey = "hash_" + this.hashFunction(key);

    if (hashKey in this.data) {
      const entries = this.data[hashKey];

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key)) return true;
      }
    }

    return false;
  }

  get(key) {
    const hashKey = "hash_" + this.hashFunction(key);

    if (hashKey in this.data) {
      const entries = this.data[hashKey];

      for (let i = 0; i < entries.length; i++) {
        const entry = entries[i];
        if (this.equalsFunction(key, entry.key)) return entry.value;
      }
    }

    return null;
  }

  entries() {
    let l = [];

    for (const key in this.data) {
      if (key.indexOf("hash_") === 0) {
        l = l.concat(this.data[key]);
      }
    }

    return l;
  }

  getKeys() {
    return this.entries().map(function (e) {
      return e.key;
    });
  }

  getValues() {
    return this.entries().map(function (e) {
      return e.value;
    });
  }

  toString() {
    const ss = this.entries().map(function (entry) {
      return '{' + entry.key + ':' + entry.value + '}';
    });
    return '[' + ss.join(", ") + ']';
  }

  get length() {
    let l = 0;

    for (const hashKey in this.data) {
      if (hashKey.indexOf("hash_") === 0) {
        l = l + this.data[hashKey].length;
      }
    }

    return l;
  }

}

class AltDict {
  constructor() {
    this.data = {};
  }

  get(key) {
    key = "k-" + key;

    if (key in this.data) {
      return this.data[key];
    } else {
      return null;
    }
  }

  put(key, value) {
    key = "k-" + key;
    this.data[key] = value;
  }

  values() {
    const data = this.data;
    const keys = Object.keys(this.data);
    return keys.map(function (key) {
      return data[key];
    });
  }

}

class DoubleDict {
  constructor(defaultMapCtor) {
    this.defaultMapCtor = defaultMapCtor || Map;
    this.cacheMap = new this.defaultMapCtor();
  }

  get(a, b) {
    const d = this.cacheMap.get(a) || null;
    return d === null ? null : d.get(b) || null;
  }

  set(a, b, o) {
    let d = this.cacheMap.get(a) || null;

    if (d === null) {
      d = new this.defaultMapCtor();
      this.cacheMap.put(a, d);
    }

    d.put(b, o);
  }

}

class Hash {
  constructor() {
    this.count = 0;
    this.hash = 0;
  }

  update() {
    for (let i = 0; i < arguments.length; i++) {
      const value = arguments[i];
      if (value == null) continue;
      if (Array.isArray(value)) this.update.apply(this, value);else {
        let k = 0;

        switch (typeof value) {
          case 'undefined':
          case 'function':
            continue;

          case 'number':
          case 'boolean':
            k = value;
            break;

          case 'string':
            k = value.hashCode();
            break;

          default:
            if (value.updateHashCode) value.updateHashCode(this);else console.log("No updateHashCode for " + value.toString());
            continue;
        }

        k = k * 0xCC9E2D51;
        k = k << 15 | k >>> 32 - 15;
        k = k * 0x1B873593;
        this.count = this.count + 1;
        let hash = this.hash ^ k;
        hash = hash << 13 | hash >>> 32 - 13;
        hash = hash * 5 + 0xE6546B64;
        this.hash = hash;
      }
    }
  }

  finish() {
    let hash = this.hash ^ this.count * 4;
    hash = hash ^ hash >>> 16;
    hash = hash * 0x85EBCA6B;
    hash = hash ^ hash >>> 13;
    hash = hash * 0xC2B2AE35;
    hash = hash ^ hash >>> 16;
    return hash;
  }

}

function hashStuff() {
  const hash = new Hash();
  hash.update.apply(hash, arguments);
  return hash.finish();
}

function escapeWhitespace(s, escapeSpaces) {
  s = s.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");

  if (escapeSpaces) {
    s = s.replace(/ /g, "\u00B7");
  }

  return s;
}

function titleCase(str) {
  return str.replace(/\w\S*/g, function (txt) {
    return txt.charAt(0).toUpperCase() + txt.substr(1);
  });
}

function equalArrays(a, b) {
  if (!Array.isArray(a) || !Array.isArray(b)) return false;
  if (a === b) return true;
  if (a.length !== b.length) return false;

  for (let i = 0; i < a.length; i++) {
    if (a[i] === b[i]) continue;
    if (!a[i].equals || !a[i].equals(b[i])) return false;
  }

  return true;
}

module.exports = {
  Hash,
  Set,
  Map,
  BitSet,
  AltDict,
  DoubleDict,
  hashStuff,
  escapeWhitespace,
  arrayToString,
  titleCase,
  equalArrays
};

/***/ }),
/* 12 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * A token has properties: text, type, line, character position in the line
 * (so we can ignore tabs), token channel, index, and source from which
 * we obtained this token.
 */
class Token {
  constructor() {
    this.source = null;
    this.type = null; // token type of the token

    this.channel = null; // The parser ignores everything not on DEFAULT_CHANNEL

    this.start = null; // optional; return -1 if not implemented.

    this.stop = null; // optional; return -1 if not implemented.

    this.tokenIndex = null; // from 0..n-1 of the token object in the input stream

    this.line = null; // line=1..n of the 1st character

    this.column = null; // beginning of the line at which it occurs, 0..n-1

    this._text = null; // text of the token.
  }

  getTokenSource() {
    return this.source[0];
  }

  getInputStream() {
    return this.source[1];
  }

  get text() {
    return this._text;
  }

  set text(text) {
    this._text = text;
  }

}

Token.INVALID_TYPE = 0;
/**
 * During lookahead operations, this "token" signifies we hit rule end ATN state
 * and did not follow it despite needing to.
 */

Token.EPSILON = -2;
Token.MIN_USER_TOKEN_TYPE = 1;
Token.EOF = -1;
/**
 * All tokens go to the parser (unless skip() is called in that rule)
 * on a particular "channel". The parser tunes to a particular channel
 * so that whitespace etc... can go to the parser on a "hidden" channel.
 */

Token.DEFAULT_CHANNEL = 0;
/**
 * Anything on different channel than DEFAULT_CHANNEL is not parsed
 * by parser.
 */

Token.HIDDEN_CHANNEL = 1;

class CommonToken extends Token {
  constructor(source, type, channel, start, stop) {
    super();
    this.source = source !== undefined ? source : CommonToken.EMPTY_SOURCE;
    this.type = type !== undefined ? type : null;
    this.channel = channel !== undefined ? channel : Token.DEFAULT_CHANNEL;
    this.start = start !== undefined ? start : -1;
    this.stop = stop !== undefined ? stop : -1;
    this.tokenIndex = -1;

    if (this.source[0] !== null) {
      this.line = source[0].line;
      this.column = source[0].column;
    } else {
      this.column = -1;
    }
  }
  /**
   * Constructs a new {@link CommonToken} as a copy of another {@link Token}.
   *
   * <p>
   * If {@code oldToken} is also a {@link CommonToken} instance, the newly
   * constructed token will share a reference to the {@link //text} field and
   * the {@link Pair} stored in {@link //source}. Otherwise, {@link //text} will
   * be assigned the result of calling {@link //getText}, and {@link //source}
   * will be constructed from the result of {@link Token//getTokenSource} and
   * {@link Token//getInputStream}.</p>
   *
   * @param oldToken The token to copy.
   */


  clone() {
    const t = new CommonToken(this.source, this.type, this.channel, this.start, this.stop);
    t.tokenIndex = this.tokenIndex;
    t.line = this.line;
    t.column = this.column;
    t.text = this.text;
    return t;
  }

  toString() {
    let txt = this.text;

    if (txt !== null) {
      txt = txt.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
    } else {
      txt = "<no text>";
    }

    return "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + txt + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
  }

  get text() {
    if (this._text !== null) {
      return this._text;
    }

    const input = this.getInputStream();

    if (input === null) {
      return null;
    }

    const n = input.size;

    if (this.start < n && this.stop < n) {
      return input.getText(this.start, this.stop);
    } else {
      return "<EOF>";
    }
  }

  set text(text) {
    this._text = text;
  }

}
/**
 * An empty {@link Pair} which is used as the default value of
 * {@link //source} for tokens that do not have a source.
 */


CommonToken.EMPTY_SOURCE = [null, null];
module.exports = {
  Token,
  CommonToken
};

/***/ }),
/* 13 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  DecisionState
} = __webpack_require__(14);

const {
  SemanticContext
} = __webpack_require__(15);

const {
  Hash
} = __webpack_require__(11);

function checkParams(params, isCfg) {
  if (params === null) {
    const result = {
      state: null,
      alt: null,
      context: null,
      semanticContext: null
    };

    if (isCfg) {
      result.reachesIntoOuterContext = 0;
    }

    return result;
  } else {
    const props = {};
    props.state = params.state || null;
    props.alt = params.alt === undefined ? null : params.alt;
    props.context = params.context || null;
    props.semanticContext = params.semanticContext || null;

    if (isCfg) {
      props.reachesIntoOuterContext = params.reachesIntoOuterContext || 0;
      props.precedenceFilterSuppressed = params.precedenceFilterSuppressed || false;
    }

    return props;
  }
}

class ATNConfig {
  /**
   * @param {Object} params A tuple: (ATN state, predicted alt, syntactic, semantic context).
   * The syntactic context is a graph-structured stack node whose
   * path(s) to the root is the rule invocation(s)
   * chain used to arrive at the state.  The semantic context is
   * the tree of semantic predicates encountered before reaching
   * an ATN state
   */
  constructor(params, config) {
    this.checkContext(params, config);
    params = checkParams(params);
    config = checkParams(config, true); // The ATN state associated with this configuration///

    this.state = params.state !== null ? params.state : config.state; // What alt (or lexer rule) is predicted by this configuration///

    this.alt = params.alt !== null ? params.alt : config.alt;
    /**
     * The stack of invoking states leading to the rule/states associated
     * with this config.  We track only those contexts pushed during
     * execution of the ATN simulator
     */

    this.context = params.context !== null ? params.context : config.context;
    this.semanticContext = params.semanticContext !== null ? params.semanticContext : config.semanticContext !== null ? config.semanticContext : SemanticContext.NONE; // TODO: make it a boolean then

    /**
     * We cannot execute predicates dependent upon local context unless
     * we know for sure we are in the correct context. Because there is
     * no way to do this efficiently, we simply cannot evaluate
     * dependent predicates unless we are in the rule that initially
     * invokes the ATN simulator.
     * closure() tracks the depth of how far we dip into the
     * outer context: depth &gt; 0.  Note that it may not be totally
     * accurate depth since I don't ever decrement
     */

    this.reachesIntoOuterContext = config.reachesIntoOuterContext;
    this.precedenceFilterSuppressed = config.precedenceFilterSuppressed;
  }

  checkContext(params, config) {
    if ((params.context === null || params.context === undefined) && (config === null || config.context === null || config.context === undefined)) {
      this.context = null;
    }
  }

  hashCode() {
    const hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
  }

  updateHashCode(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
  }
  /**
   * An ATN configuration is equal to another if both have
   * the same state, they predict the same alternative, and
   * syntactic/semantic contexts are the same
   */


  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && (this.context === null ? other.context === null : this.context.equals(other.context)) && this.semanticContext.equals(other.semanticContext) && this.precedenceFilterSuppressed === other.precedenceFilterSuppressed;
    }
  }

  hashCodeForConfigSet() {
    const hash = new Hash();
    hash.update(this.state.stateNumber, this.alt, this.semanticContext);
    return hash.finish();
  }

  equalsForConfigSet(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ATNConfig)) {
      return false;
    } else {
      return this.state.stateNumber === other.state.stateNumber && this.alt === other.alt && this.semanticContext.equals(other.semanticContext);
    }
  }

  toString() {
    return "(" + this.state + "," + this.alt + (this.context !== null ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== SemanticContext.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
  }

}

class LexerATNConfig extends ATNConfig {
  constructor(params, config) {
    super(params, config); // This is the backing field for {@link //getLexerActionExecutor}.

    const lexerActionExecutor = params.lexerActionExecutor || null;
    this.lexerActionExecutor = lexerActionExecutor || (config !== null ? config.lexerActionExecutor : null);
    this.passedThroughNonGreedyDecision = config !== null ? this.checkNonGreedyDecision(config, this.state) : false;
    this.hashCodeForConfigSet = LexerATNConfig.prototype.hashCode;
    this.equalsForConfigSet = LexerATNConfig.prototype.equals;
    return this;
  }

  updateHashCode(hash) {
    hash.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
  }

  equals(other) {
    return this === other || other instanceof LexerATNConfig && this.passedThroughNonGreedyDecision === other.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(other.lexerActionExecutor) : !other.lexerActionExecutor) && super.equals(other);
  }

  checkNonGreedyDecision(source, target) {
    return source.passedThroughNonGreedyDecision || target instanceof DecisionState && target.nonGreedy;
  }

}

module.exports.ATNConfig = ATNConfig;
module.exports.LexerATNConfig = LexerATNConfig;

/***/ }),
/* 14 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const INITIAL_NUM_TRANSITIONS = 4;
/**
 * The following images show the relation of states and
 * {@link ATNState//transitions} for various grammar constructs.
 *
 * <ul>
 *
 * <li>Solid edges marked with an &//0949; indicate a required
 * {@link EpsilonTransition}.</li>
 *
 * <li>Dashed edges indicate locations where any transition derived from
 * {@link Transition} might appear.</li>
 *
 * <li>Dashed nodes are place holders for either a sequence of linked
 * {@link BasicState} states or the inclusion of a block representing a nested
 * construct in one of the forms below.</li>
 *
 * <li>Nodes showing multiple outgoing alternatives with a {@code ...} support
 * any number of alternatives (one or more). Nodes without the {@code ...} only
 * support the exact number of alternatives shown in the diagram.</li>
 *
 * </ul>
 *
 * <h2>Basic Blocks</h2>
 *
 * <h3>Rule</h3>
 *
 * <embed src="images/Rule.svg" type="image/svg+xml"/>
 *
 * <h3>Block of 1 or more alternatives</h3>
 *
 * <embed src="images/Block.svg" type="image/svg+xml"/>
 *
 * <h2>Greedy Loops</h2>
 *
 * <h3>Greedy Closure: {@code (...)*}</h3>
 *
 * <embed src="images/ClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Positive Closure: {@code (...)+}</h3>
 *
 * <embed src="images/PositiveClosureGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Greedy Optional: {@code (...)?}</h3>
 *
 * <embed src="images/OptionalGreedy.svg" type="image/svg+xml"/>
 *
 * <h2>Non-Greedy Loops</h2>
 *
 * <h3>Non-Greedy Closure: {@code (...)*?}</h3>
 *
 * <embed src="images/ClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Positive Closure: {@code (...)+?}</h3>
 *
 * <embed src="images/PositiveClosureNonGreedy.svg" type="image/svg+xml"/>
 *
 * <h3>Non-Greedy Optional: {@code (...)??}</h3>
 *
 * <embed src="images/OptionalNonGreedy.svg" type="image/svg+xml"/>
 */

class ATNState {
  constructor() {
    // Which ATN are we in?
    this.atn = null;
    this.stateNumber = ATNState.INVALID_STATE_NUMBER;
    this.stateType = null;
    this.ruleIndex = 0; // at runtime, we don't have Rule objects

    this.epsilonOnlyTransitions = false; // Track the transitions emanating from this ATN state.

    this.transitions = []; // Used to cache lookahead during parsing, not used during construction

    this.nextTokenWithinRule = null;
  }

  toString() {
    return this.stateNumber;
  }

  equals(other) {
    if (other instanceof ATNState) {
      return this.stateNumber === other.stateNumber;
    } else {
      return false;
    }
  }

  isNonGreedyExitState() {
    return false;
  }

  addTransition(trans, index) {
    if (index === undefined) {
      index = -1;
    }

    if (this.transitions.length === 0) {
      this.epsilonOnlyTransitions = trans.isEpsilon;
    } else if (this.epsilonOnlyTransitions !== trans.isEpsilon) {
      this.epsilonOnlyTransitions = false;
    }

    if (index === -1) {
      this.transitions.push(trans);
    } else {
      this.transitions.splice(index, 1, trans);
    }
  }

} // constants for serialization


ATNState.INVALID_TYPE = 0;
ATNState.BASIC = 1;
ATNState.RULE_START = 2;
ATNState.BLOCK_START = 3;
ATNState.PLUS_BLOCK_START = 4;
ATNState.STAR_BLOCK_START = 5;
ATNState.TOKEN_START = 6;
ATNState.RULE_STOP = 7;
ATNState.BLOCK_END = 8;
ATNState.STAR_LOOP_BACK = 9;
ATNState.STAR_LOOP_ENTRY = 10;
ATNState.PLUS_LOOP_BACK = 11;
ATNState.LOOP_END = 12;
ATNState.serializationNames = ["INVALID", "BASIC", "RULE_START", "BLOCK_START", "PLUS_BLOCK_START", "STAR_BLOCK_START", "TOKEN_START", "RULE_STOP", "BLOCK_END", "STAR_LOOP_BACK", "STAR_LOOP_ENTRY", "PLUS_LOOP_BACK", "LOOP_END"];
ATNState.INVALID_STATE_NUMBER = -1;

class BasicState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BASIC;
  }

}

class DecisionState extends ATNState {
  constructor() {
    super();
    this.decision = -1;
    this.nonGreedy = false;
    return this;
  }

}
/**
 *  The start of a regular {@code (...)} block
 */


class BlockStartState extends DecisionState {
  constructor() {
    super();
    this.endState = null;
    return this;
  }

}

class BasicBlockStartState extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_START;
    return this;
  }

}
/**
 * Terminal node of a simple {@code (a|b|c)} block
 */


class BlockEndState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.BLOCK_END;
    this.startState = null;
    return this;
  }

}
/**
 * The last node in the ATN for a rule, unless that rule is the start symbol.
 * In that case, there is one transition to EOF. Later, we might encode
 * references to all calls to this rule to compute FOLLOW sets for
 * error handling
 */


class RuleStopState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_STOP;
    return this;
  }

}

class RuleStartState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.RULE_START;
    this.stopState = null;
    this.isPrecedenceRule = false;
    return this;
  }

}
/**
 * Decision state for {@code A+} and {@code (A|B)+}.  It has two transitions:
 * one to the loop back to start of the block and one to exit.
 */


class PlusLoopbackState extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_LOOP_BACK;
    return this;
  }

}
/**
 * Start of {@code (A|B|...)+} loop. Technically a decision state, but
 * we don't use for code generation; somebody might need it, so I'm defining
 * it for completeness. In reality, the {@link PlusLoopbackState} node is the
 * real decision-making note for {@code A+}
 */


class PlusBlockStartState extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.PLUS_BLOCK_START;
    this.loopBackState = null;
    return this;
  }

}
/**
 * The block that begins a closure loop
 */


class StarBlockStartState extends BlockStartState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_BLOCK_START;
    return this;
  }

}

class StarLoopbackState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_BACK;
    return this;
  }

}

class StarLoopEntryState extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.STAR_LOOP_ENTRY;
    this.loopBackState = null; // Indicates whether this state can benefit from a precedence DFA during SLL decision making.

    this.isPrecedenceDecision = null;
    return this;
  }

}
/**
 * Mark the end of a * or + loop
 */


class LoopEndState extends ATNState {
  constructor() {
    super();
    this.stateType = ATNState.LOOP_END;
    this.loopBackState = null;
    return this;
  }

}
/**
 * The Tokens rule start state linking to each lexer rule start state
 */


class TokensStartState extends DecisionState {
  constructor() {
    super();
    this.stateType = ATNState.TOKEN_START;
    return this;
  }

}

module.exports = {
  ATNState,
  BasicState,
  DecisionState,
  BlockStartState,
  BlockEndState,
  LoopEndState,
  RuleStartState,
  RuleStopState,
  TokensStartState,
  PlusLoopbackState,
  StarLoopbackState,
  StarLoopEntryState,
  PlusBlockStartState,
  StarBlockStartState,
  BasicBlockStartState
};

/***/ }),
/* 15 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Set,
  Hash,
  equalArrays
} = __webpack_require__(11);
/**
 * A tree structure used to record the semantic context in which
 * an ATN configuration is valid.  It's either a single predicate,
 * a conjunction {@code p1&&p2}, or a sum of products {@code p1||p2}.
 *
 * <p>I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of
 * {@link SemanticContext} within the scope of this outer class.</p>
 */


class SemanticContext {
  hashCode() {
    const hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
  }
  /**
   * For context independent predicates, we evaluate them without a local
   * context (i.e., null context). That way, we can evaluate them without
   * having to create proper rule-specific context during prediction (as
   * opposed to the parser, which creates them naturally). In a practical
   * sense, this avoids a cast exception from RuleContext to myruleContext.
   *
   * <p>For context dependent predicates, we must pass in a local context so that
   * references such as $arg evaluate properly as _localctx.arg. We only
   * capture context dependent predicates in the context in which we begin
   * prediction, so we passed in the outer context here in case of context
   * dependent predicate evaluation.</p>
   */


  evaluate(parser, outerContext) {}
  /**
   * Evaluate the precedence predicates for the context and reduce the result.
   *
   * @param parser The parser instance.
   * @param outerContext The current parser context object.
   * @return The simplified semantic context after precedence predicates are
   * evaluated, which will be one of the following values.
   * <ul>
   * <li>{@link //NONE}: if the predicate simplifies to {@code true} after
   * precedence predicates are evaluated.</li>
   * <li>{@code null}: if the predicate simplifies to {@code false} after
   * precedence predicates are evaluated.</li>
   * <li>{@code this}: if the semantic context is not changed as a result of
   * precedence predicate evaluation.</li>
   * <li>A non-{@code null} {@link SemanticContext}: the new simplified
   * semantic context after precedence predicates are evaluated.</li>
   * </ul>
   */


  evalPrecedence(parser, outerContext) {
    return this;
  }

  static andContext(a, b) {
    if (a === null || a === SemanticContext.NONE) {
      return b;
    }

    if (b === null || b === SemanticContext.NONE) {
      return a;
    }

    const result = new AND(a, b);

    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }

  static orContext(a, b) {
    if (a === null) {
      return b;
    }

    if (b === null) {
      return a;
    }

    if (a === SemanticContext.NONE || b === SemanticContext.NONE) {
      return SemanticContext.NONE;
    }

    const result = new OR(a, b);

    if (result.opnds.length === 1) {
      return result.opnds[0];
    } else {
      return result;
    }
  }

}

class Predicate extends SemanticContext {
  constructor(ruleIndex, predIndex, isCtxDependent) {
    super();
    this.ruleIndex = ruleIndex === undefined ? -1 : ruleIndex;
    this.predIndex = predIndex === undefined ? -1 : predIndex;
    this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred
  }

  evaluate(parser, outerContext) {
    const localctx = this.isCtxDependent ? outerContext : null;
    return parser.sempred(localctx, this.ruleIndex, this.predIndex);
  }

  updateHashCode(hash) {
    hash.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof Predicate)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.predIndex === other.predIndex && this.isCtxDependent === other.isCtxDependent;
    }
  }

  toString() {
    return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
  }

}
/**
 * The default {@link SemanticContext}, which is semantically equivalent to
 * a predicate of the form {@code {true}?}
 */


SemanticContext.NONE = new Predicate();

class PrecedencePredicate extends SemanticContext {
  constructor(precedence) {
    super();
    this.precedence = precedence === undefined ? 0 : precedence;
  }

  evaluate(parser, outerContext) {
    return parser.precpred(outerContext, this.precedence);
  }

  evalPrecedence(parser, outerContext) {
    if (parser.precpred(outerContext, this.precedence)) {
      return SemanticContext.NONE;
    } else {
      return null;
    }
  }

  compareTo(other) {
    return this.precedence - other.precedence;
  }

  updateHashCode(hash) {
    hash.update(this.precedence);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof PrecedencePredicate)) {
      return false;
    } else {
      return this.precedence === other.precedence;
    }
  }

  toString() {
    return "{" + this.precedence + ">=prec}?";
  }

  static filterPrecedencePredicates(set) {
    const result = [];
    set.values().map(function (context) {
      if (context instanceof PrecedencePredicate) {
        result.push(context);
      }
    });
    return result;
  }

}

class AND extends SemanticContext {
  /**
   * A semantic context which is true whenever none of the contained contexts
   * is false
   */
  constructor(a, b) {
    super();
    const operands = new Set();

    if (a instanceof AND) {
      a.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }

    if (b instanceof AND) {
      b.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }

    const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);

    if (precedencePredicates.length > 0) {
      // interested in the transition with the lowest precedence
      let reduced = null;
      precedencePredicates.map(function (p) {
        if (reduced === null || p.precedence < reduced.precedence) {
          reduced = p;
        }
      });
      operands.add(reduced);
    }

    this.opnds = Array.from(operands.values());
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof AND)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }

  updateHashCode(hash) {
    hash.update(this.opnds, "AND");
  }
  /**
   * {@inheritDoc}
   *
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */


  evaluate(parser, outerContext) {
    for (let i = 0; i < this.opnds.length; i++) {
      if (!this.opnds[i].evaluate(parser, outerContext)) {
        return false;
      }
    }

    return true;
  }

  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];

    for (let i = 0; i < this.opnds.length; i++) {
      const context = this.opnds[i];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;

      if (evaluated === null) {
        // The AND context is false if any element is false
        return null;
      } else if (evaluated !== SemanticContext.NONE) {
        // Reduce the result by skipping true elements
        operands.push(evaluated);
      }
    }

    if (!differs) {
      return this;
    }

    if (operands.length === 0) {
      // all elements were true, so the AND context is true
      return SemanticContext.NONE;
    }

    let result = null;
    operands.map(function (o) {
      result = result === null ? o : SemanticContext.andContext(result, o);
    });
    return result;
  }

  toString() {
    const s = this.opnds.map(o => o.toString());
    return (s.length > 3 ? s.slice(3) : s).join("&&");
  }

}

class OR extends SemanticContext {
  /**
   * A semantic context which is true whenever at least one of the contained
   * contexts is true
   */
  constructor(a, b) {
    super();
    const operands = new Set();

    if (a instanceof OR) {
      a.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(a);
    }

    if (b instanceof OR) {
      b.opnds.map(function (o) {
        operands.add(o);
      });
    } else {
      operands.add(b);
    }

    const precedencePredicates = PrecedencePredicate.filterPrecedencePredicates(operands);

    if (precedencePredicates.length > 0) {
      // interested in the transition with the highest precedence
      const s = precedencePredicates.sort(function (a, b) {
        return a.compareTo(b);
      });
      const reduced = s[s.length - 1];
      operands.add(reduced);
    }

    this.opnds = Array.from(operands.values());
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof OR)) {
      return false;
    } else {
      return equalArrays(this.opnds, other.opnds);
    }
  }

  updateHashCode(hash) {
    hash.update(this.opnds, "OR");
  }
  /**
   * <p>
   * The evaluation of predicates by this context is short-circuiting, but
   * unordered.</p>
   */


  evaluate(parser, outerContext) {
    for (let i = 0; i < this.opnds.length; i++) {
      if (this.opnds[i].evaluate(parser, outerContext)) {
        return true;
      }
    }

    return false;
  }

  evalPrecedence(parser, outerContext) {
    let differs = false;
    const operands = [];

    for (let i = 0; i < this.opnds.length; i++) {
      const context = this.opnds[i];
      const evaluated = context.evalPrecedence(parser, outerContext);
      differs |= evaluated !== context;

      if (evaluated === SemanticContext.NONE) {
        // The OR context is true if any element is true
        return SemanticContext.NONE;
      } else if (evaluated !== null) {
        // Reduce the result by skipping false elements
        operands.push(evaluated);
      }
    }

    if (!differs) {
      return this;
    }

    if (operands.length === 0) {
      // all elements were false, so the OR context is false
      return null;
    }

    const result = null;
    operands.map(function (o) {
      return result === null ? o : SemanticContext.orContext(result, o);
    });
    return result;
  }

  toString() {
    const s = this.opnds.map(o => o.toString());
    return (s.length > 3 ? s.slice(3) : s).join("||");
  }

}

module.exports = {
  SemanticContext,
  PrecedencePredicate,
  Predicate
};

/***/ }),
/* 16 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);
/* stop is not included! */


class Interval {
  constructor(start, stop) {
    this.start = start;
    this.stop = stop;
  }

  clone() {
    return new Interval(this.start, this.stop);
  }

  contains(item) {
    return item >= this.start && item < this.stop;
  }

  toString() {
    if (this.start === this.stop - 1) {
      return this.start.toString();
    } else {
      return this.start.toString() + ".." + (this.stop - 1).toString();
    }
  }

  get length() {
    return this.stop - this.start;
  }

}

class IntervalSet {
  constructor() {
    this.intervals = null;
    this.readOnly = false;
  }

  first(v) {
    if (this.intervals === null || this.intervals.length === 0) {
      return Token.INVALID_TYPE;
    } else {
      return this.intervals[0].start;
    }
  }

  addOne(v) {
    this.addInterval(new Interval(v, v + 1));
  }

  addRange(l, h) {
    this.addInterval(new Interval(l, h + 1));
  }

  addInterval(toAdd) {
    if (this.intervals === null) {
      this.intervals = [];
      this.intervals.push(toAdd.clone());
    } else {
      // find insert pos
      for (let pos = 0; pos < this.intervals.length; pos++) {
        const existing = this.intervals[pos]; // distinct range -> insert

        if (toAdd.stop < existing.start) {
          this.intervals.splice(pos, 0, toAdd);
          return;
        } // contiguous range -> adjust
        else if (toAdd.stop === existing.start) {
          this.intervals[pos] = new Interval(toAdd.start, existing.stop);
          return;
        } // overlapping range -> adjust and reduce
        else if (toAdd.start <= existing.stop) {
          this.intervals[pos] = new Interval(Math.min(existing.start, toAdd.start), Math.max(existing.stop, toAdd.stop));
          this.reduce(pos);
          return;
        }
      } // greater than any existing


      this.intervals.push(toAdd.clone());
    }
  }

  addSet(other) {
    if (other.intervals !== null) {
      other.intervals.forEach(toAdd => this.addInterval(toAdd), this);
    }

    return this;
  }

  reduce(pos) {
    // only need to reduce if pos is not the last
    if (pos < this.intervals.length - 1) {
      const current = this.intervals[pos];
      const next = this.intervals[pos + 1]; // if next contained in current

      if (current.stop >= next.stop) {
        this.intervals.splice(pos + 1, 1);
        this.reduce(pos);
      } else if (current.stop >= next.start) {
        this.intervals[pos] = new Interval(current.start, next.stop);
        this.intervals.splice(pos + 1, 1);
      }
    }
  }

  complement(start, stop) {
    const result = new IntervalSet();
    result.addInterval(new Interval(start, stop + 1));
    if (this.intervals !== null) this.intervals.forEach(toRemove => result.removeRange(toRemove));
    return result;
  }

  contains(item) {
    if (this.intervals === null) {
      return false;
    } else {
      for (let k = 0; k < this.intervals.length; k++) {
        if (this.intervals[k].contains(item)) {
          return true;
        }
      }

      return false;
    }
  }

  removeRange(toRemove) {
    if (toRemove.start === toRemove.stop - 1) {
      this.removeOne(toRemove.start);
    } else if (this.intervals !== null) {
      let pos = 0;

      for (let n = 0; n < this.intervals.length; n++) {
        const existing = this.intervals[pos]; // intervals are ordered

        if (toRemove.stop <= existing.start) {
          return;
        } // check for including range, split it
        else if (toRemove.start > existing.start && toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
          const x = new Interval(toRemove.stop, existing.stop);
          this.intervals.splice(pos, 0, x);
          return;
        } // check for included range, remove it
        else if (toRemove.start <= existing.start && toRemove.stop >= existing.stop) {
          this.intervals.splice(pos, 1);
          pos = pos - 1; // need another pass
        } // check for lower boundary
        else if (toRemove.start < existing.stop) {
          this.intervals[pos] = new Interval(existing.start, toRemove.start);
        } // check for upper boundary
        else if (toRemove.stop < existing.stop) {
          this.intervals[pos] = new Interval(toRemove.stop, existing.stop);
        }

        pos += 1;
      }
    }
  }

  removeOne(value) {
    if (this.intervals !== null) {
      for (let i = 0; i < this.intervals.length; i++) {
        const existing = this.intervals[i]; // intervals are ordered

        if (value < existing.start) {
          return;
        } // check for single value range
        else if (value === existing.start && value === existing.stop - 1) {
          this.intervals.splice(i, 1);
          return;
        } // check for lower boundary
        else if (value === existing.start) {
          this.intervals[i] = new Interval(existing.start + 1, existing.stop);
          return;
        } // check for upper boundary
        else if (value === existing.stop - 1) {
          this.intervals[i] = new Interval(existing.start, existing.stop - 1);
          return;
        } // split existing range
        else if (value < existing.stop - 1) {
          const replace = new Interval(existing.start, value);
          existing.start = value + 1;
          this.intervals.splice(i, 0, replace);
          return;
        }
      }
    }
  }

  toString(literalNames, symbolicNames, elemsAreChar) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;
    elemsAreChar = elemsAreChar || false;

    if (this.intervals === null) {
      return "{}";
    } else if (literalNames !== null || symbolicNames !== null) {
      return this.toTokenString(literalNames, symbolicNames);
    } else if (elemsAreChar) {
      return this.toCharString();
    } else {
      return this.toIndexString();
    }
  }

  toCharString() {
    const names = [];

    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];

      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names.push("<EOF>");
        } else {
          names.push("'" + String.fromCharCode(existing.start) + "'");
        }
      } else {
        names.push("'" + String.fromCharCode(existing.start) + "'..'" + String.fromCharCode(existing.stop - 1) + "'");
      }
    }

    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }

  toIndexString() {
    const names = [];

    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];

      if (existing.stop === existing.start + 1) {
        if (existing.start === Token.EOF) {
          names.push("<EOF>");
        } else {
          names.push(existing.start.toString());
        }
      } else {
        names.push(existing.start.toString() + ".." + (existing.stop - 1).toString());
      }
    }

    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }

  toTokenString(literalNames, symbolicNames) {
    const names = [];

    for (let i = 0; i < this.intervals.length; i++) {
      const existing = this.intervals[i];

      for (let j = existing.start; j < existing.stop; j++) {
        names.push(this.elementName(literalNames, symbolicNames, j));
      }
    }

    if (names.length > 1) {
      return "{" + names.join(", ") + "}";
    } else {
      return names[0];
    }
  }

  elementName(literalNames, symbolicNames, token) {
    if (token === Token.EOF) {
      return "<EOF>";
    } else if (token === Token.EPSILON) {
      return "<EPSILON>";
    } else {
      return literalNames[token] || symbolicNames[token];
    }
  }

  get length() {
    return this.intervals.map(interval => interval.length).reduce((acc, val) => acc + val);
  }

}

module.exports = {
  Interval,
  IntervalSet
};

/***/ }),
/* 17 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const {
  IntervalSet
} = __webpack_require__(16);

const {
  Predicate,
  PrecedencePredicate
} = __webpack_require__(15);
/**
 * An ATN transition between any two ATN states.  Subclasses define
 * atom, set, epsilon, action, predicate, rule transitions.
 *
 * <p>This is a one way link.  It emanates from a state (usually via a list of
 * transitions) and has a target state.</p>
 *
 * <p>Since we never have to change the ATN transitions once we construct it,
 * we can fix these transitions as specific classes. The DFA transitions
 * on the other hand need to update the labels as it adds transitions to
 * the states. We'll use the term Edge for the DFA to distinguish them from
 * ATN transitions.</p>
 */


class Transition {
  constructor(target) {
    // The target of this transition.
    if (target === undefined || target === null) {
      throw "target cannot be null.";
    }

    this.target = target; // Are we epsilon, action, sempred?

    this.isEpsilon = false;
    this.label = null;
  }

} // constants for serialization


Transition.EPSILON = 1;
Transition.RANGE = 2;
Transition.RULE = 3; // e.g., {isType(input.LT(1))}?

Transition.PREDICATE = 4;
Transition.ATOM = 5;
Transition.ACTION = 6; // ~(A|B) or ~atom, wildcard, which convert to next 2

Transition.SET = 7;
Transition.NOT_SET = 8;
Transition.WILDCARD = 9;
Transition.PRECEDENCE = 10;
Transition.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"];
Transition.serializationTypes = {
  EpsilonTransition: Transition.EPSILON,
  RangeTransition: Transition.RANGE,
  RuleTransition: Transition.RULE,
  PredicateTransition: Transition.PREDICATE,
  AtomTransition: Transition.ATOM,
  ActionTransition: Transition.ACTION,
  SetTransition: Transition.SET,
  NotSetTransition: Transition.NOT_SET,
  WildcardTransition: Transition.WILDCARD,
  PrecedencePredicateTransition: Transition.PRECEDENCE
}; // TODO: make all transitions sets? no, should remove set edges

class AtomTransition extends Transition {
  constructor(target, label) {
    super(target); // The token type or character value; or, signifies special label.

    this.label_ = label;
    this.label = this.makeLabel();
    this.serializationType = Transition.ATOM;
  }

  makeLabel() {
    const s = new IntervalSet();
    s.addOne(this.label_);
    return s;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label_ === symbol;
  }

  toString() {
    return this.label_;
  }

}

class RuleTransition extends Transition {
  constructor(ruleStart, ruleIndex, precedence, followState) {
    super(ruleStart); // ptr to the rule definition object for this rule ref

    this.ruleIndex = ruleIndex;
    this.precedence = precedence; // what node to begin computations following ref to rule

    this.followState = followState;
    this.serializationType = Transition.RULE;
    this.isEpsilon = true;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }

}

class EpsilonTransition extends Transition {
  constructor(target, outermostPrecedenceReturn) {
    super(target);
    this.serializationType = Transition.EPSILON;
    this.isEpsilon = true;
    this.outermostPrecedenceReturn = outermostPrecedenceReturn;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }

  toString() {
    return "epsilon";
  }

}

class RangeTransition extends Transition {
  constructor(target, start, stop) {
    super(target);
    this.serializationType = Transition.RANGE;
    this.start = start;
    this.stop = stop;
    this.label = this.makeLabel();
  }

  makeLabel() {
    const s = new IntervalSet();
    s.addRange(this.start, this.stop);
    return s;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= this.start && symbol <= this.stop;
  }

  toString() {
    return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
  }

}

class AbstractPredicateTransition extends Transition {
  constructor(target) {
    super(target);
  }

}

class PredicateTransition extends AbstractPredicateTransition {
  constructor(target, ruleIndex, predIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.PREDICATE;
    this.ruleIndex = ruleIndex;
    this.predIndex = predIndex;
    this.isCtxDependent = isCtxDependent; // e.g., $i ref in pred

    this.isEpsilon = true;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }

  getPredicate() {
    return new Predicate(this.ruleIndex, this.predIndex, this.isCtxDependent);
  }

  toString() {
    return "pred_" + this.ruleIndex + ":" + this.predIndex;
  }

}

class ActionTransition extends Transition {
  constructor(target, ruleIndex, actionIndex, isCtxDependent) {
    super(target);
    this.serializationType = Transition.ACTION;
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex === undefined ? -1 : actionIndex;
    this.isCtxDependent = isCtxDependent === undefined ? false : isCtxDependent; // e.g., $i ref in pred

    this.isEpsilon = true;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }

  toString() {
    return "action_" + this.ruleIndex + ":" + this.actionIndex;
  }

} // A transition containing a set of values.


class SetTransition extends Transition {
  constructor(target, set) {
    super(target);
    this.serializationType = Transition.SET;

    if (set !== undefined && set !== null) {
      this.label = set;
    } else {
      this.label = new IntervalSet();
      this.label.addOne(Token.INVALID_TYPE);
    }
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return this.label.contains(symbol);
  }

  toString() {
    return this.label.toString();
  }

}

class NotSetTransition extends SetTransition {
  constructor(target, set) {
    super(target, set);
    this.serializationType = Transition.NOT_SET;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol && !super.matches(symbol, minVocabSymbol, maxVocabSymbol);
  }

  toString() {
    return '~' + super.toString();
  }

}

class WildcardTransition extends Transition {
  constructor(target) {
    super(target);
    this.serializationType = Transition.WILDCARD;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return symbol >= minVocabSymbol && symbol <= maxVocabSymbol;
  }

  toString() {
    return ".";
  }

}

class PrecedencePredicateTransition extends AbstractPredicateTransition {
  constructor(target, precedence) {
    super(target);
    this.serializationType = Transition.PRECEDENCE;
    this.precedence = precedence;
    this.isEpsilon = true;
  }

  matches(symbol, minVocabSymbol, maxVocabSymbol) {
    return false;
  }

  getPredicate() {
    return new PrecedencePredicate(this.precedence);
  }

  toString() {
    return this.precedence + " >= _p";
  }

}

module.exports = {
  Transition,
  AtomTransition,
  SetTransition,
  NotSetTransition,
  RuleTransition,
  ActionTransition,
  EpsilonTransition,
  RangeTransition,
  WildcardTransition,
  PredicateTransition,
  PrecedencePredicateTransition,
  AbstractPredicateTransition
};

/***/ }),
/* 18 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const RuleContext = __webpack_require__(19);

const {
  Hash,
  Map,
  equalArrays
} = __webpack_require__(11);

class PredictionContext {
  constructor(cachedHashCode) {
    this.cachedHashCode = cachedHashCode;
  }
  /**
   * Stores the computed hash code of this {@link PredictionContext}. The hash
   * code is computed in parts to match the following reference algorithm.
   *
   * <pre>
   * private int referenceHashCode() {
   * int hash = {@link MurmurHash//initialize MurmurHash.initialize}({@link
   * //INITIAL_HASH});
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link //getParent
   * getParent}(i));
   * }
   *
   * for (int i = 0; i &lt; {@link //size()}; i++) {
   * hash = {@link MurmurHash//update MurmurHash.update}(hash, {@link
   * //getReturnState getReturnState}(i));
   * }
   *
   * hash = {@link MurmurHash//finish MurmurHash.finish}(hash, 2// {@link
   * //size()});
   * return hash;
   * }
   * </pre>
   * This means only the {@link //EMPTY} context is in set.
   */


  isEmpty() {
    return this === PredictionContext.EMPTY;
  }

  hasEmptyPath() {
    return this.getReturnState(this.length - 1) === PredictionContext.EMPTY_RETURN_STATE;
  }

  hashCode() {
    return this.cachedHashCode;
  }

  updateHashCode(hash) {
    hash.update(this.cachedHashCode);
  }

}
/**
 * Represents {@code $} in local context prediction, which means wildcard.
 * {@code//+x =//}.
 */


PredictionContext.EMPTY = null;
/**
 * Represents {@code $} in an array in full context mode, when {@code $}
 * doesn't mean wildcard: {@code $ + x = [$,x]}. Here,
 * {@code $} = {@link //EMPTY_RETURN_STATE}.
 */

PredictionContext.EMPTY_RETURN_STATE = 0x7FFFFFFF;
PredictionContext.globalNodeCount = 1;
PredictionContext.id = PredictionContext.globalNodeCount;
/*
function calculateHashString(parent, returnState) {
	return "" + parent + returnState;
}
*/

/**
 * Used to cache {@link PredictionContext} objects. Its used for the shared
 * context cash associated with contexts in DFA states. This cache
 * can be used for both lexers and parsers.
 */

class PredictionContextCache {
  constructor() {
    this.cache = new Map();
  }
  /**
   * Add a context to the cache and return it. If the context already exists,
   * return that one instead and do not add a new context to the cache.
   * Protect shared cache from unsafe thread access.
   */


  add(ctx) {
    if (ctx === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY;
    }

    const existing = this.cache.get(ctx) || null;

    if (existing !== null) {
      return existing;
    }

    this.cache.put(ctx, ctx);
    return ctx;
  }

  get(ctx) {
    return this.cache.get(ctx) || null;
  }

  get length() {
    return this.cache.length;
  }

}

class SingletonPredictionContext extends PredictionContext {
  constructor(parent, returnState) {
    let hashCode = 0;
    const hash = new Hash();

    if (parent !== null) {
      hash.update(parent, returnState);
    } else {
      hash.update(1);
    }

    hashCode = hash.finish();
    super(hashCode);
    this.parentCtx = parent;
    this.returnState = returnState;
  }

  getParent(index) {
    return this.parentCtx;
  }

  getReturnState(index) {
    return this.returnState;
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof SingletonPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false; // can't be same if hash is different
    } else {
      if (this.returnState !== other.returnState) return false;else if (this.parentCtx == null) return other.parentCtx == null;else return this.parentCtx.equals(other.parentCtx);
    }
  }

  toString() {
    const up = this.parentCtx === null ? "" : this.parentCtx.toString();

    if (up.length === 0) {
      if (this.returnState === PredictionContext.EMPTY_RETURN_STATE) {
        return "$";
      } else {
        return "" + this.returnState;
      }
    } else {
      return "" + this.returnState + " " + up;
    }
  }

  get length() {
    return 1;
  }

  static create(parent, returnState) {
    if (returnState === PredictionContext.EMPTY_RETURN_STATE && parent === null) {
      // someone can pass in the bits of an array ctx that mean $
      return PredictionContext.EMPTY;
    } else {
      return new SingletonPredictionContext(parent, returnState);
    }
  }

}

class EmptyPredictionContext extends SingletonPredictionContext {
  constructor() {
    super(null, PredictionContext.EMPTY_RETURN_STATE);
  }

  isEmpty() {
    return true;
  }

  getParent(index) {
    return null;
  }

  getReturnState(index) {
    return this.returnState;
  }

  equals(other) {
    return this === other;
  }

  toString() {
    return "$";
  }

}

PredictionContext.EMPTY = new EmptyPredictionContext();

class ArrayPredictionContext extends PredictionContext {
  constructor(parents, returnStates) {
    /**
     * Parent can be null only if full ctx mode and we make an array
     * from {@link //EMPTY} and non-empty. We merge {@link //EMPTY} by using
     * null parent and
     * returnState == {@link //EMPTY_RETURN_STATE}.
     */
    const h = new Hash();
    h.update(parents, returnStates);
    const hashCode = h.finish();
    super(hashCode);
    this.parents = parents;
    this.returnStates = returnStates;
    return this;
  }

  isEmpty() {
    // since EMPTY_RETURN_STATE can only appear in the last position, we
    // don't need to verify that size==1
    return this.returnStates[0] === PredictionContext.EMPTY_RETURN_STATE;
  }

  getParent(index) {
    return this.parents[index];
  }

  getReturnState(index) {
    return this.returnStates[index];
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof ArrayPredictionContext)) {
      return false;
    } else if (this.hashCode() !== other.hashCode()) {
      return false; // can't be same if hash is different
    } else {
      return equalArrays(this.returnStates, other.returnStates) && equalArrays(this.parents, other.parents);
    }
  }

  toString() {
    if (this.isEmpty()) {
      return "[]";
    } else {
      let s = "[";

      for (let i = 0; i < this.returnStates.length; i++) {
        if (i > 0) {
          s = s + ", ";
        }

        if (this.returnStates[i] === PredictionContext.EMPTY_RETURN_STATE) {
          s = s + "$";
          continue;
        }

        s = s + this.returnStates[i];

        if (this.parents[i] !== null) {
          s = s + " " + this.parents[i];
        } else {
          s = s + "null";
        }
      }

      return s + "]";
    }
  }

  get length() {
    return this.returnStates.length;
  }

}
/**
 * Convert a {@link RuleContext} tree to a {@link PredictionContext} graph.
 * Return {@link //EMPTY} if {@code outerContext} is empty or null.
 */


function predictionContextFromRuleContext(atn, outerContext) {
  if (outerContext === undefined || outerContext === null) {
    outerContext = RuleContext.EMPTY;
  } // if we are in RuleContext of start rule, s, then PredictionContext
  // is EMPTY. Nobody called us. (if we are empty, return empty)


  if (outerContext.parentCtx === null || outerContext === RuleContext.EMPTY) {
    return PredictionContext.EMPTY;
  } // If we have a parent, convert it to a PredictionContext graph


  const parent = predictionContextFromRuleContext(atn, outerContext.parentCtx);
  const state = atn.states[outerContext.invokingState];
  const transition = state.transitions[0];
  return SingletonPredictionContext.create(parent, transition.followState.stateNumber);
}
/*
function calculateListsHashString(parents, returnStates) {
	const s = "";
	parents.map(function(p) {
		s = s + p;
	});
	returnStates.map(function(r) {
		s = s + r;
	});
	return s;
}
*/


function merge(a, b, rootIsWildcard, mergeCache) {
  // share same graph if both same
  if (a === b) {
    return a;
  }

  if (a instanceof SingletonPredictionContext && b instanceof SingletonPredictionContext) {
    return mergeSingletons(a, b, rootIsWildcard, mergeCache);
  } // At least one of a or b is array
  // If one is $ and rootIsWildcard, return $ as// wildcard


  if (rootIsWildcard) {
    if (a instanceof EmptyPredictionContext) {
      return a;
    }

    if (b instanceof EmptyPredictionContext) {
      return b;
    }
  } // convert singleton so both are arrays to normalize


  if (a instanceof SingletonPredictionContext) {
    a = new ArrayPredictionContext([a.getParent()], [a.returnState]);
  }

  if (b instanceof SingletonPredictionContext) {
    b = new ArrayPredictionContext([b.getParent()], [b.returnState]);
  }

  return mergeArrays(a, b, rootIsWildcard, mergeCache);
}
/**
 * Merge two {@link SingletonPredictionContext} instances.
 *
 * <p>Stack tops equal, parents merge is same; return left graph.<br>
 * <embed src="images/SingletonMerge_SameRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Same stack top, parents differ; merge parents giving array node, then
 * remainders of those graphs. A new root node is created to point to the
 * merged parents.<br>
 * <embed src="images/SingletonMerge_SameRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to same parent. Make array node for the
 * root where both element in the root point to the same (original)
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootSamePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Different stack tops pointing to different parents. Make array node for
 * the root where each element points to the corresponding original
 * parent.<br>
 * <embed src="images/SingletonMerge_DiffRootDiffPar.svg"
 * type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 * @param mergeCache
 */


function mergeSingletons(a, b, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a, b);

    if (previous !== null) {
      return previous;
    }

    previous = mergeCache.get(b, a);

    if (previous !== null) {
      return previous;
    }
  }

  const rootMerge = mergeRoot(a, b, rootIsWildcard);

  if (rootMerge !== null) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, rootMerge);
    }

    return rootMerge;
  }

  if (a.returnState === b.returnState) {
    const parent = merge(a.parentCtx, b.parentCtx, rootIsWildcard, mergeCache); // if parent is same as existing a or b parent or reduced to a parent,
    // return it

    if (parent === a.parentCtx) {
      return a; // ax + bx = ax, if a=b
    }

    if (parent === b.parentCtx) {
      return b; // ax + bx = bx, if a=b
    } // else: ax + ay = a'[x,y]
    // merge parents x and y, giving array node with x,y then remainders
    // of those graphs. dup a, a' points at merged array
    // new joined parent so create new singleton pointing to it, a'


    const spc = SingletonPredictionContext.create(parent, a.returnState);

    if (mergeCache !== null) {
      mergeCache.set(a, b, spc);
    }

    return spc;
  } else {
    // a != b payloads differ
    // see if we can collapse parents due to $+x parents if local ctx
    let singleParent = null;

    if (a === b || a.parentCtx !== null && a.parentCtx === b.parentCtx) {
      // ax +
      // bx =
      // [a,b]x
      singleParent = a.parentCtx;
    }

    if (singleParent !== null) {
      // parents are same
      // sort payloads and use same parent
      const payloads = [a.returnState, b.returnState];

      if (a.returnState > b.returnState) {
        payloads[0] = b.returnState;
        payloads[1] = a.returnState;
      }

      const parents = [singleParent, singleParent];
      const apc = new ArrayPredictionContext(parents, payloads);

      if (mergeCache !== null) {
        mergeCache.set(a, b, apc);
      }

      return apc;
    } // parents differ and can't merge them. Just pack together
    // into array; can't merge.
    // ax + by = [ax,by]


    const payloads = [a.returnState, b.returnState];
    let parents = [a.parentCtx, b.parentCtx];

    if (a.returnState > b.returnState) {
      // sort by payload
      payloads[0] = b.returnState;
      payloads[1] = a.returnState;
      parents = [b.parentCtx, a.parentCtx];
    }

    const a_ = new ArrayPredictionContext(parents, payloads);

    if (mergeCache !== null) {
      mergeCache.set(a, b, a_);
    }

    return a_;
  }
}
/**
 * Handle case where at least one of {@code a} or {@code b} is
 * {@link //EMPTY}. In the following diagrams, the symbol {@code $} is used
 * to represent {@link //EMPTY}.
 *
 * <h2>Local-Context Merges</h2>
 *
 * <p>These local-context merge operations are used when {@code rootIsWildcard}
 * is true.</p>
 *
 * <p>{@link //EMPTY} is superset of any graph; return {@link //EMPTY}.<br>
 * <embed src="images/LocalMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p>{@link //EMPTY} and anything is {@code //EMPTY}, so merged parent is
 * {@code //EMPTY}; return left graph.<br>
 * <embed src="images/LocalMerge_EmptyParent.svg" type="image/svg+xml"/></p>
 *
 * <p>Special case of last merge if local context.<br>
 * <embed src="images/LocalMerge_DiffRoots.svg" type="image/svg+xml"/></p>
 *
 * <h2>Full-Context Merges</h2>
 *
 * <p>These full-context merge operations are used when {@code rootIsWildcard}
 * is false.</p>
 *
 * <p><embed src="images/FullMerge_EmptyRoots.svg" type="image/svg+xml"/></p>
 *
 * <p>Must keep all contexts; {@link //EMPTY} in array is a special value (and
 * null parent).<br>
 * <embed src="images/FullMerge_EmptyRoot.svg" type="image/svg+xml"/></p>
 *
 * <p><embed src="images/FullMerge_SameRoot.svg" type="image/svg+xml"/></p>
 *
 * @param a the first {@link SingletonPredictionContext}
 * @param b the second {@link SingletonPredictionContext}
 * @param rootIsWildcard {@code true} if this is a local-context merge,
 * otherwise false to indicate a full-context merge
 */


function mergeRoot(a, b, rootIsWildcard) {
  if (rootIsWildcard) {
    if (a === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY; // // + b =//
    }

    if (b === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY; // a +// =//
    }
  } else {
    if (a === PredictionContext.EMPTY && b === PredictionContext.EMPTY) {
      return PredictionContext.EMPTY; // $ + $ = $
    } else if (a === PredictionContext.EMPTY) {
      // $ + x = [$,x]
      const payloads = [b.returnState, PredictionContext.EMPTY_RETURN_STATE];
      const parents = [b.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    } else if (b === PredictionContext.EMPTY) {
      // x + $ = [$,x] ($ is always first if present)
      const payloads = [a.returnState, PredictionContext.EMPTY_RETURN_STATE];
      const parents = [a.parentCtx, null];
      return new ArrayPredictionContext(parents, payloads);
    }
  }

  return null;
}
/**
 * Merge two {@link ArrayPredictionContext} instances.
 *
 * <p>Different tops, different parents.<br>
 * <embed src="images/ArrayMerge_DiffTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, same parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSamePar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, different parents.<br>
 * <embed src="images/ArrayMerge_ShareTopDiffPar.svg" type="image/svg+xml"/></p>
 *
 * <p>Shared top, all shared parents.<br>
 * <embed src="images/ArrayMerge_ShareTopSharePar.svg"
 * type="image/svg+xml"/></p>
 *
 * <p>Equal tops, merge parents and reduce top to
 * {@link SingletonPredictionContext}.<br>
 * <embed src="images/ArrayMerge_EqualTop.svg" type="image/svg+xml"/></p>
 */


function mergeArrays(a, b, rootIsWildcard, mergeCache) {
  if (mergeCache !== null) {
    let previous = mergeCache.get(a, b);

    if (previous !== null) {
      return previous;
    }

    previous = mergeCache.get(b, a);

    if (previous !== null) {
      return previous;
    }
  } // merge sorted payloads a + b => M


  let i = 0; // walks a

  let j = 0; // walks b

  let k = 0; // walks target M array

  let mergedReturnStates = [];
  let mergedParents = []; // walk and merge to yield mergedParents, mergedReturnStates

  while (i < a.returnStates.length && j < b.returnStates.length) {
    const a_parent = a.parents[i];
    const b_parent = b.parents[j];

    if (a.returnStates[i] === b.returnStates[j]) {
      // same payload (stack tops are equal), must yield merged singleton
      const payload = a.returnStates[i]; // $+$ = $

      const bothDollars = payload === PredictionContext.EMPTY_RETURN_STATE && a_parent === null && b_parent === null;
      const ax_ax = a_parent !== null && b_parent !== null && a_parent === b_parent; // ax+ax
      // ->
      // ax

      if (bothDollars || ax_ax) {
        mergedParents[k] = a_parent; // choose left

        mergedReturnStates[k] = payload;
      } else {
        // ax+ay -> a'[x,y]
        mergedParents[k] = merge(a_parent, b_parent, rootIsWildcard, mergeCache);
        mergedReturnStates[k] = payload;
      }

      i += 1; // hop over left one as usual

      j += 1; // but also skip one in right side since we merge
    } else if (a.returnStates[i] < b.returnStates[j]) {
      // copy a[i] to M
      mergedParents[k] = a_parent;
      mergedReturnStates[k] = a.returnStates[i];
      i += 1;
    } else {
      // b > a, copy b[j] to M
      mergedParents[k] = b_parent;
      mergedReturnStates[k] = b.returnStates[j];
      j += 1;
    }

    k += 1;
  } // copy over any payloads remaining in either array


  if (i < a.returnStates.length) {
    for (let p = i; p < a.returnStates.length; p++) {
      mergedParents[k] = a.parents[p];
      mergedReturnStates[k] = a.returnStates[p];
      k += 1;
    }
  } else {
    for (let p = j; p < b.returnStates.length; p++) {
      mergedParents[k] = b.parents[p];
      mergedReturnStates[k] = b.returnStates[p];
      k += 1;
    }
  } // trim merged if we combined a few that had same stack tops


  if (k < mergedParents.length) {
    // write index < last position; trim
    if (k === 1) {
      // for just one merged element, return singleton top
      const a_ = SingletonPredictionContext.create(mergedParents[0], mergedReturnStates[0]);

      if (mergeCache !== null) {
        mergeCache.set(a, b, a_);
      }

      return a_;
    }

    mergedParents = mergedParents.slice(0, k);
    mergedReturnStates = mergedReturnStates.slice(0, k);
  }

  const M = new ArrayPredictionContext(mergedParents, mergedReturnStates); // if we created same array as a or b, return that instead
  // TODO: track whether this is possible above during merge sort for speed

  if (M === a) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, a);
    }

    return a;
  }

  if (M === b) {
    if (mergeCache !== null) {
      mergeCache.set(a, b, b);
    }

    return b;
  }

  combineCommonParents(mergedParents);

  if (mergeCache !== null) {
    mergeCache.set(a, b, M);
  }

  return M;
}
/**
 * Make pass over all <em>M</em> {@code parents}; merge any {@code equals()}
 * ones.
 */


function combineCommonParents(parents) {
  const uniqueParents = new Map();

  for (let p = 0; p < parents.length; p++) {
    const parent = parents[p];

    if (!uniqueParents.containsKey(parent)) {
      uniqueParents.put(parent, parent);
    }
  }

  for (let q = 0; q < parents.length; q++) {
    parents[q] = uniqueParents.get(parents[q]);
  }
}

function getCachedPredictionContext(context, contextCache, visited) {
  if (context.isEmpty()) {
    return context;
  }

  let existing = visited.get(context) || null;

  if (existing !== null) {
    return existing;
  }

  existing = contextCache.get(context);

  if (existing !== null) {
    visited.put(context, existing);
    return existing;
  }

  let changed = false;
  let parents = [];

  for (let i = 0; i < parents.length; i++) {
    const parent = getCachedPredictionContext(context.getParent(i), contextCache, visited);

    if (changed || parent !== context.getParent(i)) {
      if (!changed) {
        parents = [];

        for (let j = 0; j < context.length; j++) {
          parents[j] = context.getParent(j);
        }

        changed = true;
      }

      parents[i] = parent;
    }
  }

  if (!changed) {
    contextCache.add(context);
    visited.put(context, context);
    return context;
  }

  let updated = null;

  if (parents.length === 0) {
    updated = PredictionContext.EMPTY;
  } else if (parents.length === 1) {
    updated = SingletonPredictionContext.create(parents[0], context.getReturnState(0));
  } else {
    updated = new ArrayPredictionContext(parents, context.returnStates);
  }

  contextCache.add(updated);
  visited.put(updated, updated);
  visited.put(context, updated);
  return updated;
} // ter's recursive version of Sam's getAllNodes()


function getAllContextNodes(context, nodes, visited) {
  if (nodes === null) {
    nodes = [];
    return getAllContextNodes(context, nodes, visited);
  } else if (visited === null) {
    visited = new Map();
    return getAllContextNodes(context, nodes, visited);
  } else {
    if (context === null || visited.containsKey(context)) {
      return nodes;
    }

    visited.put(context, context);
    nodes.push(context);

    for (let i = 0; i < context.length; i++) {
      getAllContextNodes(context.getParent(i), nodes, visited);
    }

    return nodes;
  }
}

module.exports = {
  merge,
  PredictionContext,
  PredictionContextCache,
  SingletonPredictionContext,
  predictionContextFromRuleContext,
  getCachedPredictionContext
};

/***/ }),
/* 19 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  RuleNode
} = __webpack_require__(20);

const {
  INVALID_INTERVAL
} = __webpack_require__(20);

const Trees = __webpack_require__(21);

class RuleContext extends RuleNode {
  /** A rule context is a record of a single rule invocation. It knows
   * which context invoked it, if any. If there is no parent context, then
   * naturally the invoking state is not valid.  The parent link
   * provides a chain upwards from the current rule invocation to the root
   * of the invocation tree, forming a stack. We actually carry no
   * information about the rule associated with this context (except
   * when parsing). We keep only the state number of the invoking state from
   * the ATN submachine that invoked this. Contrast this with the s
   * pointer inside ParserRuleContext that tracks the current state
   * being "executed" for the current rule.
   *
   * The parent contexts are useful for computing lookahead sets and
   * getting error information.
   *
   * These objects are used during parsing and prediction.
   * For the special case of parsers, we use the subclass
   * ParserRuleContext.
   *
   * @see ParserRuleContext
   */
  constructor(parent, invokingState) {
    // What context invoked this rule?
    super();
    this.parentCtx = parent || null;
    /**
     * What state invoked the rule associated with this context?
     * The "return address" is the followState of invokingState
     * If parent is null, this should be -1.
     */

    this.invokingState = invokingState || -1;
  }

  depth() {
    let n = 0;
    let p = this;

    while (p !== null) {
      p = p.parentCtx;
      n += 1;
    }

    return n;
  }
  /**
   * A context is empty if there is no invoking state; meaning nobody call
   * current context.
   */


  isEmpty() {
    return this.invokingState === -1;
  } // satisfy the ParseTree / SyntaxTree interface


  getSourceInterval() {
    return INVALID_INTERVAL;
  }

  getRuleContext() {
    return this;
  }

  getPayload() {
    return this;
  }
  /**
   * Return the combined text of all child nodes. This method only considers
   * tokens which have been added to the parse tree.
   * <p>
   * Since tokens on hidden channels (e.g. whitespace or comments) are not
   * added to the parse trees, they will not appear in the output of this
   * method.
   */


  getText() {
    if (this.getChildCount() === 0) {
      return "";
    } else {
      return this.children.map(function (child) {
        return child.getText();
      }).join("");
    }
  }
  /**
   * For rule associated with this parse tree internal node, return
   * the outer alternative number used to match the input. Default
   * implementation does not compute nor store this alt num. Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   * to set it.
   */


  getAltNumber() {
    // use constant value of ATN.INVALID_ALT_NUMBER to avoid circular dependency
    return 0;
  }
  /**
   * Set the outer alternative number for this context node. Default
   * implementation does nothing to avoid backing field overhead for
   * trees that don't need it.  Create
   * a subclass of ParserRuleContext with backing field and set
   * option contextSuperClass.
   */


  setAltNumber(altNumber) {}

  getChild(i) {
    return null;
  }

  getChildCount() {
    return 0;
  }

  accept(visitor) {
    return visitor.visitChildren(this);
  }
  /**
   * Print out a whole tree, not just a node, in LISP format
   * (root child1 .. childN). Print just a node if this is a leaf.
   */


  toStringTree(ruleNames, recog) {
    return Trees.toStringTree(this, ruleNames, recog);
  }

  toString(ruleNames, stop) {
    ruleNames = ruleNames || null;
    stop = stop || null;
    let p = this;
    let s = "[";

    while (p !== null && p !== stop) {
      if (ruleNames === null) {
        if (!p.isEmpty()) {
          s += p.invokingState;
        }
      } else {
        const ri = p.ruleIndex;
        const ruleName = ri >= 0 && ri < ruleNames.length ? ruleNames[ri] : "" + ri;
        s += ruleName;
      }

      if (p.parentCtx !== null && (ruleNames !== null || !p.parentCtx.isEmpty())) {
        s += " ";
      }

      p = p.parentCtx;
    }

    s += "]";
    return s;
  }

}

module.exports = RuleContext;

/***/ }),
/* 20 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const {
  Interval
} = __webpack_require__(16);

const INVALID_INTERVAL = new Interval(-1, -2);
/**
 * The basic notion of a tree has a parent, a payload, and a list of children.
 * It is the most abstract interface for all the trees used by ANTLR.
 */

class Tree {}

class SyntaxTree extends Tree {
  constructor() {
    super();
  }

}

class ParseTree extends SyntaxTree {
  constructor() {
    super();
  }

}

class RuleNode extends ParseTree {
  constructor() {
    super();
  }

  getRuleContext() {
    throw new Error("missing interface implementation");
  }

}

class TerminalNode extends ParseTree {
  constructor() {
    super();
  }

}

class ErrorNode extends TerminalNode {
  constructor() {
    super();
  }

}

class ParseTreeVisitor {
  visit(ctx) {
    if (Array.isArray(ctx)) {
      return ctx.map(function (child) {
        return child.accept(this);
      }, this);
    } else {
      return ctx.accept(this);
    }
  }

  visitChildren(ctx) {
    if (ctx.children) {
      return this.visit(ctx.children);
    } else {
      return null;
    }
  }

  visitTerminal(node) {}

  visitErrorNode(node) {}

}

class ParseTreeListener {
  visitTerminal(node) {}

  visitErrorNode(node) {}

  enterEveryRule(node) {}

  exitEveryRule(node) {}

}

class TerminalNodeImpl extends TerminalNode {
  constructor(symbol) {
    super();
    this.parentCtx = null;
    this.symbol = symbol;
  }

  getChild(i) {
    return null;
  }

  getSymbol() {
    return this.symbol;
  }

  getParent() {
    return this.parentCtx;
  }

  getPayload() {
    return this.symbol;
  }

  getSourceInterval() {
    if (this.symbol === null) {
      return INVALID_INTERVAL;
    }

    const tokenIndex = this.symbol.tokenIndex;
    return new Interval(tokenIndex, tokenIndex);
  }

  getChildCount() {
    return 0;
  }

  accept(visitor) {
    return visitor.visitTerminal(this);
  }

  getText() {
    return this.symbol.text;
  }

  toString() {
    if (this.symbol.type === Token.EOF) {
      return "<EOF>";
    } else {
      return this.symbol.text;
    }
  }

}
/**
 * Represents a token that was consumed during resynchronization
 * rather than during a valid match operation. For example,
 * we will create this kind of a node during single token insertion
 * and deletion as well as during "consume until error recovery set"
 * upon no viable alternative exceptions.
 */


class ErrorNodeImpl extends TerminalNodeImpl {
  constructor(token) {
    super(token);
  }

  isErrorNode() {
    return true;
  }

  accept(visitor) {
    return visitor.visitErrorNode(this);
  }

}

class ParseTreeWalker {
  /**
   * Performs a walk on the given parse tree starting at the root and going down recursively
   * with depth-first search. On each node, {@link ParseTreeWalker//enterRule} is called before
   * recursively walking down into child nodes, then
   * {@link ParseTreeWalker//exitRule} is called after the recursive call to wind up.
   * @param listener The listener used by the walker to process grammar rules
   * @param t The parse tree to be walked on
   */
  walk(listener, t) {
    const errorNode = t instanceof ErrorNode || t.isErrorNode !== undefined && t.isErrorNode();

    if (errorNode) {
      listener.visitErrorNode(t);
    } else if (t instanceof TerminalNode) {
      listener.visitTerminal(t);
    } else {
      this.enterRule(listener, t);

      for (let i = 0; i < t.getChildCount(); i++) {
        const child = t.getChild(i);
        this.walk(listener, child);
      }

      this.exitRule(listener, t);
    }
  }
  /**
   * Enters a grammar rule by first triggering the generic event {@link ParseTreeListener//enterEveryRule}
   * then by triggering the event specific to the given parse tree node
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */


  enterRule(listener, r) {
    const ctx = r.getRuleContext();
    listener.enterEveryRule(ctx);
    ctx.enterRule(listener);
  }
  /**
   * Exits a grammar rule by first triggering the event specific to the given parse tree node
   * then by triggering the generic event {@link ParseTreeListener//exitEveryRule}
   * @param listener The listener responding to the trigger events
   * @param r The grammar rule containing the rule context
   */


  exitRule(listener, r) {
    const ctx = r.getRuleContext();
    ctx.exitRule(listener);
    listener.exitEveryRule(ctx);
  }

}

ParseTreeWalker.DEFAULT = new ParseTreeWalker();
module.exports = {
  RuleNode,
  ErrorNode,
  TerminalNode,
  ErrorNodeImpl,
  TerminalNodeImpl,
  ParseTreeListener,
  ParseTreeVisitor,
  ParseTreeWalker,
  INVALID_INTERVAL
};

/***/ }),
/* 21 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Utils = __webpack_require__(11);

const {
  Token
} = __webpack_require__(12);

const {
  ErrorNode,
  TerminalNode,
  RuleNode
} = __webpack_require__(20);
/** A set of utility routines useful for all kinds of ANTLR trees. */


const Trees = {
  /**
   * Print out a whole tree in LISP form. {@link //getNodeText} is used on the
   *  node payloads to get the text for the nodes.  Detect
   *  parse trees and extract data appropriately.
   */
  toStringTree: function (tree, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;

    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }

    let s = Trees.getNodeText(tree, ruleNames);
    s = Utils.escapeWhitespace(s, false);
    const c = tree.getChildCount();

    if (c === 0) {
      return s;
    }

    let res = "(" + s + ' ';

    if (c > 0) {
      s = Trees.toStringTree(tree.getChild(0), ruleNames);
      res = res.concat(s);
    }

    for (let i = 1; i < c; i++) {
      s = Trees.toStringTree(tree.getChild(i), ruleNames);
      res = res.concat(' ' + s);
    }

    res = res.concat(")");
    return res;
  },
  getNodeText: function (t, ruleNames, recog) {
    ruleNames = ruleNames || null;
    recog = recog || null;

    if (recog !== null) {
      ruleNames = recog.ruleNames;
    }

    if (ruleNames !== null) {
      if (t instanceof RuleNode) {
        const context = t.getRuleContext();
        const altNumber = context.getAltNumber(); // use const value of ATN.INVALID_ALT_NUMBER to avoid circular dependency

        if (altNumber != 0) {
          return ruleNames[t.ruleIndex] + ":" + altNumber;
        }

        return ruleNames[t.ruleIndex];
      } else if (t instanceof ErrorNode) {
        return t.toString();
      } else if (t instanceof TerminalNode) {
        if (t.symbol !== null) {
          return t.symbol.text;
        }
      }
    } // no recog for rule names


    const payload = t.getPayload();

    if (payload instanceof Token) {
      return payload.text;
    }

    return t.getPayload().toString();
  },

  /**
   * Return ordered list of all children of this node
   */
  getChildren: function (t) {
    const list = [];

    for (let i = 0; i < t.getChildCount(); i++) {
      list.push(t.getChild(i));
    }

    return list;
  },

  /**
   * Return a list of all ancestors of this node.  The first node of
   * list is the root and the last is the parent of this node.
   */
  getAncestors: function (t) {
    let ancestors = [];
    t = t.getParent();

    while (t !== null) {
      ancestors = [t].concat(ancestors);
      t = t.getParent();
    }

    return ancestors;
  },
  findAllTokenNodes: function (t, ttype) {
    return Trees.findAllNodes(t, ttype, true);
  },
  findAllRuleNodes: function (t, ruleIndex) {
    return Trees.findAllNodes(t, ruleIndex, false);
  },
  findAllNodes: function (t, index, findTokens) {
    const nodes = [];

    Trees._findAllNodes(t, index, findTokens, nodes);

    return nodes;
  },
  _findAllNodes: function (t, index, findTokens, nodes) {
    // check this node (the root) first
    if (findTokens && t instanceof TerminalNode) {
      if (t.symbol.type === index) {
        nodes.push(t);
      }
    } else if (!findTokens && t instanceof RuleNode) {
      if (t.ruleIndex === index) {
        nodes.push(t);
      }
    } // check children


    for (let i = 0; i < t.getChildCount(); i++) {
      Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);
    }
  },
  descendants: function (t) {
    let nodes = [t];

    for (let i = 0; i < t.getChildCount(); i++) {
      nodes = nodes.concat(Trees.descendants(t.getChild(i)));
    }

    return nodes;
  }
};
module.exports = Trees;

/***/ }),
/* 22 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const ATN = __webpack_require__(9);

const ATNType = __webpack_require__(23);

const {
  ATNState,
  BasicState,
  DecisionState,
  BlockStartState,
  BlockEndState,
  LoopEndState,
  RuleStartState,
  RuleStopState,
  TokensStartState,
  PlusLoopbackState,
  StarLoopbackState,
  StarLoopEntryState,
  PlusBlockStartState,
  StarBlockStartState,
  BasicBlockStartState
} = __webpack_require__(14);

const {
  Transition,
  AtomTransition,
  SetTransition,
  NotSetTransition,
  RuleTransition,
  RangeTransition,
  ActionTransition,
  EpsilonTransition,
  WildcardTransition,
  PredicateTransition,
  PrecedencePredicateTransition
} = __webpack_require__(17);

const {
  IntervalSet
} = __webpack_require__(16);

const ATNDeserializationOptions = __webpack_require__(24);

const {
  LexerActionType,
  LexerSkipAction,
  LexerChannelAction,
  LexerCustomAction,
  LexerMoreAction,
  LexerTypeAction,
  LexerPushModeAction,
  LexerPopModeAction,
  LexerModeAction
} = __webpack_require__(25); // This is the earliest supported serialized UUID.
// stick to serialized version for now, we don't need a UUID instance


const BASE_SERIALIZED_UUID = "AADB8D7E-AEEF-4415-AD2B-8204D6CF042E"; //
// This UUID indicates the serialized ATN contains two sets of
// IntervalSets, where the second set's values are encoded as
// 32-bit integers to support the full Unicode SMP range up to U+10FFFF.
//

const ADDED_UNICODE_SMP = "59627784-3BE5-417A-B9EB-8131A7286089"; // This list contains all of the currently supported UUIDs, ordered by when
// the feature first appeared in this branch.

const SUPPORTED_UUIDS = [BASE_SERIALIZED_UUID, ADDED_UNICODE_SMP];
const SERIALIZED_VERSION = 3; // This is the current serialized UUID.

const SERIALIZED_UUID = ADDED_UNICODE_SMP;

function initArray(length, value) {
  const tmp = [];
  tmp[length - 1] = value;
  return tmp.map(function (i) {
    return value;
  });
}

class ATNDeserializer {
  constructor(options) {
    if (options === undefined || options === null) {
      options = ATNDeserializationOptions.defaultOptions;
    }

    this.deserializationOptions = options;
    this.stateFactories = null;
    this.actionFactories = null;
  }
  /**
   * Determines if a particular serialized representation of an ATN supports
   * a particular feature, identified by the {@link UUID} used for serializing
   * the ATN at the time the feature was first introduced.
   *
   * @param feature The {@link UUID} marking the first time the feature was
   * supported in the serialized ATN.
   * @param actualUuid The {@link UUID} of the actual serialized ATN which is
   * currently being deserialized.
   * @return {@code true} if the {@code actualUuid} value represents a
   * serialized ATN at or after the feature identified by {@code feature} was
   * introduced; otherwise, {@code false}.
  */


  isFeatureSupported(feature, actualUuid) {
    const idx1 = SUPPORTED_UUIDS.indexOf(feature);

    if (idx1 < 0) {
      return false;
    }

    const idx2 = SUPPORTED_UUIDS.indexOf(actualUuid);
    return idx2 >= idx1;
  }

  deserialize(data) {
    this.reset(data);
    this.checkVersion();
    this.checkUUID();
    const atn = this.readATN();
    this.readStates(atn);
    this.readRules(atn);
    this.readModes(atn);
    const sets = []; // First, deserialize sets with 16-bit arguments <= U+FFFF.

    this.readSets(atn, sets, this.readInt.bind(this)); // Next, if the ATN was serialized with the Unicode SMP feature,
    // deserialize sets with 32-bit arguments <= U+10FFFF.

    if (this.isFeatureSupported(ADDED_UNICODE_SMP, this.uuid)) {
      this.readSets(atn, sets, this.readInt32.bind(this));
    }

    this.readEdges(atn, sets);
    this.readDecisions(atn);
    this.readLexerActions(atn);
    this.markPrecedenceDecisions(atn);
    this.verifyATN(atn);

    if (this.deserializationOptions.generateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {
      this.generateRuleBypassTransitions(atn); // re-verify after modification

      this.verifyATN(atn);
    }

    return atn;
  }

  reset(data) {
    const adjust = function (c) {
      const v = c.charCodeAt(0);
      return v > 1 ? v - 2 : v + 65534;
    };

    const temp = data.split("").map(adjust); // don't adjust the first value since that's the version number

    temp[0] = data.charCodeAt(0);
    this.data = temp;
    this.pos = 0;
  }

  checkVersion() {
    const version = this.readInt();

    if (version !== SERIALIZED_VERSION) {
      throw "Could not deserialize ATN with version " + version + " (expected " + SERIALIZED_VERSION + ").";
    }
  }

  checkUUID() {
    const uuid = this.readUUID();

    if (SUPPORTED_UUIDS.indexOf(uuid) < 0) {
      throw "Could not deserialize ATN with UUID: " + uuid + " (expected " + SERIALIZED_UUID + " or a legacy UUID).", uuid, SERIALIZED_UUID;
    }

    this.uuid = uuid;
  }

  readATN() {
    const grammarType = this.readInt();
    const maxTokenType = this.readInt();
    return new ATN(grammarType, maxTokenType);
  }

  readStates(atn) {
    let j, pair, stateNumber;
    const loopBackStateNumbers = [];
    const endStateNumbers = [];
    const nstates = this.readInt();

    for (let i = 0; i < nstates; i++) {
      const stype = this.readInt(); // ignore bad type of states

      if (stype === ATNState.INVALID_TYPE) {
        atn.addState(null);
        continue;
      }

      let ruleIndex = this.readInt();

      if (ruleIndex === 0xFFFF) {
        ruleIndex = -1;
      }

      const s = this.stateFactory(stype, ruleIndex);

      if (stype === ATNState.LOOP_END) {
        // special case
        const loopBackStateNumber = this.readInt();
        loopBackStateNumbers.push([s, loopBackStateNumber]);
      } else if (s instanceof BlockStartState) {
        const endStateNumber = this.readInt();
        endStateNumbers.push([s, endStateNumber]);
      }

      atn.addState(s);
    } // delay the assignment of loop back and end states until we know all the
    // state instances have been initialized


    for (j = 0; j < loopBackStateNumbers.length; j++) {
      pair = loopBackStateNumbers[j];
      pair[0].loopBackState = atn.states[pair[1]];
    }

    for (j = 0; j < endStateNumbers.length; j++) {
      pair = endStateNumbers[j];
      pair[0].endState = atn.states[pair[1]];
    }

    let numNonGreedyStates = this.readInt();

    for (j = 0; j < numNonGreedyStates; j++) {
      stateNumber = this.readInt();
      atn.states[stateNumber].nonGreedy = true;
    }

    let numPrecedenceStates = this.readInt();

    for (j = 0; j < numPrecedenceStates; j++) {
      stateNumber = this.readInt();
      atn.states[stateNumber].isPrecedenceRule = true;
    }
  }

  readRules(atn) {
    let i;
    const nrules = this.readInt();

    if (atn.grammarType === ATNType.LEXER) {
      atn.ruleToTokenType = initArray(nrules, 0);
    }

    atn.ruleToStartState = initArray(nrules, 0);

    for (i = 0; i < nrules; i++) {
      const s = this.readInt();
      atn.ruleToStartState[i] = atn.states[s];

      if (atn.grammarType === ATNType.LEXER) {
        let tokenType = this.readInt();

        if (tokenType === 0xFFFF) {
          tokenType = Token.EOF;
        }

        atn.ruleToTokenType[i] = tokenType;
      }
    }

    atn.ruleToStopState = initArray(nrules, 0);

    for (i = 0; i < atn.states.length; i++) {
      const state = atn.states[i];

      if (!(state instanceof RuleStopState)) {
        continue;
      }

      atn.ruleToStopState[state.ruleIndex] = state;
      atn.ruleToStartState[state.ruleIndex].stopState = state;
    }
  }

  readModes(atn) {
    const nmodes = this.readInt();

    for (let i = 0; i < nmodes; i++) {
      let s = this.readInt();
      atn.modeToStartState.push(atn.states[s]);
    }
  }

  readSets(atn, sets, readUnicode) {
    const m = this.readInt();

    for (let i = 0; i < m; i++) {
      const iset = new IntervalSet();
      sets.push(iset);
      const n = this.readInt();
      const containsEof = this.readInt();

      if (containsEof !== 0) {
        iset.addOne(-1);
      }

      for (let j = 0; j < n; j++) {
        const i1 = readUnicode();
        const i2 = readUnicode();
        iset.addRange(i1, i2);
      }
    }
  }

  readEdges(atn, sets) {
    let i, j, state, trans, target;
    const nedges = this.readInt();

    for (i = 0; i < nedges; i++) {
      const src = this.readInt();
      const trg = this.readInt();
      const ttype = this.readInt();
      const arg1 = this.readInt();
      const arg2 = this.readInt();
      const arg3 = this.readInt();
      trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);
      const srcState = atn.states[src];
      srcState.addTransition(trans);
    } // edges for rule stop states can be derived, so they aren't serialized


    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];

      for (j = 0; j < state.transitions.length; j++) {
        const t = state.transitions[j];

        if (!(t instanceof RuleTransition)) {
          continue;
        }

        let outermostPrecedenceReturn = -1;

        if (atn.ruleToStartState[t.target.ruleIndex].isPrecedenceRule) {
          if (t.precedence === 0) {
            outermostPrecedenceReturn = t.target.ruleIndex;
          }
        }

        trans = new EpsilonTransition(t.followState, outermostPrecedenceReturn);
        atn.ruleToStopState[t.target.ruleIndex].addTransition(trans);
      }
    }

    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];

      if (state instanceof BlockStartState) {
        // we need to know the end state to set its start state
        if (state.endState === null) {
          throw "IllegalState";
        } // block end states can only be associated to a single block start
        // state


        if (state.endState.startState !== null) {
          throw "IllegalState";
        }

        state.endState.startState = state;
      }

      if (state instanceof PlusLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;

          if (target instanceof PlusBlockStartState) {
            target.loopBackState = state;
          }
        }
      } else if (state instanceof StarLoopbackState) {
        for (j = 0; j < state.transitions.length; j++) {
          target = state.transitions[j].target;

          if (target instanceof StarLoopEntryState) {
            target.loopBackState = state;
          }
        }
      }
    }
  }

  readDecisions(atn) {
    const ndecisions = this.readInt();

    for (let i = 0; i < ndecisions; i++) {
      const s = this.readInt();
      const decState = atn.states[s];
      atn.decisionToState.push(decState);
      decState.decision = i;
    }
  }

  readLexerActions(atn) {
    if (atn.grammarType === ATNType.LEXER) {
      const count = this.readInt();
      atn.lexerActions = initArray(count, null);

      for (let i = 0; i < count; i++) {
        const actionType = this.readInt();
        let data1 = this.readInt();

        if (data1 === 0xFFFF) {
          data1 = -1;
        }

        let data2 = this.readInt();

        if (data2 === 0xFFFF) {
          data2 = -1;
        }

        atn.lexerActions[i] = this.lexerActionFactory(actionType, data1, data2);
      }
    }
  }

  generateRuleBypassTransitions(atn) {
    let i;
    const count = atn.ruleToStartState.length;

    for (i = 0; i < count; i++) {
      atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;
    }

    for (i = 0; i < count; i++) {
      this.generateRuleBypassTransition(atn, i);
    }
  }

  generateRuleBypassTransition(atn, idx) {
    let i, state;
    const bypassStart = new BasicBlockStartState();
    bypassStart.ruleIndex = idx;
    atn.addState(bypassStart);
    const bypassStop = new BlockEndState();
    bypassStop.ruleIndex = idx;
    atn.addState(bypassStop);
    bypassStart.endState = bypassStop;
    atn.defineDecisionState(bypassStart);
    bypassStop.startState = bypassStart;
    let excludeTransition = null;
    let endState = null;

    if (atn.ruleToStartState[idx].isPrecedenceRule) {
      // wrap from the beginning of the rule to the StarLoopEntryState
      endState = null;

      for (i = 0; i < atn.states.length; i++) {
        state = atn.states[i];

        if (this.stateIsEndStateFor(state, idx)) {
          endState = state;
          excludeTransition = state.loopBackState.transitions[0];
          break;
        }
      }

      if (excludeTransition === null) {
        throw "Couldn't identify final state of the precedence rule prefix section.";
      }
    } else {
      endState = atn.ruleToStopState[idx];
    } // all non-excluded transitions that currently target end state need to
    // target blockEnd instead


    for (i = 0; i < atn.states.length; i++) {
      state = atn.states[i];

      for (let j = 0; j < state.transitions.length; j++) {
        const transition = state.transitions[j];

        if (transition === excludeTransition) {
          continue;
        }

        if (transition.target === endState) {
          transition.target = bypassStop;
        }
      }
    } // all transitions leaving the rule start state need to leave blockStart
    // instead


    const ruleToStartState = atn.ruleToStartState[idx];
    const count = ruleToStartState.transitions.length;

    while (count > 0) {
      bypassStart.addTransition(ruleToStartState.transitions[count - 1]);
      ruleToStartState.transitions = ruleToStartState.transitions.slice(-1);
    } // link the new states


    atn.ruleToStartState[idx].addTransition(new EpsilonTransition(bypassStart));
    bypassStop.addTransition(new EpsilonTransition(endState));
    const matchState = new BasicState();
    atn.addState(matchState);
    matchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[idx]));
    bypassStart.addTransition(new EpsilonTransition(matchState));
  }

  stateIsEndStateFor(state, idx) {
    if (state.ruleIndex !== idx) {
      return null;
    }

    if (!(state instanceof StarLoopEntryState)) {
      return null;
    }

    const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;

    if (!(maybeLoopEndState instanceof LoopEndState)) {
      return null;
    }

    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
      return state;
    } else {
      return null;
    }
  }
  /**
   * Analyze the {@link StarLoopEntryState} states in the specified ATN to set
   * the {@link StarLoopEntryState//isPrecedenceDecision} field to the
   * correct value.
   * @param atn The ATN.
   */


  markPrecedenceDecisions(atn) {
    for (let i = 0; i < atn.states.length; i++) {
      const state = atn.states[i];

      if (!(state instanceof StarLoopEntryState)) {
        continue;
      } // We analyze the ATN to determine if this ATN decision state is the
      // decision for the closure block that determines whether a
      // precedence rule should continue or complete.


      if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {
        const maybeLoopEndState = state.transitions[state.transitions.length - 1].target;

        if (maybeLoopEndState instanceof LoopEndState) {
          if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transitions[0].target instanceof RuleStopState) {
            state.isPrecedenceDecision = true;
          }
        }
      }
    }
  }

  verifyATN(atn) {
    if (!this.deserializationOptions.verifyATN) {
      return;
    } // verify assumptions


    for (let i = 0; i < atn.states.length; i++) {
      const state = atn.states[i];

      if (state === null) {
        continue;
      }

      this.checkCondition(state.epsilonOnlyTransitions || state.transitions.length <= 1);

      if (state instanceof PlusBlockStartState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof StarLoopEntryState) {
        this.checkCondition(state.loopBackState !== null);
        this.checkCondition(state.transitions.length === 2);

        if (state.transitions[0].target instanceof StarBlockStartState) {
          this.checkCondition(state.transitions[1].target instanceof LoopEndState);
          this.checkCondition(!state.nonGreedy);
        } else if (state.transitions[0].target instanceof LoopEndState) {
          this.checkCondition(state.transitions[1].target instanceof StarBlockStartState);
          this.checkCondition(state.nonGreedy);
        } else {
          throw "IllegalState";
        }
      } else if (state instanceof StarLoopbackState) {
        this.checkCondition(state.transitions.length === 1);
        this.checkCondition(state.transitions[0].target instanceof StarLoopEntryState);
      } else if (state instanceof LoopEndState) {
        this.checkCondition(state.loopBackState !== null);
      } else if (state instanceof RuleStartState) {
        this.checkCondition(state.stopState !== null);
      } else if (state instanceof BlockStartState) {
        this.checkCondition(state.endState !== null);
      } else if (state instanceof BlockEndState) {
        this.checkCondition(state.startState !== null);
      } else if (state instanceof DecisionState) {
        this.checkCondition(state.transitions.length <= 1 || state.decision >= 0);
      } else {
        this.checkCondition(state.transitions.length <= 1 || state instanceof RuleStopState);
      }
    }
  }

  checkCondition(condition, message) {
    if (!condition) {
      if (message === undefined || message === null) {
        message = "IllegalState";
      }

      throw message;
    }
  }

  readInt() {
    return this.data[this.pos++];
  }

  readInt32() {
    const low = this.readInt();
    const high = this.readInt();
    return low | high << 16;
  }

  readLong() {
    const low = this.readInt32();
    const high = this.readInt32();
    return low & 0x00000000FFFFFFFF | high << 32;
  }

  readUUID() {
    const bb = [];

    for (let i = 7; i >= 0; i--) {
      const int = this.readInt();
      /* jshint bitwise: false */

      bb[2 * i + 1] = int & 0xFF;
      bb[2 * i] = int >> 8 & 0xFF;
    }

    return byteToHex[bb[0]] + byteToHex[bb[1]] + byteToHex[bb[2]] + byteToHex[bb[3]] + '-' + byteToHex[bb[4]] + byteToHex[bb[5]] + '-' + byteToHex[bb[6]] + byteToHex[bb[7]] + '-' + byteToHex[bb[8]] + byteToHex[bb[9]] + '-' + byteToHex[bb[10]] + byteToHex[bb[11]] + byteToHex[bb[12]] + byteToHex[bb[13]] + byteToHex[bb[14]] + byteToHex[bb[15]];
  }

  edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {
    const target = atn.states[trg];

    switch (type) {
      case Transition.EPSILON:
        return new EpsilonTransition(target);

      case Transition.RANGE:
        return arg3 !== 0 ? new RangeTransition(target, Token.EOF, arg2) : new RangeTransition(target, arg1, arg2);

      case Transition.RULE:
        return new RuleTransition(atn.states[arg1], arg2, arg3, target);

      case Transition.PREDICATE:
        return new PredicateTransition(target, arg1, arg2, arg3 !== 0);

      case Transition.PRECEDENCE:
        return new PrecedencePredicateTransition(target, arg1);

      case Transition.ATOM:
        return arg3 !== 0 ? new AtomTransition(target, Token.EOF) : new AtomTransition(target, arg1);

      case Transition.ACTION:
        return new ActionTransition(target, arg1, arg2, arg3 !== 0);

      case Transition.SET:
        return new SetTransition(target, sets[arg1]);

      case Transition.NOT_SET:
        return new NotSetTransition(target, sets[arg1]);

      case Transition.WILDCARD:
        return new WildcardTransition(target);

      default:
        throw "The specified transition type: " + type + " is not valid.";
    }
  }

  stateFactory(type, ruleIndex) {
    if (this.stateFactories === null) {
      const sf = [];
      sf[ATNState.INVALID_TYPE] = null;

      sf[ATNState.BASIC] = () => new BasicState();

      sf[ATNState.RULE_START] = () => new RuleStartState();

      sf[ATNState.BLOCK_START] = () => new BasicBlockStartState();

      sf[ATNState.PLUS_BLOCK_START] = () => new PlusBlockStartState();

      sf[ATNState.STAR_BLOCK_START] = () => new StarBlockStartState();

      sf[ATNState.TOKEN_START] = () => new TokensStartState();

      sf[ATNState.RULE_STOP] = () => new RuleStopState();

      sf[ATNState.BLOCK_END] = () => new BlockEndState();

      sf[ATNState.STAR_LOOP_BACK] = () => new StarLoopbackState();

      sf[ATNState.STAR_LOOP_ENTRY] = () => new StarLoopEntryState();

      sf[ATNState.PLUS_LOOP_BACK] = () => new PlusLoopbackState();

      sf[ATNState.LOOP_END] = () => new LoopEndState();

      this.stateFactories = sf;
    }

    if (type > this.stateFactories.length || this.stateFactories[type] === null) {
      throw "The specified state type " + type + " is not valid.";
    } else {
      const s = this.stateFactories[type]();

      if (s !== null) {
        s.ruleIndex = ruleIndex;
        return s;
      }
    }
  }

  lexerActionFactory(type, data1, data2) {
    if (this.actionFactories === null) {
      const af = [];

      af[LexerActionType.CHANNEL] = (data1, data2) => new LexerChannelAction(data1);

      af[LexerActionType.CUSTOM] = (data1, data2) => new LexerCustomAction(data1, data2);

      af[LexerActionType.MODE] = (data1, data2) => new LexerModeAction(data1);

      af[LexerActionType.MORE] = (data1, data2) => LexerMoreAction.INSTANCE;

      af[LexerActionType.POP_MODE] = (data1, data2) => LexerPopModeAction.INSTANCE;

      af[LexerActionType.PUSH_MODE] = (data1, data2) => new LexerPushModeAction(data1);

      af[LexerActionType.SKIP] = (data1, data2) => LexerSkipAction.INSTANCE;

      af[LexerActionType.TYPE] = (data1, data2) => new LexerTypeAction(data1);

      this.actionFactories = af;
    }

    if (type > this.actionFactories.length || this.actionFactories[type] === null) {
      throw "The specified lexer action type " + type + " is not valid.";
    } else {
      return this.actionFactories[type](data1, data2);
    }
  }

}

function createByteToHex() {
  const bth = [];

  for (let i = 0; i < 256; i++) {
    bth[i] = (i + 0x100).toString(16).substr(1).toUpperCase();
  }

  return bth;
}

const byteToHex = createByteToHex();
module.exports = ATNDeserializer;

/***/ }),
/* 23 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Represents the type of recognizer an ATN applies to
 */
module.exports = {
  LEXER: 0,
  PARSER: 1
};

/***/ }),
/* 24 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
class ATNDeserializationOptions {
  constructor(copyFrom) {
    if (copyFrom === undefined) {
      copyFrom = null;
    }

    this.readOnly = false;
    this.verifyATN = copyFrom === null ? true : copyFrom.verifyATN;
    this.generateRuleBypassTransitions = copyFrom === null ? false : copyFrom.generateRuleBypassTransitions;
  }

}

ATNDeserializationOptions.defaultOptions = new ATNDeserializationOptions();
ATNDeserializationOptions.defaultOptions.readOnly = true; //    def __setattr__(self, key, value):
//        if key!="readOnly" and self.readOnly:
//            raise Exception("The object is read only.")
//        super(type(self), self).__setattr__(key,value)

module.exports = ATNDeserializationOptions;

/***/ }),
/* 25 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const LexerActionType = {
  // The type of a {@link LexerChannelAction} action.
  CHANNEL: 0,
  // The type of a {@link LexerCustomAction} action
  CUSTOM: 1,
  // The type of a {@link LexerModeAction} action.
  MODE: 2,
  //The type of a {@link LexerMoreAction} action.
  MORE: 3,
  //The type of a {@link LexerPopModeAction} action.
  POP_MODE: 4,
  //The type of a {@link LexerPushModeAction} action.
  PUSH_MODE: 5,
  //The type of a {@link LexerSkipAction} action.
  SKIP: 6,
  //The type of a {@link LexerTypeAction} action.
  TYPE: 7
};

class LexerAction {
  constructor(action) {
    this.actionType = action;
    this.isPositionDependent = false;
  }

  hashCode() {
    const hash = new Hash();
    this.updateHashCode(hash);
    return hash.finish();
  }

  updateHashCode(hash) {
    hash.update(this.actionType);
  }

  equals(other) {
    return this === other;
  }

}
/**
 * Implements the {@code skip} lexer action by calling {@link Lexer//skip}.
 *
 * <p>The {@code skip} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */


class LexerSkipAction extends LexerAction {
  constructor() {
    super(LexerActionType.SKIP);
  }

  execute(lexer) {
    lexer.skip();
  }

  toString() {
    return "skip";
  }

} // Provides a singleton instance of this parameterless lexer action.


LexerSkipAction.INSTANCE = new LexerSkipAction();
/**
 * Implements the {@code type} lexer action by calling {@link Lexer//setType}
 * with the assigned type
 */

class LexerTypeAction extends LexerAction {
  constructor(type) {
    super(LexerActionType.TYPE);
    this.type = type;
  }

  execute(lexer) {
    lexer.type = this.type;
  }

  updateHashCode(hash) {
    hash.update(this.actionType, this.type);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerTypeAction)) {
      return false;
    } else {
      return this.type === other.type;
    }
  }

  toString() {
    return "type(" + this.type + ")";
  }

}
/**
 * Implements the {@code pushMode} lexer action by calling
 * {@link Lexer//pushMode} with the assigned mode
 */


class LexerPushModeAction extends LexerAction {
  constructor(mode) {
    super(LexerActionType.PUSH_MODE);
    this.mode = mode;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//pushMode} with the
   * value provided by {@link //getMode}.</p>
   */


  execute(lexer) {
    lexer.pushMode(this.mode);
  }

  updateHashCode(hash) {
    hash.update(this.actionType, this.mode);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerPushModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }

  toString() {
    return "pushMode(" + this.mode + ")";
  }

}
/**
 * Implements the {@code popMode} lexer action by calling {@link Lexer//popMode}.
 *
 * <p>The {@code popMode} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */


class LexerPopModeAction extends LexerAction {
  constructor() {
    super(LexerActionType.POP_MODE);
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */


  execute(lexer) {
    lexer.popMode();
  }

  toString() {
    return "popMode";
  }

}

LexerPopModeAction.INSTANCE = new LexerPopModeAction();
/**
 * Implements the {@code more} lexer action by calling {@link Lexer//more}.
 *
 * <p>The {@code more} command does not have any parameters, so this action is
 * implemented as a singleton instance exposed by {@link //INSTANCE}.</p>
 */

class LexerMoreAction extends LexerAction {
  constructor() {
    super(LexerActionType.MORE);
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//popMode}.</p>
   */


  execute(lexer) {
    lexer.more();
  }

  toString() {
    return "more";
  }

}

LexerMoreAction.INSTANCE = new LexerMoreAction();
/**
 * Implements the {@code mode} lexer action by calling {@link Lexer//mode} with
 * the assigned mode
 */

class LexerModeAction extends LexerAction {
  constructor(mode) {
    super(LexerActionType.MODE);
    this.mode = mode;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//mode} with the
   * value provided by {@link //getMode}.</p>
   */


  execute(lexer) {
    lexer.mode(this.mode);
  }

  updateHashCode(hash) {
    hash.update(this.actionType, this.mode);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerModeAction)) {
      return false;
    } else {
      return this.mode === other.mode;
    }
  }

  toString() {
    return "mode(" + this.mode + ")";
  }

}
/**
 * Executes a custom lexer action by calling {@link Recognizer//action} with the
 * rule and action indexes assigned to the custom action. The implementation of
 * a custom action is added to the generated code for the lexer in an override
 * of {@link Recognizer//action} when the grammar is compiled.
 *
 * <p>This class may represent embedded actions created with the <code>{...}</code>
 * syntax in ANTLR 4, as well as actions created for lexer commands where the
 * command argument could not be evaluated when the grammar was compiled.</p>
 */


class LexerCustomAction extends LexerAction {
  /**
   * Constructs a custom lexer action with the specified rule and action
   * indexes.
   *
   * @param ruleIndex The rule index to use for calls to
   * {@link Recognizer//action}.
   * @param actionIndex The action index to use for calls to
   * {@link Recognizer//action}.
   */
  constructor(ruleIndex, actionIndex) {
    super(LexerActionType.CUSTOM);
    this.ruleIndex = ruleIndex;
    this.actionIndex = actionIndex;
    this.isPositionDependent = true;
  }
  /**
   * <p>Custom actions are implemented by calling {@link Lexer//action} with the
   * appropriate rule and action indexes.</p>
   */


  execute(lexer) {
    lexer.action(null, this.ruleIndex, this.actionIndex);
  }

  updateHashCode(hash) {
    hash.update(this.actionType, this.ruleIndex, this.actionIndex);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerCustomAction)) {
      return false;
    } else {
      return this.ruleIndex === other.ruleIndex && this.actionIndex === other.actionIndex;
    }
  }

}
/**
 * Implements the {@code channel} lexer action by calling
 * {@link Lexer//setChannel} with the assigned channel.
 * Constructs a new {@code channel} action with the specified channel value.
 * @param channel The channel value to pass to {@link Lexer//setChannel}
 */


class LexerChannelAction extends LexerAction {
  constructor(channel) {
    super(LexerActionType.CHANNEL);
    this.channel = channel;
  }
  /**
   * <p>This action is implemented by calling {@link Lexer//setChannel} with the
   * value provided by {@link //getChannel}.</p>
   */


  execute(lexer) {
    lexer._channel = this.channel;
  }

  updateHashCode(hash) {
    hash.update(this.actionType, this.channel);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerChannelAction)) {
      return false;
    } else {
      return this.channel === other.channel;
    }
  }

  toString() {
    return "channel(" + this.channel + ")";
  }

}
/**
 * This implementation of {@link LexerAction} is used for tracking input offsets
 * for position-dependent actions within a {@link LexerActionExecutor}.
 *
 * <p>This action is not serialized as part of the ATN, and is only required for
 * position-dependent lexer actions which appear at a location other than the
 * end of a rule. For more information about DFA optimizations employed for
 * lexer actions, see {@link LexerActionExecutor//append} and
 * {@link LexerActionExecutor//fixOffsetBeforeMatch}.</p>
 *
 * Constructs a new indexed custom action by associating a character offset
 * with a {@link LexerAction}.
 *
 * <p>Note: This class is only required for lexer actions for which
 * {@link LexerAction//isPositionDependent} returns {@code true}.</p>
 *
 * @param offset The offset into the input {@link CharStream}, relative to
 * the token start index, at which the specified lexer action should be
 * executed.
 * @param action The lexer action to execute at a particular offset in the
 * input {@link CharStream}.
 */


class LexerIndexedCustomAction extends LexerAction {
  constructor(offset, action) {
    super(action.actionType);
    this.offset = offset;
    this.action = action;
    this.isPositionDependent = true;
  }
  /**
   * <p>This method calls {@link //execute} on the result of {@link //getAction}
   * using the provided {@code lexer}.</p>
   */


  execute(lexer) {
    // assume the input stream position was properly set by the calling code
    this.action.execute(lexer);
  }

  updateHashCode(hash) {
    hash.update(this.actionType, this.offset, this.action);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerIndexedCustomAction)) {
      return false;
    } else {
      return this.offset === other.offset && this.action === other.action;
    }
  }

}

module.exports = {
  LexerActionType,
  LexerSkipAction,
  LexerChannelAction,
  LexerCustomAction,
  LexerIndexedCustomAction,
  LexerMoreAction,
  LexerTypeAction,
  LexerPushModeAction,
  LexerPopModeAction,
  LexerModeAction
};

/***/ }),
/* 26 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const Lexer = __webpack_require__(27);

const ATN = __webpack_require__(9);

const ATNSimulator = __webpack_require__(32);

const {
  DFAState
} = __webpack_require__(33);

const {
  OrderedATNConfigSet
} = __webpack_require__(34);

const {
  PredictionContext
} = __webpack_require__(18);

const {
  SingletonPredictionContext
} = __webpack_require__(18);

const {
  RuleStopState
} = __webpack_require__(14);

const {
  LexerATNConfig
} = __webpack_require__(13);

const {
  Transition
} = __webpack_require__(17);

const LexerActionExecutor = __webpack_require__(35);

const {
  LexerNoViableAltException
} = __webpack_require__(31);

function resetSimState(sim) {
  sim.index = -1;
  sim.line = 0;
  sim.column = -1;
  sim.dfaState = null;
}

class SimState {
  constructor() {
    resetSimState(this);
  }

  reset() {
    resetSimState(this);
  }

}

class LexerATNSimulator extends ATNSimulator {
  /**
   * When we hit an accept state in either the DFA or the ATN, we
   * have to notify the character stream to start buffering characters
   * via {@link IntStream//mark} and record the current state. The current sim state
   * includes the current index into the input, the current line,
   * and current character position in that line. Note that the Lexer is
   * tracking the starting line and characterization of the token. These
   * variables track the "state" of the simulator when it hits an accept state.
   *
   * <p>We track these variables separately for the DFA and ATN simulation
   * because the DFA simulation often has to fail over to the ATN
   * simulation. If the ATN simulation fails, we need the DFA to fall
   * back to its previously accepted state, if any. If the ATN succeeds,
   * then the ATN does the accept and the DFA simulator that invoked it
   * can simply return the predicted token type.</p>
   */
  constructor(recog, atn, decisionToDFA, sharedContextCache) {
    super(atn, sharedContextCache);
    this.decisionToDFA = decisionToDFA;
    this.recog = recog;
    /**
     * The current token's starting index into the character stream.
     * Shared across DFA to ATN simulation in case the ATN fails and the
     * DFA did not have a previous accept state. In this case, we use the
     * ATN-generated exception object
     */

    this.startIndex = -1; // line number 1..n within the input///

    this.line = 1;
    /**
     * The index of the character relative to the beginning of the line
     * 0..n-1
     */

    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
    /**
     * Used during DFA/ATN exec to record the most recent accept configuration
     * info
     */

    this.prevAccept = new SimState();
  }

  copyState(simulator) {
    this.column = simulator.column;
    this.line = simulator.line;
    this.mode = simulator.mode;
    this.startIndex = simulator.startIndex;
  }

  match(input, mode) {
    this.match_calls += 1;
    this.mode = mode;
    const mark = input.mark();

    try {
      this.startIndex = input.index;
      this.prevAccept.reset();
      const dfa = this.decisionToDFA[mode];

      if (dfa.s0 === null) {
        return this.matchATN(input);
      } else {
        return this.execATN(input, dfa.s0);
      }
    } finally {
      input.release(mark);
    }
  }

  reset() {
    this.prevAccept.reset();
    this.startIndex = -1;
    this.line = 1;
    this.column = 0;
    this.mode = Lexer.DEFAULT_MODE;
  }

  matchATN(input) {
    const startState = this.atn.modeToStartState[this.mode];

    if (LexerATNSimulator.debug) {
      console.log("matchATN mode " + this.mode + " start: " + startState);
    }

    const old_mode = this.mode;
    const s0_closure = this.computeStartState(input, startState);
    const suppressEdge = s0_closure.hasSemanticContext;
    s0_closure.hasSemanticContext = false;
    const next = this.addDFAState(s0_closure);

    if (!suppressEdge) {
      this.decisionToDFA[this.mode].s0 = next;
    }

    const predict = this.execATN(input, next);

    if (LexerATNSimulator.debug) {
      console.log("DFA after matchATN: " + this.decisionToDFA[old_mode].toLexerString());
    }

    return predict;
  }

  execATN(input, ds0) {
    if (LexerATNSimulator.debug) {
      console.log("start state closure=" + ds0.configs);
    }

    if (ds0.isAcceptState) {
      // allow zero-length tokens
      this.captureSimState(this.prevAccept, input, ds0);
    }

    let t = input.LA(1);
    let s = ds0; // s is current/from DFA state

    while (true) {
      // while more work
      if (LexerATNSimulator.debug) {
        console.log("execATN loop starting closure: " + s.configs);
      }
      /**
       * As we move src->trg, src->trg, we keep track of the previous trg to
       * avoid looking up the DFA state again, which is expensive.
       * If the previous target was already part of the DFA, we might
       * be able to avoid doing a reach operation upon t. If s!=null,
       * it means that semantic predicates didn't prevent us from
       * creating a DFA state. Once we know s!=null, we check to see if
       * the DFA state has an edge already for t. If so, we can just reuse
       * it's configuration set; there's no point in re-computing it.
       * This is kind of like doing DFA simulation within the ATN
       * simulation because DFA simulation is really just a way to avoid
       * computing reach/closure sets. Technically, once we know that
       * we have a previously added DFA state, we could jump over to
       * the DFA simulator. But, that would mean popping back and forth
       * a lot and making things more complicated algorithmically.
       * This optimization makes a lot of sense for loops within DFA.
       * A character will take us back to an existing DFA state
       * that already has lots of edges out of it. e.g., .* in comments.
       * print("Target for:" + str(s) + " and:" + str(t))
       */


      let target = this.getExistingTargetState(s, t); // print("Existing:" + str(target))

      if (target === null) {
        target = this.computeTargetState(input, s, t); // print("Computed:" + str(target))
      }

      if (target === ATNSimulator.ERROR) {
        break;
      } // If this is a consumable input element, make sure to consume before
      // capturing the accept state so the input index, line, and char
      // position accurately reflect the state of the interpreter at the
      // end of the token.


      if (t !== Token.EOF) {
        this.consume(input);
      }

      if (target.isAcceptState) {
        this.captureSimState(this.prevAccept, input, target);

        if (t === Token.EOF) {
          break;
        }
      }

      t = input.LA(1);
      s = target; // flip; current DFA target becomes new src/from state
    }

    return this.failOrAccept(this.prevAccept, input, s.configs, t);
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param s The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */


  getExistingTargetState(s, t) {
    if (s.edges === null || t < LexerATNSimulator.MIN_DFA_EDGE || t > LexerATNSimulator.MAX_DFA_EDGE) {
      return null;
    }

    let target = s.edges[t - LexerATNSimulator.MIN_DFA_EDGE];

    if (target === undefined) {
      target = null;
    }

    if (LexerATNSimulator.debug && target !== null) {
      console.log("reuse state " + s.stateNumber + " edge to " + target.stateNumber);
    }

    return target;
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param input The input stream
   * @param s The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR}.
   */


  computeTargetState(input, s, t) {
    const reach = new OrderedATNConfigSet(); // if we don't find an existing DFA state
    // Fill reach starting from closure, following t transitions

    this.getReachableConfigSet(input, s.configs, reach, t);

    if (reach.items.length === 0) {
      // we got nowhere on t from s
      if (!reach.hasSemanticContext) {
        // we got nowhere on t, don't throw out this knowledge; it'd
        // cause a failover from DFA later.
        this.addDFAEdge(s, t, ATNSimulator.ERROR);
      } // stop when we can't match any more char


      return ATNSimulator.ERROR;
    } // Add an edge from s to target DFA found/created for reach


    return this.addDFAEdge(s, t, null, reach);
  }

  failOrAccept(prevAccept, input, reach, t) {
    if (this.prevAccept.dfaState !== null) {
      const lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;
      this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.column);
      return prevAccept.dfaState.prediction;
    } else {
      // if no accept and EOF is first char, return EOF
      if (t === Token.EOF && input.index === this.startIndex) {
        return Token.EOF;
      }

      throw new LexerNoViableAltException(this.recog, input, this.startIndex, reach);
    }
  }
  /**
   * Given a starting configuration set, figure out all ATN configurations
   * we can reach upon input {@code t}. Parameter {@code reach} is a return
   * parameter.
   */


  getReachableConfigSet(input, closure, reach, t) {
    // this is used to skip processing for configs which have a lower priority
    // than a config that already reached an accept state for the same rule
    let skipAlt = ATN.INVALID_ALT_NUMBER;

    for (let i = 0; i < closure.items.length; i++) {
      const cfg = closure.items[i];
      const currentAltReachedAcceptState = cfg.alt === skipAlt;

      if (currentAltReachedAcceptState && cfg.passedThroughNonGreedyDecision) {
        continue;
      }

      if (LexerATNSimulator.debug) {
        console.log("testing %s at %s\n", this.getTokenName(t), cfg.toString(this.recog, true));
      }

      for (let j = 0; j < cfg.state.transitions.length; j++) {
        const trans = cfg.state.transitions[j]; // for each transition

        const target = this.getReachableTarget(trans, t);

        if (target !== null) {
          let lexerActionExecutor = cfg.lexerActionExecutor;

          if (lexerActionExecutor !== null) {
            lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);
          }

          const treatEofAsEpsilon = t === Token.EOF;
          const config = new LexerATNConfig({
            state: target,
            lexerActionExecutor: lexerActionExecutor
          }, cfg);

          if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {
            // any remaining configs for this alt have a lower priority
            // than the one that just reached an accept state.
            skipAlt = cfg.alt;
          }
        }
      }
    }
  }

  accept(input, lexerActionExecutor, startIndex, index, line, charPos) {
    if (LexerATNSimulator.debug) {
      console.log("ACTION %s\n", lexerActionExecutor);
    } // seek to after last char in token


    input.seek(index);
    this.line = line;
    this.column = charPos;

    if (lexerActionExecutor !== null && this.recog !== null) {
      lexerActionExecutor.execute(this.recog, input, startIndex);
    }
  }

  getReachableTarget(trans, t) {
    if (trans.matches(t, 0, Lexer.MAX_CHAR_VALUE)) {
      return trans.target;
    } else {
      return null;
    }
  }

  computeStartState(input, p) {
    const initialContext = PredictionContext.EMPTY;
    const configs = new OrderedATNConfigSet();

    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const cfg = new LexerATNConfig({
        state: target,
        alt: i + 1,
        context: initialContext
      }, null);
      this.closure(input, cfg, configs, false, false, false);
    }

    return configs;
  }
  /**
   * Since the alternatives within any lexer decision are ordered by
   * preference, this method stops pursuing the closure as soon as an accept
   * state is reached. After the first accept state is reached by depth-first
   * search from {@code config}, all other (potentially reachable) states for
   * this rule would have a lower priority.
   *
   * @return {Boolean} {@code true} if an accept state is reached, otherwise
   * {@code false}.
   */


  closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {
    let cfg = null;

    if (LexerATNSimulator.debug) {
      console.log("closure(" + config.toString(this.recog, true) + ")");
    }

    if (config.state instanceof RuleStopState) {
      if (LexerATNSimulator.debug) {
        if (this.recog !== null) {
          console.log("closure at %s rule stop %s\n", this.recog.ruleNames[config.state.ruleIndex], config);
        } else {
          console.log("closure at rule stop %s\n", config);
        }
      }

      if (config.context === null || config.context.hasEmptyPath()) {
        if (config.context === null || config.context.isEmpty()) {
          configs.add(config);
          return true;
        } else {
          configs.add(new LexerATNConfig({
            state: config.state,
            context: PredictionContext.EMPTY
          }, config));
          currentAltReachedAcceptState = true;
        }
      }

      if (config.context !== null && !config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) !== PredictionContext.EMPTY_RETURN_STATE) {
            const newContext = config.context.getParent(i); // "pop" return state

            const returnState = this.atn.states[config.context.getReturnState(i)];
            cfg = new LexerATNConfig({
              state: returnState,
              context: newContext
            }, config);
            currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
          }
        }
      }

      return currentAltReachedAcceptState;
    } // optimization


    if (!config.state.epsilonOnlyTransitions) {
      if (!currentAltReachedAcceptState || !config.passedThroughNonGreedyDecision) {
        configs.add(config);
      }
    }

    for (let j = 0; j < config.state.transitions.length; j++) {
      const trans = config.state.transitions[j];
      cfg = this.getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon);

      if (cfg !== null) {
        currentAltReachedAcceptState = this.closure(input, cfg, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);
      }
    }

    return currentAltReachedAcceptState;
  } // side-effect: can alter configs.hasSemanticContext


  getEpsilonTarget(input, config, trans, configs, speculative, treatEofAsEpsilon) {
    let cfg = null;

    if (trans.serializationType === Transition.RULE) {
      const newContext = SingletonPredictionContext.create(config.context, trans.followState.stateNumber);
      cfg = new LexerATNConfig({
        state: trans.target,
        context: newContext
      }, config);
    } else if (trans.serializationType === Transition.PRECEDENCE) {
      throw "Precedence predicates are not supported in lexers.";
    } else if (trans.serializationType === Transition.PREDICATE) {
      // Track traversing semantic predicates. If we traverse,
      // we cannot add a DFA state for this "reach" computation
      // because the DFA would not test the predicate again in the
      // future. Rather than creating collections of semantic predicates
      // like v3 and testing them on prediction, v4 will test them on the
      // fly all the time using the ATN not the DFA. This is slower but
      // semantically it's not used that often. One of the key elements to
      // this predicate mechanism is not adding DFA states that see
      // predicates immediately afterwards in the ATN. For example,
      // a : ID {p1}? | ID {p2}? ;
      // should create the start state for rule 'a' (to save start state
      // competition), but should not create target of ID state. The
      // collection of ATN states the following ID references includes
      // states reached by traversing predicates. Since this is when we
      // test them, we cannot cash the DFA state target of ID.
      if (LexerATNSimulator.debug) {
        console.log("EVAL rule " + trans.ruleIndex + ":" + trans.predIndex);
      }

      configs.hasSemanticContext = true;

      if (this.evaluatePredicate(input, trans.ruleIndex, trans.predIndex, speculative)) {
        cfg = new LexerATNConfig({
          state: trans.target
        }, config);
      }
    } else if (trans.serializationType === Transition.ACTION) {
      if (config.context === null || config.context.hasEmptyPath()) {
        // execute actions anywhere in the start rule for a token.
        //
        // TODO: if the entry rule is invoked recursively, some
        // actions may be executed during the recursive call. The
        // problem can appear when hasEmptyPath() is true but
        // isEmpty() is false. In this case, the config needs to be
        // split into two contexts - one with just the empty path
        // and another with everything but the empty path.
        // Unfortunately, the current algorithm does not allow
        // getEpsilonTarget to return two configurations, so
        // additional modifications are needed before we can support
        // the split operation.
        const lexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[trans.actionIndex]);
        cfg = new LexerATNConfig({
          state: trans.target,
          lexerActionExecutor: lexerActionExecutor
        }, config);
      } else {
        // ignore actions in referenced rules
        cfg = new LexerATNConfig({
          state: trans.target
        }, config);
      }
    } else if (trans.serializationType === Transition.EPSILON) {
      cfg = new LexerATNConfig({
        state: trans.target
      }, config);
    } else if (trans.serializationType === Transition.ATOM || trans.serializationType === Transition.RANGE || trans.serializationType === Transition.SET) {
      if (treatEofAsEpsilon) {
        if (trans.matches(Token.EOF, 0, Lexer.MAX_CHAR_VALUE)) {
          cfg = new LexerATNConfig({
            state: trans.target
          }, config);
        }
      }
    }

    return cfg;
  }
  /**
   * Evaluate a predicate specified in the lexer.
   *
   * <p>If {@code speculative} is {@code true}, this method was called before
   * {@link //consume} for the matched character. This method should call
   * {@link //consume} before evaluating the predicate to ensure position
   * sensitive values, including {@link Lexer//getText}, {@link Lexer//getLine},
   * and {@link Lexer//getcolumn}, properly reflect the current
   * lexer state. This method should restore {@code input} and the simulator
   * to the original state before returning (i.e. undo the actions made by the
   * call to {@link //consume}.</p>
   *
   * @param input The input stream.
   * @param ruleIndex The rule containing the predicate.
   * @param predIndex The index of the predicate within the rule.
   * @param speculative {@code true} if the current index in {@code input} is
   * one character before the predicate's location.
   *
   * @return {@code true} if the specified predicate evaluates to
   * {@code true}.
   */


  evaluatePredicate(input, ruleIndex, predIndex, speculative) {
    // assume true if no recognizer was provided
    if (this.recog === null) {
      return true;
    }

    if (!speculative) {
      return this.recog.sempred(null, ruleIndex, predIndex);
    }

    const savedcolumn = this.column;
    const savedLine = this.line;
    const index = input.index;
    const marker = input.mark();

    try {
      this.consume(input);
      return this.recog.sempred(null, ruleIndex, predIndex);
    } finally {
      this.column = savedcolumn;
      this.line = savedLine;
      input.seek(index);
      input.release(marker);
    }
  }

  captureSimState(settings, input, dfaState) {
    settings.index = input.index;
    settings.line = this.line;
    settings.column = this.column;
    settings.dfaState = dfaState;
  }

  addDFAEdge(from_, tk, to, cfgs) {
    if (to === undefined) {
      to = null;
    }

    if (cfgs === undefined) {
      cfgs = null;
    }

    if (to === null && cfgs !== null) {
      // leading to this call, ATNConfigSet.hasSemanticContext is used as a
      // marker indicating dynamic predicate evaluation makes this edge
      // dependent on the specific input sequence, so the static edge in the
      // DFA should be omitted. The target DFAState is still created since
      // execATN has the ability to resynchronize with the DFA state cache
      // following the predicate evaluation step.
      //
      // TJP notes: next time through the DFA, we see a pred again and eval.
      // If that gets us to a previously created (but dangling) DFA
      // state, we can continue in pure DFA mode from there.
      // /
      const suppressEdge = cfgs.hasSemanticContext;
      cfgs.hasSemanticContext = false;
      to = this.addDFAState(cfgs);

      if (suppressEdge) {
        return to;
      }
    } // add the edge


    if (tk < LexerATNSimulator.MIN_DFA_EDGE || tk > LexerATNSimulator.MAX_DFA_EDGE) {
      // Only track edges within the DFA bounds
      return to;
    }

    if (LexerATNSimulator.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + tk);
    }

    if (from_.edges === null) {
      // make room for tokens 1..n and -1 masquerading as index 0
      from_.edges = [];
    }

    from_.edges[tk - LexerATNSimulator.MIN_DFA_EDGE] = to; // connect

    return to;
  }
  /**
   * Add a new DFA state if there isn't one with this set of
   * configurations already. This method also detects the first
   * configuration containing an ATN rule stop state. Later, when
   * traversing the DFA, we will know which rule to accept.
   */


  addDFAState(configs) {
    const proposed = new DFAState(null, configs);
    let firstConfigWithRuleStopState = null;

    for (let i = 0; i < configs.items.length; i++) {
      const cfg = configs.items[i];

      if (cfg.state instanceof RuleStopState) {
        firstConfigWithRuleStopState = cfg;
        break;
      }
    }

    if (firstConfigWithRuleStopState !== null) {
      proposed.isAcceptState = true;
      proposed.lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;
      proposed.prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];
    }

    const dfa = this.decisionToDFA[this.mode];
    const existing = dfa.states.get(proposed);

    if (existing !== null) {
      return existing;
    }

    const newState = proposed;
    newState.stateNumber = dfa.states.length;
    configs.setReadonly(true);
    newState.configs = configs;
    dfa.states.add(newState);
    return newState;
  }

  getDFA(mode) {
    return this.decisionToDFA[mode];
  } // Get the text matched so far for the current token.


  getText(input) {
    // index is first lookahead char, don't include.
    return input.getText(this.startIndex, input.index - 1);
  }

  consume(input) {
    const curChar = input.LA(1);

    if (curChar === "\n".charCodeAt(0)) {
      this.line += 1;
      this.column = 0;
    } else {
      this.column += 1;
    }

    input.consume();
  }

  getTokenName(tt) {
    if (tt === -1) {
      return "EOF";
    } else {
      return "'" + String.fromCharCode(tt) + "'";
    }
  }

}

LexerATNSimulator.debug = false;
LexerATNSimulator.dfa_debug = false;
LexerATNSimulator.MIN_DFA_EDGE = 0;
LexerATNSimulator.MAX_DFA_EDGE = 127; // forces unicode to stay in ATN

LexerATNSimulator.match_calls = 0;
module.exports = LexerATNSimulator;

/***/ }),
/* 27 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const Recognizer = __webpack_require__(28);

const CommonTokenFactory = __webpack_require__(30);

const {
  RecognitionException
} = __webpack_require__(31);

const {
  LexerNoViableAltException
} = __webpack_require__(31);

class TokenSource {}
/**
 * A lexer is recognizer that draws input symbols from a character stream.
 * lexer grammars result in a subclass of this object. A Lexer object
 * uses simplified match() and error recovery mechanisms in the interest of speed.
 */


class Lexer extends Recognizer {
  constructor(input) {
    super();
    this._input = input;
    this._factory = CommonTokenFactory.DEFAULT;
    this._tokenFactorySourcePair = [this, input];
    this._interp = null; // child classes must populate this

    /**
     * The goal of all lexer rules/methods is to create a token object.
     * this is an instance variable as multiple rules may collaborate to
     * create a single token. nextToken will return this object after
     * matching lexer rule(s). If you subclass to allow multiple token
     * emissions, then set this to the last token to be matched or
     * something nonnull so that the auto token emit mechanism will not
     * emit another token.
     */

    this._token = null;
    /**
     * What character index in the stream did the current token start at?
     * Needed, for example, to get the text for current token. Set at
     * the start of nextToken.
     */

    this._tokenStartCharIndex = -1; // The line on which the first character of the token resides///

    this._tokenStartLine = -1; // The character position of first character within the line///

    this._tokenStartColumn = -1; // Once we see EOF on char stream, next token will be EOF.
    // If you have DONE : EOF ; then you see DONE EOF.

    this._hitEOF = false; // The channel number for the current token///

    this._channel = Token.DEFAULT_CHANNEL; // The token type for the current token///

    this._type = Token.INVALID_TYPE;
    this._modeStack = [];
    this._mode = Lexer.DEFAULT_MODE;
    /**
     * You can set the text for the current token to override what is in
     * the input char buffer. Use setText() or can set this instance var.
     */

    this._text = null;
  }

  reset() {
    // wack Lexer state variables
    if (this._input !== null) {
      this._input.seek(0); // rewind the input

    }

    this._token = null;
    this._type = Token.INVALID_TYPE;
    this._channel = Token.DEFAULT_CHANNEL;
    this._tokenStartCharIndex = -1;
    this._tokenStartColumn = -1;
    this._tokenStartLine = -1;
    this._text = null;
    this._hitEOF = false;
    this._mode = Lexer.DEFAULT_MODE;
    this._modeStack = [];

    this._interp.reset();
  } // Return a token from this source; i.e., match a token on the char stream.


  nextToken() {
    if (this._input === null) {
      throw "nextToken requires a non-null input stream.";
    }
    /**
     * Mark start location in char stream so unbuffered streams are
     * guaranteed at least have text of current token
     */


    const tokenStartMarker = this._input.mark();

    try {
      while (true) {
        if (this._hitEOF) {
          this.emitEOF();
          return this._token;
        }

        this._token = null;
        this._channel = Token.DEFAULT_CHANNEL;
        this._tokenStartCharIndex = this._input.index;
        this._tokenStartColumn = this._interp.column;
        this._tokenStartLine = this._interp.line;
        this._text = null;
        let continueOuter = false;

        while (true) {
          this._type = Token.INVALID_TYPE;
          let ttype = Lexer.SKIP;

          try {
            ttype = this._interp.match(this._input, this._mode);
          } catch (e) {
            if (e instanceof RecognitionException) {
              this.notifyListeners(e); // report error

              this.recover(e);
            } else {
              console.log(e.stack);
              throw e;
            }
          }

          if (this._input.LA(1) === Token.EOF) {
            this._hitEOF = true;
          }

          if (this._type === Token.INVALID_TYPE) {
            this._type = ttype;
          }

          if (this._type === Lexer.SKIP) {
            continueOuter = true;
            break;
          }

          if (this._type !== Lexer.MORE) {
            break;
          }
        }

        if (continueOuter) {
          continue;
        }

        if (this._token === null) {
          this.emit();
        }

        return this._token;
      }
    } finally {
      // make sure we release marker after match or
      // unbuffered char stream will keep buffering
      this._input.release(tokenStartMarker);
    }
  }
  /**
   * Instruct the lexer to skip creating a token for current lexer rule
   * and look for another token. nextToken() knows to keep looking when
   * a lexer rule finishes with token set to SKIP_TOKEN. Recall that
   * if token==null at end of any token rule, it creates one for you
   * and emits it.
   */


  skip() {
    this._type = Lexer.SKIP;
  }

  more() {
    this._type = Lexer.MORE;
  }

  mode(m) {
    this._mode = m;
  }

  pushMode(m) {
    if (this._interp.debug) {
      console.log("pushMode " + m);
    }

    this._modeStack.push(this._mode);

    this.mode(m);
  }

  popMode() {
    if (this._modeStack.length === 0) {
      throw "Empty Stack";
    }

    if (this._interp.debug) {
      console.log("popMode back to " + this._modeStack.slice(0, -1));
    }

    this.mode(this._modeStack.pop());
    return this._mode;
  }
  /**
   * By default does not support multiple emits per nextToken invocation
   * for efficiency reasons. Subclass and override this method, nextToken,
   * and getToken (to push tokens into a list and pull from that list
   * rather than a single variable as this implementation does).
   */


  emitToken(token) {
    this._token = token;
  }
  /**
   * The standard method called to automatically emit a token at the
   * outermost lexical rule. The token object should point into the
   * char buffer start..stop. If there is a text override in 'text',
   * use that to set the token's text. Override this method to emit
   * custom Token objects or provide a new factory.
   */


  emit() {
    const t = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);

    this.emitToken(t);
    return t;
  }

  emitEOF() {
    const cpos = this.column;
    const lpos = this.line;

    const eof = this._factory.create(this._tokenFactorySourcePair, Token.EOF, null, Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, lpos, cpos);

    this.emitToken(eof);
    return eof;
  } // What is the index of the current character of lookahead?///


  getCharIndex() {
    return this._input.index;
  }
  /**
   * Return a list of all Token objects in input char stream.
   * Forces load of all tokens. Does not include EOF token.
   */


  getAllTokens() {
    const tokens = [];
    let t = this.nextToken();

    while (t.type !== Token.EOF) {
      tokens.push(t);
      t = this.nextToken();
    }

    return tokens;
  }

  notifyListeners(e) {
    const start = this._tokenStartCharIndex;
    const stop = this._input.index;

    const text = this._input.getText(start, stop);

    const msg = "token recognition error at: '" + this.getErrorDisplay(text) + "'";
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, msg, e);
  }

  getErrorDisplay(s) {
    const d = [];

    for (let i = 0; i < s.length; i++) {
      d.push(s[i]);
    }

    return d.join('');
  }

  getErrorDisplayForChar(c) {
    if (c.charCodeAt(0) === Token.EOF) {
      return "<EOF>";
    } else if (c === '\n') {
      return "\\n";
    } else if (c === '\t') {
      return "\\t";
    } else if (c === '\r') {
      return "\\r";
    } else {
      return c;
    }
  }

  getCharErrorDisplay(c) {
    return "'" + this.getErrorDisplayForChar(c) + "'";
  }
  /**
   * Lexers can normally match any char in it's vocabulary after matching
   * a token, so do the easy thing and just kill a character and hope
   * it all works out. You can instead use the rule invocation stack
   * to do sophisticated error recovery if you are in a fragment rule.
   */


  recover(re) {
    if (this._input.LA(1) !== Token.EOF) {
      if (re instanceof LexerNoViableAltException) {
        // skip a char and try again
        this._interp.consume(this._input);
      } else {
        // TODO: Do we lose character or line position information?
        this._input.consume();
      }
    }
  }

  get inputStream() {
    return this._input;
  }

  set inputStream(input) {
    this._input = null;
    this._tokenFactorySourcePair = [this, this._input];
    this.reset();
    this._input = input;
    this._tokenFactorySourcePair = [this, this._input];
  }

  get sourceName() {
    return this._input.sourceName;
  }

  get type() {
    return this._type;
  }

  set type(type) {
    this._type = type;
  }

  get line() {
    return this._interp.line;
  }

  set line(line) {
    this._interp.line = line;
  }

  get column() {
    return this._interp.column;
  }

  set column(column) {
    this._interp.column = column;
  }

  get text() {
    if (this._text !== null) {
      return this._text;
    } else {
      return this._interp.getText(this._input);
    }
  }

  set text(text) {
    this._text = text;
  }

}

Lexer.DEFAULT_MODE = 0;
Lexer.MORE = -2;
Lexer.SKIP = -3;
Lexer.DEFAULT_TOKEN_CHANNEL = Token.DEFAULT_CHANNEL;
Lexer.HIDDEN = Token.HIDDEN_CHANNEL;
Lexer.MIN_CHAR_VALUE = 0x0000;
Lexer.MAX_CHAR_VALUE = 0x10FFFF; // Set the char stream and reset the lexer

module.exports = Lexer;

/***/ }),
/* 28 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const {
  ConsoleErrorListener
} = __webpack_require__(29);

const {
  ProxyErrorListener
} = __webpack_require__(29);

class Recognizer {
  constructor() {
    this._listeners = [ConsoleErrorListener.INSTANCE];
    this._interp = null;
    this._stateNumber = -1;
  }

  checkVersion(toolVersion) {
    const runtimeVersion = "4.9.3";

    if (runtimeVersion !== toolVersion) {
      console.log("ANTLR runtime and generated code versions disagree: " + runtimeVersion + "!=" + toolVersion);
    }
  }

  addErrorListener(listener) {
    this._listeners.push(listener);
  }

  removeErrorListeners() {
    this._listeners = [];
  }

  getLiteralNames() {
    return Object.getPrototypeOf(this).constructor.literalNames || [];
  }

  getSymbolicNames() {
    return Object.getPrototypeOf(this).constructor.symbolicNames || [];
  }

  getTokenNames() {
    if (!this.tokenNames) {
      const literalNames = this.getLiteralNames();
      const symbolicNames = this.getSymbolicNames();
      const length = literalNames.length > symbolicNames.length ? literalNames.length : symbolicNames.length;
      this.tokenNames = [];

      for (let i = 0; i < length; i++) {
        this.tokenNames[i] = literalNames[i] || symbolicNames[i] || "<INVALID";
      }
    }

    return this.tokenNames;
  }

  getTokenTypeMap() {
    const tokenNames = this.getTokenNames();

    if (tokenNames === null) {
      throw "The current recognizer does not provide a list of token names.";
    }

    let result = this.tokenTypeMapCache[tokenNames];

    if (result === undefined) {
      result = tokenNames.reduce(function (o, k, i) {
        o[k] = i;
      });
      result.EOF = Token.EOF;
      this.tokenTypeMapCache[tokenNames] = result;
    }

    return result;
  }
  /**
   * Get a map from rule names to rule indexes.
   * <p>Used for XPath and tree pattern compilation.</p>
   */


  getRuleIndexMap() {
    const ruleNames = this.ruleNames;

    if (ruleNames === null) {
      throw "The current recognizer does not provide a list of rule names.";
    }

    let result = this.ruleIndexMapCache[ruleNames]; // todo: should it be Recognizer.ruleIndexMapCache ?

    if (result === undefined) {
      result = ruleNames.reduce(function (o, k, i) {
        o[k] = i;
      });
      this.ruleIndexMapCache[ruleNames] = result;
    }

    return result;
  }

  getTokenType(tokenName) {
    const ttype = this.getTokenTypeMap()[tokenName];

    if (ttype !== undefined) {
      return ttype;
    } else {
      return Token.INVALID_TYPE;
    }
  } // What is the error header, normally line/character position information?


  getErrorHeader(e) {
    const line = e.getOffendingToken().line;
    const column = e.getOffendingToken().column;
    return "line " + line + ":" + column;
  }
  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out.  Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   *
   * @deprecated This method is not called by the ANTLR 4 Runtime. Specific
   * implementations of {@link ANTLRErrorStrategy} may provide a similar
   * feature when necessary. For example, see
   * {@link DefaultErrorStrategy//getTokenErrorDisplay}.*/


  getTokenErrorDisplay(t) {
    if (t === null) {
      return "<no token>";
    }

    let s = t.text;

    if (s === null) {
      if (t.type === Token.EOF) {
        s = "<EOF>";
      } else {
        s = "<" + t.type + ">";
      }
    }

    s = s.replace("\n", "\\n").replace("\r", "\\r").replace("\t", "\\t");
    return "'" + s + "'";
  }

  getErrorListenerDispatch() {
    return new ProxyErrorListener(this._listeners);
  }
  /**
   * subclass needs to override these if there are sempreds or actions
   * that the ATN interp needs to execute
   */


  sempred(localctx, ruleIndex, actionIndex) {
    return true;
  }

  precpred(localctx, precedence) {
    return true;
  }

  get state() {
    return this._stateNumber;
  }

  set state(state) {
    this._stateNumber = state;
  }

}

Recognizer.tokenTypeMapCache = {};
Recognizer.ruleIndexMapCache = {};
module.exports = Recognizer;

/***/ }),
/* 29 */
/***/ (function(module) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * Provides an empty default implementation of {@link ANTLRErrorListener}. The
 * default implementation of each method does nothing, but can be overridden as
 * necessary.
 */
class ErrorListener {
  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {}

  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {}

  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {}

  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {}

}
/**
 * {@inheritDoc}
 *
 * <p>
 * This implementation prints messages to {@link System//err} containing the
 * values of {@code line}, {@code charPositionInLine}, and {@code msg} using
 * the following format.</p>
 *
 * <pre>
 * line <em>line</em>:<em>charPositionInLine</em> <em>msg</em>
 * </pre>
 *
 */


class ConsoleErrorListener extends ErrorListener {
  constructor() {
    super();
  }

  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    console.error("line " + line + ":" + column + " " + msg);
  }

}
/**
 * Provides a default instance of {@link ConsoleErrorListener}.
 */


ConsoleErrorListener.INSTANCE = new ConsoleErrorListener();

class ProxyErrorListener extends ErrorListener {
  constructor(delegates) {
    super();

    if (delegates === null) {
      throw "delegates";
    }

    this.delegates = delegates;
    return this;
  }

  syntaxError(recognizer, offendingSymbol, line, column, msg, e) {
    this.delegates.map(d => d.syntaxError(recognizer, offendingSymbol, line, column, msg, e));
  }

  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    this.delegates.map(d => d.reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs));
  }

  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    this.delegates.map(d => d.reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs));
  }

  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    this.delegates.map(d => d.reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs));
  }

}

module.exports = {
  ErrorListener,
  ConsoleErrorListener,
  ProxyErrorListener
};

/***/ }),
/* 30 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const CommonToken = (__webpack_require__(12).CommonToken);

class TokenFactory {}
/**
 * This default implementation of {@link TokenFactory} creates
 * {@link CommonToken} objects.
 */


class CommonTokenFactory extends TokenFactory {
  constructor(copyText) {
    super();
    /**
     * Indicates whether {@link CommonToken//setText} should be called after
     * constructing tokens to explicitly set the text. This is useful for cases
     * where the input stream might not be able to provide arbitrary substrings
     * of text from the input after the lexer creates a token (e.g. the
     * implementation of {@link CharStream//getText} in
     * {@link UnbufferedCharStream} throws an
     * {@link UnsupportedOperationException}). Explicitly setting the token text
     * allows {@link Token//getText} to be called at any time regardless of the
     * input stream implementation.
     *
     * <p>
     * The default value is {@code false} to avoid the performance and memory
     * overhead of copying text for every token unless explicitly requested.</p>
     */

    this.copyText = copyText === undefined ? false : copyText;
  }

  create(source, type, text, channel, start, stop, line, column) {
    const t = new CommonToken(source, type, channel, start, stop);
    t.line = line;
    t.column = column;

    if (text !== null) {
      t.text = text;
    } else if (this.copyText && source[1] !== null) {
      t.text = source[1].getText(start, stop);
    }

    return t;
  }

  createThin(type, text) {
    const t = new CommonToken(null, type);
    t.text = text;
    return t;
  }

}
/**
 * The default {@link CommonTokenFactory} instance.
 *
 * <p>
 * This token factory does not explicitly copy token text when constructing
 * tokens.</p>
 */


CommonTokenFactory.DEFAULT = new CommonTokenFactory();
module.exports = CommonTokenFactory;

/***/ }),
/* 31 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

/**
 * The root of the ANTLR exception hierarchy. In general, ANTLR tracks just
 *  3 kinds of errors: prediction errors, failed predicate errors, and
 *  mismatched input errors. In each case, the parser knows where it is
 *  in the input, where it is in the ATN, the rule invocation stack,
 *  and what kind of problem occurred.
 */
const {
  PredicateTransition
} = __webpack_require__(17);

const {
  Interval
} = (__webpack_require__(16).Interval);

class RecognitionException extends Error {
  constructor(params) {
    super(params.message);

    if (!!Error.captureStackTrace) {
      Error.captureStackTrace(this, RecognitionException);
    } else {
      var stack = new Error().stack;
    }

    this.message = params.message;
    this.recognizer = params.recognizer;
    this.input = params.input;
    this.ctx = params.ctx;
    /**
     * The current {@link Token} when an error occurred. Since not all streams
     * support accessing symbols by index, we have to track the {@link Token}
     * instance itself
    */

    this.offendingToken = null;
    /**
     * Get the ATN state number the parser was in at the time the error
     * occurred. For {@link NoViableAltException} and
     * {@link LexerNoViableAltException} exceptions, this is the
     * {@link DecisionState} number. For others, it is the state whose outgoing
     * edge we couldn't match.
     */

    this.offendingState = -1;

    if (this.recognizer !== null) {
      this.offendingState = this.recognizer.state;
    }
  }
  /**
   * Gets the set of input symbols which could potentially follow the
   * previously matched symbol at the time this exception was thrown.
   *
   * <p>If the set of expected tokens is not known and could not be computed,
   * this method returns {@code null}.</p>
   *
   * @return The set of token types that could potentially follow the current
   * state in the ATN, or {@code null} if the information is not available.
   */


  getExpectedTokens() {
    if (this.recognizer !== null) {
      return this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx);
    } else {
      return null;
    }
  } // <p>If the state number is not known, this method returns -1.</p>


  toString() {
    return this.message;
  }

}

class LexerNoViableAltException extends RecognitionException {
  constructor(lexer, input, startIndex, deadEndConfigs) {
    super({
      message: "",
      recognizer: lexer,
      input: input,
      ctx: null
    });
    this.startIndex = startIndex;
    this.deadEndConfigs = deadEndConfigs;
  }

  toString() {
    let symbol = "";

    if (this.startIndex >= 0 && this.startIndex < this.input.size) {
      symbol = this.input.getText(new Interval(this.startIndex, this.startIndex));
    }

    return "LexerNoViableAltException" + symbol;
  }

}
/**
 * Indicates that the parser could not decide which of two or more paths
 * to take based upon the remaining input. It tracks the starting token
 * of the offending input and also knows where the parser was
 * in the various paths when the error. Reported by reportNoViableAlternative()
 */


class NoViableAltException extends RecognitionException {
  constructor(recognizer, input, startToken, offendingToken, deadEndConfigs, ctx) {
    ctx = ctx || recognizer._ctx;
    offendingToken = offendingToken || recognizer.getCurrentToken();
    startToken = startToken || recognizer.getCurrentToken();
    input = input || recognizer.getInputStream();
    super({
      message: "",
      recognizer: recognizer,
      input: input,
      ctx: ctx
    }); // Which configurations did we try at input.index() that couldn't match
    // input.LT(1)?//

    this.deadEndConfigs = deadEndConfigs; // The token object at the start index; the input stream might
    // not be buffering tokens so get a reference to it. (At the
    // time the error occurred, of course the stream needs to keep a
    // buffer all of the tokens but later we might not have access to those.)

    this.startToken = startToken;
    this.offendingToken = offendingToken;
  }

}
/**
 * This signifies any kind of mismatched input exceptions such as
 * when the current input does not match the expected token.
*/


class InputMismatchException extends RecognitionException {
  constructor(recognizer) {
    super({
      message: "",
      recognizer: recognizer,
      input: recognizer.getInputStream(),
      ctx: recognizer._ctx
    });
    this.offendingToken = recognizer.getCurrentToken();
  }

}

function formatMessage(predicate, message) {
  if (message !== null) {
    return message;
  } else {
    return "failed predicate: {" + predicate + "}?";
  }
}
/**
 * A semantic predicate failed during validation. Validation of predicates
 * occurs when normally parsing the alternative just like matching a token.
 * Disambiguating predicate evaluation occurs when we test a predicate during
 * prediction.
*/


class FailedPredicateException extends RecognitionException {
  constructor(recognizer, predicate, message) {
    super({
      message: formatMessage(predicate, message || null),
      recognizer: recognizer,
      input: recognizer.getInputStream(),
      ctx: recognizer._ctx
    });
    const s = recognizer._interp.atn.states[recognizer.state];
    const trans = s.transitions[0];

    if (trans instanceof PredicateTransition) {
      this.ruleIndex = trans.ruleIndex;
      this.predicateIndex = trans.predIndex;
    } else {
      this.ruleIndex = 0;
      this.predicateIndex = 0;
    }

    this.predicate = predicate;
    this.offendingToken = recognizer.getCurrentToken();
  }

}

class ParseCancellationException extends Error {
  constructor() {
    super();
    Error.captureStackTrace(this, ParseCancellationException);
  }

}

module.exports = {
  RecognitionException,
  NoViableAltException,
  LexerNoViableAltException,
  InputMismatchException,
  FailedPredicateException,
  ParseCancellationException
};

/***/ }),
/* 32 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  DFAState
} = __webpack_require__(33);

const {
  ATNConfigSet
} = __webpack_require__(34);

const {
  getCachedPredictionContext
} = __webpack_require__(18);

const {
  Map
} = __webpack_require__(11);

class ATNSimulator {
  constructor(atn, sharedContextCache) {
    /**
     * The context cache maps all PredictionContext objects that are ==
     * to a single cached copy. This cache is shared across all contexts
     * in all ATNConfigs in all DFA states.  We rebuild each ATNConfigSet
     * to use only cached nodes/graphs in addDFAState(). We don't want to
     * fill this during closure() since there are lots of contexts that
     * pop up but are not used ever again. It also greatly slows down closure().
     *
     * <p>This cache makes a huge difference in memory and a little bit in speed.
     * For the Java grammar on java.*, it dropped the memory requirements
     * at the end from 25M to 16M. We don't store any of the full context
     * graphs in the DFA because they are limited to local context only,
     * but apparently there's a lot of repetition there as well. We optimize
     * the config contexts before storing the config set in the DFA states
     * by literally rebuilding them with cached subgraphs only.</p>
     *
     * <p>I tried a cache for use during closure operations, that was
     * whacked after each adaptivePredict(). It cost a little bit
     * more time I think and doesn't save on the overall footprint
     * so it's not worth the complexity.</p>
     */
    this.atn = atn;
    this.sharedContextCache = sharedContextCache;
    return this;
  }

  getCachedContext(context) {
    if (this.sharedContextCache === null) {
      return context;
    }

    const visited = new Map();
    return getCachedPredictionContext(context, this.sharedContextCache, visited);
  }

} // Must distinguish between missing edge and edge we know leads nowhere///


ATNSimulator.ERROR = new DFAState(0x7FFFFFFF, new ATNConfigSet());
module.exports = ATNSimulator;

/***/ }),
/* 33 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  ATNConfigSet
} = __webpack_require__(34);

const {
  Hash,
  Set
} = __webpack_require__(11);
/**
 * Map a predicate to a predicted alternative.
 */


class PredPrediction {
  constructor(pred, alt) {
    this.alt = alt;
    this.pred = pred;
  }

  toString() {
    return "(" + this.pred + ", " + this.alt + ")";
  }

}
/**
 * A DFA state represents a set of possible ATN configurations.
 * As Aho, Sethi, Ullman p. 117 says "The DFA uses its state
 * to keep track of all possible states the ATN can be in after
 * reading each input symbol. That is to say, after reading
 * input a1a2..an, the DFA is in a state that represents the
 * subset T of the states of the ATN that are reachable from the
 * ATN's start state along some path labeled a1a2..an."
 * In conventional NFA&rarr;DFA conversion, therefore, the subset T
 * would be a bitset representing the set of states the
 * ATN could be in. We need to track the alt predicted by each
 * state as well, however. More importantly, we need to maintain
 * a stack of states, tracking the closure operations as they
 * jump from rule to rule, emulating rule invocations (method calls).
 * I have to add a stack to simulate the proper lookahead sequences for
 * the underlying LL grammar from which the ATN was derived.
 *
 * <p>I use a set of ATNConfig objects not simple states. An ATNConfig
 * is both a state (ala normal conversion) and a RuleContext describing
 * the chain of rules (if any) followed to arrive at that state.</p>
 *
 * <p>A DFA state may have multiple references to a particular state,
 * but with different ATN contexts (with same or different alts)
 * meaning that state was reached via a different set of rule invocations.</p>
 */


class DFAState {
  constructor(stateNumber, configs) {
    if (stateNumber === null) {
      stateNumber = -1;
    }

    if (configs === null) {
      configs = new ATNConfigSet();
    }

    this.stateNumber = stateNumber;
    this.configs = configs;
    /**
     * {@code edges[symbol]} points to target of symbol. Shift up by 1 so (-1)
     * {@link Token//EOF} maps to {@code edges[0]}.
     */

    this.edges = null;
    this.isAcceptState = false;
    /**
     * if accept state, what ttype do we match or alt do we predict?
     * This is set to {@link ATN//INVALID_ALT_NUMBER} when {@link//predicates}
     * {@code !=null} or {@link //requiresFullContext}.
     */

    this.prediction = 0;
    this.lexerActionExecutor = null;
    /**
     * Indicates that this state was created during SLL prediction that
     * discovered a conflict between the configurations in the state. Future
     * {@link ParserATNSimulator//execATN} invocations immediately jumped doing
     * full context prediction if this field is true.
     */

    this.requiresFullContext = false;
    /**
     * During SLL parsing, this is a list of predicates associated with the
     * ATN configurations of the DFA state. When we have predicates,
     * {@link //requiresFullContext} is {@code false} since full context
     * prediction evaluates predicates
     * on-the-fly. If this is not null, then {@link //prediction} is
     * {@link ATN//INVALID_ALT_NUMBER}.
     *
     * <p>We only use these for non-{@link //requiresFullContext} but
     * conflicting states. That
     * means we know from the context (it's $ or we don't dip into outer
     * context) that it's an ambiguity not a conflict.</p>
     *
     * <p>This list is computed by {@link
     * ParserATNSimulator//predicateDFAState}.</p>
     */

    this.predicates = null;
    return this;
  }
  /**
   * Get the set of all alts mentioned by all ATN configurations in this
   * DFA state.
   */


  getAltSet() {
    const alts = new Set();

    if (this.configs !== null) {
      for (let i = 0; i < this.configs.length; i++) {
        const c = this.configs[i];
        alts.add(c.alt);
      }
    }

    if (alts.length === 0) {
      return null;
    } else {
      return alts;
    }
  }
  /**
   * Two {@link DFAState} instances are equal if their ATN configuration sets
   * are the same. This method is used to see if a state already exists.
   *
   * <p>Because the number of alternatives and number of ATN configurations are
   * finite, there is a finite number of DFA states that can be processed.
   * This is necessary to show that the algorithm terminates.</p>
   *
   * <p>Cannot test the DFA state numbers here because in
   * {@link ParserATNSimulator//addDFAState} we need to know if any other state
   * exists that has this exact set of ATN configurations. The
   * {@link //stateNumber} is irrelevant.</p>
   */


  equals(other) {
    // compare set of ATN configurations in this set with other
    return this === other || other instanceof DFAState && this.configs.equals(other.configs);
  }

  toString() {
    let s = "" + this.stateNumber + ":" + this.configs;

    if (this.isAcceptState) {
      s = s + "=>";
      if (this.predicates !== null) s = s + this.predicates;else s = s + this.prediction;
    }

    return s;
  }

  hashCode() {
    const hash = new Hash();
    hash.update(this.configs);
    return hash.finish();
  }

}

module.exports = {
  DFAState,
  PredPrediction
};

/***/ }),
/* 34 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const ATN = __webpack_require__(9);

const Utils = __webpack_require__(11);

const {
  SemanticContext
} = __webpack_require__(15);

const {
  merge
} = __webpack_require__(18);

function hashATNConfig(c) {
  return c.hashCodeForConfigSet();
}

function equalATNConfigs(a, b) {
  if (a === b) {
    return true;
  } else if (a === null || b === null) {
    return false;
  } else return a.equalsForConfigSet(b);
}
/**
 * Specialized {@link Set}{@code <}{@link ATNConfig}{@code >} that can track
 * info about the set, with support for combining similar configurations using a
 * graph-structured stack
 */


class ATNConfigSet {
  constructor(fullCtx) {
    /**
     * The reason that we need this is because we don't want the hash map to use
     * the standard hash code and equals. We need all configurations with the
     * same
     * {@code (s,i,_,semctx)} to be equal. Unfortunately, this key effectively
     * doubles
     * the number of objects associated with ATNConfigs. The other solution is
     * to
     * use a hash table that lets us specify the equals/hashcode operation.
     * All configs but hashed by (s, i, _, pi) not including context. Wiped out
     * when we go readonly as this set becomes a DFA state
     */
    this.configLookup = new Utils.Set(hashATNConfig, equalATNConfigs);
    /**
     * Indicates that this configuration set is part of a full context
     * LL prediction. It will be used to determine how to merge $. With SLL
     * it's a wildcard whereas it is not for LL context merge
     */

    this.fullCtx = fullCtx === undefined ? true : fullCtx;
    /**
     * Indicates that the set of configurations is read-only. Do not
     * allow any code to manipulate the set; DFA states will point at
     * the sets and they must not change. This does not protect the other
     * fields; in particular, conflictingAlts is set after
     * we've made this readonly
     */

    this.readOnly = false; // Track the elements as they are added to the set; supports get(i)///

    this.configs = []; // TODO: these fields make me pretty uncomfortable but nice to pack up info
    // together, saves recomputation
    // TODO: can we track conflicts as they are added to save scanning configs
    // later?

    this.uniqueAlt = 0;
    this.conflictingAlts = null;
    /**
     * Used in parser and lexer. In lexer, it indicates we hit a pred
     * while computing a closure operation. Don't make a DFA state from this
     */

    this.hasSemanticContext = false;
    this.dipsIntoOuterContext = false;
    this.cachedHashCode = -1;
  }
  /**
   * Adding a new config means merging contexts with existing configs for
   * {@code (s, i, pi, _)}, where {@code s} is the
   * {@link ATNConfig//state}, {@code i} is the {@link ATNConfig//alt}, and
   * {@code pi} is the {@link ATNConfig//semanticContext}. We use
   * {@code (s,i,pi)} as key.
   *
   * <p>This method updates {@link //dipsIntoOuterContext} and
   * {@link //hasSemanticContext} when necessary.</p>
   */


  add(config, mergeCache) {
    if (mergeCache === undefined) {
      mergeCache = null;
    }

    if (this.readOnly) {
      throw "This set is readonly";
    }

    if (config.semanticContext !== SemanticContext.NONE) {
      this.hasSemanticContext = true;
    }

    if (config.reachesIntoOuterContext > 0) {
      this.dipsIntoOuterContext = true;
    }

    const existing = this.configLookup.add(config);

    if (existing === config) {
      this.cachedHashCode = -1;
      this.configs.push(config); // track order here

      return true;
    } // a previous (s,i,pi,_), merge with it and save result


    const rootIsWildcard = !this.fullCtx;
    const merged = merge(existing.context, config.context, rootIsWildcard, mergeCache);
    /**
     * no need to check for existing.context, config.context in cache
     * since only way to create new graphs is "call rule" and here. We
     * cache at both places
     */

    existing.reachesIntoOuterContext = Math.max(existing.reachesIntoOuterContext, config.reachesIntoOuterContext); // make sure to preserve the precedence filter suppression during the merge

    if (config.precedenceFilterSuppressed) {
      existing.precedenceFilterSuppressed = true;
    }

    existing.context = merged; // replace context; no need to alt mapping

    return true;
  }

  getStates() {
    const states = new Utils.Set();

    for (let i = 0; i < this.configs.length; i++) {
      states.add(this.configs[i].state);
    }

    return states;
  }

  getPredicates() {
    const preds = [];

    for (let i = 0; i < this.configs.length; i++) {
      const c = this.configs[i].semanticContext;

      if (c !== SemanticContext.NONE) {
        preds.push(c.semanticContext);
      }
    }

    return preds;
  }

  optimizeConfigs(interpreter) {
    if (this.readOnly) {
      throw "This set is readonly";
    }

    if (this.configLookup.length === 0) {
      return;
    }

    for (let i = 0; i < this.configs.length; i++) {
      const config = this.configs[i];
      config.context = interpreter.getCachedContext(config.context);
    }
  }

  addAll(coll) {
    for (let i = 0; i < coll.length; i++) {
      this.add(coll[i]);
    }

    return false;
  }

  equals(other) {
    return this === other || other instanceof ATNConfigSet && Utils.equalArrays(this.configs, other.configs) && this.fullCtx === other.fullCtx && this.uniqueAlt === other.uniqueAlt && this.conflictingAlts === other.conflictingAlts && this.hasSemanticContext === other.hasSemanticContext && this.dipsIntoOuterContext === other.dipsIntoOuterContext;
  }

  hashCode() {
    const hash = new Utils.Hash();
    hash.update(this.configs);
    return hash.finish();
  }

  updateHashCode(hash) {
    if (this.readOnly) {
      if (this.cachedHashCode === -1) {
        this.cachedHashCode = this.hashCode();
      }

      hash.update(this.cachedHashCode);
    } else {
      hash.update(this.hashCode());
    }
  }

  isEmpty() {
    return this.configs.length === 0;
  }

  contains(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }

    return this.configLookup.contains(item);
  }

  containsFast(item) {
    if (this.configLookup === null) {
      throw "This method is not implemented for readonly sets.";
    }

    return this.configLookup.containsFast(item);
  }

  clear() {
    if (this.readOnly) {
      throw "This set is readonly";
    }

    this.configs = [];
    this.cachedHashCode = -1;
    this.configLookup = new Utils.Set();
  }

  setReadonly(readOnly) {
    this.readOnly = readOnly;

    if (readOnly) {
      this.configLookup = null; // can't mod, no need for lookup cache
    }
  }

  toString() {
    return Utils.arrayToString(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== ATN.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (this.conflictingAlts !== null ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
  }

  get items() {
    return this.configs;
  }

  get length() {
    return this.configs.length;
  }

}

class OrderedATNConfigSet extends ATNConfigSet {
  constructor() {
    super();
    this.configLookup = new Utils.Set();
  }

}

module.exports = {
  ATNConfigSet,
  OrderedATNConfigSet
};

/***/ }),
/* 35 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  hashStuff
} = __webpack_require__(11);

const {
  LexerIndexedCustomAction
} = __webpack_require__(25);

class LexerActionExecutor {
  /**
   * Represents an executor for a sequence of lexer actions which traversed during
   * the matching operation of a lexer rule (token).
   *
   * <p>The executor tracks position information for position-dependent lexer actions
   * efficiently, ensuring that actions appearing only at the end of the rule do
   * not cause bloating of the {@link DFA} created for the lexer.</p>
   */
  constructor(lexerActions) {
    this.lexerActions = lexerActions === null ? [] : lexerActions;
    /**
     * Caches the result of {@link //hashCode} since the hash code is an element
     * of the performance-critical {@link LexerATNConfig//hashCode} operation
     */

    this.cachedHashCode = hashStuff(lexerActions); // "".join([str(la) for la in
    // lexerActions]))

    return this;
  }
  /**
   * Creates a {@link LexerActionExecutor} which encodes the current offset
   * for position-dependent lexer actions.
   *
   * <p>Normally, when the executor encounters lexer actions where
   * {@link LexerAction//isPositionDependent} returns {@code true}, it calls
   * {@link IntStream//seek} on the input {@link CharStream} to set the input
   * position to the <em>end</em> of the current token. This behavior provides
   * for efficient DFA representation of lexer actions which appear at the end
   * of a lexer rule, even when the lexer rule matches a variable number of
   * characters.</p>
   *
   * <p>Prior to traversing a match transition in the ATN, the current offset
   * from the token start index is assigned to all position-dependent lexer
   * actions which have not already been assigned a fixed offset. By storing
   * the offsets relative to the token start index, the DFA representation of
   * lexer actions which appear in the middle of tokens remains efficient due
   * to sharing among tokens of the same length, regardless of their absolute
   * position in the input stream.</p>
   *
   * <p>If the current executor already has offsets assigned to all
   * position-dependent lexer actions, the method returns {@code this}.</p>
   *
   * @param offset The current offset to assign to all position-dependent
   * lexer actions which do not already have offsets assigned.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} which stores input stream offsets
   * for all position-dependent lexer actions.
   */


  fixOffsetBeforeMatch(offset) {
    let updatedLexerActions = null;

    for (let i = 0; i < this.lexerActions.length; i++) {
      if (this.lexerActions[i].isPositionDependent && !(this.lexerActions[i] instanceof LexerIndexedCustomAction)) {
        if (updatedLexerActions === null) {
          updatedLexerActions = this.lexerActions.concat([]);
        }

        updatedLexerActions[i] = new LexerIndexedCustomAction(offset, this.lexerActions[i]);
      }
    }

    if (updatedLexerActions === null) {
      return this;
    } else {
      return new LexerActionExecutor(updatedLexerActions);
    }
  }
  /**
   * Execute the actions encapsulated by this executor within the context of a
   * particular {@link Lexer}.
   *
   * <p>This method calls {@link IntStream//seek} to set the position of the
   * {@code input} {@link CharStream} prior to calling
   * {@link LexerAction//execute} on a position-dependent action. Before the
   * method returns, the input position will be restored to the same position
   * it was in when the method was invoked.</p>
   *
   * @param lexer The lexer instance.
   * @param input The input stream which is the source for the current token.
   * When this method is called, the current {@link IntStream//index} for
   * {@code input} should be the start of the following token, i.e. 1
   * character past the end of the current token.
   * @param startIndex The token start index. This value may be passed to
   * {@link IntStream//seek} to set the {@code input} position to the beginning
   * of the token.
   */


  execute(lexer, input, startIndex) {
    let requiresSeek = false;
    const stopIndex = input.index;

    try {
      for (let i = 0; i < this.lexerActions.length; i++) {
        let lexerAction = this.lexerActions[i];

        if (lexerAction instanceof LexerIndexedCustomAction) {
          const offset = lexerAction.offset;
          input.seek(startIndex + offset);
          lexerAction = lexerAction.action;
          requiresSeek = startIndex + offset !== stopIndex;
        } else if (lexerAction.isPositionDependent) {
          input.seek(stopIndex);
          requiresSeek = false;
        }

        lexerAction.execute(lexer);
      }
    } finally {
      if (requiresSeek) {
        input.seek(stopIndex);
      }
    }
  }

  hashCode() {
    return this.cachedHashCode;
  }

  updateHashCode(hash) {
    hash.update(this.cachedHashCode);
  }

  equals(other) {
    if (this === other) {
      return true;
    } else if (!(other instanceof LexerActionExecutor)) {
      return false;
    } else if (this.cachedHashCode != other.cachedHashCode) {
      return false;
    } else if (this.lexerActions.length != other.lexerActions.length) {
      return false;
    } else {
      const numActions = this.lexerActions.length;

      for (let idx = 0; idx < numActions; ++idx) {
        if (!this.lexerActions[idx].equals(other.lexerActions[idx])) {
          return false;
        }
      }

      return true;
    }
  }
  /**
   * Creates a {@link LexerActionExecutor} which executes the actions for
   * the input {@code lexerActionExecutor} followed by a specified
   * {@code lexerAction}.
   *
   * @param lexerActionExecutor The executor for actions already traversed by
   * the lexer while matching a token within a particular
   * {@link LexerATNConfig}. If this is {@code null}, the method behaves as
   * though it were an empty executor.
   * @param lexerAction The lexer action to execute after the actions
   * specified in {@code lexerActionExecutor}.
   *
   * @return {LexerActionExecutor} A {@link LexerActionExecutor} for executing the combine actions
   * of {@code lexerActionExecutor} and {@code lexerAction}.
   */


  static append(lexerActionExecutor, lexerAction) {
    if (lexerActionExecutor === null) {
      return new LexerActionExecutor([lexerAction]);
    }

    const lexerActions = lexerActionExecutor.lexerActions.concat([lexerAction]);
    return new LexerActionExecutor(lexerActions);
  }

}

module.exports = LexerActionExecutor;

/***/ }),
/* 36 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Utils = __webpack_require__(11);

const {
  Set,
  BitSet,
  DoubleDict
} = Utils;

const ATN = __webpack_require__(9);

const {
  ATNState,
  RuleStopState
} = __webpack_require__(14);

const {
  ATNConfig
} = __webpack_require__(13);

const {
  ATNConfigSet
} = __webpack_require__(34);

const {
  Token
} = __webpack_require__(12);

const {
  DFAState,
  PredPrediction
} = __webpack_require__(33);

const ATNSimulator = __webpack_require__(32);

const PredictionMode = __webpack_require__(37);

const RuleContext = __webpack_require__(19);

const ParserRuleContext = __webpack_require__(38);

const {
  SemanticContext
} = __webpack_require__(15);

const {
  PredictionContext
} = __webpack_require__(18);

const {
  Interval
} = __webpack_require__(16);

const {
  Transition,
  SetTransition,
  NotSetTransition,
  RuleTransition,
  ActionTransition
} = __webpack_require__(17);

const {
  NoViableAltException
} = __webpack_require__(31);

const {
  SingletonPredictionContext,
  predictionContextFromRuleContext
} = __webpack_require__(18);
/**
 * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.
 *
 * <p>
 * The basic complexity of the adaptive strategy makes it harder to understand.
 * We begin with ATN simulation to build paths in a DFA. Subsequent prediction
 * requests go through the DFA first. If they reach a state without an edge for
 * the current symbol, the algorithm fails over to the ATN simulation to
 * complete the DFA path for the current input (until it finds a conflict state
 * or uniquely predicting state).</p>
 *
 * <p>
 * All of that is done without using the outer context because we want to create
 * a DFA that is not dependent upon the rule invocation stack when we do a
 * prediction. One DFA works in all contexts. We avoid using context not
 * necessarily because it's slower, although it can be, but because of the DFA
 * caching problem. The closure routine only considers the rule invocation stack
 * created during prediction beginning in the decision rule. For example, if
 * prediction occurs without invoking another rule's ATN, there are no context
 * stacks in the configurations. When lack of context leads to a conflict, we
 * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing
 * strategy (versus full LL(*)).</p>
 *
 * <p>
 * When SLL yields a configuration set with conflict, we rewind the input and
 * retry the ATN simulation, this time using full outer context without adding
 * to the DFA. Configuration context stacks will be the full invocation stacks
 * from the start rule. If we get a conflict using full context, then we can
 * definitively say we have a true ambiguity for that input sequence. If we
 * don't get a conflict, it implies that the decision is sensitive to the outer
 * context. (It is not context-sensitive in the sense of context-sensitive
 * grammars.)</p>
 *
 * <p>
 * The next time we reach this DFA state with an SLL conflict, through DFA
 * simulation, we will again retry the ATN simulation using full context mode.
 * This is slow because we can't save the results and have to "interpret" the
 * ATN each time we get that input.</p>
 *
 * <p>
 * <strong>CACHING FULL CONTEXT PREDICTIONS</strong></p>
 *
 * <p>
 * We could cache results from full context to predicted alternative easily and
 * that saves a lot of time but doesn't work in presence of predicates. The set
 * of visible predicates from the ATN start state changes depending on the
 * context, because closure can fall off the end of a rule. I tried to cache
 * tuples (stack context, semantic context, predicted alt) but it was slower
 * than interpreting and much more complicated. Also required a huge amount of
 * memory. The goal is not to create the world's fastest parser anyway. I'd like
 * to keep this algorithm simple. By launching multiple threads, we can improve
 * the speed of parsing across a large number of files.</p>
 *
 * <p>
 * There is no strict ordering between the amount of input used by SLL vs LL,
 * which makes it really hard to build a cache for full context. Let's say that
 * we have input A B C that leads to an SLL conflict with full context X. That
 * implies that using X we might only use A B but we could also use A B C D to
 * resolve conflict. Input A B C D could predict alternative 1 in one position
 * in the input and A B C E could predict alternative 2 in another position in
 * input. The conflicting SLL configurations could still be non-unique in the
 * full context prediction, which would lead us to requiring more input than the
 * original A B C.	To make a	prediction cache work, we have to track	the exact
 * input	used during the previous prediction. That amounts to a cache that maps
 * X to a specific DFA for that context.</p>
 *
 * <p>
 * Something should be done for left-recursive expression predictions. They are
 * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry
 * with full LL thing Sam does.</p>
 *
 * <p>
 * <strong>AVOIDING FULL CONTEXT PREDICTION</strong></p>
 *
 * <p>
 * We avoid doing full context retry when the outer context is empty, we did not
 * dip into the outer context by falling off the end of the decision state rule,
 * or when we force SLL mode.</p>
 *
 * <p>
 * As an example of the not dip into outer context case, consider as super
 * constructor calls versus function calls. One grammar might look like
 * this:</p>
 *
 * <pre>
 * ctorBody
 *   : '{' superCall? stat* '}'
 *   ;
 * </pre>
 *
 * <p>
 * Or, you might see something like</p>
 *
 * <pre>
 * stat
 *   : superCall ';'
 *   | expression ';'
 *   | ...
 *   ;
 * </pre>
 *
 * <p>
 * In both cases I believe that no closure operations will dip into the outer
 * context. In the first case ctorBody in the worst case will stop at the '}'.
 * In the 2nd case it should stop at the ';'. Both cases should stay within the
 * entry rule and not dip into the outer context.</p>
 *
 * <p>
 * <strong>PREDICATES</strong></p>
 *
 * <p>
 * Predicates are always evaluated if present in either SLL or LL both. SLL and
 * LL simulation deals with predicates differently. SLL collects predicates as
 * it performs closure operations like ANTLR v3 did. It delays predicate
 * evaluation until it reaches and accept state. This allows us to cache the SLL
 * ATN simulation whereas, if we had evaluated predicates on-the-fly during
 * closure, the DFA state configuration sets would be different and we couldn't
 * build up a suitable DFA.</p>
 *
 * <p>
 * When building a DFA accept state during ATN simulation, we evaluate any
 * predicates and return the sole semantically valid alternative. If there is
 * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,
 * we throw an exception. Alternatives without predicates act like they have
 * true predicates. The simple way to think about it is to strip away all
 * alternatives with false predicates and choose the minimum alternative that
 * remains.</p>
 *
 * <p>
 * When we start in the DFA and reach an accept state that's predicated, we test
 * those and return the minimum semantically viable alternative. If no
 * alternatives are viable, we throw an exception.</p>
 *
 * <p>
 * During full LL ATN simulation, closure always evaluates predicates and
 * on-the-fly. This is crucial to reducing the configuration set size during
 * closure. It hits a landmine when parsing with the Java grammar, for example,
 * without this on-the-fly evaluation.</p>
 *
 * <p>
 * <strong>SHARING DFA</strong></p>
 *
 * <p>
 * All instances of the same parser share the same decision DFAs through a
 * static field. Each instance gets its own ATN simulator but they share the
 * same {@link //decisionToDFA} field. They also share a
 * {@link PredictionContextCache} object that makes sure that all
 * {@link PredictionContext} objects are shared among the DFA states. This makes
 * a big size difference.</p>
 *
 * <p>
 * <strong>THREAD SAFETY</strong></p>
 *
 * <p>
 * The {@link ParserATNSimulator} locks on the {@link //decisionToDFA} field when
 * it adds a new DFA object to that array. {@link //addDFAEdge}
 * locks on the DFA for the current decision when setting the
 * {@link DFAState//edges} field. {@link //addDFAState} locks on
 * the DFA for the current decision when looking up a DFA state to see if it
 * already exists. We must make sure that all requests to add DFA states that
 * are equivalent result in the same shared DFA object. This is because lots of
 * threads will be trying to update the DFA at once. The
 * {@link //addDFAState} method also locks inside the DFA lock
 * but this time on the shared context cache when it rebuilds the
 * configurations' {@link PredictionContext} objects using cached
 * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is
 * safe as long as we can guarantee that all threads referencing
 * {@code s.edge[t]} get the same physical target {@link DFAState}, or
 * {@code null}. Once into the DFA, the DFA simulation does not reference the
 * {@link DFA//states} map. It follows the {@link DFAState//edges} field to new
 * targets. The DFA simulator will either find {@link DFAState//edges} to be
 * {@code null}, to be non-{@code null} and {@code dfa.edges[t]} null, or
 * {@code dfa.edges[t]} to be non-null. The
 * {@link //addDFAEdge} method could be racing to set the field
 * but in either case the DFA simulator works; if {@code null}, and requests ATN
 * simulation. It could also race trying to get {@code dfa.edges[t]}, but either
 * way it will work because it's not doing a test and set operation.</p>
 *
 * <p>
 * <strong>Starting with SLL then failing to combined SLL/LL (Two-Stage
 * Parsing)</strong></p>
 *
 * <p>
 * Sam pointed out that if SLL does not give a syntax error, then there is no
 * point in doing full LL, which is slower. We only have to try LL if we get a
 * syntax error. For maximum speed, Sam starts the parser set to pure SLL
 * mode with the {@link BailErrorStrategy}:</p>
 *
 * <pre>
 * parser.{@link Parser//getInterpreter() getInterpreter()}.{@link //setPredictionMode setPredictionMode}{@code (}{@link PredictionMode//SLL}{@code )};
 * parser.{@link Parser//setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());
 * </pre>
 *
 * <p>
 * If it does not get a syntax error, then we're done. If it does get a syntax
 * error, we need to retry with the combined SLL/LL strategy.</p>
 *
 * <p>
 * The reason this works is as follows. If there are no SLL conflicts, then the
 * grammar is SLL (at least for that input set). If there is an SLL conflict,
 * the full LL analysis must yield a set of viable alternatives which is a
 * subset of the alternatives reported by SLL. If the LL set is a singleton,
 * then the grammar is LL but not SLL. If the LL set is the same size as the SLL
 * set, the decision is SLL. If the LL set has size &gt; 1, then that decision
 * is truly ambiguous on the current input. If the LL set is smaller, then the
 * SLL conflict resolution might choose an alternative that the full LL would
 * rule out as a possibility based upon better context information. If that's
 * the case, then the SLL parse will definitely get an error because the full LL
 * analysis says it's not viable. If SLL conflict resolution chooses an
 * alternative within the LL set, them both SLL and LL would choose the same
 * alternative because they both choose the minimum of multiple conflicting
 * alternatives.</p>
 *
 * <p>
 * Let's say we have a set of SLL conflicting alternatives {@code {1, 2, 3}} and
 * a smaller LL set called <em>s</em>. If <em>s</em> is {@code {2, 3}}, then SLL
 * parsing will get an error because SLL will pursue alternative 1. If
 * <em>s</em> is {@code {1, 2}} or {@code {1, 3}} then both SLL and LL will
 * choose the same alternative because alternative one is the minimum of either
 * set. If <em>s</em> is {@code {2}} or {@code {3}} then SLL will get a syntax
 * error. If <em>s</em> is {@code {1}} then SLL will succeed.</p>
 *
 * <p>
 * Of course, if the input is invalid, then we will get an error for sure in
 * both SLL and LL parsing. Erroneous input will therefore require 2 passes over
 * the input.</p>
 */


class ParserATNSimulator extends ATNSimulator {
  constructor(parser, atn, decisionToDFA, sharedContextCache) {
    super(atn, sharedContextCache);
    this.parser = parser;
    this.decisionToDFA = decisionToDFA; // SLL, LL, or LL + exact ambig detection?//

    this.predictionMode = PredictionMode.LL; // LAME globals to avoid parameters!!!!! I need these down deep in predTransition

    this._input = null;
    this._startIndex = 0;
    this._outerContext = null;
    this._dfa = null;
    /**
     * Each prediction operation uses a cache for merge of prediction contexts.
     *  Don't keep around as it wastes huge amounts of memory. DoubleKeyMap
     *  isn't synchronized but we're ok since two threads shouldn't reuse same
     *  parser/atnsim object because it can only handle one input at a time.
     *  This maps graphs a and b to merged result c. (a,b)&rarr;c. We can avoid
     *  the merge if we ever see a and b again.  Note that (b,a)&rarr;c should
     *  also be examined during cache lookup.
     */

    this.mergeCache = null;
    this.debug = false;
    this.debug_closure = false;
    this.debug_add = false;
    this.debug_list_atn_decisions = false;
    this.dfa_debug = false;
    this.retry_debug = false;
  }

  reset() {}

  adaptivePredict(input, decision, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("adaptivePredict decision " + decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }

    this._input = input;
    this._startIndex = input.index;
    this._outerContext = outerContext;
    const dfa = this.decisionToDFA[decision];
    this._dfa = dfa;
    const m = input.mark();
    const index = input.index; // Now we are certain to have a specific decision's DFA
    // But, do we still need an initial state?

    try {
      let s0;

      if (dfa.precedenceDfa) {
        // the start state for a precedence DFA depends on the current
        // parser precedence, and is provided by a DFA method.
        s0 = dfa.getPrecedenceStartState(this.parser.getPrecedence());
      } else {
        // the start state for a "regular" DFA is just s0
        s0 = dfa.s0;
      }

      if (s0 === null) {
        if (outerContext === null) {
          outerContext = RuleContext.EMPTY;
        }

        if (this.debug || this.debug_list_atn_decisions) {
          console.log("predictATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + ", outerContext=" + outerContext.toString(this.parser.ruleNames));
        }

        const fullCtx = false;
        let s0_closure = this.computeStartState(dfa.atnStartState, RuleContext.EMPTY, fullCtx);

        if (dfa.precedenceDfa) {
          // If this is a precedence DFA, we use applyPrecedenceFilter
          // to convert the computed start state to a precedence start
          // state. We then use DFA.setPrecedenceStartState to set the
          // appropriate start state for the precedence level rather
          // than simply setting DFA.s0.
          //
          dfa.s0.configs = s0_closure; // not used for prediction but useful to know start configs anyway

          s0_closure = this.applyPrecedenceFilter(s0_closure);
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.setPrecedenceStartState(this.parser.getPrecedence(), s0);
        } else {
          s0 = this.addDFAState(dfa, new DFAState(null, s0_closure));
          dfa.s0 = s0;
        }
      }

      const alt = this.execATN(dfa, s0, input, index, outerContext);

      if (this.debug) {
        console.log("DFA after predictATN: " + dfa.toString(this.parser.literalNames, this.parser.symbolicNames));
      }

      return alt;
    } finally {
      this._dfa = null;
      this.mergeCache = null; // wack cache after each prediction

      input.seek(index);
      input.release(m);
    }
  }
  /**
   * Performs ATN simulation to compute a predicted alternative based
   *  upon the remaining input, but also updates the DFA cache to avoid
   *  having to traverse the ATN again for the same input sequence.
   *
   * There are some key conditions we're looking for after computing a new
   * set of ATN configs (proposed DFA state):
   *       if the set is empty, there is no viable alternative for current symbol
   *       does the state uniquely predict an alternative?
   *       does the state have a conflict that would prevent us from
   *         putting it on the work list?
   *
   * We also have some key operations to do:
   *       add an edge from previous DFA state to potentially new DFA state, D,
   *         upon current symbol but only if adding to work list, which means in all
   *         cases except no viable alternative (and possibly non-greedy decisions?)
   *       collecting predicates and adding semantic context to DFA accept states
   *       adding rule context to context-sensitive DFA accept states
   *       consuming an input symbol
   *       reporting a conflict
   *       reporting an ambiguity
   *       reporting a context sensitivity
   *       reporting insufficient predicates
   *
   * cover these cases:
   *    dead end
   *    single alt
   *    single alt + preds
   *    conflict
   *    conflict + preds
   *
   */


  execATN(dfa, s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATN decision " + dfa.decision + " exec LA(1)==" + this.getLookaheadName(input) + " line " + input.LT(1).line + ":" + input.LT(1).column);
    }

    let alt;
    let previousD = s0;

    if (this.debug) {
      console.log("s0 = " + s0);
    }

    let t = input.LA(1);

    while (true) {
      // while more work
      let D = this.getExistingTargetState(previousD, t);

      if (D === null) {
        D = this.computeTargetState(dfa, previousD, t);
      }

      if (D === ATNSimulator.ERROR) {
        // if any configs in previous dipped into outer context, that
        // means that input up to t actually finished entry rule
        // at least for SLL decision. Full LL doesn't dip into outer
        // so don't need special case.
        // We will get an error no matter what so delay until after
        // decision; better error message. Also, no reachable target
        // ATN states in SLL implies LL will also get nowhere.
        // If conflict in states that dip out, choose min since we
        // will get error no matter what.
        const e = this.noViableAlt(input, outerContext, previousD.configs, startIndex);
        input.seek(startIndex);
        alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previousD.configs, outerContext);

        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }

      if (D.requiresFullContext && this.predictionMode !== PredictionMode.SLL) {
        // IF PREDS, MIGHT RESOLVE TO SINGLE ALT => SLL (or syntax error)
        let conflictingAlts = null;

        if (D.predicates !== null) {
          if (this.debug) {
            console.log("DFA state has preds in DFA sim LL failover");
          }

          const conflictIndex = input.index;

          if (conflictIndex !== startIndex) {
            input.seek(startIndex);
          }

          conflictingAlts = this.evalSemanticContext(D.predicates, outerContext, true);

          if (conflictingAlts.length === 1) {
            if (this.debug) {
              console.log("Full LL avoided");
            }

            return conflictingAlts.minValue();
          }

          if (conflictIndex !== startIndex) {
            // restore the index so reporting the fallback to full
            // context occurs with the index at the correct spot
            input.seek(conflictIndex);
          }
        }

        if (this.dfa_debug) {
          console.log("ctx sensitive state " + outerContext + " in " + D);
        }

        const fullCtx = true;
        const s0_closure = this.computeStartState(dfa.atnStartState, outerContext, fullCtx);
        this.reportAttemptingFullContext(dfa, conflictingAlts, D.configs, startIndex, input.index);
        alt = this.execATNWithFullContext(dfa, D, s0_closure, input, startIndex, outerContext);
        return alt;
      }

      if (D.isAcceptState) {
        if (D.predicates === null) {
          return D.prediction;
        }

        const stopIndex = input.index;
        input.seek(startIndex);
        const alts = this.evalSemanticContext(D.predicates, outerContext, true);

        if (alts.length === 0) {
          throw this.noViableAlt(input, outerContext, D.configs, startIndex);
        } else if (alts.length === 1) {
          return alts.minValue();
        } else {
          // report ambiguity after predicate evaluation to make sure the correct set of ambig alts is reported.
          this.reportAmbiguity(dfa, D, startIndex, stopIndex, false, alts, D.configs);
          return alts.minValue();
        }
      }

      previousD = D;

      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    }
  }
  /**
   * Get an existing target state for an edge in the DFA. If the target state
   * for the edge has not yet been computed or is otherwise not available,
   * this method returns {@code null}.
   *
   * @param previousD The current DFA state
   * @param t The next input symbol
   * @return The existing target DFA state for the given input symbol
   * {@code t}, or {@code null} if the target state for this edge is not
   * already cached
   */


  getExistingTargetState(previousD, t) {
    const edges = previousD.edges;

    if (edges === null) {
      return null;
    } else {
      return edges[t + 1] || null;
    }
  }
  /**
   * Compute a target state for an edge in the DFA, and attempt to add the
   * computed state and corresponding edge to the DFA.
   *
   * @param dfa The DFA
   * @param previousD The current DFA state
   * @param t The next input symbol
   *
   * @return The computed target DFA state for the given input symbol
   * {@code t}. If {@code t} does not lead to a valid DFA state, this method
   * returns {@link //ERROR
   */


  computeTargetState(dfa, previousD, t) {
    const reach = this.computeReachSet(previousD.configs, t, false);

    if (reach === null) {
      this.addDFAEdge(dfa, previousD, t, ATNSimulator.ERROR);
      return ATNSimulator.ERROR;
    } // create new target state; we'll add to DFA after it's complete


    let D = new DFAState(null, reach);
    const predictedAlt = this.getUniqueAlt(reach);

    if (this.debug) {
      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);
      console.log("SLL altSubSets=" + Utils.arrayToString(altSubSets) +
      /*", previous=" + previousD.configs + */
      ", configs=" + reach + ", predict=" + predictedAlt + ", allSubsetsConflict=" + PredictionMode.allSubsetsConflict(altSubSets) + ", conflictingAlts=" + this.getConflictingAlts(reach));
    }

    if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
      // NO CONFLICT, UNIQUELY PREDICTED ALT
      D.isAcceptState = true;
      D.configs.uniqueAlt = predictedAlt;
      D.prediction = predictedAlt;
    } else if (PredictionMode.hasSLLConflictTerminatingPrediction(this.predictionMode, reach)) {
      // MORE THAN ONE VIABLE ALTERNATIVE
      D.configs.conflictingAlts = this.getConflictingAlts(reach);
      D.requiresFullContext = true; // in SLL-only mode, we will stop at this state and return the minimum alt

      D.isAcceptState = true;
      D.prediction = D.configs.conflictingAlts.minValue();
    }

    if (D.isAcceptState && D.configs.hasSemanticContext) {
      this.predicateDFAState(D, this.atn.getDecisionState(dfa.decision));

      if (D.predicates !== null) {
        D.prediction = ATN.INVALID_ALT_NUMBER;
      }
    } // all adds to dfa are done after we've created full D state


    D = this.addDFAEdge(dfa, previousD, t, D);
    return D;
  }

  predicateDFAState(dfaState, decisionState) {
    // We need to test all predicates, even in DFA states that
    // uniquely predict alternative.
    const nalts = decisionState.transitions.length; // Update DFA so reach becomes accept state with (predicate,alt)
    // pairs if preds found for conflicting alts

    const altsToCollectPredsFrom = this.getConflictingAltsOrUniqueAlt(dfaState.configs);
    const altToPred = this.getPredsForAmbigAlts(altsToCollectPredsFrom, dfaState.configs, nalts);

    if (altToPred !== null) {
      dfaState.predicates = this.getPredicatePredictions(altsToCollectPredsFrom, altToPred);
      dfaState.prediction = ATN.INVALID_ALT_NUMBER; // make sure we use preds
    } else {
      // There are preds in configs but they might go away
      // when OR'd together like {p}? || NONE == NONE. If neither
      // alt has preds, resolve to min alt
      dfaState.prediction = altsToCollectPredsFrom.minValue();
    }
  } // comes back with reach.uniqueAlt set to a valid alt


  execATNWithFullContext(dfa, D, // how far we got before failing over
  s0, input, startIndex, outerContext) {
    if (this.debug || this.debug_list_atn_decisions) {
      console.log("execATNWithFullContext " + s0);
    }

    const fullCtx = true;
    let foundExactAmbig = false;
    let reach;
    let previous = s0;
    input.seek(startIndex);
    let t = input.LA(1);
    let predictedAlt = -1;

    while (true) {
      // while more work
      reach = this.computeReachSet(previous, t, fullCtx);

      if (reach === null) {
        // if any configs in previous dipped into outer context, that
        // means that input up to t actually finished entry rule
        // at least for LL decision. Full LL doesn't dip into outer
        // so don't need special case.
        // We will get an error no matter what so delay until after
        // decision; better error message. Also, no reachable target
        // ATN states in SLL implies LL will also get nowhere.
        // If conflict in states that dip out, choose min since we
        // will get error no matter what.
        const e = this.noViableAlt(input, outerContext, previous, startIndex);
        input.seek(startIndex);
        const alt = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(previous, outerContext);

        if (alt !== ATN.INVALID_ALT_NUMBER) {
          return alt;
        } else {
          throw e;
        }
      }

      const altSubSets = PredictionMode.getConflictingAltSubsets(reach);

      if (this.debug) {
        console.log("LL altSubSets=" + altSubSets + ", predict=" + PredictionMode.getUniqueAlt(altSubSets) + ", resolvesToJustOneViableAlt=" + PredictionMode.resolvesToJustOneViableAlt(altSubSets));
      }

      reach.uniqueAlt = this.getUniqueAlt(reach); // unique prediction?

      if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
        predictedAlt = reach.uniqueAlt;
        break;
      } else if (this.predictionMode !== PredictionMode.LL_EXACT_AMBIG_DETECTION) {
        predictedAlt = PredictionMode.resolvesToJustOneViableAlt(altSubSets);

        if (predictedAlt !== ATN.INVALID_ALT_NUMBER) {
          break;
        }
      } else {
        // In exact ambiguity mode, we never try to terminate early.
        // Just keeps scarfing until we know what the conflict is
        if (PredictionMode.allSubsetsConflict(altSubSets) && PredictionMode.allSubsetsEqual(altSubSets)) {
          foundExactAmbig = true;
          predictedAlt = PredictionMode.getSingleViableAlt(altSubSets);
          break;
        } // else there are multiple non-conflicting subsets or
        // we're not sure what the ambiguity is yet.
        // So, keep going.

      }

      previous = reach;

      if (t !== Token.EOF) {
        input.consume();
        t = input.LA(1);
      }
    } // If the configuration set uniquely predicts an alternative,
    // without conflict, then we know that it's a full LL decision
    // not SLL.


    if (reach.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      this.reportContextSensitivity(dfa, predictedAlt, reach, startIndex, input.index);
      return predictedAlt;
    } // We do not check predicates here because we have checked them
    // on-the-fly when doing full context prediction.
    //
    // In non-exact ambiguity detection mode, we might	actually be able to
    // detect an exact ambiguity, but I'm not going to spend the cycles
    // needed to check. We only emit ambiguity warnings in exact ambiguity
    // mode.
    //
    // For example, we might know that we have conflicting configurations.
    // But, that does not mean that there is no way forward without a
    // conflict. It's possible to have nonconflicting alt subsets as in:
    // altSubSets=[{1, 2}, {1, 2}, {1}, {1, 2}]
    // from
    //
    //    [(17,1,[5 $]), (13,1,[5 10 $]), (21,1,[5 10 $]), (11,1,[$]),
    //     (13,2,[5 10 $]), (21,2,[5 10 $]), (11,2,[$])]
    //
    // In this case, (17,1,[5 $]) indicates there is some next sequence that
    // would resolve this without conflict to alternative 1. Any other viable
    // next sequence, however, is associated with a conflict.  We stop
    // looking for input because no amount of further lookahead will alter
    // the fact that we should predict alternative 1.  We just can't say for
    // sure that there is an ambiguity without looking further.


    this.reportAmbiguity(dfa, D, startIndex, input.index, foundExactAmbig, null, reach);
    return predictedAlt;
  }

  computeReachSet(closure, t, fullCtx) {
    if (this.debug) {
      console.log("in computeReachSet, starting closure: " + closure);
    }

    if (this.mergeCache === null) {
      this.mergeCache = new DoubleDict();
    }

    const intermediate = new ATNConfigSet(fullCtx); // Configurations already in a rule stop state indicate reaching the end
    // of the decision rule (local context) or end of the start rule (full
    // context). Once reached, these configurations are never updated by a
    // closure operation, so they are handled separately for the performance
    // advantage of having a smaller intermediate set when calling closure.
    //
    // For full-context reach operations, separate handling is required to
    // ensure that the alternative matching the longest overall sequence is
    // chosen when multiple such configurations can match the input.

    let skippedStopStates = null; // First figure out where we can reach on input t

    for (let i = 0; i < closure.items.length; i++) {
      const c = closure.items[i];

      if (this.debug) {
        console.log("testing " + this.getTokenName(t) + " at " + c);
      }

      if (c.state instanceof RuleStopState) {
        if (fullCtx || t === Token.EOF) {
          if (skippedStopStates === null) {
            skippedStopStates = [];
          }

          skippedStopStates.push(c);

          if (this.debug_add) {
            console.log("added " + c + " to skippedStopStates");
          }
        }

        continue;
      }

      for (let j = 0; j < c.state.transitions.length; j++) {
        const trans = c.state.transitions[j];
        const target = this.getReachableTarget(trans, t);

        if (target !== null) {
          const cfg = new ATNConfig({
            state: target
          }, c);
          intermediate.add(cfg, this.mergeCache);

          if (this.debug_add) {
            console.log("added " + cfg + " to intermediate");
          }
        }
      }
    } // Now figure out where the reach operation can take us...


    let reach = null; // This block optimizes the reach operation for intermediate sets which
    // trivially indicate a termination state for the overall
    // adaptivePredict operation.
    //
    // The conditions assume that intermediate
    // contains all configurations relevant to the reach set, but this
    // condition is not true when one or more configurations have been
    // withheld in skippedStopStates, or when the current symbol is EOF.
    //

    if (skippedStopStates === null && t !== Token.EOF) {
      if (intermediate.items.length === 1) {
        // Don't pursue the closure if there is just one state.
        // It can only have one alternative; just add to result
        // Also don't pursue the closure if there is unique alternative
        // among the configurations.
        reach = intermediate;
      } else if (this.getUniqueAlt(intermediate) !== ATN.INVALID_ALT_NUMBER) {
        // Also don't pursue the closure if there is unique alternative
        // among the configurations.
        reach = intermediate;
      }
    } // If the reach set could not be trivially determined, perform a closure
    // operation on the intermediate set to compute its initial value.
    //


    if (reach === null) {
      reach = new ATNConfigSet(fullCtx);
      const closureBusy = new Set();
      const treatEofAsEpsilon = t === Token.EOF;

      for (let k = 0; k < intermediate.items.length; k++) {
        this.closure(intermediate.items[k], reach, closureBusy, false, fullCtx, treatEofAsEpsilon);
      }
    }

    if (t === Token.EOF) {
      // After consuming EOF no additional input is possible, so we are
      // only interested in configurations which reached the end of the
      // decision rule (local context) or end of the start rule (full
      // context). Update reach to contain only these configurations. This
      // handles both explicit EOF transitions in the grammar and implicit
      // EOF transitions following the end of the decision or start rule.
      //
      // When reach==intermediate, no closure operation was performed. In
      // this case, removeAllConfigsNotInRuleStopState needs to check for
      // reachable rule stop states as well as configurations already in
      // a rule stop state.
      //
      // This is handled before the configurations in skippedStopStates,
      // because any configurations potentially added from that list are
      // already guaranteed to meet this condition whether or not it's
      // required.
      //
      reach = this.removeAllConfigsNotInRuleStopState(reach, reach === intermediate);
    } // If skippedStopStates!==null, then it contains at least one
    // configuration. For full-context reach operations, these
    // configurations reached the end of the start rule, in which case we
    // only add them back to reach if no configuration during the current
    // closure operation reached such a state. This ensures adaptivePredict
    // chooses an alternative matching the longest overall sequence when
    // multiple alternatives are viable.
    //


    if (skippedStopStates !== null && (!fullCtx || !PredictionMode.hasConfigInRuleStopState(reach))) {
      for (let l = 0; l < skippedStopStates.length; l++) {
        reach.add(skippedStopStates[l], this.mergeCache);
      }
    }

    if (reach.items.length === 0) {
      return null;
    } else {
      return reach;
    }
  }
  /**
   * Return a configuration set containing only the configurations from
   * {@code configs} which are in a {@link RuleStopState}. If all
   * configurations in {@code configs} are already in a rule stop state, this
   * method simply returns {@code configs}.
   *
   * <p>When {@code lookToEndOfRule} is true, this method uses
   * {@link ATN//nextTokens} for each configuration in {@code configs} which is
   * not already in a rule stop state to see if a rule stop state is reachable
   * from the configuration via epsilon-only transitions.</p>
   *
   * @param configs the configuration set to update
   * @param lookToEndOfRule when true, this method checks for rule stop states
   * reachable by epsilon-only transitions from each configuration in
   * {@code configs}.
   *
   * @return {@code configs} if all configurations in {@code configs} are in a
   * rule stop state, otherwise return a new configuration set containing only
   * the configurations from {@code configs} which are in a rule stop state
   */


  removeAllConfigsNotInRuleStopState(configs, lookToEndOfRule) {
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
      return configs;
    }

    const result = new ATNConfigSet(configs.fullCtx);

    for (let i = 0; i < configs.items.length; i++) {
      const config = configs.items[i];

      if (config.state instanceof RuleStopState) {
        result.add(config, this.mergeCache);
        continue;
      }

      if (lookToEndOfRule && config.state.epsilonOnlyTransitions) {
        const nextTokens = this.atn.nextTokens(config.state);

        if (nextTokens.contains(Token.EPSILON)) {
          const endOfRuleState = this.atn.ruleToStopState[config.state.ruleIndex];
          result.add(new ATNConfig({
            state: endOfRuleState
          }, config), this.mergeCache);
        }
      }
    }

    return result;
  }

  computeStartState(p, ctx, fullCtx) {
    // always at least the implicit call to start rule
    const initialContext = predictionContextFromRuleContext(this.atn, ctx);
    const configs = new ATNConfigSet(fullCtx);

    for (let i = 0; i < p.transitions.length; i++) {
      const target = p.transitions[i].target;
      const c = new ATNConfig({
        state: target,
        alt: i + 1,
        context: initialContext
      }, null);
      const closureBusy = new Set();
      this.closure(c, configs, closureBusy, true, fullCtx, false);
    }

    return configs;
  }
  /**
   * This method transforms the start state computed by
   * {@link //computeStartState} to the special start state used by a
   * precedence DFA for a particular precedence value. The transformation
   * process applies the following changes to the start state's configuration
   * set.
   *
   * <ol>
   * <li>Evaluate the precedence predicates for each configuration using
   * {@link SemanticContext//evalPrecedence}.</li>
   * <li>Remove all configurations which predict an alternative greater than
   * 1, for which another configuration that predicts alternative 1 is in the
   * same ATN state with the same prediction context. This transformation is
   * valid for the following reasons:
   * <ul>
   * <li>The closure block cannot contain any epsilon transitions which bypass
   * the body of the closure, so all states reachable via alternative 1 are
   * part of the precedence alternatives of the transformed left-recursive
   * rule.</li>
   * <li>The "primary" portion of a left recursive rule cannot contain an
   * epsilon transition, so the only way an alternative other than 1 can exist
   * in a state that is also reachable via alternative 1 is by nesting calls
   * to the left-recursive rule, with the outer calls not being at the
   * preferred precedence level.</li>
   * </ul>
   * </li>
   * </ol>
   *
   * <p>
   * The prediction context must be considered by this filter to address
   * situations like the following.
   * </p>
   * <code>
   * <pre>
   * grammar TA;
   * prog: statement* EOF;
   * statement: letterA | statement letterA 'b' ;
   * letterA: 'a';
   * </pre>
   * </code>
   * <p>
   * If the above grammar, the ATN state immediately before the token
   * reference {@code 'a'} in {@code letterA} is reachable from the left edge
   * of both the primary and closure blocks of the left-recursive rule
   * {@code statement}. The prediction context associated with each of these
   * configurations distinguishes between them, and prevents the alternative
   * which stepped out to {@code prog} (and then back in to {@code statement}
   * from being eliminated by the filter.
   * </p>
   *
   * @param configs The configuration set computed by
   * {@link //computeStartState} as the start state for the DFA.
   * @return The transformed configuration set representing the start state
   * for a precedence DFA at a particular precedence level (determined by
   * calling {@link Parser//getPrecedence})
   */


  applyPrecedenceFilter(configs) {
    let config;
    const statesFromAlt1 = [];
    const configSet = new ATNConfigSet(configs.fullCtx);

    for (let i = 0; i < configs.items.length; i++) {
      config = configs.items[i]; // handle alt 1 first

      if (config.alt !== 1) {
        continue;
      }

      const updatedContext = config.semanticContext.evalPrecedence(this.parser, this._outerContext);

      if (updatedContext === null) {
        // the configuration was eliminated
        continue;
      }

      statesFromAlt1[config.state.stateNumber] = config.context;

      if (updatedContext !== config.semanticContext) {
        configSet.add(new ATNConfig({
          semanticContext: updatedContext
        }, config), this.mergeCache);
      } else {
        configSet.add(config, this.mergeCache);
      }
    }

    for (let i = 0; i < configs.items.length; i++) {
      config = configs.items[i];

      if (config.alt === 1) {
        // already handled
        continue;
      } // In the future, this elimination step could be updated to also
      // filter the prediction context for alternatives predicting alt>1
      // (basically a graph subtraction algorithm).


      if (!config.precedenceFilterSuppressed) {
        const context = statesFromAlt1[config.state.stateNumber] || null;

        if (context !== null && context.equals(config.context)) {
          // eliminated
          continue;
        }
      }

      configSet.add(config, this.mergeCache);
    }

    return configSet;
  }

  getReachableTarget(trans, ttype) {
    if (trans.matches(ttype, 0, this.atn.maxTokenType)) {
      return trans.target;
    } else {
      return null;
    }
  }

  getPredsForAmbigAlts(ambigAlts, configs, nalts) {
    // REACH=[1|1|[]|0:0, 1|2|[]|0:1]
    // altToPred starts as an array of all null contexts. The entry at index i
    // corresponds to alternative i. altToPred[i] may have one of three values:
    //   1. null: no ATNConfig c is found such that c.alt==i
    //   2. SemanticContext.NONE: At least one ATNConfig c exists such that
    //      c.alt==i and c.semanticContext==SemanticContext.NONE. In other words,
    //      alt i has at least one unpredicated config.
    //   3. Non-NONE Semantic Context: There exists at least one, and for all
    //      ATNConfig c such that c.alt==i, c.semanticContext!=SemanticContext.NONE.
    //
    // From this, it is clear that NONE||anything==NONE.
    //
    let altToPred = [];

    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];

      if (ambigAlts.contains(c.alt)) {
        altToPred[c.alt] = SemanticContext.orContext(altToPred[c.alt] || null, c.semanticContext);
      }
    }

    let nPredAlts = 0;

    for (let i = 1; i < nalts + 1; i++) {
      const pred = altToPred[i] || null;

      if (pred === null) {
        altToPred[i] = SemanticContext.NONE;
      } else if (pred !== SemanticContext.NONE) {
        nPredAlts += 1;
      }
    } // nonambig alts are null in altToPred


    if (nPredAlts === 0) {
      altToPred = null;
    }

    if (this.debug) {
      console.log("getPredsForAmbigAlts result " + Utils.arrayToString(altToPred));
    }

    return altToPred;
  }

  getPredicatePredictions(ambigAlts, altToPred) {
    const pairs = [];
    let containsPredicate = false;

    for (let i = 1; i < altToPred.length; i++) {
      const pred = altToPred[i]; // unpredicated is indicated by SemanticContext.NONE

      if (ambigAlts !== null && ambigAlts.contains(i)) {
        pairs.push(new PredPrediction(pred, i));
      }

      if (pred !== SemanticContext.NONE) {
        containsPredicate = true;
      }
    }

    if (!containsPredicate) {
      return null;
    }

    return pairs;
  }
  /**
   * This method is used to improve the localization of error messages by
   * choosing an alternative rather than throwing a
   * {@link NoViableAltException} in particular prediction scenarios where the
   * {@link //ERROR} state was reached during ATN simulation.
   *
   * <p>
   * The default implementation of this method uses the following
   * algorithm to identify an ATN configuration which successfully parsed the
   * decision entry rule. Choosing such an alternative ensures that the
   * {@link ParserRuleContext} returned by the calling rule will be complete
   * and valid, and the syntax error will be reported later at a more
   * localized location.</p>
   *
   * <ul>
   * <li>If a syntactically valid path or paths reach the end of the decision rule and
   * they are semantically valid if predicated, return the min associated alt.</li>
   * <li>Else, if a semantically invalid but syntactically valid path exist
   * or paths exist, return the minimum associated alt.
   * </li>
   * <li>Otherwise, return {@link ATN//INVALID_ALT_NUMBER}.</li>
   * </ul>
   *
   * <p>
   * In some scenarios, the algorithm described above could predict an
   * alternative which will result in a {@link FailedPredicateException} in
   * the parser. Specifically, this could occur if the <em>only</em> configuration
   * capable of successfully parsing to the end of the decision rule is
   * blocked by a semantic predicate. By choosing this alternative within
   * {@link //adaptivePredict} instead of throwing a
   * {@link NoViableAltException}, the resulting
   * {@link FailedPredicateException} in the parser will identify the specific
   * predicate which is preventing the parser from successfully parsing the
   * decision rule, which helps developers identify and correct logic errors
   * in semantic predicates.
   * </p>
   *
   * @param configs The ATN configurations which were valid immediately before
   * the {@link //ERROR} state was reached
   * @param outerContext The is the \gamma_0 initial parser context from the paper
   * or the parser stack at the instant before prediction commences.
   *
   * @return The value to return from {@link //adaptivePredict}, or
   * {@link ATN//INVALID_ALT_NUMBER} if a suitable alternative was not
   * identified and {@link //adaptivePredict} should report an error instead
   */


  getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(configs, outerContext) {
    const cfgs = this.splitAccordingToSemanticValidity(configs, outerContext);
    const semValidConfigs = cfgs[0];
    const semInvalidConfigs = cfgs[1];
    let alt = this.getAltThatFinishedDecisionEntryRule(semValidConfigs);

    if (alt !== ATN.INVALID_ALT_NUMBER) {
      // semantically/syntactically viable path exists
      return alt;
    } // Is there a syntactically valid path with a failed pred?


    if (semInvalidConfigs.items.length > 0) {
      alt = this.getAltThatFinishedDecisionEntryRule(semInvalidConfigs);

      if (alt !== ATN.INVALID_ALT_NUMBER) {
        // syntactically viable path exists
        return alt;
      }
    }

    return ATN.INVALID_ALT_NUMBER;
  }

  getAltThatFinishedDecisionEntryRule(configs) {
    const alts = [];

    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];

      if (c.reachesIntoOuterContext > 0 || c.state instanceof RuleStopState && c.context.hasEmptyPath()) {
        if (alts.indexOf(c.alt) < 0) {
          alts.push(c.alt);
        }
      }
    }

    if (alts.length === 0) {
      return ATN.INVALID_ALT_NUMBER;
    } else {
      return Math.min.apply(null, alts);
    }
  }
  /**
   * Walk the list of configurations and split them according to
   * those that have preds evaluating to true/false.  If no pred, assume
   * true pred and include in succeeded set.  Returns Pair of sets.
   *
   * Create a new set so as not to alter the incoming parameter.
   *
   * Assumption: the input stream has been restored to the starting point
   * prediction, which is where predicates need to evaluate.*/


  splitAccordingToSemanticValidity(configs, outerContext) {
    const succeeded = new ATNConfigSet(configs.fullCtx);
    const failed = new ATNConfigSet(configs.fullCtx);

    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];

      if (c.semanticContext !== SemanticContext.NONE) {
        const predicateEvaluationResult = c.semanticContext.evaluate(this.parser, outerContext);

        if (predicateEvaluationResult) {
          succeeded.add(c);
        } else {
          failed.add(c);
        }
      } else {
        succeeded.add(c);
      }
    }

    return [succeeded, failed];
  }
  /**
   * Look through a list of predicate/alt pairs, returning alts for the
   * pairs that win. A {@code NONE} predicate indicates an alt containing an
   * unpredicated config which behaves as "always true." If !complete
   * then we stop at the first predicate that evaluates to true. This
   * includes pairs with null predicates.
   */


  evalSemanticContext(predPredictions, outerContext, complete) {
    const predictions = new BitSet();

    for (let i = 0; i < predPredictions.length; i++) {
      const pair = predPredictions[i];

      if (pair.pred === SemanticContext.NONE) {
        predictions.add(pair.alt);

        if (!complete) {
          break;
        }

        continue;
      }

      const predicateEvaluationResult = pair.pred.evaluate(this.parser, outerContext);

      if (this.debug || this.dfa_debug) {
        console.log("eval pred " + pair + "=" + predicateEvaluationResult);
      }

      if (predicateEvaluationResult) {
        if (this.debug || this.dfa_debug) {
          console.log("PREDICT " + pair.alt);
        }

        predictions.add(pair.alt);

        if (!complete) {
          break;
        }
      }
    }

    return predictions;
  } // TODO: If we are doing predicates, there is no point in pursuing
  //     closure operations if we reach a DFA state that uniquely predicts
  //     alternative. We will not be caching that DFA state and it is a
  //     waste to pursue the closure. Might have to advance when we do
  //     ambig detection thought :(
  //


  closure(config, configs, closureBusy, collectPredicates, fullCtx, treatEofAsEpsilon) {
    const initialDepth = 0;
    this.closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, initialDepth, treatEofAsEpsilon);
  }

  closureCheckingStopState(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    if (this.debug || this.debug_closure) {
      console.log("closure(" + config.toString(this.parser, true) + ")"); // console.log("configs(" + configs.toString() + ")");

      if (config.reachesIntoOuterContext > 50) {
        throw "problem";
      }
    }

    if (config.state instanceof RuleStopState) {
      // We hit rule end. If we have context info, use it
      // run thru all possible stack tops in ctx
      if (!config.context.isEmpty()) {
        for (let i = 0; i < config.context.length; i++) {
          if (config.context.getReturnState(i) === PredictionContext.EMPTY_RETURN_STATE) {
            if (fullCtx) {
              configs.add(new ATNConfig({
                state: config.state,
                context: PredictionContext.EMPTY
              }, config), this.mergeCache);
              continue;
            } else {
              // we have no context info, just chase follow links (if greedy)
              if (this.debug) {
                console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
              }

              this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
            }

            continue;
          }

          const returnState = this.atn.states[config.context.getReturnState(i)];
          const newContext = config.context.getParent(i); // "pop" return state

          const parms = {
            state: returnState,
            alt: config.alt,
            context: newContext,
            semanticContext: config.semanticContext
          };
          const c = new ATNConfig(parms, null); // While we have context to pop back from, we may have
          // gotten that context AFTER having falling off a rule.
          // Make sure we track that we are now out of context.

          c.reachesIntoOuterContext = config.reachesIntoOuterContext;
          this.closureCheckingStopState(c, configs, closureBusy, collectPredicates, fullCtx, depth - 1, treatEofAsEpsilon);
        }

        return;
      } else if (fullCtx) {
        // reached end of start rule
        configs.add(config, this.mergeCache);
        return;
      } else {
        // else if we have no context info, just chase follow links (if greedy)
        if (this.debug) {
          console.log("FALLING off rule " + this.getRuleName(config.state.ruleIndex));
        }
      }
    }

    this.closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon);
  } // Do the actual work of walking epsilon edges//


  closure_(config, configs, closureBusy, collectPredicates, fullCtx, depth, treatEofAsEpsilon) {
    const p = config.state; // optimization

    if (!p.epsilonOnlyTransitions) {
      configs.add(config, this.mergeCache); // make sure to not return here, because EOF transitions can act as
      // both epsilon transitions and non-epsilon transitions.
    }

    for (let i = 0; i < p.transitions.length; i++) {
      if (i === 0 && this.canDropLoopEntryEdgeInLeftRecursiveRule(config)) continue;
      const t = p.transitions[i];
      const continueCollecting = collectPredicates && !(t instanceof ActionTransition);
      const c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, fullCtx, treatEofAsEpsilon);

      if (c !== null) {
        let newDepth = depth;

        if (config.state instanceof RuleStopState) {
          // target fell off end of rule; mark resulting c as having dipped into outer context
          // We can't get here if incoming config was rule stop and we had context
          // track how far we dip into outer context.  Might
          // come in handy and we avoid evaluating context dependent
          // preds if this is > 0.
          if (this._dfa !== null && this._dfa.precedenceDfa) {
            if (t.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex) {
              c.precedenceFilterSuppressed = true;
            }
          }

          c.reachesIntoOuterContext += 1;

          if (closureBusy.add(c) !== c) {
            // avoid infinite recursion for right-recursive rules
            continue;
          }

          configs.dipsIntoOuterContext = true; // TODO: can remove? only care when we add to set per middle of this method

          newDepth -= 1;

          if (this.debug) {
            console.log("dips into outer ctx: " + c);
          }
        } else {
          if (!t.isEpsilon && closureBusy.add(c) !== c) {
            // avoid infinite recursion for EOF* and EOF+
            continue;
          }

          if (t instanceof RuleTransition) {
            // latch when newDepth goes negative - once we step out of the entry context we can't return
            if (newDepth >= 0) {
              newDepth += 1;
            }
          }
        }

        this.closureCheckingStopState(c, configs, closureBusy, continueCollecting, fullCtx, newDepth, treatEofAsEpsilon);
      }
    }
  }

  canDropLoopEntryEdgeInLeftRecursiveRule(config) {
    // return False
    const p = config.state; // First check to see if we are in StarLoopEntryState generated during
    // left-recursion elimination. For efficiency, also check if
    // the context has an empty stack case. If so, it would mean
    // global FOLLOW so we can't perform optimization
    // Are we the special loop entry/exit state? or SLL wildcard

    if (p.stateType !== ATNState.STAR_LOOP_ENTRY) return false;
    if (p.stateType !== ATNState.STAR_LOOP_ENTRY || !p.isPrecedenceDecision || config.context.isEmpty() || config.context.hasEmptyPath()) return false; // Require all return states to return back to the same rule that p is in.

    const numCtxs = config.context.length;

    for (let i = 0; i < numCtxs; i++) {
      // for each stack context
      const returnState = this.atn.states[config.context.getReturnState(i)];
      if (returnState.ruleIndex !== p.ruleIndex) return false;
    }

    const decisionStartState = p.transitions[0].target;
    const blockEndStateNum = decisionStartState.endState.stateNumber;
    const blockEndState = this.atn.states[blockEndStateNum]; // Verify that the top of each stack context leads to loop entry/exit
    // state through epsilon edges and w/o leaving rule.

    for (let i = 0; i < numCtxs; i++) {
      // for each stack context
      const returnStateNumber = config.context.getReturnState(i);
      const returnState = this.atn.states[returnStateNumber]; // all states must have single outgoing epsilon edge

      if (returnState.transitions.length !== 1 || !returnState.transitions[0].isEpsilon) return false; // Look for prefix op case like 'not expr', (' type ')' expr

      const returnStateTarget = returnState.transitions[0].target;
      if (returnState.stateType === ATNState.BLOCK_END && returnStateTarget === p) continue; // Look for 'expr op expr' or case where expr's return state is block end
      // of (...)* internal block; the block end points to loop back
      // which points to p but we don't need to check that

      if (returnState === blockEndState) continue; // Look for ternary expr ? expr : expr. The return state points at block end,
      // which points at loop entry state

      if (returnStateTarget === blockEndState) continue; // Look for complex prefix 'between expr and expr' case where 2nd expr's
      // return state points at block end state of (...)* internal block

      if (returnStateTarget.stateType === ATNState.BLOCK_END && returnStateTarget.transitions.length === 1 && returnStateTarget.transitions[0].isEpsilon && returnStateTarget.transitions[0].target === p) continue; // anything else ain't conforming

      return false;
    }

    return true;
  }

  getRuleName(index) {
    if (this.parser !== null && index >= 0) {
      return this.parser.ruleNames[index];
    } else {
      return "<rule " + index + ">";
    }
  }

  getEpsilonTarget(config, t, collectPredicates, inContext, fullCtx, treatEofAsEpsilon) {
    switch (t.serializationType) {
      case Transition.RULE:
        return this.ruleTransition(config, t);

      case Transition.PRECEDENCE:
        return this.precedenceTransition(config, t, collectPredicates, inContext, fullCtx);

      case Transition.PREDICATE:
        return this.predTransition(config, t, collectPredicates, inContext, fullCtx);

      case Transition.ACTION:
        return this.actionTransition(config, t);

      case Transition.EPSILON:
        return new ATNConfig({
          state: t.target
        }, config);

      case Transition.ATOM:
      case Transition.RANGE:
      case Transition.SET:
        // EOF transitions act like epsilon transitions after the first EOF
        // transition is traversed
        if (treatEofAsEpsilon) {
          if (t.matches(Token.EOF, 0, 1)) {
            return new ATNConfig({
              state: t.target
            }, config);
          }
        }

        return null;

      default:
        return null;
    }
  }

  actionTransition(config, t) {
    if (this.debug) {
      const index = t.actionIndex === -1 ? 65535 : t.actionIndex;
      console.log("ACTION edge " + t.ruleIndex + ":" + index);
    }

    return new ATNConfig({
      state: t.target
    }, config);
  }

  precedenceTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.precedence + ">=_p, ctx dependent=true");

      if (this.parser !== null) {
        console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
      }
    }

    let c = null;

    if (collectPredicates && inContext) {
      if (fullCtx) {
        // In full context mode, we can evaluate predicates on-the-fly
        // during closure, which dramatically reduces the size of
        // the config sets. It also obviates the need to test predicates
        // later during conflict resolution.
        const currentPosition = this._input.index;

        this._input.seek(this._startIndex);

        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);

        this._input.seek(currentPosition);

        if (predSucceeds) {
          c = new ATNConfig({
            state: pt.target
          }, config); // no pred context
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = new ATNConfig({
          state: pt.target,
          semanticContext: newSemCtx
        }, config);
      }
    } else {
      c = new ATNConfig({
        state: pt.target
      }, config);
    }

    if (this.debug) {
      console.log("config from pred transition=" + c);
    }

    return c;
  }

  predTransition(config, pt, collectPredicates, inContext, fullCtx) {
    if (this.debug) {
      console.log("PRED (collectPredicates=" + collectPredicates + ") " + pt.ruleIndex + ":" + pt.predIndex + ", ctx dependent=" + pt.isCtxDependent);

      if (this.parser !== null) {
        console.log("context surrounding pred is " + Utils.arrayToString(this.parser.getRuleInvocationStack()));
      }
    }

    let c = null;

    if (collectPredicates && (pt.isCtxDependent && inContext || !pt.isCtxDependent)) {
      if (fullCtx) {
        // In full context mode, we can evaluate predicates on-the-fly
        // during closure, which dramatically reduces the size of
        // the config sets. It also obviates the need to test predicates
        // later during conflict resolution.
        const currentPosition = this._input.index;

        this._input.seek(this._startIndex);

        const predSucceeds = pt.getPredicate().evaluate(this.parser, this._outerContext);

        this._input.seek(currentPosition);

        if (predSucceeds) {
          c = new ATNConfig({
            state: pt.target
          }, config); // no pred context
        }
      } else {
        const newSemCtx = SemanticContext.andContext(config.semanticContext, pt.getPredicate());
        c = new ATNConfig({
          state: pt.target,
          semanticContext: newSemCtx
        }, config);
      }
    } else {
      c = new ATNConfig({
        state: pt.target
      }, config);
    }

    if (this.debug) {
      console.log("config from pred transition=" + c);
    }

    return c;
  }

  ruleTransition(config, t) {
    if (this.debug) {
      console.log("CALL rule " + this.getRuleName(t.target.ruleIndex) + ", ctx=" + config.context);
    }

    const returnState = t.followState;
    const newContext = SingletonPredictionContext.create(config.context, returnState.stateNumber);
    return new ATNConfig({
      state: t.target,
      context: newContext
    }, config);
  }

  getConflictingAlts(configs) {
    const altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.getAlts(altsets);
  }
  /**
   * Sam pointed out a problem with the previous definition, v3, of
   * ambiguous states. If we have another state associated with conflicting
   * alternatives, we should keep going. For example, the following grammar
   *
   * s : (ID | ID ID?) ';' ;
   *
   * When the ATN simulation reaches the state before ';', it has a DFA
   * state that looks like: [12|1|[], 6|2|[], 12|2|[]]. Naturally
   * 12|1|[] and 12|2|[] conflict, but we cannot stop processing this node
   * because alternative to has another way to continue, via [6|2|[]].
   * The key is that we have a single state that has config's only associated
   * with a single alternative, 2, and crucially the state transitions
   * among the configurations are all non-epsilon transitions. That means
   * we don't consider any conflicts that include alternative 2. So, we
   * ignore the conflict between alts 1 and 2. We ignore a set of
   * conflicting alts when there is an intersection with an alternative
   * associated with a single alt state in the state&rarr;config-list map.
   *
   * It's also the case that we might have two conflicting configurations but
   * also a 3rd nonconflicting configuration for a different alternative:
   * [1|1|[], 1|2|[], 8|3|[]]. This can come about from grammar:
   *
   * a : A | A | A B ;
   *
   * After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not
   * stop working on this state. In the previous example, we're concerned
   * with states associated with the conflicting alternatives. Here alt
   * 3 is not associated with the conflicting configs, but since we can continue
   * looking for input reasonably, I don't declare the state done. We
   * ignore a set of conflicting alts when we have an alternative
   * that we still need to pursue
   */


  getConflictingAltsOrUniqueAlt(configs) {
    let conflictingAlts = null;

    if (configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {
      conflictingAlts = new BitSet();
      conflictingAlts.add(configs.uniqueAlt);
    } else {
      conflictingAlts = configs.conflictingAlts;
    }

    return conflictingAlts;
  }

  getTokenName(t) {
    if (t === Token.EOF) {
      return "EOF";
    }

    if (this.parser !== null && this.parser.literalNames !== null) {
      if (t >= this.parser.literalNames.length && t >= this.parser.symbolicNames.length) {
        console.log("" + t + " ttype out of range: " + this.parser.literalNames);
        console.log("" + this.parser.getInputStream().getTokens());
      } else {
        const name = this.parser.literalNames[t] || this.parser.symbolicNames[t];
        return name + "<" + t + ">";
      }
    }

    return "" + t;
  }

  getLookaheadName(input) {
    return this.getTokenName(input.LA(1));
  }
  /**
   * Used for debugging in adaptivePredict around execATN but I cut
   * it out for clarity now that alg. works well. We can leave this
   * "dead" code for a bit
   */


  dumpDeadEndConfigs(nvae) {
    console.log("dead end configs: ");
    const decs = nvae.getDeadEndConfigs();

    for (let i = 0; i < decs.length; i++) {
      const c = decs[i];
      let trans = "no edges";

      if (c.state.transitions.length > 0) {
        const t = c.state.transitions[0];

        if (t instanceof AtomTransition) {
          trans = "Atom " + this.getTokenName(t.label);
        } else if (t instanceof SetTransition) {
          const neg = t instanceof NotSetTransition;
          trans = (neg ? "~" : "") + "Set " + t.set;
        }
      }

      console.error(c.toString(this.parser, true) + ":" + trans);
    }
  }

  noViableAlt(input, outerContext, configs, startIndex) {
    return new NoViableAltException(this.parser, input, input.get(startIndex), input.LT(1), configs, outerContext);
  }

  getUniqueAlt(configs) {
    let alt = ATN.INVALID_ALT_NUMBER;

    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];

      if (alt === ATN.INVALID_ALT_NUMBER) {
        alt = c.alt; // found first alt
      } else if (c.alt !== alt) {
        return ATN.INVALID_ALT_NUMBER;
      }
    }

    return alt;
  }
  /**
   * Add an edge to the DFA, if possible. This method calls
   * {@link //addDFAState} to ensure the {@code to} state is present in the
   * DFA. If {@code from} is {@code null}, or if {@code t} is outside the
   * range of edges that can be represented in the DFA tables, this method
   * returns without adding the edge to the DFA.
   *
   * <p>If {@code to} is {@code null}, this method returns {@code null}.
   * Otherwise, this method returns the {@link DFAState} returned by calling
   * {@link //addDFAState} for the {@code to} state.</p>
   *
   * @param dfa The DFA
   * @param from_ The source state for the edge
   * @param t The input symbol
   * @param to The target state for the edge
   *
   * @return If {@code to} is {@code null}, this method returns {@code null};
   * otherwise this method returns the result of calling {@link //addDFAState}
   * on {@code to}
   */


  addDFAEdge(dfa, from_, t, to) {
    if (this.debug) {
      console.log("EDGE " + from_ + " -> " + to + " upon " + this.getTokenName(t));
    }

    if (to === null) {
      return null;
    }

    to = this.addDFAState(dfa, to); // used existing if possible not incoming

    if (from_ === null || t < -1 || t > this.atn.maxTokenType) {
      return to;
    }

    if (from_.edges === null) {
      from_.edges = [];
    }

    from_.edges[t + 1] = to; // connect

    if (this.debug) {
      const literalNames = this.parser === null ? null : this.parser.literalNames;
      const symbolicNames = this.parser === null ? null : this.parser.symbolicNames;
      console.log("DFA=\n" + dfa.toString(literalNames, symbolicNames));
    }

    return to;
  }
  /**
   * Add state {@code D} to the DFA if it is not already present, and return
   * the actual instance stored in the DFA. If a state equivalent to {@code D}
   * is already in the DFA, the existing state is returned. Otherwise this
   * method returns {@code D} after adding it to the DFA.
   *
   * <p>If {@code D} is {@link //ERROR}, this method returns {@link //ERROR} and
   * does not change the DFA.</p>
   *
   * @param dfa The dfa
   * @param D The DFA state to add
   * @return The state stored in the DFA. This will be either the existing
   * state if {@code D} is already in the DFA, or {@code D} itself if the
   * state was not already present
   */


  addDFAState(dfa, D) {
    if (D === ATNSimulator.ERROR) {
      return D;
    }

    const existing = dfa.states.get(D);

    if (existing !== null) {
      return existing;
    }

    D.stateNumber = dfa.states.length;

    if (!D.configs.readOnly) {
      D.configs.optimizeConfigs(this);
      D.configs.setReadonly(true);
    }

    dfa.states.add(D);

    if (this.debug) {
      console.log("adding new DFA state: " + D);
    }

    return D;
  }

  reportAttemptingFullContext(dfa, conflictingAlts, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAttemptingFullContext decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }

    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, dfa, startIndex, stopIndex, conflictingAlts, configs);
    }
  }

  reportContextSensitivity(dfa, prediction, configs, startIndex, stopIndex) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportContextSensitivity decision=" + dfa.decision + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }

    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, dfa, startIndex, stopIndex, prediction, configs);
    }
  } // If context sensitive parsing, we know it's ambiguity not conflict//


  reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.debug || this.retry_debug) {
      const interval = new Interval(startIndex, stopIndex + 1);
      console.log("reportAmbiguity " + ambigAlts + ":" + configs + ", input=" + this.parser.getTokenStream().getText(interval));
    }

    if (this.parser !== null) {
      this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);
    }
  }

}

module.exports = ParserATNSimulator;

/***/ }),
/* 37 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Map,
  BitSet,
  AltDict,
  hashStuff
} = __webpack_require__(11);

const ATN = __webpack_require__(9);

const {
  RuleStopState
} = __webpack_require__(14);

const {
  ATNConfigSet
} = __webpack_require__(34);

const {
  ATNConfig
} = __webpack_require__(13);

const {
  SemanticContext
} = __webpack_require__(15);
/**
 * This enumeration defines the prediction modes available in ANTLR 4 along with
 * utility methods for analyzing configuration sets for conflicts and/or
 * ambiguities.
 */


const PredictionMode = {
  /**
   * The SLL(*) prediction mode. This prediction mode ignores the current
   * parser context when making predictions. This is the fastest prediction
   * mode, and provides correct results for many grammars. This prediction
   * mode is more powerful than the prediction mode provided by ANTLR 3, but
   * may result in syntax errors for grammar and input combinations which are
   * not SLL.
   *
   * <p>
   * When using this prediction mode, the parser will either return a correct
   * parse tree (i.e. the same parse tree that would be returned with the
   * {@link //LL} prediction mode), or it will report a syntax error. If a
   * syntax error is encountered when using the {@link //SLL} prediction mode,
   * it may be due to either an actual syntax error in the input or indicate
   * that the particular combination of grammar and input requires the more
   * powerful {@link //LL} prediction abilities to complete successfully.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  SLL: 0,

  /**
   * The LL(*) prediction mode. This prediction mode allows the current parser
   * context to be used for resolving SLL conflicts that occur during
   * prediction. This is the fastest prediction mode that guarantees correct
   * parse results for all combinations of grammars with syntactically correct
   * inputs.
   *
   * <p>
   * When using this prediction mode, the parser will make correct decisions
   * for all syntactically-correct grammar and input combinations. However, in
   * cases where the grammar is truly ambiguous this prediction mode might not
   * report a precise answer for <em>exactly which</em> alternatives are
   * ambiguous.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL: 1,

  /**
   *
   * The LL(*) prediction mode with exact ambiguity detection. In addition to
   * the correctness guarantees provided by the {@link //LL} prediction mode,
   * this prediction mode instructs the prediction algorithm to determine the
   * complete and exact set of ambiguous alternatives for every ambiguous
   * decision encountered while parsing.
   *
   * <p>
   * This prediction mode may be used for diagnosing ambiguities during
   * grammar development. Due to the performance overhead of calculating sets
   * of ambiguous alternatives, this prediction mode should be avoided when
   * the exact results are not necessary.</p>
   *
   * <p>
   * This prediction mode does not provide any guarantees for prediction
   * behavior for syntactically-incorrect inputs.</p>
   */
  LL_EXACT_AMBIG_DETECTION: 2,

  /**
   *
   * Computes the SLL prediction termination condition.
   *
   * <p>
   * This method computes the SLL prediction termination condition for both of
   * the following cases.</p>
   *
   * <ul>
   * <li>The usual SLL+LL fallback upon SLL conflict</li>
   * <li>Pure SLL without LL fallback</li>
   * </ul>
   *
   * <p><strong>COMBINED SLL+LL PARSING</strong></p>
   *
   * <p>When LL-fallback is enabled upon SLL conflict, correct predictions are
   * ensured regardless of how the termination condition is computed by this
   * method. Due to the substantially higher cost of LL prediction, the
   * prediction should only fall back to LL when the additional lookahead
   * cannot lead to a unique SLL prediction.</p>
   *
   * <p>Assuming combined SLL+LL parsing, an SLL configuration set with only
   * conflicting subsets should fall back to full LL, even if the
   * configuration sets don't resolve to the same alternative (e.g.
   * {@code {1,2}} and {@code {3,4}}. If there is at least one non-conflicting
   * configuration, SLL could continue with the hopes that more lookahead will
   * resolve via one of those non-conflicting configurations.</p>
   *
   * <p>Here's the prediction termination rule them: SLL (for SLL+LL parsing)
   * stops when it sees only conflicting configuration subsets. In contrast,
   * full LL keeps going when there is uncertainty.</p>
   *
   * <p><strong>HEURISTIC</strong></p>
   *
   * <p>As a heuristic, we stop prediction when we see any conflicting subset
   * unless we see a state that only has one alternative associated with it.
   * The single-alt-state thing lets prediction continue upon rules like
   * (otherwise, it would admit defeat too soon):</p>
   *
   * <p>{@code [12|1|[], 6|2|[], 12|2|[]]. s : (ID | ID ID?) ';' ;}</p>
   *
   * <p>When the ATN simulation reaches the state before {@code ';'}, it has a
   * DFA state that looks like: {@code [12|1|[], 6|2|[], 12|2|[]]}. Naturally
   * {@code 12|1|[]} and {@code 12|2|[]} conflict, but we cannot stop
   * processing this node because alternative to has another way to continue,
   * via {@code [6|2|[]]}.</p>
   *
   * <p>It also let's us continue for this rule:</p>
   *
   * <p>{@code [1|1|[], 1|2|[], 8|3|[]] a : A | A | A B ;}</p>
   *
   * <p>After matching input A, we reach the stop state for rule A, state 1.
   * State 8 is the state right before B. Clearly alternatives 1 and 2
   * conflict and no amount of further lookahead will separate the two.
   * However, alternative 3 will be able to continue and so we do not stop
   * working on this state. In the previous example, we're concerned with
   * states associated with the conflicting alternatives. Here alt 3 is not
   * associated with the conflicting configs, but since we can continue
   * looking for input reasonably, don't declare the state done.</p>
   *
   * <p><strong>PURE SLL PARSING</strong></p>
   *
   * <p>To handle pure SLL parsing, all we have to do is make sure that we
   * combine stack contexts for configurations that differ only by semantic
   * predicate. From there, we can do the usual SLL termination heuristic.</p>
   *
   * <p><strong>PREDICATES IN SLL+LL PARSING</strong></p>
   *
   * <p>SLL decisions don't evaluate predicates until after they reach DFA stop
   * states because they need to create the DFA cache that works in all
   * semantic situations. In contrast, full LL evaluates predicates collected
   * during start state computation so it can ignore predicates thereafter.
   * This means that SLL termination detection can totally ignore semantic
   * predicates.</p>
   *
   * <p>Implementation-wise, {@link ATNConfigSet} combines stack contexts but not
   * semantic predicate contexts so we might see two configurations like the
   * following.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p})}</p>
   *
   * <p>Before testing these configurations against others, we have to merge
   * {@code x} and {@code x'} (without modifying the existing configurations).
   * For example, we test {@code (x+x')==x''} when looking for conflicts in
   * the following configurations.</p>
   *
   * <p>{@code (s, 1, x, {}), (s, 1, x', {p}), (s, 2, x'', {})}</p>
   *
   * <p>If the configuration set has predicates (as indicated by
   * {@link ATNConfigSet//hasSemanticContext}), this algorithm makes a copy of
   * the configurations to strip out all of the predicates so that a standard
   * {@link ATNConfigSet} will merge everything ignoring predicates.</p>
   */
  hasSLLConflictTerminatingPrediction: function (mode, configs) {
    // Configs in rule stop states indicate reaching the end of the decision
    // rule (local context) or end of start rule (full context). If all
    // configs meet this condition, then none of the configurations is able
    // to match additional input so we terminate prediction.
    //
    if (PredictionMode.allConfigsInRuleStopStates(configs)) {
      return true;
    } // pure SLL mode parsing


    if (mode === PredictionMode.SLL) {
      // Don't bother with combining configs from different semantic
      // contexts if we can fail over to full LL; costs more time
      // since we'll often fail over anyway.
      if (configs.hasSemanticContext) {
        // dup configs, tossing out semantic predicates
        const dup = new ATNConfigSet();

        for (let i = 0; i < configs.items.length; i++) {
          let c = configs.items[i];
          c = new ATNConfig({
            semanticContext: SemanticContext.NONE
          }, c);
          dup.add(c);
        }

        configs = dup;
      } // now we have combined contexts for configs with dissimilar preds

    } // pure SLL or combined SLL+LL mode parsing


    const altsets = PredictionMode.getConflictingAltSubsets(configs);
    return PredictionMode.hasConflictingAltSet(altsets) && !PredictionMode.hasStateAssociatedWithOneAlt(configs);
  },

  /**
   * Checks if any configuration in {@code configs} is in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if any configuration in {@code configs} is in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  hasConfigInRuleStopState: function (configs) {
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];

      if (c.state instanceof RuleStopState) {
        return true;
      }
    }

    return false;
  },

  /**
   * Checks if all configurations in {@code configs} are in a
   * {@link RuleStopState}. Configurations meeting this condition have reached
   * the end of the decision rule (local context) or end of start rule (full
   * context).
   *
   * @param configs the configuration set to test
   * @return {@code true} if all configurations in {@code configs} are in a
   * {@link RuleStopState}, otherwise {@code false}
   */
  allConfigsInRuleStopStates: function (configs) {
    for (let i = 0; i < configs.items.length; i++) {
      const c = configs.items[i];

      if (!(c.state instanceof RuleStopState)) {
        return false;
      }
    }

    return true;
  },

  /**
   *
   * Full LL prediction termination.
   *
   * <p>Can we stop looking ahead during ATN simulation or is there some
   * uncertainty as to which alternative we will ultimately pick, after
   * consuming more input? Even if there are partial conflicts, we might know
   * that everything is going to resolve to the same minimum alternative. That
   * means we can stop since no more lookahead will change that fact. On the
   * other hand, there might be multiple conflicts that resolve to different
   * minimums. That means we need more look ahead to decide which of those
   * alternatives we should predict.</p>
   *
   * <p>The basic idea is to split the set of configurations {@code C}, into
   * conflicting subsets {@code (s, _, ctx, _)} and singleton subsets with
   * non-conflicting configurations. Two configurations conflict if they have
   * identical {@link ATNConfig//state} and {@link ATNConfig//context} values
   * but different {@link ATNConfig//alt} value, e.g. {@code (s, i, ctx, _)}
   * and {@code (s, j, ctx, _)} for {@code i!=j}.</p>
   *
   * <p>Reduce these configuration subsets to the set of possible alternatives.
   * You can compute the alternative subsets in one pass as follows:</p>
   *
   * <p>{@code A_s,ctx = {i | (s, i, ctx, _)}} for each configuration in
   * {@code C} holding {@code s} and {@code ctx} fixed.</p>
   *
   * <p>Or in pseudo-code, for each configuration {@code c} in {@code C}:</p>
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   *
   * <p>The values in {@code map} are the set of {@code A_s,ctx} sets.</p>
   *
   * <p>If {@code |A_s,ctx|=1} then there is no conflict associated with
   * {@code s} and {@code ctx}.</p>
   *
   * <p>Reduce the subsets to singletons by choosing a minimum of each subset. If
   * the union of these alternative subsets is a singleton, then no amount of
   * more lookahead will help us. We will always pick that alternative. If,
   * however, there is more than one alternative, then we are uncertain which
   * alternative to predict and must continue looking for resolution. We may
   * or may not discover an ambiguity in the future, even if there are no
   * conflicting subsets this round.</p>
   *
   * <p>The biggest sin is to terminate early because it means we've made a
   * decision but were uncertain as to the eventual outcome. We haven't used
   * enough lookahead. On the other hand, announcing a conflict too late is no
   * big deal; you will still have the conflict. It's just inefficient. It
   * might even look until the end of file.</p>
   *
   * <p>No special consideration for semantic predicates is required because
   * predicates are evaluated on-the-fly for full LL prediction, ensuring that
   * no configuration contains a semantic context during the termination
   * check.</p>
   *
   * <p><strong>CONFLICTING CONFIGS</strong></p>
   *
   * <p>Two configurations {@code (s, i, x)} and {@code (s, j, x')}, conflict
   * when {@code i!=j} but {@code x=x'}. Because we merge all
   * {@code (s, i, _)} configurations together, that means that there are at
   * most {@code n} configurations associated with state {@code s} for
   * {@code n} possible alternatives in the decision. The merged stacks
   * complicate the comparison of configuration contexts {@code x} and
   * {@code x'}. Sam checks to see if one is a subset of the other by calling
   * merge and checking to see if the merged result is either {@code x} or
   * {@code x'}. If the {@code x} associated with lowest alternative {@code i}
   * is the superset, then {@code i} is the only possible prediction since the
   * others resolve to {@code min(i)} as well. However, if {@code x} is
   * associated with {@code j>i} then at least one stack configuration for
   * {@code j} is not in conflict with alternative {@code i}. The algorithm
   * should keep going, looking for more lookahead due to the uncertainty.</p>
   *
   * <p>For simplicity, I'm doing a equality check between {@code x} and
   * {@code x'} that lets the algorithm continue to consume lookahead longer
   * than necessary. The reason I like the equality is of course the
   * simplicity but also because that is the test you need to detect the
   * alternatives that are actually in conflict.</p>
   *
   * <p><strong>CONTINUE/STOP RULE</strong></p>
   *
   * <p>Continue if union of resolved alternative sets from non-conflicting and
   * conflicting alternative subsets has more than one alternative. We are
   * uncertain about which alternative to predict.</p>
   *
   * <p>The complete set of alternatives, {@code [i for (_,i,_)]}, tells us which
   * alternatives are still in the running for the amount of input we've
   * consumed at this point. The conflicting sets let us to strip away
   * configurations that won't lead to more states because we resolve
   * conflicts to the configuration with a minimum alternate for the
   * conflicting set.</p>
   *
   * <p><strong>CASES</strong></p>
   *
   * <ul>
   *
   * <li>no conflicts and more than 1 alternative in set =&gt; continue</li>
   *
   * <li> {@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s, 3, z)},
   * {@code (s', 1, y)}, {@code (s', 2, y)} yields non-conflicting set
   * {@code {3}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1,3}} =&gt; continue
   * </li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)}, {@code (s'', 1, z)} yields non-conflicting set
   * {@code {1}} U conflicting sets {@code min({1,2})} U {@code min({1,2})} =
   * {@code {1}} =&gt; stop and predict 1</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 1, y)},
   * {@code (s', 2, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {1}} = {@code {1}} =&gt; stop and predict 1, can announce
   * ambiguity {@code {1,2}}</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 2, y)},
   * {@code (s', 3, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {2}} = {@code {1,2}} =&gt; continue</li>
   *
   * <li>{@code (s, 1, x)}, {@code (s, 2, x)}, {@code (s', 3, y)},
   * {@code (s', 4, y)} yields conflicting, reduced sets {@code {1}} U
   * {@code {3}} = {@code {1,3}} =&gt; continue</li>
   *
   * </ul>
   *
   * <p><strong>EXACT AMBIGUITY DETECTION</strong></p>
   *
   * <p>If all states report the same conflicting set of alternatives, then we
   * know we have the exact ambiguity set.</p>
   *
   * <p><code>|A_<em>i</em>|&gt;1</code> and
   * <code>A_<em>i</em> = A_<em>j</em></code> for all <em>i</em>, <em>j</em>.</p>
   *
   * <p>In other words, we continue examining lookahead until all {@code A_i}
   * have more than one alternative and all {@code A_i} are the same. If
   * {@code A={{1,2}, {1,3}}}, then regular LL prediction would terminate
   * because the resolved set is {@code {1}}. To determine what the real
   * ambiguity is, we have to know whether the ambiguity is between one and
   * two or one and three so we keep going. We can only stop prediction when
   * we need exact ambiguity detection when the sets look like
   * {@code A={{1,2}}} or {@code {{1,2},{1,2}}}, etc...</p>
   */
  resolvesToJustOneViableAlt: function (altsets) {
    return PredictionMode.getSingleViableAlt(altsets);
  },

  /**
   * Determines if every alternative subset in {@code altsets} contains more
   * than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every {@link BitSet} in {@code altsets} has
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  allSubsetsConflict: function (altsets) {
    return !PredictionMode.hasNonConflictingAltSet(altsets);
  },

  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * exactly one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} 1, otherwise {@code false}
   */
  hasNonConflictingAltSet: function (altsets) {
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];

      if (alts.length === 1) {
        return true;
      }
    }

    return false;
  },

  /**
   * Determines if any single alternative subset in {@code altsets} contains
   * more than one alternative.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if {@code altsets} contains a {@link BitSet} with
   * {@link BitSet//cardinality cardinality} &gt; 1, otherwise {@code false}
   */
  hasConflictingAltSet: function (altsets) {
    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];

      if (alts.length > 1) {
        return true;
      }
    }

    return false;
  },

  /**
   * Determines if every alternative subset in {@code altsets} is equivalent.
   *
   * @param altsets a collection of alternative subsets
   * @return {@code true} if every member of {@code altsets} is equal to the
   * others, otherwise {@code false}
   */
  allSubsetsEqual: function (altsets) {
    let first = null;

    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];

      if (first === null) {
        first = alts;
      } else if (alts !== first) {
        return false;
      }
    }

    return true;
  },

  /**
   * Returns the unique alternative predicted by all alternative subsets in
   * {@code altsets}. If no such alternative exists, this method returns
   * {@link ATN//INVALID_ALT_NUMBER}.
   *
   * @param altsets a collection of alternative subsets
   */
  getUniqueAlt: function (altsets) {
    const all = PredictionMode.getAlts(altsets);

    if (all.length === 1) {
      return all.minValue();
    } else {
      return ATN.INVALID_ALT_NUMBER;
    }
  },

  /**
   * Gets the complete set of represented alternatives for a collection of
   * alternative subsets. This method returns the union of each {@link BitSet}
   * in {@code altsets}.
   *
   * @param altsets a collection of alternative subsets
   * @return the set of represented alternatives in {@code altsets}
   */
  getAlts: function (altsets) {
    const all = new BitSet();
    altsets.map(function (alts) {
      all.or(alts);
    });
    return all;
  },

  /**
   * This function gets the conflicting alt subsets from a configuration set.
   * For each configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c] U= c.{@link ATNConfig//alt alt} // map hash/equals uses s and x, not
   * alt and not pred
   * </pre>
   */
  getConflictingAltSubsets: function (configs) {
    const configToAlts = new Map();

    configToAlts.hashFunction = function (cfg) {
      hashStuff(cfg.state.stateNumber, cfg.context);
    };

    configToAlts.equalsFunction = function (c1, c2) {
      return c1.state.stateNumber === c2.state.stateNumber && c1.context.equals(c2.context);
    };

    configs.items.map(function (cfg) {
      let alts = configToAlts.get(cfg);

      if (alts === null) {
        alts = new BitSet();
        configToAlts.put(cfg, alts);
      }

      alts.add(cfg.alt);
    });
    return configToAlts.getValues();
  },

  /**
   * Get a map from state to alt subset from a configuration set. For each
   * configuration {@code c} in {@code configs}:
   *
   * <pre>
   * map[c.{@link ATNConfig//state state}] U= c.{@link ATNConfig//alt alt}
   * </pre>
   */
  getStateToAltMap: function (configs) {
    const m = new AltDict();
    configs.items.map(function (c) {
      let alts = m.get(c.state);

      if (alts === null) {
        alts = new BitSet();
        m.put(c.state, alts);
      }

      alts.add(c.alt);
    });
    return m;
  },
  hasStateAssociatedWithOneAlt: function (configs) {
    const values = PredictionMode.getStateToAltMap(configs).values();

    for (let i = 0; i < values.length; i++) {
      if (values[i].length === 1) {
        return true;
      }
    }

    return false;
  },
  getSingleViableAlt: function (altsets) {
    let result = null;

    for (let i = 0; i < altsets.length; i++) {
      const alts = altsets[i];
      const minAlt = alts.minValue();

      if (result === null) {
        result = minAlt;
      } else if (result !== minAlt) {
        // more than 1 viable alt
        return ATN.INVALID_ALT_NUMBER;
      }
    }

    return result;
  }
};
module.exports = PredictionMode;

/***/ }),
/* 38 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const RuleContext = __webpack_require__(19);

const Tree = __webpack_require__(20);

const INVALID_INTERVAL = Tree.INVALID_INTERVAL;
const TerminalNode = Tree.TerminalNode;
const TerminalNodeImpl = Tree.TerminalNodeImpl;
const ErrorNodeImpl = Tree.ErrorNodeImpl;

const Interval = (__webpack_require__(16).Interval);
/**
 * A rule invocation record for parsing.
 *
 *  Contains all of the information about the current rule not stored in the
 *  RuleContext. It handles parse tree children list, Any ATN state
 *  tracing, and the default values available for rule indications:
 *  start, stop, rule index, current alt number, current
 *  ATN state.
 *
 *  Subclasses made for each rule and grammar track the parameters,
 *  return values, locals, and labels specific to that rule. These
 *  are the objects that are returned from rules.
 *
 *  Note text is not an actual field of a rule return value; it is computed
 *  from start and stop using the input stream's toString() method.  I
 *  could add a ctor to this so that we can pass in and store the input
 *  stream, but I'm not sure we want to do that.  It would seem to be undefined
 *  to get the .text property anyway if the rule matches tokens from multiple
 *  input streams.
 *
 *  I do not use getters for fields of objects that are used simply to
 *  group values such as this aggregate.  The getters/setters are there to
 *  satisfy the superclass interface.
 */


class ParserRuleContext extends RuleContext {
  constructor(parent, invokingStateNumber) {
    parent = parent || null;
    invokingStateNumber = invokingStateNumber || null;
    super(parent, invokingStateNumber);
    this.ruleIndex = -1;
    /**
     * If we are debugging or building a parse tree for a visitor,
     * we need to track all of the tokens and rule invocations associated
     * with this rule's context. This is empty for parsing w/o tree constr.
     * operation because we don't the need to track the details about
     * how we parse this rule.
     */

    this.children = null;
    this.start = null;
    this.stop = null;
    /**
     * The exception that forced this rule to return. If the rule successfully
     * completed, this is {@code null}.
     */

    this.exception = null;
  } // COPY a ctx (I'm deliberately not using copy constructor)


  copyFrom(ctx) {
    // from RuleContext
    this.parentCtx = ctx.parentCtx;
    this.invokingState = ctx.invokingState;
    this.children = null;
    this.start = ctx.start;
    this.stop = ctx.stop; // copy any error nodes to alt label node

    if (ctx.children) {
      this.children = []; // reset parent pointer for any error nodes

      ctx.children.map(function (child) {
        if (child instanceof ErrorNodeImpl) {
          this.children.push(child);
          child.parentCtx = this;
        }
      }, this);
    }
  } // Double dispatch methods for listeners


  enterRule(listener) {}

  exitRule(listener) {} // Does not set parent link; other add methods do that


  addChild(child) {
    if (this.children === null) {
      this.children = [];
    }

    this.children.push(child);
    return child;
  }
  /** Used by enterOuterAlt to toss out a RuleContext previously added as
   * we entered a rule. If we have // label, we will need to remove
   * generic ruleContext object.
   */


  removeLastChild() {
    if (this.children !== null) {
      this.children.pop();
    }
  }

  addTokenNode(token) {
    const node = new TerminalNodeImpl(token);
    this.addChild(node);
    node.parentCtx = this;
    return node;
  }

  addErrorNode(badToken) {
    const node = new ErrorNodeImpl(badToken);
    this.addChild(node);
    node.parentCtx = this;
    return node;
  }

  getChild(i, type) {
    type = type || null;

    if (this.children === null || i < 0 || i >= this.children.length) {
      return null;
    }

    if (type === null) {
      return this.children[i];
    } else {
      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];

        if (child instanceof type) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }

      return null;
    }
  }

  getToken(ttype, i) {
    if (this.children === null || i < 0 || i >= this.children.length) {
      return null;
    }

    for (let j = 0; j < this.children.length; j++) {
      const child = this.children[j];

      if (child instanceof TerminalNode) {
        if (child.symbol.type === ttype) {
          if (i === 0) {
            return child;
          } else {
            i -= 1;
          }
        }
      }
    }

    return null;
  }

  getTokens(ttype) {
    if (this.children === null) {
      return [];
    } else {
      const tokens = [];

      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];

        if (child instanceof TerminalNode) {
          if (child.symbol.type === ttype) {
            tokens.push(child);
          }
        }
      }

      return tokens;
    }
  }

  getTypedRuleContext(ctxType, i) {
    return this.getChild(i, ctxType);
  }

  getTypedRuleContexts(ctxType) {
    if (this.children === null) {
      return [];
    } else {
      const contexts = [];

      for (let j = 0; j < this.children.length; j++) {
        const child = this.children[j];

        if (child instanceof ctxType) {
          contexts.push(child);
        }
      }

      return contexts;
    }
  }

  getChildCount() {
    if (this.children === null) {
      return 0;
    } else {
      return this.children.length;
    }
  }

  getSourceInterval() {
    if (this.start === null || this.stop === null) {
      return INVALID_INTERVAL;
    } else {
      return new Interval(this.start.tokenIndex, this.stop.tokenIndex);
    }
  }

}

RuleContext.EMPTY = new ParserRuleContext();

class InterpreterRuleContext extends ParserRuleContext {
  constructor(parent, invokingStateNumber, ruleIndex) {
    super(parent, invokingStateNumber);
    this.ruleIndex = ruleIndex;
  }

}

module.exports = ParserRuleContext;

/***/ }),
/* 39 */
/***/ (function() {

/*! https://mths.be/codepointat v0.2.0 by @mathias */
if (!String.prototype.codePointAt) {
  (function () {
    'use strict'; // needed to support `apply`/`call` with `undefined`/`null`

    var defineProperty = function () {
      // IE 8 only supports `Object.defineProperty` on DOM elements
      let result;

      try {
        const object = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {}

      return result;
    }();

    const codePointAt = function (position) {
      if (this == null) {
        throw TypeError();
      }

      const string = String(this);
      const size = string.length; // `ToInteger`

      let index = position ? Number(position) : 0;

      if (index !== index) {
        // better `isNaN`
        index = 0;
      } // Account for out-of-bounds indices:


      if (index < 0 || index >= size) {
        return undefined;
      } // Get the first code unit


      const first = string.charCodeAt(index);
      let second;

      if ( // check if its the start of a surrogate pair
      first >= 0xD800 && first <= 0xDBFF && // high surrogate
      size > index + 1 // there is a next code unit
      ) {
        second = string.charCodeAt(index + 1);

        if (second >= 0xDC00 && second <= 0xDFFF) {
          // low surrogate
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
        }
      }

      return first;
    };

    if (defineProperty) {
      defineProperty(String.prototype, 'codePointAt', {
        'value': codePointAt,
        'configurable': true,
        'writable': true
      });
    } else {
      String.prototype.codePointAt = codePointAt;
    }
  })();
}

/***/ }),
/* 40 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
exports.DFA = __webpack_require__(41);
exports.DFASerializer = __webpack_require__(42).DFASerializer;
exports.LexerDFASerializer = __webpack_require__(42).LexerDFASerializer;
exports.PredPrediction = __webpack_require__(33).PredPrediction;

/***/ }),
/* 41 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Set
} = __webpack_require__(11);

const {
  DFAState
} = __webpack_require__(33);

const {
  StarLoopEntryState
} = __webpack_require__(14);

const {
  ATNConfigSet
} = __webpack_require__(34);

const {
  DFASerializer
} = __webpack_require__(42);

const {
  LexerDFASerializer
} = __webpack_require__(42);

class DFA {
  constructor(atnStartState, decision) {
    if (decision === undefined) {
      decision = 0;
    }
    /**
     * From which ATN state did we create this DFA?
     */


    this.atnStartState = atnStartState;
    this.decision = decision;
    /**
     * A set of all DFA states. Use {@link Map} so we can get old state back
     * ({@link Set} only allows you to see if it's there).
     */

    this._states = new Set();
    this.s0 = null;
    /**
     * {@code true} if this DFA is for a precedence decision; otherwise,
     * {@code false}. This is the backing field for {@link //isPrecedenceDfa},
     * {@link //setPrecedenceDfa}
     */

    this.precedenceDfa = false;

    if (atnStartState instanceof StarLoopEntryState) {
      if (atnStartState.isPrecedenceDecision) {
        this.precedenceDfa = true;
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      }
    }
  }
  /**
   * Get the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @return The start state corresponding to the specified precedence, or
   * {@code null} if no start state exists for the specified precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */


  getPrecedenceStartState(precedence) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    } // s0.edges is never null for a precedence DFA


    if (precedence < 0 || precedence >= this.s0.edges.length) {
      return null;
    }

    return this.s0.edges[precedence] || null;
  }
  /**
   * Set the start state for a specific precedence value.
   *
   * @param precedence The current precedence.
   * @param startState The start state corresponding to the specified
   * precedence.
   *
   * @throws IllegalStateException if this is not a precedence DFA.
   * @see //isPrecedenceDfa()
   */


  setPrecedenceStartState(precedence, startState) {
    if (!this.precedenceDfa) {
      throw "Only precedence DFAs may contain a precedence start state.";
    }

    if (precedence < 0) {
      return;
    }
    /**
     * synchronization on s0 here is ok. when the DFA is turned into a
     * precedence DFA, s0 will be initialized once and not updated again
     * s0.edges is never null for a precedence DFA
     */


    this.s0.edges[precedence] = startState;
  }
  /**
   * Sets whether this is a precedence DFA. If the specified value differs
   * from the current DFA configuration, the following actions are taken;
   * otherwise no changes are made to the current DFA.
   *
   * <ul>
   * <li>The {@link //states} map is cleared</li>
   * <li>If {@code precedenceDfa} is {@code false}, the initial state
   * {@link //s0} is set to {@code null}; otherwise, it is initialized to a new
   * {@link DFAState} with an empty outgoing {@link DFAState//edges} array to
   * store the start states for individual precedence values.</li>
   * <li>The {@link //precedenceDfa} field is updated</li>
   * </ul>
   *
   * @param precedenceDfa {@code true} if this is a precedence DFA; otherwise,
   * {@code false}
   */


  setPrecedenceDfa(precedenceDfa) {
    if (this.precedenceDfa !== precedenceDfa) {
      this._states = new Set();

      if (precedenceDfa) {
        const precedenceState = new DFAState(null, new ATNConfigSet());
        precedenceState.edges = [];
        precedenceState.isAcceptState = false;
        precedenceState.requiresFullContext = false;
        this.s0 = precedenceState;
      } else {
        this.s0 = null;
      }

      this.precedenceDfa = precedenceDfa;
    }
  }
  /**
   * Return a list of all states in this DFA, ordered by state number.
   */


  sortedStates() {
    const list = this._states.values();

    return list.sort(function (a, b) {
      return a.stateNumber - b.stateNumber;
    });
  }

  toString(literalNames, symbolicNames) {
    literalNames = literalNames || null;
    symbolicNames = symbolicNames || null;

    if (this.s0 === null) {
      return "";
    }

    const serializer = new DFASerializer(this, literalNames, symbolicNames);
    return serializer.toString();
  }

  toLexerString() {
    if (this.s0 === null) {
      return "";
    }

    const serializer = new LexerDFASerializer(this);
    return serializer.toString();
  }

  get states() {
    return this._states;
  }

}

module.exports = DFA;

/***/ }),
/* 42 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Utils = __webpack_require__(11);
/**
 * A DFA walker that knows how to dump them to serialized strings.
 */


class DFASerializer {
  constructor(dfa, literalNames, symbolicNames) {
    this.dfa = dfa;
    this.literalNames = literalNames || [];
    this.symbolicNames = symbolicNames || [];
  }

  toString() {
    if (this.dfa.s0 === null) {
      return null;
    }

    let buf = "";
    const states = this.dfa.sortedStates();

    for (let i = 0; i < states.length; i++) {
      const s = states[i];

      if (s.edges !== null) {
        const n = s.edges.length;

        for (let j = 0; j < n; j++) {
          const t = s.edges[j] || null;

          if (t !== null && t.stateNumber !== 0x7FFFFFFF) {
            buf = buf.concat(this.getStateString(s));
            buf = buf.concat("-");
            buf = buf.concat(this.getEdgeLabel(j));
            buf = buf.concat("->");
            buf = buf.concat(this.getStateString(t));
            buf = buf.concat('\n');
          }
        }
      }
    }

    return buf.length === 0 ? null : buf;
  }

  getEdgeLabel(i) {
    if (i === 0) {
      return "EOF";
    } else if (this.literalNames !== null || this.symbolicNames !== null) {
      return this.literalNames[i - 1] || this.symbolicNames[i - 1];
    } else {
      return String.fromCharCode(i - 1);
    }
  }

  getStateString(s) {
    const baseStateStr = (s.isAcceptState ? ":" : "") + "s" + s.stateNumber + (s.requiresFullContext ? "^" : "");

    if (s.isAcceptState) {
      if (s.predicates !== null) {
        return baseStateStr + "=>" + Utils.arrayToString(s.predicates);
      } else {
        return baseStateStr + "=>" + s.prediction.toString();
      }
    } else {
      return baseStateStr;
    }
  }

}

class LexerDFASerializer extends DFASerializer {
  constructor(dfa) {
    super(dfa, null);
  }

  getEdgeLabel(i) {
    return "'" + String.fromCharCode(i) + "'";
  }

}

module.exports = {
  DFASerializer,
  LexerDFASerializer
};

/***/ }),
/* 43 */
/***/ (function() {

/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */
if (!String.fromCodePoint) {
  (function () {
    const defineProperty = function () {
      // IE 8 only supports `Object.defineProperty` on DOM elements
      let result;

      try {
        const object = {};
        const $defineProperty = Object.defineProperty;
        result = $defineProperty(object, object, object) && $defineProperty;
      } catch (error) {}

      return result;
    }();

    const stringFromCharCode = String.fromCharCode;
    const floor = Math.floor;

    const fromCodePoint = function (_) {
      const MAX_SIZE = 0x4000;
      const codeUnits = [];
      let highSurrogate;
      let lowSurrogate;
      let index = -1;
      const length = arguments.length;

      if (!length) {
        return '';
      }

      let result = '';

      while (++index < length) {
        let codePoint = Number(arguments[index]);

        if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 || // not a valid Unicode code point
        codePoint > 0x10FFFF || // not a valid Unicode code point
        floor(codePoint) !== codePoint // not an integer
        ) {
          throw RangeError('Invalid code point: ' + codePoint);
        }

        if (codePoint <= 0xFFFF) {
          // BMP code point
          codeUnits.push(codePoint);
        } else {
          // Astral code point; split in surrogate halves
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          codePoint -= 0x10000;
          highSurrogate = (codePoint >> 10) + 0xD800;
          lowSurrogate = codePoint % 0x400 + 0xDC00;
          codeUnits.push(highSurrogate, lowSurrogate);
        }

        if (index + 1 === length || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }

      return result;
    };

    if (defineProperty) {
      defineProperty(String, 'fromCodePoint', {
        'value': fromCodePoint,
        'configurable': true,
        'writable': true
      });
    } else {
      String.fromCodePoint = fromCodePoint;
    }
  })();
}

/***/ }),
/* 44 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Tree = __webpack_require__(20);

const Trees = __webpack_require__(21);

module.exports = { ...Tree,
  Trees
};

/***/ }),
/* 45 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
module.exports.RecognitionException = __webpack_require__(31).RecognitionException;
module.exports.NoViableAltException = __webpack_require__(31).NoViableAltException;
module.exports.LexerNoViableAltException = __webpack_require__(31).LexerNoViableAltException;
module.exports.InputMismatchException = __webpack_require__(31).InputMismatchException;
module.exports.FailedPredicateException = __webpack_require__(31).FailedPredicateException;
module.exports.DiagnosticErrorListener = __webpack_require__(46);
module.exports.BailErrorStrategy = __webpack_require__(47).BailErrorStrategy;
module.exports.DefaultErrorStrategy = __webpack_require__(47).DefaultErrorStrategy;
module.exports.ErrorListener = __webpack_require__(29).ErrorListener;

/***/ }),
/* 46 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  BitSet
} = __webpack_require__(11);

const {
  ErrorListener
} = __webpack_require__(29);

const {
  Interval
} = __webpack_require__(16);
/**
 * This implementation of {@link ANTLRErrorListener} can be used to identify
 *  certain potential correctness and performance problems in grammars. "Reports"
 *  are made by calling {@link Parser//notifyErrorListeners} with the appropriate
 *  message.
 *
 *  <ul>
 *  <li><b>Ambiguities</b>: These are cases where more than one path through the
 *  grammar can match the input.</li>
 *  <li><b>Weak context sensitivity</b>: These are cases where full-context
 *  prediction resolved an SLL conflict to a unique alternative which equaled the
 *  minimum alternative of the SLL conflict.</li>
 *  <li><b>Strong (forced) context sensitivity</b>: These are cases where the
 *  full-context prediction resolved an SLL conflict to a unique alternative,
 *  <em>and</em> the minimum alternative of the SLL conflict was found to not be
 *  a truly viable alternative. Two-stage parsing cannot be used for inputs where
 *  this situation occurs.</li>
 *  </ul>
 */


class DiagnosticErrorListener extends ErrorListener {
  constructor(exactOnly) {
    super();
    exactOnly = exactOnly || true; // whether all ambiguities or only exact ambiguities are reported.

    this.exactOnly = exactOnly;
  }

  reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {
    if (this.exactOnly && !exact) {
      return;
    }

    const msg = "reportAmbiguity d=" + this.getDecisionDescription(recognizer, dfa) + ": ambigAlts=" + this.getConflictingAlts(ambigAlts, configs) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }

  reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, configs) {
    const msg = "reportAttemptingFullContext d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }

  reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, configs) {
    const msg = "reportContextSensitivity d=" + this.getDecisionDescription(recognizer, dfa) + ", input='" + recognizer.getTokenStream().getText(new Interval(startIndex, stopIndex)) + "'";
    recognizer.notifyErrorListeners(msg);
  }

  getDecisionDescription(recognizer, dfa) {
    const decision = dfa.decision;
    const ruleIndex = dfa.atnStartState.ruleIndex;
    const ruleNames = recognizer.ruleNames;

    if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {
      return "" + decision;
    }

    const ruleName = ruleNames[ruleIndex] || null;

    if (ruleName === null || ruleName.length === 0) {
      return "" + decision;
    }

    return `${decision} (${ruleName})`;
  }
  /**
   * Computes the set of conflicting or ambiguous alternatives from a
   * configuration set, if that information was not already provided by the
   * parser.
   *
   * @param reportedAlts The set of conflicting or ambiguous alternatives, as
   * reported by the parser.
   * @param configs The conflicting or ambiguous configuration set.
   * @return Returns {@code reportedAlts} if it is not {@code null}, otherwise
   * returns the set of alternatives represented in {@code configs}.
      */


  getConflictingAlts(reportedAlts, configs) {
    if (reportedAlts !== null) {
      return reportedAlts;
    }

    const result = new BitSet();

    for (let i = 0; i < configs.items.length; i++) {
      result.add(configs.items[i].alt);
    }

    return `{${result.values().join(", ")}}`;
  }

}

module.exports = DiagnosticErrorListener;

/***/ }),
/* 47 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const {
  NoViableAltException,
  InputMismatchException,
  FailedPredicateException,
  ParseCancellationException
} = __webpack_require__(31);

const {
  ATNState
} = __webpack_require__(14);

const {
  Interval,
  IntervalSet
} = __webpack_require__(16);

class ErrorStrategy {
  reset(recognizer) {}

  recoverInline(recognizer) {}

  recover(recognizer, e) {}

  sync(recognizer) {}

  inErrorRecoveryMode(recognizer) {}

  reportError(recognizer) {}

}
/**
 * This is the default implementation of {@link ANTLRErrorStrategy} used for
 * error reporting and recovery in ANTLR parsers.
*/


class DefaultErrorStrategy extends ErrorStrategy {
  constructor() {
    super();
    /**
     * Indicates whether the error strategy is currently "recovering from an
     * error". This is used to suppress reporting multiple error messages while
     * attempting to recover from a detected syntax error.
     *
     * @see //inErrorRecoveryMode
     */

    this.errorRecoveryMode = false;
    /**
     * The index into the input stream where the last error occurred.
     * This is used to prevent infinite loops where an error is found
     * but no token is consumed during recovery...another error is found,
     * ad nauseum. This is a failsafe mechanism to guarantee that at least
     * one token/tree node is consumed for two errors.
     */

    this.lastErrorIndex = -1;
    this.lastErrorStates = null;
    this.nextTokensContext = null;
    this.nextTokenState = 0;
  }
  /**
   * <p>The default implementation simply calls {@link //endErrorCondition} to
   * ensure that the handler is not in error recovery mode.</p>
  */


  reset(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * This method is called to enter error recovery mode when a recognition
   * exception is reported.
   *
   * @param recognizer the parser instance
  */


  beginErrorCondition(recognizer) {
    this.errorRecoveryMode = true;
  }

  inErrorRecoveryMode(recognizer) {
    return this.errorRecoveryMode;
  }
  /**
   * This method is called to leave error recovery mode after recovering from
   * a recognition exception.
   * @param recognizer
   */


  endErrorCondition(recognizer) {
    this.errorRecoveryMode = false;
    this.lastErrorStates = null;
    this.lastErrorIndex = -1;
  }
  /**
   * {@inheritDoc}
   * <p>The default implementation simply calls {@link //endErrorCondition}.</p>
   */


  reportMatch(recognizer) {
    this.endErrorCondition(recognizer);
  }
  /**
   * {@inheritDoc}
   *
   * <p>The default implementation returns immediately if the handler is already
   * in error recovery mode. Otherwise, it calls {@link //beginErrorCondition}
   * and dispatches the reporting task based on the runtime type of {@code e}
   * according to the following table.</p>
   *
   * <ul>
   * <li>{@link NoViableAltException}: Dispatches the call to
   * {@link //reportNoViableAlternative}</li>
   * <li>{@link InputMismatchException}: Dispatches the call to
   * {@link //reportInputMismatch}</li>
   * <li>{@link FailedPredicateException}: Dispatches the call to
   * {@link //reportFailedPredicate}</li>
   * <li>All other types: calls {@link Parser//notifyErrorListeners} to report
   * the exception</li>
   * </ul>
   */


  reportError(recognizer, e) {
    // if we've already reported an error and have not matched a token
    // yet successfully, don't report any errors.
    if (this.inErrorRecoveryMode(recognizer)) {
      return; // don't report spurious errors
    }

    this.beginErrorCondition(recognizer);

    if (e instanceof NoViableAltException) {
      this.reportNoViableAlternative(recognizer, e);
    } else if (e instanceof InputMismatchException) {
      this.reportInputMismatch(recognizer, e);
    } else if (e instanceof FailedPredicateException) {
      this.reportFailedPredicate(recognizer, e);
    } else {
      console.log("unknown recognition error type: " + e.constructor.name);
      console.log(e.stack);
      recognizer.notifyErrorListeners(e.getOffendingToken(), e.getMessage(), e);
    }
  }
  /**
   *
   * {@inheritDoc}
   *
   * <p>The default implementation resynchronizes the parser by consuming tokens
   * until we find one in the resynchronization set--loosely the set of tokens
   * that can follow the current rule.</p>
   *
   */


  recover(recognizer, e) {
    if (this.lastErrorIndex === recognizer.getInputStream().index && this.lastErrorStates !== null && this.lastErrorStates.indexOf(recognizer.state) >= 0) {
      // uh oh, another error at same token index and previously-visited
      // state in ATN; must be a case where LT(1) is in the recovery
      // token set so nothing got consumed. Consume a single token
      // at least to prevent an infinite loop; this is a failsafe.
      recognizer.consume();
    }

    this.lastErrorIndex = recognizer._input.index;

    if (this.lastErrorStates === null) {
      this.lastErrorStates = [];
    }

    this.lastErrorStates.push(recognizer.state);
    const followSet = this.getErrorRecoverySet(recognizer);
    this.consumeUntil(recognizer, followSet);
  }
  /**
   * The default implementation of {@link ANTLRErrorStrategy//sync} makes sure
   * that the current lookahead symbol is consistent with what were expecting
   * at this point in the ATN. You can call this anytime but ANTLR only
   * generates code to check before subrules/loops and each iteration.
   *
   * <p>Implements Jim Idle's magic sync mechanism in closures and optional
   * subrules. E.g.,</p>
   *
   * <pre>
   * a : sync ( stuff sync )* ;
   * sync : {consume to what can follow sync} ;
   * </pre>
   *
   * At the start of a sub rule upon error, {@link //sync} performs single
   * token deletion, if possible. If it can't do that, it bails on the current
   * rule and uses the default error recovery, which consumes until the
   * resynchronization set of the current rule.
   *
   * <p>If the sub rule is optional ({@code (...)?}, {@code (...)*}, or block
   * with an empty alternative), then the expected set includes what follows
   * the subrule.</p>
   *
   * <p>During loop iteration, it consumes until it sees a token that can start a
   * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to
   * stay in the loop as long as possible.</p>
   *
   * <p><strong>ORIGINS</strong></p>
   *
   * <p>Previous versions of ANTLR did a poor job of their recovery within loops.
   * A single mismatch token or missing token would force the parser to bail
   * out of the entire rules surrounding the loop. So, for rule</p>
   *
   * <pre>
   * classDef : 'class' ID '{' member* '}'
   * </pre>
   *
   * input with an extra token between members would force the parser to
   * consume until it found the next class definition rather than the next
   * member definition of the current class.
   *
   * <p>This functionality cost a little bit of effort because the parser has to
   * compare token set at the start of the loop and at each iteration. If for
   * some reason speed is suffering for you, you can turn off this
   * functionality by simply overriding this method as a blank { }.</p>
   *
   */


  sync(recognizer) {
    // If already recovering, don't try to sync
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }

    const s = recognizer._interp.atn.states[recognizer.state];
    const la = recognizer.getTokenStream().LA(1); // try cheaper subset first; might get lucky. seems to shave a wee bit off

    const nextTokens = recognizer.atn.nextTokens(s);

    if (nextTokens.contains(la)) {
      this.nextTokensContext = null;
      this.nextTokenState = ATNState.INVALID_STATE_NUMBER;
      return;
    } else if (nextTokens.contains(Token.EPSILON)) {
      if (this.nextTokensContext === null) {
        // It's possible the next token won't match information tracked
        // by sync is restricted for performance.
        this.nextTokensContext = recognizer._ctx;
        this.nextTokensState = recognizer._stateNumber;
      }

      return;
    }

    switch (s.stateType) {
      case ATNState.BLOCK_START:
      case ATNState.STAR_BLOCK_START:
      case ATNState.PLUS_BLOCK_START:
      case ATNState.STAR_LOOP_ENTRY:
        // report error and recover if possible
        if (this.singleTokenDeletion(recognizer) !== null) {
          return;
        } else {
          throw new InputMismatchException(recognizer);
        }

      case ATNState.PLUS_LOOP_BACK:
      case ATNState.STAR_LOOP_BACK:
        this.reportUnwantedToken(recognizer);
        const expecting = new IntervalSet();
        expecting.addSet(recognizer.getExpectedTokens());
        const whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
        this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
        break;

      default: // do nothing if we can't identify the exact kind of ATN state

    }
  }
  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link NoViableAltException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */


  reportNoViableAlternative(recognizer, e) {
    const tokens = recognizer.getTokenStream();
    let input;

    if (tokens !== null) {
      if (e.startToken.type === Token.EOF) {
        input = "<EOF>";
      } else {
        input = tokens.getText(new Interval(e.startToken.tokenIndex, e.offendingToken.tokenIndex));
      }
    } else {
      input = "<unknown input>";
    }

    const msg = "no viable alternative at input " + this.escapeWSAndQuote(input);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This is called by {@link //reportError} when the exception is an
   * {@link InputMismatchException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */


  reportInputMismatch(recognizer, e) {
    const msg = "mismatched input " + this.getTokenErrorDisplay(e.offendingToken) + " expecting " + e.getExpectedTokens().toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This is called by {@link //reportError} when the exception is a
   * {@link FailedPredicateException}.
   *
   * @see //reportError
   *
   * @param recognizer the parser instance
   * @param e the recognition exception
   */


  reportFailedPredicate(recognizer, e) {
    const ruleName = recognizer.ruleNames[recognizer._ctx.ruleIndex];
    const msg = "rule " + ruleName + " " + e.message;
    recognizer.notifyErrorListeners(msg, e.offendingToken, e);
  }
  /**
   * This method is called to report a syntax error which requires the removal
   * of a token from the input stream. At the time this method is called, the
   * erroneous symbol is current {@code LT(1)} symbol and has not yet been
   * removed from the input stream. When this method returns,
   * {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenDeletion} identifies
   * single-token deletion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   *
   */


  reportUnwantedToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }

    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const tokenName = this.getTokenErrorDisplay(t);
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "extraneous input " + tokenName + " expecting " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    recognizer.notifyErrorListeners(msg, t, null);
  }
  /**
   * This method is called to report a syntax error which requires the
   * insertion of a missing token into the input stream. At the time this
   * method is called, the missing token has not yet been inserted. When this
   * method returns, {@code recognizer} is in error recovery mode.
   *
   * <p>This method is called when {@link //singleTokenInsertion} identifies
   * single-token insertion as a viable recovery strategy for a mismatched
   * input error.</p>
   *
   * <p>The default implementation simply returns if the handler is already in
   * error recovery mode. Otherwise, it calls {@link //beginErrorCondition} to
   * enter error recovery mode, followed by calling
   * {@link Parser//notifyErrorListeners}.</p>
   *
   * @param recognizer the parser instance
   */


  reportMissingToken(recognizer) {
    if (this.inErrorRecoveryMode(recognizer)) {
      return;
    }

    this.beginErrorCondition(recognizer);
    const t = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const msg = "missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) + " at " + this.getTokenErrorDisplay(t);
    recognizer.notifyErrorListeners(msg, t, null);
  }
  /**
   * <p>The default implementation attempts to recover from the mismatched input
   * by using single token insertion and deletion as described below. If the
   * recovery attempt fails, this method throws an
   * {@link InputMismatchException}.</p>
   *
   * <p><strong>EXTRA TOKEN</strong> (single token deletion)</p>
   *
   * <p>{@code LA(1)} is not what we are looking for. If {@code LA(2)} has the
   * right token, however, then assume {@code LA(1)} is some extra spurious
   * token and delete it. Then consume and return the next token (which was
   * the {@code LA(2)} token) as the successful result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
   * //singleTokenDeletion}.</p>
   *
   * <p><strong>MISSING TOKEN</strong> (single token insertion)</p>
   *
   * <p>If current token (at {@code LA(1)}) is consistent with what could come
   * after the expected {@code LA(1)} token, then assume the token is missing
   * and use the parser's {@link TokenFactory} to create it on the fly. The
   * "insertion" is performed by returning the created token as the successful
   * result of the match operation.</p>
   *
   * <p>This recovery strategy is implemented by {@link
   * //singleTokenInsertion}.</p>
   *
   * <p><strong>EXAMPLE</strong></p>
   *
   * <p>For example, Input {@code i=(3;} is clearly missing the {@code ')'}. When
   * the parser returns from the nested call to {@code expr}, it will have
   * call chain:</p>
   *
   * <pre>
   * stat &rarr; expr &rarr; atom
   * </pre>
   *
   * and it will be trying to match the {@code ')'} at this point in the
   * derivation:
   *
   * <pre>
   * =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
   * ^
   * </pre>
   *
   * The attempt to match {@code ')'} will fail when it sees {@code ';'} and
   * call {@link //recoverInline}. To recover, it sees that {@code LA(1)==';'}
   * is in the set of tokens that can follow the {@code ')'} token reference
   * in rule {@code atom}. It can assume that you forgot the {@code ')'}.
   */


  recoverInline(recognizer) {
    // SINGLE TOKEN DELETION
    const matchedSymbol = this.singleTokenDeletion(recognizer);

    if (matchedSymbol !== null) {
      // we have deleted the extra token.
      // now, move past ttype token as if all were ok
      recognizer.consume();
      return matchedSymbol;
    } // SINGLE TOKEN INSERTION


    if (this.singleTokenInsertion(recognizer)) {
      return this.getMissingSymbol(recognizer);
    } // even that didn't work; must throw the exception


    throw new InputMismatchException(recognizer);
  }
  /**
   * This method implements the single-token insertion inline error recovery
   * strategy. It is called by {@link //recoverInline} if the single-token
   * deletion strategy fails to recover from the mismatched input. If this
   * method returns {@code true}, {@code recognizer} will be in error recovery
   * mode.
   *
   * <p>This method determines whether or not single-token insertion is viable by
   * checking if the {@code LA(1)} input symbol could be successfully matched
   * if it were instead the {@code LA(2)} symbol. If this method returns
   * {@code true}, the caller is responsible for creating and inserting a
   * token with the correct type to produce this behavior.</p>
   *
   * @param recognizer the parser instance
   * @return {@code true} if single-token insertion is a viable recovery
   * strategy for the current mismatched input, otherwise {@code false}
   */


  singleTokenInsertion(recognizer) {
    const currentSymbolType = recognizer.getTokenStream().LA(1); // if current token is consistent with what could come after current
    // ATN state, then we know we're missing a token; error recovery
    // is free to conjure up and insert the missing token

    const atn = recognizer._interp.atn;
    const currentState = atn.states[recognizer.state];
    const next = currentState.transitions[0].target;
    const expectingAtLL2 = atn.nextTokens(next, recognizer._ctx);

    if (expectingAtLL2.contains(currentSymbolType)) {
      this.reportMissingToken(recognizer);
      return true;
    } else {
      return false;
    }
  }
  /**
   * This method implements the single-token deletion inline error recovery
   * strategy. It is called by {@link //recoverInline} to attempt to recover
   * from mismatched input. If this method returns null, the parser and error
   * handler state will not have changed. If this method returns non-null,
   * {@code recognizer} will <em>not</em> be in error recovery mode since the
   * returned token was a successful match.
   *
   * <p>If the single-token deletion is successful, this method calls
   * {@link //reportUnwantedToken} to report the error, followed by
   * {@link Parser//consume} to actually "delete" the extraneous token. Then,
   * before returning {@link //reportMatch} is called to signal a successful
   * match.</p>
   *
   * @param recognizer the parser instance
   * @return the successfully matched {@link Token} instance if single-token
   * deletion successfully recovers from the mismatched input, otherwise
   * {@code null}
   */


  singleTokenDeletion(recognizer) {
    const nextTokenType = recognizer.getTokenStream().LA(2);
    const expecting = this.getExpectedTokens(recognizer);

    if (expecting.contains(nextTokenType)) {
      this.reportUnwantedToken(recognizer); // print("recoverFromMismatchedToken deleting " \
      // + str(recognizer.getTokenStream().LT(1)) \
      // + " since " + str(recognizer.getTokenStream().LT(2)) \
      // + " is what we want", file=sys.stderr)

      recognizer.consume(); // simply delete extra token
      // we want to return the token we're actually matching

      const matchedSymbol = recognizer.getCurrentToken();
      this.reportMatch(recognizer); // we know current token is correct

      return matchedSymbol;
    } else {
      return null;
    }
  }
  /**
   * Conjure up a missing token during error recovery.
   *
   * The recognizer attempts to recover from single missing
   * symbols. But, actions might refer to that missing symbol.
   * For example, x=ID {f($x);}. The action clearly assumes
   * that there has been an identifier matched previously and that
   * $x points at that token. If that token is missing, but
   * the next token in the stream is what we want we assume that
   * this token is missing and we keep going. Because we
   * have to return some token to replace the missing token,
   * we have to conjure one up. This method gives the user control
   * over the tokens returned for missing tokens. Mostly,
   * you will want to create something special for identifier
   * tokens. For literals such as '{' and ',', the default
   * action in the parser or tree parser works. It simply creates
   * a CommonToken of the appropriate type. The text will be the token.
   * If you change what tokens must be created by the lexer,
   * override this method to create the appropriate tokens.
   *
   */


  getMissingSymbol(recognizer) {
    const currentSymbol = recognizer.getCurrentToken();
    const expecting = this.getExpectedTokens(recognizer);
    const expectedTokenType = expecting.first(); // get any element

    let tokenText;

    if (expectedTokenType === Token.EOF) {
      tokenText = "<missing EOF>";
    } else {
      tokenText = "<missing " + recognizer.literalNames[expectedTokenType] + ">";
    }

    let current = currentSymbol;
    const lookback = recognizer.getTokenStream().LT(-1);

    if (current.type === Token.EOF && lookback !== null) {
      current = lookback;
    }

    return recognizer.getTokenFactory().create(current.source, expectedTokenType, tokenText, Token.DEFAULT_CHANNEL, -1, -1, current.line, current.column);
  }

  getExpectedTokens(recognizer) {
    return recognizer.getExpectedTokens();
  }
  /**
   * How should a token be displayed in an error message? The default
   * is to display just the text, but during development you might
   * want to have a lot of information spit out. Override in that case
   * to use t.toString() (which, for CommonToken, dumps everything about
   * the token). This is better than forcing you to override a method in
   * your token objects because you don't have to go modify your lexer
   * so that it creates a new Java type.
   */


  getTokenErrorDisplay(t) {
    if (t === null) {
      return "<no token>";
    }

    let s = t.text;

    if (s === null) {
      if (t.type === Token.EOF) {
        s = "<EOF>";
      } else {
        s = "<" + t.type + ">";
      }
    }

    return this.escapeWSAndQuote(s);
  }

  escapeWSAndQuote(s) {
    s = s.replace(/\n/g, "\\n");
    s = s.replace(/\r/g, "\\r");
    s = s.replace(/\t/g, "\\t");
    return "'" + s + "'";
  }
  /**
   * Compute the error recovery set for the current rule. During
   * rule invocation, the parser pushes the set of tokens that can
   * follow that rule reference on the stack; this amounts to
   * computing FIRST of what follows the rule reference in the
   * enclosing rule. See LinearApproximator.FIRST().
   * This local follow set only includes tokens
   * from within the rule; i.e., the FIRST computation done by
   * ANTLR stops at the end of a rule.
   *
   * EXAMPLE
   *
   * When you find a "no viable alt exception", the input is not
   * consistent with any of the alternatives for rule r. The best
   * thing to do is to consume tokens until you see something that
   * can legally follow a call to r//or* any rule that called r.
   * You don't want the exact set of viable next tokens because the
   * input might just be missing a token--you might consume the
   * rest of the input looking for one of the missing tokens.
   *
   * Consider grammar:
   *
   * a : '[' b ']'
   * | '(' b ')'
   * ;
   * b : c '^' INT ;
   * c : ID
   * | INT
   * ;
   *
   * At each rule invocation, the set of tokens that could follow
   * that rule is pushed on a stack. Here are the various
   * context-sensitive follow sets:
   *
   * FOLLOW(b1_in_a) = FIRST(']') = ']'
   * FOLLOW(b2_in_a) = FIRST(')') = ')'
   * FOLLOW(c_in_b) = FIRST('^') = '^'
   *
   * Upon erroneous input "[]", the call chain is
   *
   * a -> b -> c
   *
   * and, hence, the follow context stack is:
   *
   * depth follow set start of rule execution
   * 0 <EOF> a (from main())
   * 1 ']' b
   * 2 '^' c
   *
   * Notice that ')' is not included, because b would have to have
   * been called from a different context in rule a for ')' to be
   * included.
   *
   * For error recovery, we cannot consider FOLLOW(c)
   * (context-sensitive or otherwise). We need the combined set of
   * all context-sensitive FOLLOW sets--the set of all tokens that
   * could follow any reference in the call chain. We need to
   * resync to one of those tokens. Note that FOLLOW(c)='^' and if
   * we resync'd to that token, we'd consume until EOF. We need to
   * sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
   * In this case, for input "[]", LA(1) is ']' and in the set, so we would
   * not consume anything. After printing an error, rule c would
   * return normally. Rule b would not find the required '^' though.
   * At this point, it gets a mismatched token error and throws an
   * exception (since LA(1) is not in the viable following token
   * set). The rule exception handler tries to recover, but finds
   * the same recovery set and doesn't consume anything. Rule b
   * exits normally returning to rule a. Now it finds the ']' (and
   * with the successful match exits errorRecovery mode).
   *
   * So, you can see that the parser walks up the call chain looking
   * for the token that was a member of the recovery set.
   *
   * Errors are not generated in errorRecovery mode.
   *
   * ANTLR's error recovery mechanism is based upon original ideas:
   *
   * "Algorithms + Data Structures = Programs" by Niklaus Wirth
   *
   * and
   *
   * "A note on error recovery in recursive descent parsers":
   * http://portal.acm.org/citation.cfm?id=947902.947905
   *
   * Later, Josef Grosch had some good ideas:
   *
   * "Efficient and Comfortable Error Recovery in Recursive Descent
   * Parsers":
   * ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
   *
   * Like Grosch I implement context-sensitive FOLLOW sets that are combined
   * at run-time upon error to avoid overhead during parsing.
   */


  getErrorRecoverySet(recognizer) {
    const atn = recognizer._interp.atn;
    let ctx = recognizer._ctx;
    const recoverSet = new IntervalSet();

    while (ctx !== null && ctx.invokingState >= 0) {
      // compute what follows who invoked us
      const invokingState = atn.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      const follow = atn.nextTokens(rt.followState);
      recoverSet.addSet(follow);
      ctx = ctx.parentCtx;
    }

    recoverSet.removeOne(Token.EPSILON);
    return recoverSet;
  } // Consume tokens until one matches the given token set.//


  consumeUntil(recognizer, set) {
    let ttype = recognizer.getTokenStream().LA(1);

    while (ttype !== Token.EOF && !set.contains(ttype)) {
      recognizer.consume();
      ttype = recognizer.getTokenStream().LA(1);
    }
  }

}
/**
 * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors
 * by immediately canceling the parse operation with a
 * {@link ParseCancellationException}. The implementation ensures that the
 * {@link ParserRuleContext//exception} field is set for all parse tree nodes
 * that were not completed prior to encountering the error.
 *
 * <p>
 * This error strategy is useful in the following scenarios.</p>
 *
 * <ul>
 * <li><strong>Two-stage parsing:</strong> This error strategy allows the first
 * stage of two-stage parsing to immediately terminate if an error is
 * encountered, and immediately fall back to the second stage. In addition to
 * avoiding wasted work by attempting to recover from errors here, the empty
 * implementation of {@link BailErrorStrategy//sync} improves the performance of
 * the first stage.</li>
 * <li><strong>Silent validation:</strong> When syntax errors are not being
 * reported or logged, and the parse result is simply ignored if errors occur,
 * the {@link BailErrorStrategy} avoids wasting work on recovering from errors
 * when the result will be ignored either way.</li>
 * </ul>
 *
 * <p>
 * {@code myparser.setErrorHandler(new BailErrorStrategy());}</p>
 *
 * @see Parser//setErrorHandler(ANTLRErrorStrategy)
 * */


class BailErrorStrategy extends DefaultErrorStrategy {
  constructor() {
    super();
  }
  /**
   * Instead of recovering from exception {@code e}, re-throw it wrapped
   * in a {@link ParseCancellationException} so it is not caught by the
   * rule function catches. Use {@link Exception//getCause()} to get the
   * original {@link RecognitionException}.
   */


  recover(recognizer, e) {
    let context = recognizer._ctx;

    while (context !== null) {
      context.exception = e;
      context = context.parentCtx;
    }

    throw new ParseCancellationException(e);
  }
  /**
   * Make sure we don't attempt to recover inline; if the parser
   * successfully recovers, it won't throw an exception.
   */


  recoverInline(recognizer) {
    this.recover(recognizer, new InputMismatchException(recognizer));
  } // Make sure we don't attempt to recover from problems in subrules.//


  sync(recognizer) {// pass
  }

}

module.exports = {
  BailErrorStrategy,
  DefaultErrorStrategy
};

/***/ }),
/* 48 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

__webpack_require__(39);

__webpack_require__(43);
/**
 * If decodeToUnicodeCodePoints is true, the input is treated
 * as a series of Unicode code points.
 *
 * Otherwise, the input is treated as a series of 16-bit UTF-16 code
 * units.
 */


class InputStream {
  constructor(data, decodeToUnicodeCodePoints) {
    this.name = "<empty>";
    this.strdata = data;
    this.decodeToUnicodeCodePoints = decodeToUnicodeCodePoints || false; // _loadString - Vacuum all input from a string and then treat it like a buffer.

    this._index = 0;
    this.data = [];

    if (this.decodeToUnicodeCodePoints) {
      for (let i = 0; i < this.strdata.length;) {
        const codePoint = this.strdata.codePointAt(i);
        this.data.push(codePoint);
        i += codePoint <= 0xFFFF ? 1 : 2;
      }
    } else {
      this.data = new Array(this.strdata.length);

      for (let i = 0; i < this.strdata.length; i++) {
        const codeUnit = this.strdata.charCodeAt(i);
        this.data[i] = codeUnit;
      }
    }

    this._size = this.data.length;
  }
  /**
   * Reset the stream so that it's in the same state it was
   * when the object was created *except* the data array is not
   * touched.
   */


  reset() {
    this._index = 0;
  }

  consume() {
    if (this._index >= this._size) {
      // assert this.LA(1) == Token.EOF
      throw "cannot consume EOF";
    }

    this._index += 1;
  }

  LA(offset) {
    if (offset === 0) {
      return 0; // undefined
    }

    if (offset < 0) {
      offset += 1; // e.g., translate LA(-1) to use offset=0
    }

    const pos = this._index + offset - 1;

    if (pos < 0 || pos >= this._size) {
      // invalid
      return Token.EOF;
    }

    return this.data[pos];
  }

  LT(offset) {
    return this.LA(offset);
  } // mark/release do nothing; we have entire buffer


  mark() {
    return -1;
  }

  release(marker) {}
  /**
   * consume() ahead until p==_index; can't just set p=_index as we must
   * update line and column. If we seek backwards, just set p
   */


  seek(_index) {
    if (_index <= this._index) {
      this._index = _index; // just jump; don't update stream state (line,
      // ...)

      return;
    } // seek forward


    this._index = Math.min(_index, this._size);
  }

  getText(start, stop) {
    if (stop >= this._size) {
      stop = this._size - 1;
    }

    if (start >= this._size) {
      return "";
    } else {
      if (this.decodeToUnicodeCodePoints) {
        let result = "";

        for (let i = start; i <= stop; i++) {
          result += String.fromCodePoint(this.data[i]);
        }

        return result;
      } else {
        return this.strdata.slice(start, stop + 1);
      }
    }
  }

  toString() {
    return this.strdata;
  }

  get index() {
    return this._index;
  }

  get size() {
    return this._size;
  }

}

module.exports = InputStream;

/***/ }),
/* 49 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const Token = (__webpack_require__(12).Token);

const BufferedTokenStream = __webpack_require__(50);
/**
 * This class extends {@link BufferedTokenStream} with functionality to filter
 * token streams to tokens on a particular channel (tokens where
 * {@link Token//getChannel} returns a particular value).
 *
 * <p>
 * This token stream provides access to all tokens by index or when calling
 * methods like {@link //getText}. The channel filtering is only used for code
 * accessing tokens via the lookahead methods {@link //LA}, {@link //LT}, and
 * {@link //LB}.</p>
 *
 * <p>
 * By default, tokens are placed on the default channel
 * ({@link Token//DEFAULT_CHANNEL}), but may be reassigned by using the
 * {@code ->channel(HIDDEN)} lexer command, or by using an embedded action to
 * call {@link Lexer//setChannel}.
 * </p>
 *
 * <p>
 * Note: lexer rules which use the {@code ->skip} lexer command or call
 * {@link Lexer//skip} do not produce tokens at all, so input text matched by
 * such a rule will not be available as part of the token stream, regardless of
 * channel.</p>
 */


class CommonTokenStream extends BufferedTokenStream {
  constructor(lexer, channel) {
    super(lexer);
    this.channel = channel === undefined ? Token.DEFAULT_CHANNEL : channel;
  }

  adjustSeekIndex(i) {
    return this.nextTokenOnChannel(i, this.channel);
  }

  LB(k) {
    if (k === 0 || this.index - k < 0) {
      return null;
    }

    let i = this.index;
    let n = 1; // find k good tokens looking backwards

    while (n <= k) {
      // skip off-channel tokens
      i = this.previousTokenOnChannel(i - 1, this.channel);
      n += 1;
    }

    if (i < 0) {
      return null;
    }

    return this.tokens[i];
  }

  LT(k) {
    this.lazyInit();

    if (k === 0) {
      return null;
    }

    if (k < 0) {
      return this.LB(-k);
    }

    let i = this.index;
    let n = 1; // we know tokens[pos] is a good one
    // find k good tokens

    while (n < k) {
      // skip off-channel tokens, but make sure to not look past EOF
      if (this.sync(i + 1)) {
        i = this.nextTokenOnChannel(i + 1, this.channel);
      }

      n += 1;
    }

    return this.tokens[i];
  } // Count EOF just once.


  getNumberOfOnChannelTokens() {
    let n = 0;
    this.fill();

    for (let i = 0; i < this.tokens.length; i++) {
      const t = this.tokens[i];

      if (t.channel === this.channel) {
        n += 1;
      }

      if (t.type === Token.EOF) {
        break;
      }
    }

    return n;
  }

}

module.exports = CommonTokenStream;

/***/ }),
/* 50 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const Lexer = __webpack_require__(27);

const {
  Interval
} = __webpack_require__(16); // this is just to keep meaningful parameter types to Parser


class TokenStream {}
/**
 * This implementation of {@link TokenStream} loads tokens from a
 * {@link TokenSource} on-demand, and places the tokens in a buffer to provide
 * access to any previous token by index.
 *
 * <p>
 * This token stream ignores the value of {@link Token//getChannel}. If your
 * parser requires the token stream filter tokens to only those on a particular
 * channel, such as {@link Token//DEFAULT_CHANNEL} or
 * {@link Token//HIDDEN_CHANNEL}, use a filtering token stream such a
 * {@link CommonTokenStream}.</p>
 */


class BufferedTokenStream extends TokenStream {
  constructor(tokenSource) {
    super(); // The {@link TokenSource} from which tokens for this stream are fetched.

    this.tokenSource = tokenSource;
    /**
     * A collection of all tokens fetched from the token source. The list is
     * considered a complete view of the input once {@link //fetchedEOF} is set
     * to {@code true}.
     */

    this.tokens = [];
    /**
     * The index into {@link //tokens} of the current token (next token to
     * {@link //consume}). {@link //tokens}{@code [}{@link //p}{@code ]} should
     * be
     * {@link //LT LT(1)}.
     *
     * <p>This field is set to -1 when the stream is first constructed or when
     * {@link //setTokenSource} is called, indicating that the first token has
     * not yet been fetched from the token source. For additional information,
     * see the documentation of {@link IntStream} for a description of
     * Initializing Methods.</p>
     */

    this.index = -1;
    /**
     * Indicates whether the {@link Token//EOF} token has been fetched from
     * {@link //tokenSource} and added to {@link //tokens}. This field improves
     * performance for the following cases:
     *
     * <ul>
     * <li>{@link //consume}: The lookahead check in {@link //consume} to
     * prevent
     * consuming the EOF symbol is optimized by checking the values of
     * {@link //fetchedEOF} and {@link //p} instead of calling {@link
     * //LA}.</li>
     * <li>{@link //fetch}: The check to prevent adding multiple EOF symbols
     * into
     * {@link //tokens} is trivial with this field.</li>
     * <ul>
     */

    this.fetchedEOF = false;
  }

  mark() {
    return 0;
  }

  release(marker) {// no resources to release
  }

  reset() {
    this.seek(0);
  }

  seek(index) {
    this.lazyInit();
    this.index = this.adjustSeekIndex(index);
  }

  get(index) {
    this.lazyInit();
    return this.tokens[index];
  }

  consume() {
    let skipEofCheck = false;

    if (this.index >= 0) {
      if (this.fetchedEOF) {
        // the last token in tokens is EOF. skip check if p indexes any
        // fetched token except the last.
        skipEofCheck = this.index < this.tokens.length - 1;
      } else {
        // no EOF token in tokens. skip check if p indexes a fetched token.
        skipEofCheck = this.index < this.tokens.length;
      }
    } else {
      // not yet initialized
      skipEofCheck = false;
    }

    if (!skipEofCheck && this.LA(1) === Token.EOF) {
      throw "cannot consume EOF";
    }

    if (this.sync(this.index + 1)) {
      this.index = this.adjustSeekIndex(this.index + 1);
    }
  }
  /**
   * Make sure index {@code i} in tokens has a token.
   *
   * @return {Boolean} {@code true} if a token is located at index {@code i}, otherwise
   * {@code false}.
   * @see //get(int i)
   */


  sync(i) {
    const n = i - this.tokens.length + 1; // how many more elements we need?

    if (n > 0) {
      const fetched = this.fetch(n);
      return fetched >= n;
    }

    return true;
  }
  /**
   * Add {@code n} elements to buffer.
   *
   * @return {Number} The actual number of elements added to the buffer.
   */


  fetch(n) {
    if (this.fetchedEOF) {
      return 0;
    }

    for (let i = 0; i < n; i++) {
      const t = this.tokenSource.nextToken();
      t.tokenIndex = this.tokens.length;
      this.tokens.push(t);

      if (t.type === Token.EOF) {
        this.fetchedEOF = true;
        return i + 1;
      }
    }

    return n;
  } // Get all tokens from start..stop inclusively///


  getTokens(start, stop, types) {
    if (types === undefined) {
      types = null;
    }

    if (start < 0 || stop < 0) {
      return null;
    }

    this.lazyInit();
    const subset = [];

    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }

    for (let i = start; i < stop; i++) {
      const t = this.tokens[i];

      if (t.type === Token.EOF) {
        break;
      }

      if (types === null || types.contains(t.type)) {
        subset.push(t);
      }
    }

    return subset;
  }

  LA(i) {
    return this.LT(i).type;
  }

  LB(k) {
    if (this.index - k < 0) {
      return null;
    }

    return this.tokens[this.index - k];
  }

  LT(k) {
    this.lazyInit();

    if (k === 0) {
      return null;
    }

    if (k < 0) {
      return this.LB(-k);
    }

    const i = this.index + k - 1;
    this.sync(i);

    if (i >= this.tokens.length) {
      // return EOF token
      // EOF must be last token
      return this.tokens[this.tokens.length - 1];
    }

    return this.tokens[i];
  }
  /**
   * Allowed derived classes to modify the behavior of operations which change
   * the current stream position by adjusting the target token index of a seek
   * operation. The default implementation simply returns {@code i}. If an
   * exception is thrown in this method, the current stream index should not be
   * changed.
   *
   * <p>For example, {@link CommonTokenStream} overrides this method to ensure
   * that
   * the seek target is always an on-channel token.</p>
   *
   * @param {Number} i The target token index.
   * @return {Number} The adjusted target token index.
   */


  adjustSeekIndex(i) {
    return i;
  }

  lazyInit() {
    if (this.index === -1) {
      this.setup();
    }
  }

  setup() {
    this.sync(0);
    this.index = this.adjustSeekIndex(0);
  } // Reset this token stream by setting its token source.///


  setTokenSource(tokenSource) {
    this.tokenSource = tokenSource;
    this.tokens = [];
    this.index = -1;
    this.fetchedEOF = false;
  }
  /**
   * Given a starting index, return the index of the next token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and EOF.
   */


  nextTokenOnChannel(i, channel) {
    this.sync(i);

    if (i >= this.tokens.length) {
      return -1;
    }

    let token = this.tokens[i];

    while (token.channel !== this.channel) {
      if (token.type === Token.EOF) {
        return -1;
      }

      i += 1;
      this.sync(i);
      token = this.tokens[i];
    }

    return i;
  }
  /**
   * Given a starting index, return the index of the previous token on channel.
   * Return i if tokens[i] is on channel. Return -1 if there are no tokens
   * on channel between i and 0.
   */


  previousTokenOnChannel(i, channel) {
    while (i >= 0 && this.tokens[i].channel !== channel) {
      i -= 1;
    }

    return i;
  }
  /**
   * Collect all tokens on specified channel to the right of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL or
   * EOF. If channel is -1, find any non default channel token.
   */


  getHiddenTokensToRight(tokenIndex, channel) {
    if (channel === undefined) {
      channel = -1;
    }

    this.lazyInit();

    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }

    const nextOnChannel = this.nextTokenOnChannel(tokenIndex + 1, Lexer.DEFAULT_TOKEN_CHANNEL);
    const from_ = tokenIndex + 1; // if none onchannel to right, nextOnChannel=-1 so set to = last token

    const to = nextOnChannel === -1 ? this.tokens.length - 1 : nextOnChannel;
    return this.filterForChannel(from_, to, channel);
  }
  /**
   * Collect all tokens on specified channel to the left of
   * the current token up until we see a token on DEFAULT_TOKEN_CHANNEL.
   * If channel is -1, find any non default channel token.
   */


  getHiddenTokensToLeft(tokenIndex, channel) {
    if (channel === undefined) {
      channel = -1;
    }

    this.lazyInit();

    if (tokenIndex < 0 || tokenIndex >= this.tokens.length) {
      throw "" + tokenIndex + " not in 0.." + this.tokens.length - 1;
    }

    const prevOnChannel = this.previousTokenOnChannel(tokenIndex - 1, Lexer.DEFAULT_TOKEN_CHANNEL);

    if (prevOnChannel === tokenIndex - 1) {
      return null;
    } // if none on channel to left, prevOnChannel=-1 then from=0


    const from_ = prevOnChannel + 1;
    const to = tokenIndex - 1;
    return this.filterForChannel(from_, to, channel);
  }

  filterForChannel(left, right, channel) {
    const hidden = [];

    for (let i = left; i < right + 1; i++) {
      const t = this.tokens[i];

      if (channel === -1) {
        if (t.channel !== Lexer.DEFAULT_TOKEN_CHANNEL) {
          hidden.push(t);
        }
      } else if (t.channel === channel) {
        hidden.push(t);
      }
    }

    if (hidden.length === 0) {
      return null;
    }

    return hidden;
  }

  getSourceName() {
    return this.tokenSource.getSourceName();
  } // Get the text of all tokens in this buffer.///


  getText(interval) {
    this.lazyInit();
    this.fill();

    if (interval === undefined || interval === null) {
      interval = new Interval(0, this.tokens.length - 1);
    }

    let start = interval.start;

    if (start instanceof Token) {
      start = start.tokenIndex;
    }

    let stop = interval.stop;

    if (stop instanceof Token) {
      stop = stop.tokenIndex;
    }

    if (start === null || stop === null || start < 0 || stop < 0) {
      return "";
    }

    if (stop >= this.tokens.length) {
      stop = this.tokens.length - 1;
    }

    let s = "";

    for (let i = start; i < stop + 1; i++) {
      const t = this.tokens[i];

      if (t.type === Token.EOF) {
        break;
      }

      s = s + t.text;
    }

    return s;
  } // Get all tokens from lexer until EOF///


  fill() {
    this.lazyInit();

    while (this.fetch(1000) === 1000) {
      continue;
    }
  }

}

module.exports = BufferedTokenStream;

/***/ }),
/* 51 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */
const {
  Token
} = __webpack_require__(12);

const {
  ParseTreeListener,
  TerminalNode,
  ErrorNode
} = __webpack_require__(20);

const Recognizer = __webpack_require__(28);

const {
  DefaultErrorStrategy
} = __webpack_require__(47);

const ATNDeserializer = __webpack_require__(22);

const ATNDeserializationOptions = __webpack_require__(24);

const Lexer = __webpack_require__(27);

class TraceListener extends ParseTreeListener {
  constructor(parser) {
    super();
    this.parser = parser;
  }

  enterEveryRule(ctx) {
    console.log("enter   " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }

  visitTerminal(node) {
    console.log("consume " + node.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
  }

  exitEveryRule(ctx) {
    console.log("exit    " + this.parser.ruleNames[ctx.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
  }

}

class Parser extends Recognizer {
  /**
   * this is all the parsing support code essentially; most of it is error
   * recovery stuff.
   */
  constructor(input) {
    super(); // The input stream.

    this._input = null;
    /**
     * The error handling strategy for the parser. The default value is a new
     * instance of {@link DefaultErrorStrategy}.
     */

    this._errHandler = new DefaultErrorStrategy();
    this._precedenceStack = [];

    this._precedenceStack.push(0);
    /**
     * The {@link ParserRuleContext} object for the currently executing rule.
     * this is always non-null during the parsing process.
     */


    this._ctx = null;
    /**
     * Specifies whether or not the parser should construct a parse tree during
     * the parsing process. The default value is {@code true}.
     */

    this.buildParseTrees = true;
    /**
     * When {@link //setTrace}{@code (true)} is called, a reference to the
     * {@link TraceListener} is stored here so it can be easily removed in a
     * later call to {@link //setTrace}{@code (false)}. The listener itself is
     * implemented as a parser listener so this field is not directly used by
     * other parser methods.
     */

    this._tracer = null;
    /**
     * The list of {@link ParseTreeListener} listeners registered to receive
     * events during the parse.
     */

    this._parseListeners = null;
    /**
     * The number of syntax errors reported during parsing. this value is
     * incremented each time {@link //notifyErrorListeners} is called.
     */

    this._syntaxErrors = 0;
    this.setInputStream(input);
  } // reset the parser's state


  reset() {
    if (this._input !== null) {
      this._input.seek(0);
    }

    this._errHandler.reset(this);

    this._ctx = null;
    this._syntaxErrors = 0;
    this.setTrace(false);
    this._precedenceStack = [];

    this._precedenceStack.push(0);

    if (this._interp !== null) {
      this._interp.reset();
    }
  }
  /**
   * Match current input symbol against {@code ttype}. If the symbol type
   * matches, {@link ANTLRErrorStrategy//reportMatch} and {@link //consume} are
   * called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @param ttype the token type to match
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * {@code ttype} and the error strategy could not recover from the
   * mismatched symbol
   */


  match(ttype) {
    let t = this.getCurrentToken();

    if (t.type === ttype) {
      this._errHandler.reportMatch(this);

      this.consume();
    } else {
      t = this._errHandler.recoverInline(this);

      if (this.buildParseTrees && t.tokenIndex === -1) {
        // we must have conjured up a new token during single token
        // insertion
        // if it's not the current symbol
        this._ctx.addErrorNode(t);
      }
    }

    return t;
  }
  /**
   * Match current input symbol as a wildcard. If the symbol type matches
   * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy//reportMatch}
   * and {@link //consume} are called to complete the match process.
   *
   * <p>If the symbol type does not match,
   * {@link ANTLRErrorStrategy//recoverInline} is called on the current error
   * strategy to attempt recovery. If {@link //getBuildParseTree} is
   * {@code true} and the token index of the symbol returned by
   * {@link ANTLRErrorStrategy//recoverInline} is -1, the symbol is added to
   * the parse tree by calling {@link ParserRuleContext//addErrorNode}.</p>
   *
   * @return the matched symbol
   * @throws RecognitionException if the current input symbol did not match
   * a wildcard and the error strategy could not recover from the mismatched
   * symbol
   */


  matchWildcard() {
    let t = this.getCurrentToken();

    if (t.type > 0) {
      this._errHandler.reportMatch(this);

      this.consume();
    } else {
      t = this._errHandler.recoverInline(this);

      if (this._buildParseTrees && t.tokenIndex === -1) {
        // we must have conjured up a new token during single token
        // insertion
        // if it's not the current symbol
        this._ctx.addErrorNode(t);
      }
    }

    return t;
  }

  getParseListeners() {
    return this._parseListeners || [];
  }
  /**
   * Registers {@code listener} to receive events during the parsing process.
   *
   * <p>To support output-preserving grammar transformations (including but not
   * limited to left-recursion removal, automated left-factoring, and
   * optimized code generation), calls to listener methods during the parse
   * may differ substantially from calls made by
   * {@link ParseTreeWalker//DEFAULT} used after the parse is complete. In
   * particular, rule entry and exit events may occur in a different order
   * during the parse than after the parser. In addition, calls to certain
   * rule entry methods may be omitted.</p>
   *
   * <p>With the following specific exceptions, calls to listener events are
   * <em>deterministic</em>, i.e. for identical input the calls to listener
   * methods will be the same.</p>
   *
   * <ul>
   * <li>Alterations to the grammar used to generate code may change the
   * behavior of the listener calls.</li>
   * <li>Alterations to the command line options passed to ANTLR 4 when
   * generating the parser may change the behavior of the listener calls.</li>
   * <li>Changing the version of the ANTLR Tool used to generate the parser
   * may change the behavior of the listener calls.</li>
   * </ul>
   *
   * @param listener the listener to add
   *
   * @throws NullPointerException if {@code} listener is {@code null}
   */


  addParseListener(listener) {
    if (listener === null) {
      throw "listener";
    }

    if (this._parseListeners === null) {
      this._parseListeners = [];
    }

    this._parseListeners.push(listener);
  }
  /**
   * Remove {@code listener} from the list of parse listeners.
   *
   * <p>If {@code listener} is {@code null} or has not been added as a parse
   * listener, this method does nothing.</p>
   * @param listener the listener to remove
   */


  removeParseListener(listener) {
    if (this._parseListeners !== null) {
      const idx = this._parseListeners.indexOf(listener);

      if (idx >= 0) {
        this._parseListeners.splice(idx, 1);
      }

      if (this._parseListeners.length === 0) {
        this._parseListeners = null;
      }
    }
  } // Remove all parse listeners.


  removeParseListeners() {
    this._parseListeners = null;
  } // Notify any parse listeners of an enter rule event.


  triggerEnterRuleEvent() {
    if (this._parseListeners !== null) {
      const ctx = this._ctx;

      this._parseListeners.forEach(function (listener) {
        listener.enterEveryRule(ctx);
        ctx.enterRule(listener);
      });
    }
  }
  /**
   * Notify any parse listeners of an exit rule event.
   * @see //addParseListener
   */


  triggerExitRuleEvent() {
    if (this._parseListeners !== null) {
      // reverse order walk of listeners
      const ctx = this._ctx;

      this._parseListeners.slice(0).reverse().forEach(function (listener) {
        ctx.exitRule(listener);
        listener.exitEveryRule(ctx);
      });
    }
  }

  getTokenFactory() {
    return this._input.tokenSource._factory;
  } // Tell our token source and error strategy about a new way to create tokens.


  setTokenFactory(factory) {
    this._input.tokenSource._factory = factory;
  }
  /**
   * The ATN with bypass alternatives is expensive to create so we create it
   * lazily.
   *
   * @throws UnsupportedOperationException if the current parser does not
   * implement the {@link //getSerializedATN()} method.
   */


  getATNWithBypassAlts() {
    const serializedAtn = this.getSerializedATN();

    if (serializedAtn === null) {
      throw "The current parser does not support an ATN with bypass alternatives.";
    }

    let result = this.bypassAltsAtnCache[serializedAtn];

    if (result === null) {
      const deserializationOptions = new ATNDeserializationOptions();
      deserializationOptions.generateRuleBypassTransitions = true;
      result = new ATNDeserializer(deserializationOptions).deserialize(serializedAtn);
      this.bypassAltsAtnCache[serializedAtn] = result;
    }

    return result;
  }
  /**
   * The preferred method of getting a tree pattern. For example, here's a
   * sample use:
   *
   * <pre>
   * ParseTree t = parser.expr();
   * ParseTreePattern p = parser.compileParseTreePattern("&lt;ID&gt;+0",
   * MyParser.RULE_expr);
   * ParseTreeMatch m = p.match(t);
   * String id = m.get("ID");
   * </pre>
   */


  compileParseTreePattern(pattern, patternRuleIndex, lexer) {
    lexer = lexer || null;

    if (lexer === null) {
      if (this.getTokenStream() !== null) {
        const tokenSource = this.getTokenStream().tokenSource;

        if (tokenSource instanceof Lexer) {
          lexer = tokenSource;
        }
      }
    }

    if (lexer === null) {
      throw "Parser can't discover a lexer to use";
    }

    const m = new ParseTreePatternMatcher(lexer, this);
    return m.compile(pattern, patternRuleIndex);
  }

  getInputStream() {
    return this.getTokenStream();
  }

  setInputStream(input) {
    this.setTokenStream(input);
  }

  getTokenStream() {
    return this._input;
  } // Set the token stream and reset the parser.


  setTokenStream(input) {
    this._input = null;
    this.reset();
    this._input = input;
  }
  /**
   * Match needs to return the current input symbol, which gets put
   * into the label for the associated token ref; e.g., x=ID.
   */


  getCurrentToken() {
    return this._input.LT(1);
  }

  notifyErrorListeners(msg, offendingToken, err) {
    offendingToken = offendingToken || null;
    err = err || null;

    if (offendingToken === null) {
      offendingToken = this.getCurrentToken();
    }

    this._syntaxErrors += 1;
    const line = offendingToken.line;
    const column = offendingToken.column;
    const listener = this.getErrorListenerDispatch();
    listener.syntaxError(this, offendingToken, line, column, msg, err);
  }
  /**
   * Consume and return the {@linkplain //getCurrentToken current symbol}.
   *
   * <p>E.g., given the following input with {@code A} being the current
   * lookahead symbol, this function moves the cursor to {@code B} and returns
   * {@code A}.</p>
   *
   * <pre>
   * A B
   * ^
   * </pre>
   *
   * If the parser is not in error recovery mode, the consumed symbol is added
   * to the parse tree using {@link ParserRuleContext//addChild(Token)}, and
   * {@link ParseTreeListener//visitTerminal} is called on any parse listeners.
   * If the parser <em>is</em> in error recovery mode, the consumed symbol is
   * added to the parse tree using
   * {@link ParserRuleContext//addErrorNode(Token)}, and
   * {@link ParseTreeListener//visitErrorNode} is called on any parse
   * listeners.
   */


  consume() {
    const o = this.getCurrentToken();

    if (o.type !== Token.EOF) {
      this.getInputStream().consume();
    }

    const hasListener = this._parseListeners !== null && this._parseListeners.length > 0;

    if (this.buildParseTrees || hasListener) {
      let node;

      if (this._errHandler.inErrorRecoveryMode(this)) {
        node = this._ctx.addErrorNode(o);
      } else {
        node = this._ctx.addTokenNode(o);
      }

      node.invokingState = this.state;

      if (hasListener) {
        this._parseListeners.forEach(function (listener) {
          if (node instanceof ErrorNode || node.isErrorNode !== undefined && node.isErrorNode()) {
            listener.visitErrorNode(node);
          } else if (node instanceof TerminalNode) {
            listener.visitTerminal(node);
          }
        });
      }
    }

    return o;
  }

  addContextToParseTree() {
    // add current context to parent if we have a parent
    if (this._ctx.parentCtx !== null) {
      this._ctx.parentCtx.addChild(this._ctx);
    }
  }
  /**
   * Always called by generated parsers upon entry to a rule. Access field
   * {@link //_ctx} get the current context.
   */


  enterRule(localctx, state, ruleIndex) {
    this.state = state;
    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);

    if (this.buildParseTrees) {
      this.addContextToParseTree();
    }

    this.triggerEnterRuleEvent();
  }

  exitRule() {
    this._ctx.stop = this._input.LT(-1); // trigger event on _ctx, before it reverts to parent

    this.triggerExitRuleEvent();
    this.state = this._ctx.invokingState;
    this._ctx = this._ctx.parentCtx;
  }

  enterOuterAlt(localctx, altNum) {
    localctx.setAltNumber(altNum); // if we have new localctx, make sure we replace existing ctx
    // that is previous child of parse tree

    if (this.buildParseTrees && this._ctx !== localctx) {
      if (this._ctx.parentCtx !== null) {
        this._ctx.parentCtx.removeLastChild();

        this._ctx.parentCtx.addChild(localctx);
      }
    }

    this._ctx = localctx;
  }
  /**
   * Get the precedence level for the top-most precedence rule.
   *
   * @return The precedence level for the top-most precedence rule, or -1 if
   * the parser context is not nested within a precedence rule.
   */


  getPrecedence() {
    if (this._precedenceStack.length === 0) {
      return -1;
    } else {
      return this._precedenceStack[this._precedenceStack.length - 1];
    }
  }

  enterRecursionRule(localctx, state, ruleIndex, precedence) {
    this.state = state;

    this._precedenceStack.push(precedence);

    this._ctx = localctx;
    this._ctx.start = this._input.LT(1);
    this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
  } // Like {@link //enterRule} but for recursive rules.


  pushNewRecursionContext(localctx, state, ruleIndex) {
    const previous = this._ctx;
    previous.parentCtx = localctx;
    previous.invokingState = state;
    previous.stop = this._input.LT(-1);
    this._ctx = localctx;
    this._ctx.start = previous.start;

    if (this.buildParseTrees) {
      this._ctx.addChild(previous);
    }

    this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules
  }

  unrollRecursionContexts(parentCtx) {
    this._precedenceStack.pop();

    this._ctx.stop = this._input.LT(-1);
    const retCtx = this._ctx; // save current ctx (return value)
    // unroll so _ctx is as it was before call to recursive method

    const parseListeners = this.getParseListeners();

    if (parseListeners !== null && parseListeners.length > 0) {
      while (this._ctx !== parentCtx) {
        this.triggerExitRuleEvent();
        this._ctx = this._ctx.parentCtx;
      }
    } else {
      this._ctx = parentCtx;
    } // hook into tree


    retCtx.parentCtx = parentCtx;

    if (this.buildParseTrees && parentCtx !== null) {
      // add return ctx into invoking rule's tree
      parentCtx.addChild(retCtx);
    }
  }

  getInvokingContext(ruleIndex) {
    let ctx = this._ctx;

    while (ctx !== null) {
      if (ctx.ruleIndex === ruleIndex) {
        return ctx;
      }

      ctx = ctx.parentCtx;
    }

    return null;
  }

  precpred(localctx, precedence) {
    return precedence >= this._precedenceStack[this._precedenceStack.length - 1];
  }

  inContext(context) {
    // TODO: useful in parser?
    return false;
  }
  /**
   * Checks whether or not {@code symbol} can follow the current state in the
   * ATN. The behavior of this method is equivalent to the following, but is
   * implemented such that the complete context-sensitive follow set does not
   * need to be explicitly constructed.
   *
   * <pre>
   * return getExpectedTokens().contains(symbol);
   * </pre>
   *
   * @param symbol the symbol type to check
   * @return {@code true} if {@code symbol} can follow the current state in
   * the ATN, otherwise {@code false}.
   */


  isExpectedToken(symbol) {
    const atn = this._interp.atn;
    let ctx = this._ctx;
    const s = atn.states[this.state];
    let following = atn.nextTokens(s);

    if (following.contains(symbol)) {
      return true;
    }

    if (!following.contains(Token.EPSILON)) {
      return false;
    }

    while (ctx !== null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {
      const invokingState = atn.states[ctx.invokingState];
      const rt = invokingState.transitions[0];
      following = atn.nextTokens(rt.followState);

      if (following.contains(symbol)) {
        return true;
      }

      ctx = ctx.parentCtx;
    }

    if (following.contains(Token.EPSILON) && symbol === Token.EOF) {
      return true;
    } else {
      return false;
    }
  }
  /**
   * Computes the set of input symbols which could follow the current parser
   * state and context, as given by {@link //getState} and {@link //getContext},
   * respectively.
   *
   * @see ATN//getExpectedTokens(int, RuleContext)
   */


  getExpectedTokens() {
    return this._interp.atn.getExpectedTokens(this.state, this._ctx);
  }

  getExpectedTokensWithinCurrentRule() {
    const atn = this._interp.atn;
    const s = atn.states[this.state];
    return atn.nextTokens(s);
  } // Get a rule's index (i.e., {@code RULE_ruleName} field) or -1 if not found.


  getRuleIndex(ruleName) {
    const ruleIndex = this.getRuleIndexMap()[ruleName];

    if (ruleIndex !== null) {
      return ruleIndex;
    } else {
      return -1;
    }
  }
  /**
   * Return List&lt;String&gt; of the rule names in your parser instance
   * leading up to a call to the current rule. You could override if
   * you want more details such as the file/line info of where
   * in the ATN a rule is invoked.
   *
   * this is very useful for error messages.
   */


  getRuleInvocationStack(p) {
    p = p || null;

    if (p === null) {
      p = this._ctx;
    }

    const stack = [];

    while (p !== null) {
      // compute what follows who invoked us
      const ruleIndex = p.ruleIndex;

      if (ruleIndex < 0) {
        stack.push("n/a");
      } else {
        stack.push(this.ruleNames[ruleIndex]);
      }

      p = p.parentCtx;
    }

    return stack;
  } // For debugging and other purposes.


  getDFAStrings() {
    return this._interp.decisionToDFA.toString();
  } // For debugging and other purposes.


  dumpDFA() {
    let seenOne = false;

    for (let i = 0; i < this._interp.decisionToDFA.length; i++) {
      const dfa = this._interp.decisionToDFA[i];

      if (dfa.states.length > 0) {
        if (seenOne) {
          console.log();
        }

        this.printer.println("Decision " + dfa.decision + ":");
        this.printer.print(dfa.toString(this.literalNames, this.symbolicNames));
        seenOne = true;
      }
    }
  }
  /*
  	"			printer = function() {\r\n" +
  	"				this.println = function(s) { document.getElementById('output') += s + '\\n'; }\r\n" +
  	"				this.print = function(s) { document.getElementById('output') += s; }\r\n" +
  	"			};\r\n" +
  	*/


  getSourceName() {
    return this._input.sourceName;
  }
  /**
   * During a parse is sometimes useful to listen in on the rule entry and exit
   * events as well as token matches. this is for quick and dirty debugging.
   */


  setTrace(trace) {
    if (!trace) {
      this.removeParseListener(this._tracer);
      this._tracer = null;
    } else {
      if (this._tracer !== null) {
        this.removeParseListener(this._tracer);
      }

      this._tracer = new TraceListener(this);
      this.addParseListener(this._tracer);
    }
  }

}
/**
 * this field maps from the serialized ATN string to the deserialized {@link
 * ATN} with
 * bypass alternatives.
 *
 * @see ATNDeserializationOptions//isGenerateRuleBypassTransitions()
 */


Parser.bypassAltsAtnCache = {};
module.exports = Parser;

/***/ }),
/* 52 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated from FHIRPath.g4 by ANTLR 4.9.3
// jshint ignore: start
const antlr4 = __webpack_require__(7);

const serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786", "\u5964\u0002A\u0203\b\u0001\u0004\u0002\t\u0002\u0004\u0003\t\u0003", "\u0004\u0004\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007", "\t\u0007\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004", "\f\t\f\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010", "\t\u0010\u0004\u0011\t\u0011\u0004\u0012\t\u0012\u0004\u0013\t\u0013", "\u0004\u0014\t\u0014\u0004\u0015\t\u0015\u0004\u0016\t\u0016\u0004\u0017", "\t\u0017\u0004\u0018\t\u0018\u0004\u0019\t\u0019\u0004\u001a\t\u001a", "\u0004\u001b\t\u001b\u0004\u001c\t\u001c\u0004\u001d\t\u001d\u0004\u001e", "\t\u001e\u0004\u001f\t\u001f\u0004 \t \u0004!\t!\u0004\"\t\"\u0004#", "\t#\u0004$\t$\u0004%\t%\u0004&\t&\u0004\'\t\'\u0004(\t(\u0004)\t)\u0004", "*\t*\u0004+\t+\u0004,\t,\u0004-\t-\u0004.\t.\u0004/\t/\u00040\t0\u0004", "1\t1\u00042\t2\u00043\t3\u00044\t4\u00045\t5\u00046\t6\u00047\t7\u0004", "8\t8\u00049\t9\u0004:\t:\u0004;\t;\u0004<\t<\u0004=\t=\u0004>\t>\u0004", "?\t?\u0004@\t@\u0004A\tA\u0004B\tB\u0004C\tC\u0004D\tD\u0003\u0002\u0003", "\u0002\u0003\u0003\u0003\u0003\u0003\u0004\u0003\u0004\u0003\u0005\u0003", "\u0005\u0003\u0006\u0003\u0006\u0003\u0007\u0003\u0007\u0003\b\u0003", "\b\u0003\t\u0003\t\u0003\t\u0003\t\u0003\n\u0003\n\u0003\n\u0003\n\u0003", "\u000b\u0003\u000b\u0003\f\u0003\f\u0003\r\u0003\r\u0003\r\u0003\u000e", "\u0003\u000e\u0003\u000f\u0003\u000f\u0003\u0010\u0003\u0010\u0003\u0010", "\u0003\u0011\u0003\u0011\u0003\u0011\u0003\u0012\u0003\u0012\u0003\u0012", "\u0003\u0013\u0003\u0013\u0003\u0014\u0003\u0014\u0003\u0015\u0003\u0015", "\u0003\u0015\u0003\u0016\u0003\u0016\u0003\u0016\u0003\u0017\u0003\u0017", "\u0003\u0017\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018", "\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0018\u0003\u0019\u0003\u0019", "\u0003\u0019\u0003\u0019\u0003\u001a\u0003\u001a\u0003\u001a\u0003\u001b", "\u0003\u001b\u0003\u001b\u0003\u001b\u0003\u001c\u0003\u001c\u0003\u001c", "\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001c\u0003\u001d", "\u0003\u001d\u0003\u001e\u0003\u001e\u0003\u001f\u0003\u001f\u0003 ", "\u0003 \u0003!\u0003!\u0003!\u0003!\u0003!\u0003\"\u0003\"\u0003\"\u0003", "\"\u0003\"\u0003\"\u0003#\u0003#\u0003$\u0003$\u0003$\u0003$\u0003$", "\u0003$\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003%\u0003&\u0003", "&\u0003&\u0003&\u0003&\u0003&\u0003&\u0003\'\u0003\'\u0003(\u0003(\u0003", "(\u0003(\u0003(\u0003)\u0003)\u0003)\u0003)\u0003)\u0003)\u0003*\u0003", "*\u0003*\u0003*\u0003*\u0003+\u0003+\u0003+\u0003+\u0003,\u0003,\u0003", ",\u0003,\u0003,\u0003-\u0003-\u0003-\u0003-\u0003-\u0003-\u0003-\u0003", ".\u0003.\u0003.\u0003.\u0003.\u0003.\u0003.\u0003/\u0003/\u0003/\u0003", "/\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u0003/\u00030\u0003", "0\u00030\u00030\u00030\u00030\u00031\u00031\u00031\u00031\u00031\u0003", "1\u00031\u00032\u00032\u00032\u00032\u00032\u00032\u00033\u00033\u0003", "3\u00033\u00033\u00034\u00034\u00034\u00034\u00034\u00034\u00035\u0003", "5\u00035\u00035\u00035\u00035\u00035\u00035\u00036\u00036\u00036\u0003", "6\u00036\u00036\u00036\u00036\u00037\u00037\u00037\u00037\u00037\u0003", "7\u00037\u00037\u00037\u00037\u00037\u00037\u00037\u00038\u00038\u0003", "8\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u00038\u0003", "8\u00058\u0183\n8\u00058\u0185\n8\u00058\u0187\n8\u00038\u00058\u018a", "\n8\u00039\u00039\u00039\u00039\u0003:\u0003:\u0003:\u0003:\u0003:\u0003", ":\u0003:\u0003:\u0003:\u0003:\u0006:\u019a\n:\r:\u000e:\u019b\u0005", ":\u019e\n:\u0005:\u01a0\n:\u0005:\u01a2\n:\u0003:\u0003:\u0003:\u0003", ":\u0003:\u0003:\u0003:\u0005:\u01ab\n:\u0003;\u0005;\u01ae\n;\u0003", ";\u0007;\u01b1\n;\f;\u000e;\u01b4\u000b;\u0003<\u0003<\u0003<\u0007", "<\u01b9\n<\f<\u000e<\u01bc\u000b<\u0003<\u0003<\u0003=\u0003=\u0003", "=\u0007=\u01c3\n=\f=\u000e=\u01c6\u000b=\u0003=\u0003=\u0003>\u0006", ">\u01cb\n>\r>\u000e>\u01cc\u0003>\u0003>\u0006>\u01d1\n>\r>\u000e>\u01d2", "\u0005>\u01d5\n>\u0003?\u0006?\u01d8\n?\r?\u000e?\u01d9\u0003?\u0003", "?\u0003@\u0003@\u0003@\u0003@\u0007@\u01e2\n@\f@\u000e@\u01e5\u000b", "@\u0003@\u0003@\u0003@\u0003@\u0003@\u0003A\u0003A\u0003A\u0003A\u0007", "A\u01f0\nA\fA\u000eA\u01f3\u000bA\u0003A\u0003A\u0003B\u0003B\u0003", "B\u0005B\u01fa\nB\u0003C\u0003C\u0003C\u0003C\u0003C\u0003C\u0003D\u0003", "D\u0003\u01e3\u0002E\u0003\u0003\u0005\u0004\u0007\u0005\t\u0006\u000b", "\u0007\r\b\u000f\t\u0011\n\u0013\u000b\u0015\f\u0017\r\u0019\u000e\u001b", "\u000f\u001d\u0010\u001f\u0011!\u0012#\u0013%\u0014\'\u0015)\u0016+", "\u0017-\u0018/\u00191\u001a3\u001b5\u001c7\u001d9\u001e;\u001f= ?!A", "\"C#E$G%I&K\'M(O)Q*S+U,W-Y.[/]0_1a2c3e4g5i6k7m8o9q:s\u0002u;w<y={>}", "?\u007f@\u0081A\u0083\u0002\u0085\u0002\u0087\u0002\u0003\u0002\f\u0003", "\u00022;\u0004\u0002--//\u0005\u0002C\\aac|\u0006\u00022;C\\aac|\u0004", "\u0002^^bb\u0003\u0002))\u0005\u0002\u000b\f\u000f\u000f\"\"\u0004\u0002", "\f\f\u000f\u000f\n\u0002))11^^bbhhppttvv\u0005\u00022;CHch\u0002\u0214", "\u0002\u0003\u0003\u0002\u0002\u0002\u0002\u0005\u0003\u0002\u0002\u0002", "\u0002\u0007\u0003\u0002\u0002\u0002\u0002\t\u0003\u0002\u0002\u0002", "\u0002\u000b\u0003\u0002\u0002\u0002\u0002\r\u0003\u0002\u0002\u0002", "\u0002\u000f\u0003\u0002\u0002\u0002\u0002\u0011\u0003\u0002\u0002\u0002", "\u0002\u0013\u0003\u0002\u0002\u0002\u0002\u0015\u0003\u0002\u0002\u0002", "\u0002\u0017\u0003\u0002\u0002\u0002\u0002\u0019\u0003\u0002\u0002\u0002", "\u0002\u001b\u0003\u0002\u0002\u0002\u0002\u001d\u0003\u0002\u0002\u0002", "\u0002\u001f\u0003\u0002\u0002\u0002\u0002!\u0003\u0002\u0002\u0002", "\u0002#\u0003\u0002\u0002\u0002\u0002%\u0003\u0002\u0002\u0002\u0002", "\'\u0003\u0002\u0002\u0002\u0002)\u0003\u0002\u0002\u0002\u0002+\u0003", "\u0002\u0002\u0002\u0002-\u0003\u0002\u0002\u0002\u0002/\u0003\u0002", "\u0002\u0002\u00021\u0003\u0002\u0002\u0002\u00023\u0003\u0002\u0002", "\u0002\u00025\u0003\u0002\u0002\u0002\u00027\u0003\u0002\u0002\u0002", "\u00029\u0003\u0002\u0002\u0002\u0002;\u0003\u0002\u0002\u0002\u0002", "=\u0003\u0002\u0002\u0002\u0002?\u0003\u0002\u0002\u0002\u0002A\u0003", "\u0002\u0002\u0002\u0002C\u0003\u0002\u0002\u0002\u0002E\u0003\u0002", "\u0002\u0002\u0002G\u0003\u0002\u0002\u0002\u0002I\u0003\u0002\u0002", "\u0002\u0002K\u0003\u0002\u0002\u0002\u0002M\u0003\u0002\u0002\u0002", "\u0002O\u0003\u0002\u0002\u0002\u0002Q\u0003\u0002\u0002\u0002\u0002", "S\u0003\u0002\u0002\u0002\u0002U\u0003\u0002\u0002\u0002\u0002W\u0003", "\u0002\u0002\u0002\u0002Y\u0003\u0002\u0002\u0002\u0002[\u0003\u0002", "\u0002\u0002\u0002]\u0003\u0002\u0002\u0002\u0002_\u0003\u0002\u0002", "\u0002\u0002a\u0003\u0002\u0002\u0002\u0002c\u0003\u0002\u0002\u0002", "\u0002e\u0003\u0002\u0002\u0002\u0002g\u0003\u0002\u0002\u0002\u0002", "i\u0003\u0002\u0002\u0002\u0002k\u0003\u0002\u0002\u0002\u0002m\u0003", "\u0002\u0002\u0002\u0002o\u0003\u0002\u0002\u0002\u0002q\u0003\u0002", "\u0002\u0002\u0002u\u0003\u0002\u0002\u0002\u0002w\u0003\u0002\u0002", "\u0002\u0002y\u0003\u0002\u0002\u0002\u0002{\u0003\u0002\u0002\u0002", "\u0002}\u0003\u0002\u0002\u0002\u0002\u007f\u0003\u0002\u0002\u0002", "\u0002\u0081\u0003\u0002\u0002\u0002\u0003\u0089\u0003\u0002\u0002\u0002", "\u0005\u008b\u0003\u0002\u0002\u0002\u0007\u008d\u0003\u0002\u0002\u0002", "\t\u008f\u0003\u0002\u0002\u0002\u000b\u0091\u0003\u0002\u0002\u0002", "\r\u0093\u0003\u0002\u0002\u0002\u000f\u0095\u0003\u0002\u0002\u0002", "\u0011\u0097\u0003\u0002\u0002\u0002\u0013\u009b\u0003\u0002\u0002\u0002", "\u0015\u009f\u0003\u0002\u0002\u0002\u0017\u00a1\u0003\u0002\u0002\u0002", "\u0019\u00a3\u0003\u0002\u0002\u0002\u001b\u00a6\u0003\u0002\u0002\u0002", "\u001d\u00a8\u0003\u0002\u0002\u0002\u001f\u00aa\u0003\u0002\u0002\u0002", "!\u00ad\u0003\u0002\u0002\u0002#\u00b0\u0003\u0002\u0002\u0002%\u00b3", "\u0003\u0002\u0002\u0002\'\u00b5\u0003\u0002\u0002\u0002)\u00b7\u0003", "\u0002\u0002\u0002+\u00ba\u0003\u0002\u0002\u0002-\u00bd\u0003\u0002", "\u0002\u0002/\u00c0\u0003\u0002\u0002\u00021\u00c9\u0003\u0002\u0002", "\u00023\u00cd\u0003\u0002\u0002\u00025\u00d0\u0003\u0002\u0002\u0002", "7\u00d4\u0003\u0002\u0002\u00029\u00dc\u0003\u0002\u0002\u0002;\u00de", "\u0003\u0002\u0002\u0002=\u00e0\u0003\u0002\u0002\u0002?\u00e2\u0003", "\u0002\u0002\u0002A\u00e4\u0003\u0002\u0002\u0002C\u00e9\u0003\u0002", "\u0002\u0002E\u00ef\u0003\u0002\u0002\u0002G\u00f1\u0003\u0002\u0002", "\u0002I\u00f7\u0003\u0002\u0002\u0002K\u00fe\u0003\u0002\u0002\u0002", "M\u0105\u0003\u0002\u0002\u0002O\u0107\u0003\u0002\u0002\u0002Q\u010c", "\u0003\u0002\u0002\u0002S\u0112\u0003\u0002\u0002\u0002U\u0117\u0003", "\u0002\u0002\u0002W\u011b\u0003\u0002\u0002\u0002Y\u0120\u0003\u0002", "\u0002\u0002[\u0127\u0003\u0002\u0002\u0002]\u012e\u0003\u0002\u0002", "\u0002_\u013a\u0003\u0002\u0002\u0002a\u0140\u0003\u0002\u0002\u0002", "c\u0147\u0003\u0002\u0002\u0002e\u014d\u0003\u0002\u0002\u0002g\u0152", "\u0003\u0002\u0002\u0002i\u0158\u0003\u0002\u0002\u0002k\u0160\u0003", "\u0002\u0002\u0002m\u0168\u0003\u0002\u0002\u0002o\u0175\u0003\u0002", "\u0002\u0002q\u018b\u0003\u0002\u0002\u0002s\u018f\u0003\u0002\u0002", "\u0002u\u01ad\u0003\u0002\u0002\u0002w\u01b5\u0003\u0002\u0002\u0002", "y\u01bf\u0003\u0002\u0002\u0002{\u01ca\u0003\u0002\u0002\u0002}\u01d7", "\u0003\u0002\u0002\u0002\u007f\u01dd\u0003\u0002\u0002\u0002\u0081\u01eb", "\u0003\u0002\u0002\u0002\u0083\u01f6\u0003\u0002\u0002\u0002\u0085\u01fb", "\u0003\u0002\u0002\u0002\u0087\u0201\u0003\u0002\u0002\u0002\u0089\u008a", "\u00070\u0002\u0002\u008a\u0004\u0003\u0002\u0002\u0002\u008b\u008c", "\u0007]\u0002\u0002\u008c\u0006\u0003\u0002\u0002\u0002\u008d\u008e", "\u0007_\u0002\u0002\u008e\b\u0003\u0002\u0002\u0002\u008f\u0090\u0007", "-\u0002\u0002\u0090\n\u0003\u0002\u0002\u0002\u0091\u0092\u0007/\u0002", "\u0002\u0092\f\u0003\u0002\u0002\u0002\u0093\u0094\u0007,\u0002\u0002", "\u0094\u000e\u0003\u0002\u0002\u0002\u0095\u0096\u00071\u0002\u0002", "\u0096\u0010\u0003\u0002\u0002\u0002\u0097\u0098\u0007f\u0002\u0002", "\u0098\u0099\u0007k\u0002\u0002\u0099\u009a\u0007x\u0002\u0002\u009a", "\u0012\u0003\u0002\u0002\u0002\u009b\u009c\u0007o\u0002\u0002\u009c", "\u009d\u0007q\u0002\u0002\u009d\u009e\u0007f\u0002\u0002\u009e\u0014", "\u0003\u0002\u0002\u0002\u009f\u00a0\u0007(\u0002\u0002\u00a0\u0016", "\u0003\u0002\u0002\u0002\u00a1\u00a2\u0007~\u0002\u0002\u00a2\u0018", "\u0003\u0002\u0002\u0002\u00a3\u00a4\u0007>\u0002\u0002\u00a4\u00a5", "\u0007?\u0002\u0002\u00a5\u001a\u0003\u0002\u0002\u0002\u00a6\u00a7", "\u0007>\u0002\u0002\u00a7\u001c\u0003\u0002\u0002\u0002\u00a8\u00a9", "\u0007@\u0002\u0002\u00a9\u001e\u0003\u0002\u0002\u0002\u00aa\u00ab", "\u0007@\u0002\u0002\u00ab\u00ac\u0007?\u0002\u0002\u00ac \u0003\u0002", "\u0002\u0002\u00ad\u00ae\u0007k\u0002\u0002\u00ae\u00af\u0007u\u0002", "\u0002\u00af\"\u0003\u0002\u0002\u0002\u00b0\u00b1\u0007c\u0002\u0002", "\u00b1\u00b2\u0007u\u0002\u0002\u00b2$\u0003\u0002\u0002\u0002\u00b3", "\u00b4\u0007?\u0002\u0002\u00b4&\u0003\u0002\u0002\u0002\u00b5\u00b6", "\u0007\u0080\u0002\u0002\u00b6(\u0003\u0002\u0002\u0002\u00b7\u00b8", "\u0007#\u0002\u0002\u00b8\u00b9\u0007?\u0002\u0002\u00b9*\u0003\u0002", "\u0002\u0002\u00ba\u00bb\u0007#\u0002\u0002\u00bb\u00bc\u0007\u0080", "\u0002\u0002\u00bc,\u0003\u0002\u0002\u0002\u00bd\u00be\u0007k\u0002", "\u0002\u00be\u00bf\u0007p\u0002\u0002\u00bf.\u0003\u0002\u0002\u0002", "\u00c0\u00c1\u0007e\u0002\u0002\u00c1\u00c2\u0007q\u0002\u0002\u00c2", "\u00c3\u0007p\u0002\u0002\u00c3\u00c4\u0007v\u0002\u0002\u00c4\u00c5", "\u0007c\u0002\u0002\u00c5\u00c6\u0007k\u0002\u0002\u00c6\u00c7\u0007", "p\u0002\u0002\u00c7\u00c8\u0007u\u0002\u0002\u00c80\u0003\u0002\u0002", "\u0002\u00c9\u00ca\u0007c\u0002\u0002\u00ca\u00cb\u0007p\u0002\u0002", "\u00cb\u00cc\u0007f\u0002\u0002\u00cc2\u0003\u0002\u0002\u0002\u00cd", "\u00ce\u0007q\u0002\u0002\u00ce\u00cf\u0007t\u0002\u0002\u00cf4\u0003", "\u0002\u0002\u0002\u00d0\u00d1\u0007z\u0002\u0002\u00d1\u00d2\u0007", "q\u0002\u0002\u00d2\u00d3\u0007t\u0002\u0002\u00d36\u0003\u0002\u0002", "\u0002\u00d4\u00d5\u0007k\u0002\u0002\u00d5\u00d6\u0007o\u0002\u0002", "\u00d6\u00d7\u0007r\u0002\u0002\u00d7\u00d8\u0007n\u0002\u0002\u00d8", "\u00d9\u0007k\u0002\u0002\u00d9\u00da\u0007g\u0002\u0002\u00da\u00db", "\u0007u\u0002\u0002\u00db8\u0003\u0002\u0002\u0002\u00dc\u00dd\u0007", "*\u0002\u0002\u00dd:\u0003\u0002\u0002\u0002\u00de\u00df\u0007+\u0002", "\u0002\u00df<\u0003\u0002\u0002\u0002\u00e0\u00e1\u0007}\u0002\u0002", "\u00e1>\u0003\u0002\u0002\u0002\u00e2\u00e3\u0007\u007f\u0002\u0002", "\u00e3@\u0003\u0002\u0002\u0002\u00e4\u00e5\u0007v\u0002\u0002\u00e5", "\u00e6\u0007t\u0002\u0002\u00e6\u00e7\u0007w\u0002\u0002\u00e7\u00e8", "\u0007g\u0002\u0002\u00e8B\u0003\u0002\u0002\u0002\u00e9\u00ea\u0007", "h\u0002\u0002\u00ea\u00eb\u0007c\u0002\u0002\u00eb\u00ec\u0007n\u0002", "\u0002\u00ec\u00ed\u0007u\u0002\u0002\u00ed\u00ee\u0007g\u0002\u0002", "\u00eeD\u0003\u0002\u0002\u0002\u00ef\u00f0\u0007\'\u0002\u0002\u00f0", "F\u0003\u0002\u0002\u0002\u00f1\u00f2\u0007&\u0002\u0002\u00f2\u00f3", "\u0007v\u0002\u0002\u00f3\u00f4\u0007j\u0002\u0002\u00f4\u00f5\u0007", "k\u0002\u0002\u00f5\u00f6\u0007u\u0002\u0002\u00f6H\u0003\u0002\u0002", "\u0002\u00f7\u00f8\u0007&\u0002\u0002\u00f8\u00f9\u0007k\u0002\u0002", "\u00f9\u00fa\u0007p\u0002\u0002\u00fa\u00fb\u0007f\u0002\u0002\u00fb", "\u00fc\u0007g\u0002\u0002\u00fc\u00fd\u0007z\u0002\u0002\u00fdJ\u0003", "\u0002\u0002\u0002\u00fe\u00ff\u0007&\u0002\u0002\u00ff\u0100\u0007", "v\u0002\u0002\u0100\u0101\u0007q\u0002\u0002\u0101\u0102\u0007v\u0002", "\u0002\u0102\u0103\u0007c\u0002\u0002\u0103\u0104\u0007n\u0002\u0002", "\u0104L\u0003\u0002\u0002\u0002\u0105\u0106\u0007.\u0002\u0002\u0106", "N\u0003\u0002\u0002\u0002\u0107\u0108\u0007{\u0002\u0002\u0108\u0109", "\u0007g\u0002\u0002\u0109\u010a\u0007c\u0002\u0002\u010a\u010b\u0007", "t\u0002\u0002\u010bP\u0003\u0002\u0002\u0002\u010c\u010d\u0007o\u0002", "\u0002\u010d\u010e\u0007q\u0002\u0002\u010e\u010f\u0007p\u0002\u0002", "\u010f\u0110\u0007v\u0002\u0002\u0110\u0111\u0007j\u0002\u0002\u0111", "R\u0003\u0002\u0002\u0002\u0112\u0113\u0007y\u0002\u0002\u0113\u0114", "\u0007g\u0002\u0002\u0114\u0115\u0007g\u0002\u0002\u0115\u0116\u0007", "m\u0002\u0002\u0116T\u0003\u0002\u0002\u0002\u0117\u0118\u0007f\u0002", "\u0002\u0118\u0119\u0007c\u0002\u0002\u0119\u011a\u0007{\u0002\u0002", "\u011aV\u0003\u0002\u0002\u0002\u011b\u011c\u0007j\u0002\u0002\u011c", "\u011d\u0007q\u0002\u0002\u011d\u011e\u0007w\u0002\u0002\u011e\u011f", "\u0007t\u0002\u0002\u011fX\u0003\u0002\u0002\u0002\u0120\u0121\u0007", "o\u0002\u0002\u0121\u0122\u0007k\u0002\u0002\u0122\u0123\u0007p\u0002", "\u0002\u0123\u0124\u0007w\u0002\u0002\u0124\u0125\u0007v\u0002\u0002", "\u0125\u0126\u0007g\u0002\u0002\u0126Z\u0003\u0002\u0002\u0002\u0127", "\u0128\u0007u\u0002\u0002\u0128\u0129\u0007g\u0002\u0002\u0129\u012a", "\u0007e\u0002\u0002\u012a\u012b\u0007q\u0002\u0002\u012b\u012c\u0007", "p\u0002\u0002\u012c\u012d\u0007f\u0002\u0002\u012d\\\u0003\u0002\u0002", "\u0002\u012e\u012f\u0007o\u0002\u0002\u012f\u0130\u0007k\u0002\u0002", "\u0130\u0131\u0007n\u0002\u0002\u0131\u0132\u0007n\u0002\u0002\u0132", "\u0133\u0007k\u0002\u0002\u0133\u0134\u0007u\u0002\u0002\u0134\u0135", "\u0007g\u0002\u0002\u0135\u0136\u0007e\u0002\u0002\u0136\u0137\u0007", "q\u0002\u0002\u0137\u0138\u0007p\u0002\u0002\u0138\u0139\u0007f\u0002", "\u0002\u0139^\u0003\u0002\u0002\u0002\u013a\u013b\u0007{\u0002\u0002", "\u013b\u013c\u0007g\u0002\u0002\u013c\u013d\u0007c\u0002\u0002\u013d", "\u013e\u0007t\u0002\u0002\u013e\u013f\u0007u\u0002\u0002\u013f`\u0003", "\u0002\u0002\u0002\u0140\u0141\u0007o\u0002\u0002\u0141\u0142\u0007", "q\u0002\u0002\u0142\u0143\u0007p\u0002\u0002\u0143\u0144\u0007v\u0002", "\u0002\u0144\u0145\u0007j\u0002\u0002\u0145\u0146\u0007u\u0002\u0002", "\u0146b\u0003\u0002\u0002\u0002\u0147\u0148\u0007y\u0002\u0002\u0148", "\u0149\u0007g\u0002\u0002\u0149\u014a\u0007g\u0002\u0002\u014a\u014b", "\u0007m\u0002\u0002\u014b\u014c\u0007u\u0002\u0002\u014cd\u0003\u0002", "\u0002\u0002\u014d\u014e\u0007f\u0002\u0002\u014e\u014f\u0007c\u0002", "\u0002\u014f\u0150\u0007{\u0002\u0002\u0150\u0151\u0007u\u0002\u0002", "\u0151f\u0003\u0002\u0002\u0002\u0152\u0153\u0007j\u0002\u0002\u0153", "\u0154\u0007q\u0002\u0002\u0154\u0155\u0007w\u0002\u0002\u0155\u0156", "\u0007t\u0002\u0002\u0156\u0157\u0007u\u0002\u0002\u0157h\u0003\u0002", "\u0002\u0002\u0158\u0159\u0007o\u0002\u0002\u0159\u015a\u0007k\u0002", "\u0002\u015a\u015b\u0007p\u0002\u0002\u015b\u015c\u0007w\u0002\u0002", "\u015c\u015d\u0007v\u0002\u0002\u015d\u015e\u0007g\u0002\u0002\u015e", "\u015f\u0007u\u0002\u0002\u015fj\u0003\u0002\u0002\u0002\u0160\u0161", "\u0007u\u0002\u0002\u0161\u0162\u0007g\u0002\u0002\u0162\u0163\u0007", "e\u0002\u0002\u0163\u0164\u0007q\u0002\u0002\u0164\u0165\u0007p\u0002", "\u0002\u0165\u0166\u0007f\u0002\u0002\u0166\u0167\u0007u\u0002\u0002", "\u0167l\u0003\u0002\u0002\u0002\u0168\u0169\u0007o\u0002\u0002\u0169", "\u016a\u0007k\u0002\u0002\u016a\u016b\u0007n\u0002\u0002\u016b\u016c", "\u0007n\u0002\u0002\u016c\u016d\u0007k\u0002\u0002\u016d\u016e\u0007", "u\u0002\u0002\u016e\u016f\u0007g\u0002\u0002\u016f\u0170\u0007e\u0002", "\u0002\u0170\u0171\u0007q\u0002\u0002\u0171\u0172\u0007p\u0002\u0002", "\u0172\u0173\u0007f\u0002\u0002\u0173\u0174\u0007u\u0002\u0002\u0174", "n\u0003\u0002\u0002\u0002\u0175\u0176\u0007B\u0002\u0002\u0176\u0177", "\t\u0002\u0002\u0002\u0177\u0178\t\u0002\u0002\u0002\u0178\u0179\t\u0002", "\u0002\u0002\u0179\u0186\t\u0002\u0002\u0002\u017a\u017b\u0007/\u0002", "\u0002\u017b\u017c\t\u0002\u0002\u0002\u017c\u0184\t\u0002\u0002\u0002", "\u017d\u017e\u0007/\u0002\u0002\u017e\u017f\t\u0002\u0002\u0002\u017f", "\u0182\t\u0002\u0002\u0002\u0180\u0181\u0007V\u0002\u0002\u0181\u0183", "\u0005s:\u0002\u0182\u0180\u0003\u0002\u0002\u0002\u0182\u0183\u0003", "\u0002\u0002\u0002\u0183\u0185\u0003\u0002\u0002\u0002\u0184\u017d\u0003", "\u0002\u0002\u0002\u0184\u0185\u0003\u0002\u0002\u0002\u0185\u0187\u0003", "\u0002\u0002\u0002\u0186\u017a\u0003\u0002\u0002\u0002\u0186\u0187\u0003", "\u0002\u0002\u0002\u0187\u0189\u0003\u0002\u0002\u0002\u0188\u018a\u0007", "\\\u0002\u0002\u0189\u0188\u0003\u0002\u0002\u0002\u0189\u018a\u0003", "\u0002\u0002\u0002\u018ap\u0003\u0002\u0002\u0002\u018b\u018c\u0007", "B\u0002\u0002\u018c\u018d\u0007V\u0002\u0002\u018d\u018e\u0005s:\u0002", "\u018er\u0003\u0002\u0002\u0002\u018f\u0190\t\u0002\u0002\u0002\u0190", "\u01a1\t\u0002\u0002\u0002\u0191\u0192\u0007<\u0002\u0002\u0192\u0193", "\t\u0002\u0002\u0002\u0193\u019f\t\u0002\u0002\u0002\u0194\u0195\u0007", "<\u0002\u0002\u0195\u0196\t\u0002\u0002\u0002\u0196\u019d\t\u0002\u0002", "\u0002\u0197\u0199\u00070\u0002\u0002\u0198\u019a\t\u0002\u0002\u0002", "\u0199\u0198\u0003\u0002\u0002\u0002\u019a\u019b\u0003\u0002\u0002\u0002", "\u019b\u0199\u0003\u0002\u0002\u0002\u019b\u019c\u0003\u0002\u0002\u0002", "\u019c\u019e\u0003\u0002\u0002\u0002\u019d\u0197\u0003\u0002\u0002\u0002", "\u019d\u019e\u0003\u0002\u0002\u0002\u019e\u01a0\u0003\u0002\u0002\u0002", "\u019f\u0194\u0003\u0002\u0002\u0002\u019f\u01a0\u0003\u0002\u0002\u0002", "\u01a0\u01a2\u0003\u0002\u0002\u0002\u01a1\u0191\u0003\u0002\u0002\u0002", "\u01a1\u01a2\u0003\u0002\u0002\u0002\u01a2\u01aa\u0003\u0002\u0002\u0002", "\u01a3\u01ab\u0007\\\u0002\u0002\u01a4\u01a5\t\u0003\u0002\u0002\u01a5", "\u01a6\t\u0002\u0002\u0002\u01a6\u01a7\t\u0002\u0002\u0002\u01a7\u01a8", "\u0007<\u0002\u0002\u01a8\u01a9\t\u0002\u0002\u0002\u01a9\u01ab\t\u0002", "\u0002\u0002\u01aa\u01a3\u0003\u0002\u0002\u0002\u01aa\u01a4\u0003\u0002", "\u0002\u0002\u01aa\u01ab\u0003\u0002\u0002\u0002\u01abt\u0003\u0002", "\u0002\u0002\u01ac\u01ae\t\u0004\u0002\u0002\u01ad\u01ac\u0003\u0002", "\u0002\u0002\u01ae\u01b2\u0003\u0002\u0002\u0002\u01af\u01b1\t\u0005", "\u0002\u0002\u01b0\u01af\u0003\u0002\u0002\u0002\u01b1\u01b4\u0003\u0002", "\u0002\u0002\u01b2\u01b0\u0003\u0002\u0002\u0002\u01b2\u01b3\u0003\u0002", "\u0002\u0002\u01b3v\u0003\u0002\u0002\u0002\u01b4\u01b2\u0003\u0002", "\u0002\u0002\u01b5\u01ba\u0007b\u0002\u0002\u01b6\u01b9\u0005\u0083", "B\u0002\u01b7\u01b9\n\u0006\u0002\u0002\u01b8\u01b6\u0003\u0002\u0002", "\u0002\u01b8\u01b7\u0003\u0002\u0002\u0002\u01b9\u01bc\u0003\u0002\u0002", "\u0002\u01ba\u01b8\u0003\u0002\u0002\u0002\u01ba\u01bb\u0003\u0002\u0002", "\u0002\u01bb\u01bd\u0003\u0002\u0002\u0002\u01bc\u01ba\u0003\u0002\u0002", "\u0002\u01bd\u01be\u0007b\u0002\u0002\u01bex\u0003\u0002\u0002\u0002", "\u01bf\u01c4\u0007)\u0002\u0002\u01c0\u01c3\u0005\u0083B\u0002\u01c1", "\u01c3\n\u0007\u0002\u0002\u01c2\u01c0\u0003\u0002\u0002\u0002\u01c2", "\u01c1\u0003\u0002\u0002\u0002\u01c3\u01c6\u0003\u0002\u0002\u0002\u01c4", "\u01c2\u0003\u0002\u0002\u0002\u01c4\u01c5\u0003\u0002\u0002\u0002\u01c5", "\u01c7\u0003\u0002\u0002\u0002\u01c6\u01c4\u0003\u0002\u0002\u0002\u01c7", "\u01c8\u0007)\u0002\u0002\u01c8z\u0003\u0002\u0002\u0002\u01c9\u01cb", "\t\u0002\u0002\u0002\u01ca\u01c9\u0003\u0002\u0002\u0002\u01cb\u01cc", "\u0003\u0002\u0002\u0002\u01cc\u01ca\u0003\u0002\u0002\u0002\u01cc\u01cd", "\u0003\u0002\u0002\u0002\u01cd\u01d4\u0003\u0002\u0002\u0002\u01ce\u01d0", "\u00070\u0002\u0002\u01cf\u01d1\t\u0002\u0002\u0002\u01d0\u01cf\u0003", "\u0002\u0002\u0002\u01d1\u01d2\u0003\u0002\u0002\u0002\u01d2\u01d0\u0003", "\u0002\u0002\u0002\u01d2\u01d3\u0003\u0002\u0002\u0002\u01d3\u01d5\u0003", "\u0002\u0002\u0002\u01d4\u01ce\u0003\u0002\u0002\u0002\u01d4\u01d5\u0003", "\u0002\u0002\u0002\u01d5|\u0003\u0002\u0002\u0002\u01d6\u01d8\t\b\u0002", "\u0002\u01d7\u01d6\u0003\u0002\u0002\u0002\u01d8\u01d9\u0003\u0002\u0002", "\u0002\u01d9\u01d7\u0003\u0002\u0002\u0002\u01d9\u01da\u0003\u0002\u0002", "\u0002\u01da\u01db\u0003\u0002\u0002\u0002\u01db\u01dc\b?\u0002\u0002", "\u01dc~\u0003\u0002\u0002\u0002\u01dd\u01de\u00071\u0002\u0002\u01de", "\u01df\u0007,\u0002\u0002\u01df\u01e3\u0003\u0002\u0002\u0002\u01e0", "\u01e2\u000b\u0002\u0002\u0002\u01e1\u01e0\u0003\u0002\u0002\u0002\u01e2", "\u01e5\u0003\u0002\u0002\u0002\u01e3\u01e4\u0003\u0002\u0002\u0002\u01e3", "\u01e1\u0003\u0002\u0002\u0002\u01e4\u01e6\u0003\u0002\u0002\u0002\u01e5", "\u01e3\u0003\u0002\u0002\u0002\u01e6\u01e7\u0007,\u0002\u0002\u01e7", "\u01e8\u00071\u0002\u0002\u01e8\u01e9\u0003\u0002\u0002\u0002\u01e9", "\u01ea\b@\u0002\u0002\u01ea\u0080\u0003\u0002\u0002\u0002\u01eb\u01ec", "\u00071\u0002\u0002\u01ec\u01ed\u00071\u0002\u0002\u01ed\u01f1\u0003", "\u0002\u0002\u0002\u01ee\u01f0\n\t\u0002\u0002\u01ef\u01ee\u0003\u0002", "\u0002\u0002\u01f0\u01f3\u0003\u0002\u0002\u0002\u01f1\u01ef\u0003\u0002", "\u0002\u0002\u01f1\u01f2\u0003\u0002\u0002\u0002\u01f2\u01f4\u0003\u0002", "\u0002\u0002\u01f3\u01f1\u0003\u0002\u0002\u0002\u01f4\u01f5\bA\u0002", "\u0002\u01f5\u0082\u0003\u0002\u0002\u0002\u01f6\u01f9\u0007^\u0002", "\u0002\u01f7\u01fa\t\n\u0002\u0002\u01f8\u01fa\u0005\u0085C\u0002\u01f9", "\u01f7\u0003\u0002\u0002\u0002\u01f9\u01f8\u0003\u0002\u0002\u0002\u01fa", "\u0084\u0003\u0002\u0002\u0002\u01fb\u01fc\u0007w\u0002\u0002\u01fc", "\u01fd\u0005\u0087D\u0002\u01fd\u01fe\u0005\u0087D\u0002\u01fe\u01ff", "\u0005\u0087D\u0002\u01ff\u0200\u0005\u0087D\u0002\u0200\u0086\u0003", "\u0002\u0002\u0002\u0201\u0202\t\u000b\u0002\u0002\u0202\u0088\u0003", "\u0002\u0002\u0002\u001a\u0002\u0182\u0184\u0186\u0189\u019b\u019d\u019f", "\u01a1\u01aa\u01ad\u01b0\u01b2\u01b8\u01ba\u01c2\u01c4\u01cc\u01d2\u01d4", "\u01d9\u01e3\u01f1\u01f9\u0003\u0002\u0003\u0002"].join("");
const atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);
const decisionsToDFA = atn.decisionToState.map((ds, index) => new antlr4.dfa.DFA(ds, index));

class FHIRPathLexer extends antlr4.Lexer {
  static grammarFileName = "FHIRPath.g4";
  static channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"];
  static modeNames = ["DEFAULT_MODE"];
  static literalNames = [null, "'.'", "'['", "']'", "'+'", "'-'", "'*'", "'/'", "'div'", "'mod'", "'&'", "'|'", "'<='", "'<'", "'>'", "'>='", "'is'", "'as'", "'='", "'~'", "'!='", "'!~'", "'in'", "'contains'", "'and'", "'or'", "'xor'", "'implies'", "'('", "')'", "'{'", "'}'", "'true'", "'false'", "'%'", "'$this'", "'$index'", "'$total'", "','", "'year'", "'month'", "'week'", "'day'", "'hour'", "'minute'", "'second'", "'millisecond'", "'years'", "'months'", "'weeks'", "'days'", "'hours'", "'minutes'", "'seconds'", "'milliseconds'"];
  static symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "DATETIME", "TIME", "IDENTIFIER", "DELIMITEDIDENTIFIER", "STRING", "NUMBER", "WS", "COMMENT", "LINE_COMMENT"];
  static ruleNames = ["T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "T__7", "T__8", "T__9", "T__10", "T__11", "T__12", "T__13", "T__14", "T__15", "T__16", "T__17", "T__18", "T__19", "T__20", "T__21", "T__22", "T__23", "T__24", "T__25", "T__26", "T__27", "T__28", "T__29", "T__30", "T__31", "T__32", "T__33", "T__34", "T__35", "T__36", "T__37", "T__38", "T__39", "T__40", "T__41", "T__42", "T__43", "T__44", "T__45", "T__46", "T__47", "T__48", "T__49", "T__50", "T__51", "T__52", "T__53", "DATETIME", "TIME", "TIMEFORMAT", "IDENTIFIER", "DELIMITEDIDENTIFIER", "STRING", "NUMBER", "WS", "COMMENT", "LINE_COMMENT", "ESC", "UNICODE", "HEX"];

  constructor(input) {
    super(input);
    this._interp = new antlr4.atn.LexerATNSimulator(this, atn, decisionsToDFA, new antlr4.PredictionContextCache());
  }

  get atn() {
    return atn;
  }

}

FHIRPathLexer.EOF = antlr4.Token.EOF;
FHIRPathLexer.T__0 = 1;
FHIRPathLexer.T__1 = 2;
FHIRPathLexer.T__2 = 3;
FHIRPathLexer.T__3 = 4;
FHIRPathLexer.T__4 = 5;
FHIRPathLexer.T__5 = 6;
FHIRPathLexer.T__6 = 7;
FHIRPathLexer.T__7 = 8;
FHIRPathLexer.T__8 = 9;
FHIRPathLexer.T__9 = 10;
FHIRPathLexer.T__10 = 11;
FHIRPathLexer.T__11 = 12;
FHIRPathLexer.T__12 = 13;
FHIRPathLexer.T__13 = 14;
FHIRPathLexer.T__14 = 15;
FHIRPathLexer.T__15 = 16;
FHIRPathLexer.T__16 = 17;
FHIRPathLexer.T__17 = 18;
FHIRPathLexer.T__18 = 19;
FHIRPathLexer.T__19 = 20;
FHIRPathLexer.T__20 = 21;
FHIRPathLexer.T__21 = 22;
FHIRPathLexer.T__22 = 23;
FHIRPathLexer.T__23 = 24;
FHIRPathLexer.T__24 = 25;
FHIRPathLexer.T__25 = 26;
FHIRPathLexer.T__26 = 27;
FHIRPathLexer.T__27 = 28;
FHIRPathLexer.T__28 = 29;
FHIRPathLexer.T__29 = 30;
FHIRPathLexer.T__30 = 31;
FHIRPathLexer.T__31 = 32;
FHIRPathLexer.T__32 = 33;
FHIRPathLexer.T__33 = 34;
FHIRPathLexer.T__34 = 35;
FHIRPathLexer.T__35 = 36;
FHIRPathLexer.T__36 = 37;
FHIRPathLexer.T__37 = 38;
FHIRPathLexer.T__38 = 39;
FHIRPathLexer.T__39 = 40;
FHIRPathLexer.T__40 = 41;
FHIRPathLexer.T__41 = 42;
FHIRPathLexer.T__42 = 43;
FHIRPathLexer.T__43 = 44;
FHIRPathLexer.T__44 = 45;
FHIRPathLexer.T__45 = 46;
FHIRPathLexer.T__46 = 47;
FHIRPathLexer.T__47 = 48;
FHIRPathLexer.T__48 = 49;
FHIRPathLexer.T__49 = 50;
FHIRPathLexer.T__50 = 51;
FHIRPathLexer.T__51 = 52;
FHIRPathLexer.T__52 = 53;
FHIRPathLexer.T__53 = 54;
FHIRPathLexer.DATETIME = 55;
FHIRPathLexer.TIME = 56;
FHIRPathLexer.IDENTIFIER = 57;
FHIRPathLexer.DELIMITEDIDENTIFIER = 58;
FHIRPathLexer.STRING = 59;
FHIRPathLexer.NUMBER = 60;
FHIRPathLexer.WS = 61;
FHIRPathLexer.COMMENT = 62;
FHIRPathLexer.LINE_COMMENT = 63;
module.exports = FHIRPathLexer;

/***/ }),
/* 53 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated from FHIRPath.g4 by ANTLR 4.9.3
// jshint ignore: start
const antlr4 = __webpack_require__(7);

const FHIRPathListener = __webpack_require__(54);

const serializedATN = ["\u0003\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786", "\u5964\u0003A\u009c\u0004\u0002\t\u0002\u0004\u0003\t\u0003\u0004\u0004", "\t\u0004\u0004\u0005\t\u0005\u0004\u0006\t\u0006\u0004\u0007\t\u0007", "\u0004\b\t\b\u0004\t\t\t\u0004\n\t\n\u0004\u000b\t\u000b\u0004\f\t\f", "\u0004\r\t\r\u0004\u000e\t\u000e\u0004\u000f\t\u000f\u0004\u0010\t\u0010", "\u0003\u0002\u0003\u0002\u0003\u0002\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0005\u0003(\n\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003", "\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0003\u0007\u0003", "P\n\u0003\f\u0003\u000e\u0003S\u000b\u0003\u0003\u0004\u0003\u0004\u0003", "\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0003\u0004\u0005\u0004\\", "\n\u0004\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005\u0003\u0005", "\u0003\u0005\u0003\u0005\u0003\u0005\u0005\u0005f\n\u0005\u0003\u0006", "\u0003\u0006\u0003\u0006\u0005\u0006k\n\u0006\u0003\u0007\u0003\u0007", "\u0003\u0007\u0003\u0007\u0003\u0007\u0005\u0007r\n\u0007\u0003\b\u0003", "\b\u0003\b\u0005\bw\n\b\u0003\b\u0003\b\u0003\t\u0003\t\u0003\t\u0007", "\t~\n\t\f\t\u000e\t\u0081\u000b\t\u0003\n\u0003\n\u0005\n\u0085\n\n", "\u0003\u000b\u0003\u000b\u0003\u000b\u0005\u000b\u008a\n\u000b\u0003", "\f\u0003\f\u0003\r\u0003\r\u0003\u000e\u0003\u000e\u0003\u000f\u0003", "\u000f\u0003\u000f\u0007\u000f\u0095\n\u000f\f\u000f\u000e\u000f\u0098", "\u000b\u000f\u0003\u0010\u0003\u0010\u0003\u0010\u0002\u0003\u0004\u0011", "\u0002\u0004\u0006\b\n\f\u000e\u0010\u0012\u0014\u0016\u0018\u001a\u001c", "\u001e\u0002\u000e\u0003\u0002\u0006\u0007\u0003\u0002\b\u000b\u0004", "\u0002\u0006\u0007\f\f\u0003\u0002\u000e\u0011\u0003\u0002\u0014\u0017", "\u0003\u0002\u0018\u0019\u0003\u0002\u001b\u001c\u0003\u0002\u0012\u0013", "\u0003\u0002\"#\u0003\u0002)0\u0003\u000218\u0005\u0002\u0012\u0013", "\u0018\u0019;<\u0002\u00ad\u0002 \u0003\u0002\u0002\u0002\u0004\'\u0003", "\u0002\u0002\u0002\u0006[\u0003\u0002\u0002\u0002\be\u0003\u0002\u0002", "\u0002\ng\u0003\u0002\u0002\u0002\fq\u0003\u0002\u0002\u0002\u000es", "\u0003\u0002\u0002\u0002\u0010z\u0003\u0002\u0002\u0002\u0012\u0082", "\u0003\u0002\u0002\u0002\u0014\u0089\u0003\u0002\u0002\u0002\u0016\u008b", "\u0003\u0002\u0002\u0002\u0018\u008d\u0003\u0002\u0002\u0002\u001a\u008f", "\u0003\u0002\u0002\u0002\u001c\u0091\u0003\u0002\u0002\u0002\u001e\u0099", "\u0003\u0002\u0002\u0002 !\u0005\u0004\u0003\u0002!\"\u0007\u0002\u0002", "\u0003\"\u0003\u0003\u0002\u0002\u0002#$\b\u0003\u0001\u0002$(\u0005", "\u0006\u0004\u0002%&\t\u0002\u0002\u0002&(\u0005\u0004\u0003\r\'#\u0003", "\u0002\u0002\u0002\'%\u0003\u0002\u0002\u0002(Q\u0003\u0002\u0002\u0002", ")*\f\f\u0002\u0002*+\t\u0003\u0002\u0002+P\u0005\u0004\u0003\r,-\f\u000b", "\u0002\u0002-.\t\u0004\u0002\u0002.P\u0005\u0004\u0003\f/0\f\n\u0002", "\u000201\u0007\r\u0002\u00021P\u0005\u0004\u0003\u000b23\f\t\u0002\u0002", "34\t\u0005\u0002\u00024P\u0005\u0004\u0003\n56\f\u0007\u0002\u00026", "7\t\u0006\u0002\u00027P\u0005\u0004\u0003\b89\f\u0006\u0002\u00029:", "\t\u0007\u0002\u0002:P\u0005\u0004\u0003\u0007;<\f\u0005\u0002\u0002", "<=\u0007\u001a\u0002\u0002=P\u0005\u0004\u0003\u0006>?\f\u0004\u0002", "\u0002?@\t\b\u0002\u0002@P\u0005\u0004\u0003\u0005AB\f\u0003\u0002\u0002", "BC\u0007\u001d\u0002\u0002CP\u0005\u0004\u0003\u0004DE\f\u000f\u0002", "\u0002EF\u0007\u0003\u0002\u0002FP\u0005\f\u0007\u0002GH\f\u000e\u0002", "\u0002HI\u0007\u0004\u0002\u0002IJ\u0005\u0004\u0003\u0002JK\u0007\u0005", "\u0002\u0002KP\u0003\u0002\u0002\u0002LM\f\b\u0002\u0002MN\t\t\u0002", "\u0002NP\u0005\u001a\u000e\u0002O)\u0003\u0002\u0002\u0002O,\u0003\u0002", "\u0002\u0002O/\u0003\u0002\u0002\u0002O2\u0003\u0002\u0002\u0002O5\u0003", "\u0002\u0002\u0002O8\u0003\u0002\u0002\u0002O;\u0003\u0002\u0002\u0002", "O>\u0003\u0002\u0002\u0002OA\u0003\u0002\u0002\u0002OD\u0003\u0002\u0002", "\u0002OG\u0003\u0002\u0002\u0002OL\u0003\u0002\u0002\u0002PS\u0003\u0002", "\u0002\u0002QO\u0003\u0002\u0002\u0002QR\u0003\u0002\u0002\u0002R\u0005", "\u0003\u0002\u0002\u0002SQ\u0003\u0002\u0002\u0002T\\\u0005\f\u0007", "\u0002U\\\u0005\b\u0005\u0002V\\\u0005\n\u0006\u0002WX\u0007\u001e\u0002", "\u0002XY\u0005\u0004\u0003\u0002YZ\u0007\u001f\u0002\u0002Z\\\u0003", "\u0002\u0002\u0002[T\u0003\u0002\u0002\u0002[U\u0003\u0002\u0002\u0002", "[V\u0003\u0002\u0002\u0002[W\u0003\u0002\u0002\u0002\\\u0007\u0003\u0002", "\u0002\u0002]^\u0007 \u0002\u0002^f\u0007!\u0002\u0002_f\t\n\u0002\u0002", "`f\u0007=\u0002\u0002af\u0007>\u0002\u0002bf\u00079\u0002\u0002cf\u0007", ":\u0002\u0002df\u0005\u0012\n\u0002e]\u0003\u0002\u0002\u0002e_\u0003", "\u0002\u0002\u0002e`\u0003\u0002\u0002\u0002ea\u0003\u0002\u0002\u0002", "eb\u0003\u0002\u0002\u0002ec\u0003\u0002\u0002\u0002ed\u0003\u0002\u0002", "\u0002f\t\u0003\u0002\u0002\u0002gj\u0007$\u0002\u0002hk\u0005\u001e", "\u0010\u0002ik\u0007=\u0002\u0002jh\u0003\u0002\u0002\u0002ji\u0003", "\u0002\u0002\u0002k\u000b\u0003\u0002\u0002\u0002lr\u0005\u001e\u0010", "\u0002mr\u0005\u000e\b\u0002nr\u0007%\u0002\u0002or\u0007&\u0002\u0002", "pr\u0007\'\u0002\u0002ql\u0003\u0002\u0002\u0002qm\u0003\u0002\u0002", "\u0002qn\u0003\u0002\u0002\u0002qo\u0003\u0002\u0002\u0002qp\u0003\u0002", "\u0002\u0002r\r\u0003\u0002\u0002\u0002st\u0005\u001e\u0010\u0002tv", "\u0007\u001e\u0002\u0002uw\u0005\u0010\t\u0002vu\u0003\u0002\u0002\u0002", "vw\u0003\u0002\u0002\u0002wx\u0003\u0002\u0002\u0002xy\u0007\u001f\u0002", "\u0002y\u000f\u0003\u0002\u0002\u0002z\u007f\u0005\u0004\u0003\u0002", "{|\u0007(\u0002\u0002|~\u0005\u0004\u0003\u0002}{\u0003\u0002\u0002", "\u0002~\u0081\u0003\u0002\u0002\u0002\u007f}\u0003\u0002\u0002\u0002", "\u007f\u0080\u0003\u0002\u0002\u0002\u0080\u0011\u0003\u0002\u0002\u0002", "\u0081\u007f\u0003\u0002\u0002\u0002\u0082\u0084\u0007>\u0002\u0002", "\u0083\u0085\u0005\u0014\u000b\u0002\u0084\u0083\u0003\u0002\u0002\u0002", "\u0084\u0085\u0003\u0002\u0002\u0002\u0085\u0013\u0003\u0002\u0002\u0002", "\u0086\u008a\u0005\u0016\f\u0002\u0087\u008a\u0005\u0018\r\u0002\u0088", "\u008a\u0007=\u0002\u0002\u0089\u0086\u0003\u0002\u0002\u0002\u0089", "\u0087\u0003\u0002\u0002\u0002\u0089\u0088\u0003\u0002\u0002\u0002\u008a", "\u0015\u0003\u0002\u0002\u0002\u008b\u008c\t\u000b\u0002\u0002\u008c", "\u0017\u0003\u0002\u0002\u0002\u008d\u008e\t\f\u0002\u0002\u008e\u0019", "\u0003\u0002\u0002\u0002\u008f\u0090\u0005\u001c\u000f\u0002\u0090\u001b", "\u0003\u0002\u0002\u0002\u0091\u0096\u0005\u001e\u0010\u0002\u0092\u0093", "\u0007\u0003\u0002\u0002\u0093\u0095\u0005\u001e\u0010\u0002\u0094\u0092", "\u0003\u0002\u0002\u0002\u0095\u0098\u0003\u0002\u0002\u0002\u0096\u0094", "\u0003\u0002\u0002\u0002\u0096\u0097\u0003\u0002\u0002\u0002\u0097\u001d", "\u0003\u0002\u0002\u0002\u0098\u0096\u0003\u0002\u0002\u0002\u0099\u009a", "\t\r\u0002\u0002\u009a\u001f\u0003\u0002\u0002\u0002\u000e\'OQ[ejqv", "\u007f\u0084\u0089\u0096"].join("");
const atn = new antlr4.atn.ATNDeserializer().deserialize(serializedATN);
const decisionsToDFA = atn.decisionToState.map((ds, index) => new antlr4.dfa.DFA(ds, index));
const sharedContextCache = new antlr4.PredictionContextCache();

class FHIRPathParser extends antlr4.Parser {
  static grammarFileName = "FHIRPath.g4";
  static literalNames = [null, "'.'", "'['", "']'", "'+'", "'-'", "'*'", "'/'", "'div'", "'mod'", "'&'", "'|'", "'<='", "'<'", "'>'", "'>='", "'is'", "'as'", "'='", "'~'", "'!='", "'!~'", "'in'", "'contains'", "'and'", "'or'", "'xor'", "'implies'", "'('", "')'", "'{'", "'}'", "'true'", "'false'", "'%'", "'$this'", "'$index'", "'$total'", "','", "'year'", "'month'", "'week'", "'day'", "'hour'", "'minute'", "'second'", "'millisecond'", "'years'", "'months'", "'weeks'", "'days'", "'hours'", "'minutes'", "'seconds'", "'milliseconds'"];
  static symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "DATETIME", "TIME", "IDENTIFIER", "DELIMITEDIDENTIFIER", "STRING", "NUMBER", "WS", "COMMENT", "LINE_COMMENT"];
  static ruleNames = ["entireExpression", "expression", "term", "literal", "externalConstant", "invocation", "functn", "paramList", "quantity", "unit", "dateTimePrecision", "pluralDateTimePrecision", "typeSpecifier", "qualifiedIdentifier", "identifier"];

  constructor(input) {
    super(input);
    this._interp = new antlr4.atn.ParserATNSimulator(this, atn, decisionsToDFA, sharedContextCache);
    this.ruleNames = FHIRPathParser.ruleNames;
    this.literalNames = FHIRPathParser.literalNames;
    this.symbolicNames = FHIRPathParser.symbolicNames;
  }

  get atn() {
    return atn;
  }

  sempred(localctx, ruleIndex, predIndex) {
    switch (ruleIndex) {
      case 1:
        return this.expression_sempred(localctx, predIndex);

      default:
        throw "No predicate with index:" + ruleIndex;
    }
  }

  expression_sempred(localctx, predIndex) {
    switch (predIndex) {
      case 0:
        return this.precpred(this._ctx, 10);

      case 1:
        return this.precpred(this._ctx, 9);

      case 2:
        return this.precpred(this._ctx, 8);

      case 3:
        return this.precpred(this._ctx, 7);

      case 4:
        return this.precpred(this._ctx, 5);

      case 5:
        return this.precpred(this._ctx, 4);

      case 6:
        return this.precpred(this._ctx, 3);

      case 7:
        return this.precpred(this._ctx, 2);

      case 8:
        return this.precpred(this._ctx, 1);

      case 9:
        return this.precpred(this._ctx, 13);

      case 10:
        return this.precpred(this._ctx, 12);

      case 11:
        return this.precpred(this._ctx, 6);

      default:
        throw "No predicate with index:" + predIndex;
    }
  }

  entireExpression() {
    let localctx = new EntireExpressionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 0, FHIRPathParser.RULE_entireExpression);

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 30;
      this.expression(0);
      this.state = 31;
      this.match(FHIRPathParser.EOF);
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  expression(_p) {
    if (_p === undefined) {
      _p = 0;
    }

    const _parentctx = this._ctx;
    const _parentState = this.state;
    let localctx = new ExpressionContext(this, this._ctx, _parentState);
    let _prevctx = localctx;
    const _startState = 2;
    this.enterRecursionRule(localctx, 2, FHIRPathParser.RULE_expression, _p);
    var _la = 0; // Token type

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 37;

      this._errHandler.sync(this);

      switch (this._input.LA(1)) {
        case FHIRPathParser.T__15:
        case FHIRPathParser.T__16:
        case FHIRPathParser.T__21:
        case FHIRPathParser.T__22:
        case FHIRPathParser.T__27:
        case FHIRPathParser.T__29:
        case FHIRPathParser.T__31:
        case FHIRPathParser.T__32:
        case FHIRPathParser.T__33:
        case FHIRPathParser.T__34:
        case FHIRPathParser.T__35:
        case FHIRPathParser.T__36:
        case FHIRPathParser.DATETIME:
        case FHIRPathParser.TIME:
        case FHIRPathParser.IDENTIFIER:
        case FHIRPathParser.DELIMITEDIDENTIFIER:
        case FHIRPathParser.STRING:
        case FHIRPathParser.NUMBER:
          localctx = new TermExpressionContext(this, localctx);
          this._ctx = localctx;
          _prevctx = localctx;
          this.state = 34;
          this.term();
          break;

        case FHIRPathParser.T__3:
        case FHIRPathParser.T__4:
          localctx = new PolarityExpressionContext(this, localctx);
          this._ctx = localctx;
          _prevctx = localctx;
          this.state = 35;
          _la = this._input.LA(1);

          if (!(_la === FHIRPathParser.T__3 || _la === FHIRPathParser.T__4)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);

            this.consume();
          }

          this.state = 36;
          this.expression(11);
          break;

        default:
          throw new antlr4.error.NoViableAltException(this);
      }

      this._ctx.stop = this._input.LT(-1);
      this.state = 79;

      this._errHandler.sync(this);

      var _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);

      while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          if (this._parseListeners !== null) {
            this.triggerExitRuleEvent();
          }

          _prevctx = localctx;
          this.state = 77;

          this._errHandler.sync(this);

          var la_ = this._interp.adaptivePredict(this._input, 1, this._ctx);

          switch (la_) {
            case 1:
              localctx = new MultiplicativeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 39;

              if (!this.precpred(this._ctx, 10)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 10)");
              }

              this.state = 40;
              _la = this._input.LA(1);

              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__5 | 1 << FHIRPathParser.T__6 | 1 << FHIRPathParser.T__7 | 1 << FHIRPathParser.T__8)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);

                this.consume();
              }

              this.state = 41;
              this.expression(11);
              break;

            case 2:
              localctx = new AdditiveExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 42;

              if (!this.precpred(this._ctx, 9)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 9)");
              }

              this.state = 43;
              _la = this._input.LA(1);

              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__9)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);

                this.consume();
              }

              this.state = 44;
              this.expression(10);
              break;

            case 3:
              localctx = new UnionExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 45;

              if (!this.precpred(this._ctx, 8)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 8)");
              }

              this.state = 46;
              this.match(FHIRPathParser.T__10);
              this.state = 47;
              this.expression(9);
              break;

            case 4:
              localctx = new InequalityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 48;

              if (!this.precpred(this._ctx, 7)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 7)");
              }

              this.state = 49;
              _la = this._input.LA(1);

              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__11 | 1 << FHIRPathParser.T__12 | 1 << FHIRPathParser.T__13 | 1 << FHIRPathParser.T__14)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);

                this.consume();
              }

              this.state = 50;
              this.expression(8);
              break;

            case 5:
              localctx = new EqualityExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 51;

              if (!this.precpred(this._ctx, 5)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 5)");
              }

              this.state = 52;
              _la = this._input.LA(1);

              if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__17 | 1 << FHIRPathParser.T__18 | 1 << FHIRPathParser.T__19 | 1 << FHIRPathParser.T__20)) !== 0)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);

                this.consume();
              }

              this.state = 53;
              this.expression(6);
              break;

            case 6:
              localctx = new MembershipExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 54;

              if (!this.precpred(this._ctx, 4)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 4)");
              }

              this.state = 55;
              _la = this._input.LA(1);

              if (!(_la === FHIRPathParser.T__21 || _la === FHIRPathParser.T__22)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);

                this.consume();
              }

              this.state = 56;
              this.expression(5);
              break;

            case 7:
              localctx = new AndExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 57;

              if (!this.precpred(this._ctx, 3)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 3)");
              }

              this.state = 58;
              this.match(FHIRPathParser.T__23);
              this.state = 59;
              this.expression(4);
              break;

            case 8:
              localctx = new OrExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 60;

              if (!this.precpred(this._ctx, 2)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 2)");
              }

              this.state = 61;
              _la = this._input.LA(1);

              if (!(_la === FHIRPathParser.T__24 || _la === FHIRPathParser.T__25)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);

                this.consume();
              }

              this.state = 62;
              this.expression(3);
              break;

            case 9:
              localctx = new ImpliesExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 63;

              if (!this.precpred(this._ctx, 1)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 1)");
              }

              this.state = 64;
              this.match(FHIRPathParser.T__26);
              this.state = 65;
              this.expression(2);
              break;

            case 10:
              localctx = new InvocationExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 66;

              if (!this.precpred(this._ctx, 13)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 13)");
              }

              this.state = 67;
              this.match(FHIRPathParser.T__0);
              this.state = 68;
              this.invocation();
              break;

            case 11:
              localctx = new IndexerExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 69;

              if (!this.precpred(this._ctx, 12)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 12)");
              }

              this.state = 70;
              this.match(FHIRPathParser.T__1);
              this.state = 71;
              this.expression(0);
              this.state = 72;
              this.match(FHIRPathParser.T__2);
              break;

            case 12:
              localctx = new TypeExpressionContext(this, new ExpressionContext(this, _parentctx, _parentState));
              this.pushNewRecursionContext(localctx, _startState, FHIRPathParser.RULE_expression);
              this.state = 74;

              if (!this.precpred(this._ctx, 6)) {
                throw new antlr4.error.FailedPredicateException(this, "this.precpred(this._ctx, 6)");
              }

              this.state = 75;
              _la = this._input.LA(1);

              if (!(_la === FHIRPathParser.T__15 || _la === FHIRPathParser.T__16)) {
                this._errHandler.recoverInline(this);
              } else {
                this._errHandler.reportMatch(this);

                this.consume();
              }

              this.state = 76;
              this.typeSpecifier();
              break;
          }
        }

        this.state = 81;

        this._errHandler.sync(this);

        _alt = this._interp.adaptivePredict(this._input, 2, this._ctx);
      }
    } catch (error) {
      if (error instanceof antlr4.error.RecognitionException) {
        localctx.exception = error;

        this._errHandler.reportError(this, error);

        this._errHandler.recover(this, error);
      } else {
        throw error;
      }
    } finally {
      this.unrollRecursionContexts(_parentctx);
    }

    return localctx;
  }

  term() {
    let localctx = new TermContext(this, this._ctx, this.state);
    this.enterRule(localctx, 4, FHIRPathParser.RULE_term);

    try {
      this.state = 89;

      this._errHandler.sync(this);

      switch (this._input.LA(1)) {
        case FHIRPathParser.T__15:
        case FHIRPathParser.T__16:
        case FHIRPathParser.T__21:
        case FHIRPathParser.T__22:
        case FHIRPathParser.T__34:
        case FHIRPathParser.T__35:
        case FHIRPathParser.T__36:
        case FHIRPathParser.IDENTIFIER:
        case FHIRPathParser.DELIMITEDIDENTIFIER:
          localctx = new InvocationTermContext(this, localctx);
          this.enterOuterAlt(localctx, 1);
          this.state = 82;
          this.invocation();
          break;

        case FHIRPathParser.T__29:
        case FHIRPathParser.T__31:
        case FHIRPathParser.T__32:
        case FHIRPathParser.DATETIME:
        case FHIRPathParser.TIME:
        case FHIRPathParser.STRING:
        case FHIRPathParser.NUMBER:
          localctx = new LiteralTermContext(this, localctx);
          this.enterOuterAlt(localctx, 2);
          this.state = 83;
          this.literal();
          break;

        case FHIRPathParser.T__33:
          localctx = new ExternalConstantTermContext(this, localctx);
          this.enterOuterAlt(localctx, 3);
          this.state = 84;
          this.externalConstant();
          break;

        case FHIRPathParser.T__27:
          localctx = new ParenthesizedTermContext(this, localctx);
          this.enterOuterAlt(localctx, 4);
          this.state = 85;
          this.match(FHIRPathParser.T__27);
          this.state = 86;
          this.expression(0);
          this.state = 87;
          this.match(FHIRPathParser.T__28);
          break;

        default:
          throw new antlr4.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  literal() {
    let localctx = new LiteralContext(this, this._ctx, this.state);
    this.enterRule(localctx, 6, FHIRPathParser.RULE_literal);
    var _la = 0; // Token type

    try {
      this.state = 99;

      this._errHandler.sync(this);

      var la_ = this._interp.adaptivePredict(this._input, 4, this._ctx);

      switch (la_) {
        case 1:
          localctx = new NullLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 1);
          this.state = 91;
          this.match(FHIRPathParser.T__29);
          this.state = 92;
          this.match(FHIRPathParser.T__30);
          break;

        case 2:
          localctx = new BooleanLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 2);
          this.state = 93;
          _la = this._input.LA(1);

          if (!(_la === FHIRPathParser.T__31 || _la === FHIRPathParser.T__32)) {
            this._errHandler.recoverInline(this);
          } else {
            this._errHandler.reportMatch(this);

            this.consume();
          }

          break;

        case 3:
          localctx = new StringLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 3);
          this.state = 94;
          this.match(FHIRPathParser.STRING);
          break;

        case 4:
          localctx = new NumberLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 4);
          this.state = 95;
          this.match(FHIRPathParser.NUMBER);
          break;

        case 5:
          localctx = new DateTimeLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 5);
          this.state = 96;
          this.match(FHIRPathParser.DATETIME);
          break;

        case 6:
          localctx = new TimeLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 6);
          this.state = 97;
          this.match(FHIRPathParser.TIME);
          break;

        case 7:
          localctx = new QuantityLiteralContext(this, localctx);
          this.enterOuterAlt(localctx, 7);
          this.state = 98;
          this.quantity();
          break;
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  externalConstant() {
    let localctx = new ExternalConstantContext(this, this._ctx, this.state);
    this.enterRule(localctx, 8, FHIRPathParser.RULE_externalConstant);

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 101;
      this.match(FHIRPathParser.T__33);
      this.state = 104;

      this._errHandler.sync(this);

      switch (this._input.LA(1)) {
        case FHIRPathParser.T__15:
        case FHIRPathParser.T__16:
        case FHIRPathParser.T__21:
        case FHIRPathParser.T__22:
        case FHIRPathParser.IDENTIFIER:
        case FHIRPathParser.DELIMITEDIDENTIFIER:
          this.state = 102;
          this.identifier();
          break;

        case FHIRPathParser.STRING:
          this.state = 103;
          this.match(FHIRPathParser.STRING);
          break;

        default:
          throw new antlr4.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  invocation() {
    let localctx = new InvocationContext(this, this._ctx, this.state);
    this.enterRule(localctx, 10, FHIRPathParser.RULE_invocation);

    try {
      this.state = 111;

      this._errHandler.sync(this);

      var la_ = this._interp.adaptivePredict(this._input, 6, this._ctx);

      switch (la_) {
        case 1:
          localctx = new MemberInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 1);
          this.state = 106;
          this.identifier();
          break;

        case 2:
          localctx = new FunctionInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 2);
          this.state = 107;
          this.functn();
          break;

        case 3:
          localctx = new ThisInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 3);
          this.state = 108;
          this.match(FHIRPathParser.T__34);
          break;

        case 4:
          localctx = new IndexInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 4);
          this.state = 109;
          this.match(FHIRPathParser.T__35);
          break;

        case 5:
          localctx = new TotalInvocationContext(this, localctx);
          this.enterOuterAlt(localctx, 5);
          this.state = 110;
          this.match(FHIRPathParser.T__36);
          break;
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  functn() {
    let localctx = new FunctnContext(this, this._ctx, this.state);
    this.enterRule(localctx, 12, FHIRPathParser.RULE_functn);
    var _la = 0; // Token type

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 113;
      this.identifier();
      this.state = 114;
      this.match(FHIRPathParser.T__27);
      this.state = 116;

      this._errHandler.sync(this);

      _la = this._input.LA(1);

      if ((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__3 | 1 << FHIRPathParser.T__4 | 1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22 | 1 << FHIRPathParser.T__27 | 1 << FHIRPathParser.T__29)) !== 0 || (_la - 32 & ~0x1f) == 0 && (1 << _la - 32 & (1 << FHIRPathParser.T__31 - 32 | 1 << FHIRPathParser.T__32 - 32 | 1 << FHIRPathParser.T__33 - 32 | 1 << FHIRPathParser.T__34 - 32 | 1 << FHIRPathParser.T__35 - 32 | 1 << FHIRPathParser.T__36 - 32 | 1 << FHIRPathParser.DATETIME - 32 | 1 << FHIRPathParser.TIME - 32 | 1 << FHIRPathParser.IDENTIFIER - 32 | 1 << FHIRPathParser.DELIMITEDIDENTIFIER - 32 | 1 << FHIRPathParser.STRING - 32 | 1 << FHIRPathParser.NUMBER - 32)) !== 0) {
        this.state = 115;
        this.paramList();
      }

      this.state = 118;
      this.match(FHIRPathParser.T__28);
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  paramList() {
    let localctx = new ParamListContext(this, this._ctx, this.state);
    this.enterRule(localctx, 14, FHIRPathParser.RULE_paramList);
    var _la = 0; // Token type

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 120;
      this.expression(0);
      this.state = 125;

      this._errHandler.sync(this);

      _la = this._input.LA(1);

      while (_la === FHIRPathParser.T__37) {
        this.state = 121;
        this.match(FHIRPathParser.T__37);
        this.state = 122;
        this.expression(0);
        this.state = 127;

        this._errHandler.sync(this);

        _la = this._input.LA(1);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  quantity() {
    let localctx = new QuantityContext(this, this._ctx, this.state);
    this.enterRule(localctx, 16, FHIRPathParser.RULE_quantity);

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 128;
      this.match(FHIRPathParser.NUMBER);
      this.state = 130;

      this._errHandler.sync(this);

      var la_ = this._interp.adaptivePredict(this._input, 9, this._ctx);

      if (la_ === 1) {
        this.state = 129;
        this.unit();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  unit() {
    let localctx = new UnitContext(this, this._ctx, this.state);
    this.enterRule(localctx, 18, FHIRPathParser.RULE_unit);

    try {
      this.state = 135;

      this._errHandler.sync(this);

      switch (this._input.LA(1)) {
        case FHIRPathParser.T__38:
        case FHIRPathParser.T__39:
        case FHIRPathParser.T__40:
        case FHIRPathParser.T__41:
        case FHIRPathParser.T__42:
        case FHIRPathParser.T__43:
        case FHIRPathParser.T__44:
        case FHIRPathParser.T__45:
          this.enterOuterAlt(localctx, 1);
          this.state = 132;
          this.dateTimePrecision();
          break;

        case FHIRPathParser.T__46:
        case FHIRPathParser.T__47:
        case FHIRPathParser.T__48:
        case FHIRPathParser.T__49:
        case FHIRPathParser.T__50:
        case FHIRPathParser.T__51:
        case FHIRPathParser.T__52:
        case FHIRPathParser.T__53:
          this.enterOuterAlt(localctx, 2);
          this.state = 133;
          this.pluralDateTimePrecision();
          break;

        case FHIRPathParser.STRING:
          this.enterOuterAlt(localctx, 3);
          this.state = 134;
          this.match(FHIRPathParser.STRING);
          break;

        default:
          throw new antlr4.error.NoViableAltException(this);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  dateTimePrecision() {
    let localctx = new DateTimePrecisionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 20, FHIRPathParser.RULE_dateTimePrecision);
    var _la = 0; // Token type

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 137;
      _la = this._input.LA(1);

      if (!((_la - 39 & ~0x1f) == 0 && (1 << _la - 39 & (1 << FHIRPathParser.T__38 - 39 | 1 << FHIRPathParser.T__39 - 39 | 1 << FHIRPathParser.T__40 - 39 | 1 << FHIRPathParser.T__41 - 39 | 1 << FHIRPathParser.T__42 - 39 | 1 << FHIRPathParser.T__43 - 39 | 1 << FHIRPathParser.T__44 - 39 | 1 << FHIRPathParser.T__45 - 39)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);

        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  pluralDateTimePrecision() {
    let localctx = new PluralDateTimePrecisionContext(this, this._ctx, this.state);
    this.enterRule(localctx, 22, FHIRPathParser.RULE_pluralDateTimePrecision);
    var _la = 0; // Token type

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 139;
      _la = this._input.LA(1);

      if (!((_la - 47 & ~0x1f) == 0 && (1 << _la - 47 & (1 << FHIRPathParser.T__46 - 47 | 1 << FHIRPathParser.T__47 - 47 | 1 << FHIRPathParser.T__48 - 47 | 1 << FHIRPathParser.T__49 - 47 | 1 << FHIRPathParser.T__50 - 47 | 1 << FHIRPathParser.T__51 - 47 | 1 << FHIRPathParser.T__52 - 47 | 1 << FHIRPathParser.T__53 - 47)) !== 0)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);

        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  typeSpecifier() {
    let localctx = new TypeSpecifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 24, FHIRPathParser.RULE_typeSpecifier);

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 141;
      this.qualifiedIdentifier();
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  qualifiedIdentifier() {
    let localctx = new QualifiedIdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 26, FHIRPathParser.RULE_qualifiedIdentifier);

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 143;
      this.identifier();
      this.state = 148;

      this._errHandler.sync(this);

      var _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);

      while (_alt != 2 && _alt != antlr4.atn.ATN.INVALID_ALT_NUMBER) {
        if (_alt === 1) {
          this.state = 144;
          this.match(FHIRPathParser.T__0);
          this.state = 145;
          this.identifier();
        }

        this.state = 150;

        this._errHandler.sync(this);

        _alt = this._interp.adaptivePredict(this._input, 11, this._ctx);
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

  identifier() {
    let localctx = new IdentifierContext(this, this._ctx, this.state);
    this.enterRule(localctx, 28, FHIRPathParser.RULE_identifier);
    var _la = 0; // Token type

    try {
      this.enterOuterAlt(localctx, 1);
      this.state = 151;
      _la = this._input.LA(1);

      if (!((_la & ~0x1f) == 0 && (1 << _la & (1 << FHIRPathParser.T__15 | 1 << FHIRPathParser.T__16 | 1 << FHIRPathParser.T__21 | 1 << FHIRPathParser.T__22)) !== 0 || _la === FHIRPathParser.IDENTIFIER || _la === FHIRPathParser.DELIMITEDIDENTIFIER)) {
        this._errHandler.recoverInline(this);
      } else {
        this._errHandler.reportMatch(this);

        this.consume();
      }
    } catch (re) {
      if (re instanceof antlr4.error.RecognitionException) {
        localctx.exception = re;

        this._errHandler.reportError(this, re);

        this._errHandler.recover(this, re);
      } else {
        throw re;
      }
    } finally {
      this.exitRule();
    }

    return localctx;
  }

}

FHIRPathParser.EOF = antlr4.Token.EOF;
FHIRPathParser.T__0 = 1;
FHIRPathParser.T__1 = 2;
FHIRPathParser.T__2 = 3;
FHIRPathParser.T__3 = 4;
FHIRPathParser.T__4 = 5;
FHIRPathParser.T__5 = 6;
FHIRPathParser.T__6 = 7;
FHIRPathParser.T__7 = 8;
FHIRPathParser.T__8 = 9;
FHIRPathParser.T__9 = 10;
FHIRPathParser.T__10 = 11;
FHIRPathParser.T__11 = 12;
FHIRPathParser.T__12 = 13;
FHIRPathParser.T__13 = 14;
FHIRPathParser.T__14 = 15;
FHIRPathParser.T__15 = 16;
FHIRPathParser.T__16 = 17;
FHIRPathParser.T__17 = 18;
FHIRPathParser.T__18 = 19;
FHIRPathParser.T__19 = 20;
FHIRPathParser.T__20 = 21;
FHIRPathParser.T__21 = 22;
FHIRPathParser.T__22 = 23;
FHIRPathParser.T__23 = 24;
FHIRPathParser.T__24 = 25;
FHIRPathParser.T__25 = 26;
FHIRPathParser.T__26 = 27;
FHIRPathParser.T__27 = 28;
FHIRPathParser.T__28 = 29;
FHIRPathParser.T__29 = 30;
FHIRPathParser.T__30 = 31;
FHIRPathParser.T__31 = 32;
FHIRPathParser.T__32 = 33;
FHIRPathParser.T__33 = 34;
FHIRPathParser.T__34 = 35;
FHIRPathParser.T__35 = 36;
FHIRPathParser.T__36 = 37;
FHIRPathParser.T__37 = 38;
FHIRPathParser.T__38 = 39;
FHIRPathParser.T__39 = 40;
FHIRPathParser.T__40 = 41;
FHIRPathParser.T__41 = 42;
FHIRPathParser.T__42 = 43;
FHIRPathParser.T__43 = 44;
FHIRPathParser.T__44 = 45;
FHIRPathParser.T__45 = 46;
FHIRPathParser.T__46 = 47;
FHIRPathParser.T__47 = 48;
FHIRPathParser.T__48 = 49;
FHIRPathParser.T__49 = 50;
FHIRPathParser.T__50 = 51;
FHIRPathParser.T__51 = 52;
FHIRPathParser.T__52 = 53;
FHIRPathParser.T__53 = 54;
FHIRPathParser.DATETIME = 55;
FHIRPathParser.TIME = 56;
FHIRPathParser.IDENTIFIER = 57;
FHIRPathParser.DELIMITEDIDENTIFIER = 58;
FHIRPathParser.STRING = 59;
FHIRPathParser.NUMBER = 60;
FHIRPathParser.WS = 61;
FHIRPathParser.COMMENT = 62;
FHIRPathParser.LINE_COMMENT = 63;
FHIRPathParser.RULE_entireExpression = 0;
FHIRPathParser.RULE_expression = 1;
FHIRPathParser.RULE_term = 2;
FHIRPathParser.RULE_literal = 3;
FHIRPathParser.RULE_externalConstant = 4;
FHIRPathParser.RULE_invocation = 5;
FHIRPathParser.RULE_functn = 6;
FHIRPathParser.RULE_paramList = 7;
FHIRPathParser.RULE_quantity = 8;
FHIRPathParser.RULE_unit = 9;
FHIRPathParser.RULE_dateTimePrecision = 10;
FHIRPathParser.RULE_pluralDateTimePrecision = 11;
FHIRPathParser.RULE_typeSpecifier = 12;
FHIRPathParser.RULE_qualifiedIdentifier = 13;
FHIRPathParser.RULE_identifier = 14;

class EntireExpressionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_entireExpression;
  }

  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }

  EOF() {
    return this.getToken(FHIRPathParser.EOF, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterEntireExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitEntireExpression(this);
    }
  }

}

class ExpressionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_expression;
  }

  copyFrom(ctx) {
    super.copyFrom(ctx);
  }

}

class IndexerExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterIndexerExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitIndexerExpression(this);
    }
  }

}

FHIRPathParser.IndexerExpressionContext = IndexerExpressionContext;

class PolarityExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterPolarityExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitPolarityExpression(this);
    }
  }

}

FHIRPathParser.PolarityExpressionContext = PolarityExpressionContext;

class AdditiveExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterAdditiveExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitAdditiveExpression(this);
    }
  }

}

FHIRPathParser.AdditiveExpressionContext = AdditiveExpressionContext;

class MultiplicativeExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterMultiplicativeExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitMultiplicativeExpression(this);
    }
  }

}

FHIRPathParser.MultiplicativeExpressionContext = MultiplicativeExpressionContext;

class UnionExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterUnionExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitUnionExpression(this);
    }
  }

}

FHIRPathParser.UnionExpressionContext = UnionExpressionContext;

class OrExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterOrExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitOrExpression(this);
    }
  }

}

FHIRPathParser.OrExpressionContext = OrExpressionContext;

class AndExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterAndExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitAndExpression(this);
    }
  }

}

FHIRPathParser.AndExpressionContext = AndExpressionContext;

class MembershipExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterMembershipExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitMembershipExpression(this);
    }
  }

}

FHIRPathParser.MembershipExpressionContext = MembershipExpressionContext;

class InequalityExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterInequalityExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitInequalityExpression(this);
    }
  }

}

FHIRPathParser.InequalityExpressionContext = InequalityExpressionContext;

class InvocationExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }

  invocation() {
    return this.getTypedRuleContext(InvocationContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterInvocationExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitInvocationExpression(this);
    }
  }

}

FHIRPathParser.InvocationExpressionContext = InvocationExpressionContext;

class EqualityExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterEqualityExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitEqualityExpression(this);
    }
  }

}

FHIRPathParser.EqualityExpressionContext = EqualityExpressionContext;

class ImpliesExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterImpliesExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitImpliesExpression(this);
    }
  }

}

FHIRPathParser.ImpliesExpressionContext = ImpliesExpressionContext;

class TermExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  term() {
    return this.getTypedRuleContext(TermContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTermExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTermExpression(this);
    }
  }

}

FHIRPathParser.TermExpressionContext = TermExpressionContext;

class TypeExpressionContext extends ExpressionContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }

  typeSpecifier() {
    return this.getTypedRuleContext(TypeSpecifierContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTypeExpression(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTypeExpression(this);
    }
  }

}

FHIRPathParser.TypeExpressionContext = TypeExpressionContext;

class TermContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_term;
  }

  copyFrom(ctx) {
    super.copyFrom(ctx);
  }

}

class ExternalConstantTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  externalConstant() {
    return this.getTypedRuleContext(ExternalConstantContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterExternalConstantTerm(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitExternalConstantTerm(this);
    }
  }

}

FHIRPathParser.ExternalConstantTermContext = ExternalConstantTermContext;

class LiteralTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  literal() {
    return this.getTypedRuleContext(LiteralContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterLiteralTerm(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitLiteralTerm(this);
    }
  }

}

FHIRPathParser.LiteralTermContext = LiteralTermContext;

class ParenthesizedTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  expression() {
    return this.getTypedRuleContext(ExpressionContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterParenthesizedTerm(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitParenthesizedTerm(this);
    }
  }

}

FHIRPathParser.ParenthesizedTermContext = ParenthesizedTermContext;

class InvocationTermContext extends TermContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  invocation() {
    return this.getTypedRuleContext(InvocationContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterInvocationTerm(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitInvocationTerm(this);
    }
  }

}

FHIRPathParser.InvocationTermContext = InvocationTermContext;

class LiteralContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_literal;
  }

  copyFrom(ctx) {
    super.copyFrom(ctx);
  }

}

class TimeLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  TIME() {
    return this.getToken(FHIRPathParser.TIME, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTimeLiteral(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTimeLiteral(this);
    }
  }

}

FHIRPathParser.TimeLiteralContext = TimeLiteralContext;

class NullLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterNullLiteral(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitNullLiteral(this);
    }
  }

}

FHIRPathParser.NullLiteralContext = NullLiteralContext;

class DateTimeLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  DATETIME() {
    return this.getToken(FHIRPathParser.DATETIME, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterDateTimeLiteral(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitDateTimeLiteral(this);
    }
  }

}

FHIRPathParser.DateTimeLiteralContext = DateTimeLiteralContext;

class StringLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  STRING() {
    return this.getToken(FHIRPathParser.STRING, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterStringLiteral(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitStringLiteral(this);
    }
  }

}

FHIRPathParser.StringLiteralContext = StringLiteralContext;

class BooleanLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterBooleanLiteral(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitBooleanLiteral(this);
    }
  }

}

FHIRPathParser.BooleanLiteralContext = BooleanLiteralContext;

class NumberLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  NUMBER() {
    return this.getToken(FHIRPathParser.NUMBER, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterNumberLiteral(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitNumberLiteral(this);
    }
  }

}

FHIRPathParser.NumberLiteralContext = NumberLiteralContext;

class QuantityLiteralContext extends LiteralContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  quantity() {
    return this.getTypedRuleContext(QuantityContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterQuantityLiteral(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitQuantityLiteral(this);
    }
  }

}

FHIRPathParser.QuantityLiteralContext = QuantityLiteralContext;

class ExternalConstantContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_externalConstant;
  }

  identifier() {
    return this.getTypedRuleContext(IdentifierContext, 0);
  }

  STRING() {
    return this.getToken(FHIRPathParser.STRING, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterExternalConstant(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitExternalConstant(this);
    }
  }

}

class InvocationContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_invocation;
  }

  copyFrom(ctx) {
    super.copyFrom(ctx);
  }

}

class TotalInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTotalInvocation(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTotalInvocation(this);
    }
  }

}

FHIRPathParser.TotalInvocationContext = TotalInvocationContext;

class ThisInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterThisInvocation(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitThisInvocation(this);
    }
  }

}

FHIRPathParser.ThisInvocationContext = ThisInvocationContext;

class IndexInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterIndexInvocation(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitIndexInvocation(this);
    }
  }

}

FHIRPathParser.IndexInvocationContext = IndexInvocationContext;

class FunctionInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  functn() {
    return this.getTypedRuleContext(FunctnContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterFunctionInvocation(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitFunctionInvocation(this);
    }
  }

}

FHIRPathParser.FunctionInvocationContext = FunctionInvocationContext;

class MemberInvocationContext extends InvocationContext {
  constructor(parser, ctx) {
    super(parser);
    super.copyFrom(ctx);
  }

  identifier() {
    return this.getTypedRuleContext(IdentifierContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterMemberInvocation(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitMemberInvocation(this);
    }
  }

}

FHIRPathParser.MemberInvocationContext = MemberInvocationContext;

class FunctnContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_functn;
  }

  identifier() {
    return this.getTypedRuleContext(IdentifierContext, 0);
  }

  paramList() {
    return this.getTypedRuleContext(ParamListContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterFunctn(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitFunctn(this);
    }
  }

}

class ParamListContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_paramList;
  }

  expression = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(ExpressionContext);
    } else {
      return this.getTypedRuleContext(ExpressionContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterParamList(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitParamList(this);
    }
  }

}

class QuantityContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_quantity;
  }

  NUMBER() {
    return this.getToken(FHIRPathParser.NUMBER, 0);
  }

  unit() {
    return this.getTypedRuleContext(UnitContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterQuantity(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitQuantity(this);
    }
  }

}

class UnitContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_unit;
  }

  dateTimePrecision() {
    return this.getTypedRuleContext(DateTimePrecisionContext, 0);
  }

  pluralDateTimePrecision() {
    return this.getTypedRuleContext(PluralDateTimePrecisionContext, 0);
  }

  STRING() {
    return this.getToken(FHIRPathParser.STRING, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterUnit(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitUnit(this);
    }
  }

}

class DateTimePrecisionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_dateTimePrecision;
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterDateTimePrecision(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitDateTimePrecision(this);
    }
  }

}

class PluralDateTimePrecisionContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_pluralDateTimePrecision;
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterPluralDateTimePrecision(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitPluralDateTimePrecision(this);
    }
  }

}

class TypeSpecifierContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_typeSpecifier;
  }

  qualifiedIdentifier() {
    return this.getTypedRuleContext(QualifiedIdentifierContext, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterTypeSpecifier(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitTypeSpecifier(this);
    }
  }

}

class QualifiedIdentifierContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_qualifiedIdentifier;
  }

  identifier = function (i) {
    if (i === undefined) {
      i = null;
    }

    if (i === null) {
      return this.getTypedRuleContexts(IdentifierContext);
    } else {
      return this.getTypedRuleContext(IdentifierContext, i);
    }
  };

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterQualifiedIdentifier(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitQualifiedIdentifier(this);
    }
  }

}

class IdentifierContext extends antlr4.ParserRuleContext {
  constructor(parser, parent, invokingState) {
    if (parent === undefined) {
      parent = null;
    }

    if (invokingState === undefined || invokingState === null) {
      invokingState = -1;
    }

    super(parent, invokingState);
    this.parser = parser;
    this.ruleIndex = FHIRPathParser.RULE_identifier;
  }

  IDENTIFIER() {
    return this.getToken(FHIRPathParser.IDENTIFIER, 0);
  }

  DELIMITEDIDENTIFIER() {
    return this.getToken(FHIRPathParser.DELIMITEDIDENTIFIER, 0);
  }

  enterRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.enterIdentifier(this);
    }
  }

  exitRule(listener) {
    if (listener instanceof FHIRPathListener) {
      listener.exitIdentifier(this);
    }
  }

}

FHIRPathParser.EntireExpressionContext = EntireExpressionContext;
FHIRPathParser.ExpressionContext = ExpressionContext;
FHIRPathParser.TermContext = TermContext;
FHIRPathParser.LiteralContext = LiteralContext;
FHIRPathParser.ExternalConstantContext = ExternalConstantContext;
FHIRPathParser.InvocationContext = InvocationContext;
FHIRPathParser.FunctnContext = FunctnContext;
FHIRPathParser.ParamListContext = ParamListContext;
FHIRPathParser.QuantityContext = QuantityContext;
FHIRPathParser.UnitContext = UnitContext;
FHIRPathParser.DateTimePrecisionContext = DateTimePrecisionContext;
FHIRPathParser.PluralDateTimePrecisionContext = PluralDateTimePrecisionContext;
FHIRPathParser.TypeSpecifierContext = TypeSpecifierContext;
FHIRPathParser.QualifiedIdentifierContext = QualifiedIdentifierContext;
FHIRPathParser.IdentifierContext = IdentifierContext;
module.exports = FHIRPathParser;

/***/ }),
/* 54 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated from FHIRPath.g4 by ANTLR 4.9.3
// jshint ignore: start
const antlr4 = __webpack_require__(7); // This class defines a complete listener for a parse tree produced by FHIRPathParser.


class FHIRPathListener extends antlr4.tree.ParseTreeListener {
  // Enter a parse tree produced by FHIRPathParser#entireExpression.
  enterEntireExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#entireExpression.


  exitEntireExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#indexerExpression.


  enterIndexerExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#indexerExpression.


  exitIndexerExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#polarityExpression.


  enterPolarityExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#polarityExpression.


  exitPolarityExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#additiveExpression.


  enterAdditiveExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#additiveExpression.


  exitAdditiveExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#multiplicativeExpression.


  enterMultiplicativeExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#multiplicativeExpression.


  exitMultiplicativeExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#unionExpression.


  enterUnionExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#unionExpression.


  exitUnionExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#orExpression.


  enterOrExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#orExpression.


  exitOrExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#andExpression.


  enterAndExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#andExpression.


  exitAndExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#membershipExpression.


  enterMembershipExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#membershipExpression.


  exitMembershipExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#inequalityExpression.


  enterInequalityExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#inequalityExpression.


  exitInequalityExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#invocationExpression.


  enterInvocationExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#invocationExpression.


  exitInvocationExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#equalityExpression.


  enterEqualityExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#equalityExpression.


  exitEqualityExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#impliesExpression.


  enterImpliesExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#impliesExpression.


  exitImpliesExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#termExpression.


  enterTermExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#termExpression.


  exitTermExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#typeExpression.


  enterTypeExpression(ctx) {} // Exit a parse tree produced by FHIRPathParser#typeExpression.


  exitTypeExpression(ctx) {} // Enter a parse tree produced by FHIRPathParser#invocationTerm.


  enterInvocationTerm(ctx) {} // Exit a parse tree produced by FHIRPathParser#invocationTerm.


  exitInvocationTerm(ctx) {} // Enter a parse tree produced by FHIRPathParser#literalTerm.


  enterLiteralTerm(ctx) {} // Exit a parse tree produced by FHIRPathParser#literalTerm.


  exitLiteralTerm(ctx) {} // Enter a parse tree produced by FHIRPathParser#externalConstantTerm.


  enterExternalConstantTerm(ctx) {} // Exit a parse tree produced by FHIRPathParser#externalConstantTerm.


  exitExternalConstantTerm(ctx) {} // Enter a parse tree produced by FHIRPathParser#parenthesizedTerm.


  enterParenthesizedTerm(ctx) {} // Exit a parse tree produced by FHIRPathParser#parenthesizedTerm.


  exitParenthesizedTerm(ctx) {} // Enter a parse tree produced by FHIRPathParser#nullLiteral.


  enterNullLiteral(ctx) {} // Exit a parse tree produced by FHIRPathParser#nullLiteral.


  exitNullLiteral(ctx) {} // Enter a parse tree produced by FHIRPathParser#booleanLiteral.


  enterBooleanLiteral(ctx) {} // Exit a parse tree produced by FHIRPathParser#booleanLiteral.


  exitBooleanLiteral(ctx) {} // Enter a parse tree produced by FHIRPathParser#stringLiteral.


  enterStringLiteral(ctx) {} // Exit a parse tree produced by FHIRPathParser#stringLiteral.


  exitStringLiteral(ctx) {} // Enter a parse tree produced by FHIRPathParser#numberLiteral.


  enterNumberLiteral(ctx) {} // Exit a parse tree produced by FHIRPathParser#numberLiteral.


  exitNumberLiteral(ctx) {} // Enter a parse tree produced by FHIRPathParser#dateTimeLiteral.


  enterDateTimeLiteral(ctx) {} // Exit a parse tree produced by FHIRPathParser#dateTimeLiteral.


  exitDateTimeLiteral(ctx) {} // Enter a parse tree produced by FHIRPathParser#timeLiteral.


  enterTimeLiteral(ctx) {} // Exit a parse tree produced by FHIRPathParser#timeLiteral.


  exitTimeLiteral(ctx) {} // Enter a parse tree produced by FHIRPathParser#quantityLiteral.


  enterQuantityLiteral(ctx) {} // Exit a parse tree produced by FHIRPathParser#quantityLiteral.


  exitQuantityLiteral(ctx) {} // Enter a parse tree produced by FHIRPathParser#externalConstant.


  enterExternalConstant(ctx) {} // Exit a parse tree produced by FHIRPathParser#externalConstant.


  exitExternalConstant(ctx) {} // Enter a parse tree produced by FHIRPathParser#memberInvocation.


  enterMemberInvocation(ctx) {} // Exit a parse tree produced by FHIRPathParser#memberInvocation.


  exitMemberInvocation(ctx) {} // Enter a parse tree produced by FHIRPathParser#functionInvocation.


  enterFunctionInvocation(ctx) {} // Exit a parse tree produced by FHIRPathParser#functionInvocation.


  exitFunctionInvocation(ctx) {} // Enter a parse tree produced by FHIRPathParser#thisInvocation.


  enterThisInvocation(ctx) {} // Exit a parse tree produced by FHIRPathParser#thisInvocation.


  exitThisInvocation(ctx) {} // Enter a parse tree produced by FHIRPathParser#indexInvocation.


  enterIndexInvocation(ctx) {} // Exit a parse tree produced by FHIRPathParser#indexInvocation.


  exitIndexInvocation(ctx) {} // Enter a parse tree produced by FHIRPathParser#totalInvocation.


  enterTotalInvocation(ctx) {} // Exit a parse tree produced by FHIRPathParser#totalInvocation.


  exitTotalInvocation(ctx) {} // Enter a parse tree produced by FHIRPathParser#functn.


  enterFunctn(ctx) {} // Exit a parse tree produced by FHIRPathParser#functn.


  exitFunctn(ctx) {} // Enter a parse tree produced by FHIRPathParser#paramList.


  enterParamList(ctx) {} // Exit a parse tree produced by FHIRPathParser#paramList.


  exitParamList(ctx) {} // Enter a parse tree produced by FHIRPathParser#quantity.


  enterQuantity(ctx) {} // Exit a parse tree produced by FHIRPathParser#quantity.


  exitQuantity(ctx) {} // Enter a parse tree produced by FHIRPathParser#unit.


  enterUnit(ctx) {} // Exit a parse tree produced by FHIRPathParser#unit.


  exitUnit(ctx) {} // Enter a parse tree produced by FHIRPathParser#dateTimePrecision.


  enterDateTimePrecision(ctx) {} // Exit a parse tree produced by FHIRPathParser#dateTimePrecision.


  exitDateTimePrecision(ctx) {} // Enter a parse tree produced by FHIRPathParser#pluralDateTimePrecision.


  enterPluralDateTimePrecision(ctx) {} // Exit a parse tree produced by FHIRPathParser#pluralDateTimePrecision.


  exitPluralDateTimePrecision(ctx) {} // Enter a parse tree produced by FHIRPathParser#typeSpecifier.


  enterTypeSpecifier(ctx) {} // Exit a parse tree produced by FHIRPathParser#typeSpecifier.


  exitTypeSpecifier(ctx) {} // Enter a parse tree produced by FHIRPathParser#qualifiedIdentifier.


  enterQualifiedIdentifier(ctx) {} // Exit a parse tree produced by FHIRPathParser#qualifiedIdentifier.


  exitQualifiedIdentifier(ctx) {} // Enter a parse tree produced by FHIRPathParser#identifier.


  enterIdentifier(ctx) {} // Exit a parse tree produced by FHIRPathParser#identifier.


  exitIdentifier(ctx) {}

}

module.exports = FHIRPathListener;

/***/ }),
/* 55 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds utility functions used in implementing the public functions.
const util = {};

const types = __webpack_require__(56);

let {
  ResourceNode
} = types;
/**
 *  Reports and error to the calling environment and stops processing.
 * @param message the error message
 * @param fnName the name of the function raising the error (optional)
 */

util.raiseError = function (message, fnName) {
  fnName = fnName ? fnName + ": " : "";
  throw fnName + message;
};
/**
 *  Throws an exception if the collection contains more than one value.
 * @param collection the collection to be checked.
 * @param errorMsgPrefix An optional prefix for the error message to assist in
 *  debugging.
 */


util.assertAtMostOne = function (collection, errorMsgPrefix) {
  if (collection.length > 1) {
    util.raiseError("Was expecting no more than one element but got " + JSON.stringify(collection), errorMsgPrefix);
  }
};
/**
 *  Throws an exception if the data is not one of the expected types.
 * @param data the value to be checked.  This may be a ResourceNode.
 * @param types an array of the permitted types
 * @param errorMsgPrefix An optional prefix for the error message to assist in
 *  debugging.
 * @return the value that was checked.  If "data" was a ResourceNode, this will
 *  be the ReourceNode's data.
 */


util.assertType = function (data, types, errorMsgPrefix) {
  let val = this.valData(data);

  if (types.indexOf(typeof val) < 0) {
    let typeList = types.length > 1 ? "one of " + types.join(", ") : types[0];
    util.raiseError("Found type '" + typeof data + "' but was expecting " + typeList, errorMsgPrefix);
  }

  return val;
};

util.isEmpty = function (x) {
  return Array.isArray(x) && x.length == 0;
};

util.isSome = function (x) {
  return x !== null && x !== undefined && !util.isEmpty(x);
};

util.isTrue = function (x) {
  return x !== null && x !== undefined && (x === true || x.length == 1 && x[0] === true);
};

util.isFalse = function (x) {
  return x !== null && x !== undefined && (x === false || x.length == 1 && x[0] === false);
};

util.isCapitalized = function (x) {
  return x && x[0] === x[0].toUpperCase();
};

util.flatten = function (x) {
  return x.reduce(function (acc, x) {
    if (Array.isArray(x)) {
      // todo replace with array modification
      acc = acc.concat(x);
    } else {
      acc.push(x);
    }

    return acc;
  }, []);
};

util.arraify = function (x) {
  if (Array.isArray(x)) {
    return x;
  }

  if (util.isSome(x)) {
    return [x];
  }

  return [];
};
/**
 *  Returns the data value of the given parameter, which might be a ResourceNode.
 *  Otherwise, it returns the value that was passed in.
 */


util.valData = function (val) {
  return val instanceof ResourceNode ? val.data : val;
};
/**
 *  Returns the data value of the given parameter, which might be a ResourceNode.
 *  Otherwise, it returns the value that was passed in.  In the case of a
 *  ResourceNode that is a Quantity, the returned value will have been converted
 *  to an FP_Quantity.
 */


util.valDataConverted = function (val) {
  if (val instanceof ResourceNode) {
    val = val.convertData();
  }

  return val;
};
/**
 * Prepares a string for insertion into a regular expression
 * @param {string} str
 * @return {string}
 */


util.escapeStringForRegExp = function (str) {
  return str.replace(/[-[\]{}()*+?.,\\/^$|#\s]/g, '\\$&');
};

module.exports = util;

/***/ }),
/* 56 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const addMinutes = __webpack_require__(57);

const ucumUtils = (__webpack_require__(62).UcumLhcUtils.getInstance)();

const numbers = __webpack_require__(63);

const ucumSystemUrl = 'http://unitsofmeasure.org';
let timeFormat = '[0-9][0-9](\\:[0-9][0-9](\\:[0-9][0-9](\\.[0-9]+)?)?)?(Z|(\\+|-)[0-9][0-9]\\:[0-9][0-9])?';
let timeRE = new RegExp('^T?' + timeFormat + '$');
let dateTimeRE = new RegExp('^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9](T' + timeFormat + ')?)?)?Z?$');
let dateRE = new RegExp('^[0-9][0-9][0-9][0-9](-[0-9][0-9](-[0-9][0-9])?)?$'); // FHIR date/time regular expressions are slightly different.  For now, we will
// stick with the FHIRPath regular expressions.
//let fhirTimeRE = /([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?/;
//let fhirDateTimeRE =
///([0-9]([0-9]([0-9][1-9]|[1-9]0)|[1-9]00)|[1-9]000)(-(0[1-9]|1[0-2])(-(0[1-9]|[1-2][0-9]|3[0-1])(T([01][0-9]|2[0-3]):[0-5][0-9]:([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00)))?)?)?/;

/**
 *   Class FP_Type is the superclass for FHIRPath types that required special
 *   handling.
 */

class FP_Type {
  /**
   *  Tests whether this object is equal to another.  Returns either true,
   *  false, or undefined (where in the FHIRPath specification empty would be
   *  returned).  The undefined return value indicates that the values were the
   *  same to the shared precision, but that they had differnent levels of
   *  precision.
   */
  equals() {
    return false;
  }
  /**
   *  Tests whether this object is equivalant to another.  Returns either true,
   *  false, or undefined (where in the FHIRPath specification empty would be
   *  returned).
   */


  equivalentTo() {
    return false;
  }

  toString() {
    return this.asStr ? this.asStr : super.toString();
  }

  toJSON() {
    return this.toString();
  }
  /**
   *  Returns -1, 0, or 1 if this object is less then, equal to, or greater
   *  than otherObj.
   */


  compare() {
    throw 'Not implemented';
  }

}
/**
 *  A class for Quantities.
 */


class FP_Quantity extends FP_Type {
  constructor(value, unit) {
    super();
    this.asStr = value + ' ' + unit;
    this.value = value;
    this.unit = unit;
  }

  equals(otherQuantity) {
    if (!(otherQuantity instanceof this.constructor)) {
      return false;
    }

    if (this.unit === otherQuantity.unit) {
      return numbers.isEqual(this.value, otherQuantity.value);
    } // Special year/month comparison case: 1 year = 12 month


    const compareYearsAndMonths = this._compareYearsAndMonths(otherQuantity);

    if (compareYearsAndMonths) {
      return compareYearsAndMonths.isEqual;
    } // General comparison case


    const thisQuantity = FP_Quantity.toUcumQuantity(this.value, this.unit),
          normalizedOtherQuantity = FP_Quantity.toUcumQuantity(otherQuantity.value, otherQuantity.unit),
          convResult = ucumUtils.convertUnitTo(normalizedOtherQuantity.unit, normalizedOtherQuantity.value, thisQuantity.unit);

    if (convResult.status !== 'succeeded') {
      return false;
    }

    return numbers.isEqual(thisQuantity.value, convResult.toVal);
  }

  equivalentTo(otherQuantity) {
    if (!(otherQuantity instanceof this.constructor)) {
      return false;
    }

    if (this.unit === otherQuantity.unit) {
      return numbers.isEquivalent(this.value, otherQuantity.value);
    }

    const ucumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(this.unit),
          otherUcumUnitCode = FP_Quantity.getEquivalentUcumUnitCode(otherQuantity.unit),
          convResult = ucumUtils.convertUnitTo(otherUcumUnitCode, otherQuantity.value, ucumUnitCode);

    if (convResult.status !== 'succeeded') {
      return false;
    }

    return numbers.isEquivalent(this.value, convResult.toVal);
  }
  /**
   * If both quantities have one of these units: year or month,
   * then a special case will apply; otherwise returns null.
   * In the special case of comparison, the fact that 1 year = 12 months is used.
   *
   * Just note: in general, for a calendar duration:
   * 1 year = 365 days
   * 12 month = 12*30 days = 360 days
   * so, 1 year != 12 month
   * That's why this special case is needed
   *
   * @param {FP_Quantity} otherQuantity
   * @return {null|{isEqual: boolean}}
   * @private
   */


  _compareYearsAndMonths(otherQuantity) {
    const magnitude1 = FP_Quantity._yearMonthConversionFactor[this.unit],
          magnitude2 = FP_Quantity._yearMonthConversionFactor[otherQuantity.unit];

    if (magnitude1 && magnitude2) {
      return {
        isEqual: numbers.isEqual(this.value * magnitude1, otherQuantity.value * magnitude2)
      };
    }

    return null;
  }

}

const surroundingApostrophesRegex = /^'|'$/g;
/**
 * Converts a FHIR path unit to a UCUM unit code by converting a calendar duration keyword to an equivalent UCUM unit code
 * or removing single quotes for a UCUM unit.
 * @param {string} unit
 * @return {string}
 */

FP_Quantity.getEquivalentUcumUnitCode = function (unit) {
  return FP_Quantity.mapTimeUnitsToUCUMCode[unit] || unit.replace(surroundingApostrophesRegex, '');
};
/**
 * Converts FHIR path value/unit to UCUM value/unit. Usable for comparison.
 * @param {number} value
 * @param {string} unit
 * @returns { {value: number, unit: string} }
 */


FP_Quantity.toUcumQuantity = function (value, unit) {
  const magnitude = FP_Quantity._calendarDuration2Seconds[unit];

  if (magnitude) {
    return {
      value: magnitude * value,
      unit: 's'
    };
  }

  return {
    value,
    unit: unit.replace(surroundingApostrophesRegex, '')
  };
};
/**
 * Converts FHIRPath value/unit to other FHIRPath value/unit.
 * @param {string} fromUnit
 * @param {number} value
 * @param {string} toUnit
 * @return {FP_Quantity|null}
 */


FP_Quantity.convUnitTo = function (fromUnit, value, toUnit) {
  // 1 Year <-> 12 Months
  const fromYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[fromUnit],
        toYearMonthMagnitude = FP_Quantity._yearMonthConversionFactor[toUnit];

  if (fromYearMonthMagnitude && toYearMonthMagnitude) {
    return new FP_Quantity(fromYearMonthMagnitude * value / toYearMonthMagnitude, toUnit);
  }

  const fromMagnitude = FP_Quantity._calendarDuration2Seconds[fromUnit],
        toMagnitude = FP_Quantity._calendarDuration2Seconds[toUnit]; // To FHIR path calendar duration

  if (toMagnitude) {
    if (fromMagnitude) {
      return new FP_Quantity(fromMagnitude * value / toMagnitude, toUnit);
    } else {
      const convResult = ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, 's');

      if (convResult.status === 'succeeded') {
        return new FP_Quantity(convResult.toVal / toMagnitude, toUnit);
      }
    } // To Ucum unit

  } else {
    const convResult = fromMagnitude ? ucumUtils.convertUnitTo('s', fromMagnitude * value, toUnit.replace(/^'|'$/g, '')) : ucumUtils.convertUnitTo(fromUnit.replace(/^'|'$/g, ''), value, toUnit.replace(/^'|'$/g, ''));

    if (convResult.status === 'succeeded') {
      return new FP_Quantity(convResult.toVal, toUnit);
    }
  }

  return null;
}; // Defines conversion factors for calendar durations


FP_Quantity._calendarDuration2Seconds = {
  'years': 365 * 24 * 60 * 60,
  'months': 30 * 24 * 60 * 60,
  'weeks': 7 * 24 * 60 * 60,
  'days': 24 * 60 * 60,
  'hours': 60 * 60,
  'minutes': 60,
  'seconds': 1,
  'milliseconds': .001,
  'year': 365 * 24 * 60 * 60,
  'month': 30 * 24 * 60 * 60,
  'week': 7 * 24 * 60 * 60,
  'day': 24 * 60 * 60,
  'hour': 60 * 60,
  'minute': 60,
  'second': 1,
  'millisecond': .001
}; // Defines special case to compare years with months for calendar durations

FP_Quantity._yearMonthConversionFactor = {
  'years': 12,
  'months': 1,
  'year': 12,
  'month': 1
};
/**
 *  Defines a map from time units that are supported for arithmetic (including
 *  some UCUM time based units) to FHIRPath time units.
 */

FP_Quantity.arithmeticDurationUnits = {
  'years': "year",
  'months': "month",
  'weeks': "week",
  'days': "day",
  'hours': "hour",
  'minutes': "minute",
  'seconds': "second",
  'milliseconds': "millisecond",
  'year': "year",
  'month': "month",
  'week': "week",
  'day': "day",
  'hour': "hour",
  'minute': "minute",
  'second': "second",
  'millisecond': "millisecond",
  "'wk'": "week",
  "'d'": "day",
  "'h'": "hour",
  "'min'": "minute",
  "'s'": "second",
  "'ms'": "millisecond"
};
/**
 *  Defines a map from UCUM code to FHIRPath time units.
 */

FP_Quantity.mapUCUMCodeToTimeUnits = {
  'a': "year",
  'mo': "month",
  'wk': "week",
  'd': "day",
  'h': "hour",
  'min': "minute",
  's': "second",
  'ms': "millisecond"
};
/**
 *  Defines a map from FHIRPath time units to UCUM code.
 */

FP_Quantity.mapTimeUnitsToUCUMCode = Object.keys(FP_Quantity.mapUCUMCodeToTimeUnits).reduce(function (res, key) {
  res[FP_Quantity.mapUCUMCodeToTimeUnits[key]] = key;
  res[FP_Quantity.mapUCUMCodeToTimeUnits[key] + 's'] = key;
  return res;
}, {});

class FP_TimeBase extends FP_Type {
  constructor(timeStr) {
    super();
    this.asStr = timeStr;
  }
  /**
   *  Adds a time-based quantity to this date/time.
   * @param timeQuantity a quantity to be added to this date/time.  See the
   *  FHIRPath specification for supported units.
   */


  plus(timeQuantity) {
    const unit = timeQuantity.unit;
    let timeUnit = FP_Quantity.arithmeticDurationUnits[unit];

    if (!timeUnit) {
      throw new Error('For date/time arithmetic, the unit of the quantity ' + 'must be one of the following time-based units: ' + Object.keys(FP_Quantity.arithmeticDurationUnits));
    }

    const cls = this.constructor;
    const unitPrecision = cls._timeUnitToDatePrecision[timeUnit];

    if (unitPrecision === undefined) {
      throw new Error('Unsupported unit for +.  The unit should be one of ' + Object.keys(cls._timeUnitToDatePrecision).join(', ') + '.');
    }

    let qVal = timeQuantity.value;
    const isTime = cls === FP_Time; // From the FHIRPath specification: "For precisions above seconds, the
    // decimal portion of the time-valued quantity is ignored, since date/time
    // arithmetic above seconds is performed with calendar duration semantics."

    if (isTime ? unitPrecision < 2 : unitPrecision < 5) {
      qVal = Math.trunc(qVal);
    } // If the precision of the time quantity is higher than the precision of the
    // date, we need to convert the time quantity to the precision of the date.


    if (this._getPrecision() < unitPrecision) {
      const neededUnit = cls._datePrecisionToTimeUnit[this._getPrecision()];

      if (neededUnit !== 'second') {
        const newQuantity = FP_Quantity.convUnitTo(timeUnit, qVal, neededUnit);
        timeUnit = newQuantity.unit;
        qVal = Math.trunc(newQuantity.value);
      }
    }

    const newDate = FP_TimeBase.timeUnitToAddFn[timeUnit](this._getDateObj(), qVal); // newDate is a Date.  We need to make a string with the correct precision.

    let precision = this._getPrecision();

    if (isTime) precision += 3; // based on dateTimeRE, not timeRE

    let newDateStr = FP_DateTime.isoDateTime(newDate, precision);

    if (isTime) {
      // FP_Time just needs the time part of the string
      newDateStr = newDateStr.slice(newDateStr.indexOf('T') + 1);
    }

    return new cls(newDateStr);
  }
  /**
   *  Tests whether this object is equal to another.  Returns either true,
   *  false, or undefined (where in the FHIRPath specification empty would be
   *  returned).  The undefined return value indicates that the values were the
   *  same to the shared precision, but that they had differnent levels of
   *  precision.
   * @param otherDateTime any sub-type of FP_TimeBase, but it should be the same
   *  as the type of "this".
   */


  equals(otherDateTime) {
    // From the 2019May ballot:
    // For Date, DateTime and Time equality, the comparison is performed by
    // considering each precision in order, beginning with years (or hours for
    // time values), and respecting timezone offsets. If the values are the
    // same, comparison proceeds to the next precision; if the values are
    // different, the comparison stops and the result is false. If one input has
    // a value for the precision and the other does not, the comparison stops
    // and the result is empty ({ }); if neither input has a value for the
    // precision, or the last precision has been reached, the comparison stops
    // and the result is true.
    // Note:  Per the spec above
    //   2012-01 = 2012 //  empty
    //   2012-01 = 2011 //  false
    //   2012-01 ~ 2012 //  false
    var rtn;
    if (!(otherDateTime instanceof this.constructor) && !(this instanceof otherDateTime.constructor)) rtn = false;else {
      var thisPrec = this._getPrecision();

      var otherPrec = otherDateTime._getPrecision();

      if (thisPrec == otherPrec) {
        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();
      } else {
        // The dates are not equal, but decide whether to return empty or false.
        var commonPrec = thisPrec <= otherPrec ? thisPrec : otherPrec; // Adjust for timezone offsets, if any, so they are at a common timezone

        var thisUTCStr = this._getDateObj().toISOString();

        var otherUTCStr = otherDateTime._getDateObj().toISOString();

        if (this.constructor === FP_Time) {
          commonPrec += 3; // because we now have year, month, and day

          thisPrec += 3;
          otherPrec += 3;
        } // Now parse the strings and compare the adjusted time parts.
        // Dates without time specify no timezone and should be treated as already normalized to UTC. So we do not adjust the timezone, as this would change the date


        var thisAdj = thisPrec > 2 ? new FP_DateTime(thisUTCStr)._getTimeParts() : this._getTimeParts();
        var otherAdj = otherPrec > 2 ? new FP_DateTime(otherUTCStr)._getTimeParts() : otherDateTime._getTimeParts();

        for (var i = 0; i <= commonPrec && rtn !== false; ++i) {
          rtn = thisAdj[i] == otherAdj[i];
        } // if rtn is still true, then return empty to indicate the difference in
        // precision.


        if (rtn) rtn = undefined;
      }
    } // else return undefined (empty)

    return rtn;
  }
  /**
   *  Tests whether this object is equivalant to another.  Returns either true
   *  or false.
   */


  equivalentTo(otherDateTime) {
    var rtn = otherDateTime instanceof this.constructor;

    if (rtn) {
      var thisPrec = this._getPrecision();

      var otherPrec = otherDateTime._getPrecision();

      rtn = thisPrec == otherPrec;

      if (rtn) {
        rtn = this._getDateObj().getTime() == otherDateTime._getDateObj().getTime();
      }
    }

    return rtn;
  }
  /**
   *  Returns a number less than 0, equal to 0 or greater than 0
   *  if this (date) time is less than, equal to, or greater than otherTime.
   *  Comparisons are made at the lesser of the two time precisions.
   *  @param {FP_TimeBase} otherTime
   *  @return {number}
   */


  compare(otherTime) {
    var thisPrecision = this._getPrecision();

    var otherPrecision = otherTime._getPrecision();

    var thisTimeInt = thisPrecision <= otherPrecision ? this._getDateObj().getTime() : this._dateAtPrecision(otherPrecision).getTime();
    var otherTimeInt = otherPrecision <= thisPrecision ? otherTime._getDateObj().getTime() : otherTime._dateAtPrecision(thisPrecision).getTime();

    if (thisPrecision !== otherPrecision && thisTimeInt === otherTimeInt) {
      return null;
    }

    return thisTimeInt - otherTimeInt;
  }
  /**
   *  Returns a number representing the precision of the time string given to
   *  the constructor.  (Higher means more precise).  The number is the number
   *  of components of the time string (ignoring the time zone) produced by
   *  matching against the time regular expression, except that milliseconds
   *  and seconds are counted together as a single of level of precision.
   *  @return {number}
   */


  _getPrecision() {
    if (this.precision === undefined) this._getMatchData();
    return this.precision;
  }
  /**
   *  Returns the match data from matching the given RegExp against the
   *  date/time string given to the constructor.
   *  Also sets this.precision.
   * @param regEx The regular expression to match against the date/time string.
   * @param maxPrecision the maximum precision possible for the type
   */


  _getMatchData(regEx, maxPrecision) {
    if (this.timeMatchData === undefined) {
      this.timeMatchData = this.asStr.match(regEx);

      if (this.timeMatchData) {
        for (let i = maxPrecision; i >= 0 && this.precision === undefined; --i) {
          if (this.timeMatchData[i]) this.precision = i;
        }
      }
    }

    return this.timeMatchData;
  }
  /**
   *  Returns an array of the pieces of the given time string, for use in
   *  constructing lower precision versions of the time. The returned array will
   *  contain separate elements for the hour, minutes, seconds, and milliseconds
   *  (or as many of those are as present).  The length of the returned array
   *  will therefore be an indication of the precision.
   *  It will not include the timezone.
   * @timeMatchData the result of matching the time portion of the string passed
   *  into the constructor against the "timeRE" regular expression.
   */


  _getTimeParts(timeMatchData) {
    var timeParts = []; // Finish parsing the data into pieces, for later use in building
    // lower-precision versions of the date if needed.

    timeParts = [timeMatchData[0]];
    var timeZone = timeMatchData[4];

    if (timeZone) {
      // remove time zone from hours
      let hours = timeParts[0];
      timeParts[0] = hours.slice(0, hours.length - timeZone.length);
    }

    var min = timeMatchData[1];

    if (min) {
      // remove minutes from hours
      let hours = timeParts[0];
      timeParts[0] = hours.slice(0, hours.length - min.length);
      timeParts[1] = min;
      var sec = timeMatchData[2];

      if (sec) {
        // remove seconds from minutes
        timeParts[1] = min.slice(0, min.length - sec.length);
        timeParts[2] = sec;
        var ms = timeMatchData[3];

        if (ms) {
          // remove milliseconds from seconds
          timeParts[2] = sec.slice(0, sec.length - ms.length);
          timeParts[3] = ms;
        }
      }
    }

    return timeParts;
  }
  /**
   *  Returns a date object representing this time on a certain date.
   */


  _getDateObj() {
    if (!this.dateObj) {
      var precision = this._getPrecision(); // We cannot directly pass the string into the date constructor because
      // (1) we don't want to introduce a time-dependent system date and (2) the
      // time string might not have contained minutes, which are required by the
      // Date constructor.


      this.dateObj = this._dateAtPrecision(precision);
    }

    return this.dateObj;
  }
  /**
   *  Creates a date object for the given timezone.  The returned date object
   *  will have the specified date and time in the specified timezone.
   * @param year...ms Just as in the Date constructor.
   * @param timezoneOffset (optional) a string in the format (+-)HH:mm or Z, representing the
   *  timezone offset.  If not provided, the local timzone will be assumed (as the
   *  Date constructor does).
   */


  _createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset) {
    var d = new Date(year, month, day, hour, minutes, seconds, ms);

    if (timezoneOffset) {
      // d is in local time.  Adjust for the timezone offset.
      // First adjust the date by the timezone offset before reducing its
      // precision.  Otherwise,
      // @2018-11-01T-04:00 < @2018T-05:00
      var localTimezoneMinutes = d.getTimezoneOffset();
      var timezoneMinutes = 0; // if Z

      if (timezoneOffset != 'Z') {
        var timezoneParts = timezoneOffset.split(':'); // (+-)hours:minutes

        var hours = parseInt(timezoneParts[0]);
        timezoneMinutes = parseInt(timezoneParts[1]);
        if (hours < 0) timezoneMinutes = -timezoneMinutes;
        timezoneMinutes += 60 * hours;
      } // localTimezoneMinutes has the inverse sign of its timezone offset


      d = addMinutes(d, -localTimezoneMinutes - timezoneMinutes);
    }

    return d;
  }

}
/**
 *  A map from a FHIRPath time units to a function used to add that
 *  quantity to a date/time.
 */


FP_TimeBase.timeUnitToAddFn = {
  "year": __webpack_require__(64),
  "month": __webpack_require__(65),
  "week": __webpack_require__(67),
  "day": __webpack_require__(68),
  "hour": __webpack_require__(69),
  "minute": __webpack_require__(57),
  "second": __webpack_require__(70),
  "millisecond": __webpack_require__(58)
};

class FP_DateTime extends FP_TimeBase {
  /**
   *  Constructs an FP_DateTime, assuming dateStr is valid.  If you don't know
   *  whether a string is a valid DateTime, use FP_DateTime.checkString instead.
   */
  constructor(dateStr) {
    super(dateStr);
  }
  /**
   *  Returns -1, 0, or 1 if this date time is less then, equal to, or greater
   *  than otherDateTime.  Comparisons are made at the lesser of the two date time
   *  precisions.
   */


  compare(otherDateTime) {
    if (!(otherDateTime instanceof FP_DateTime)) throw 'Invalid comparison of a DateTime with something else';
    return super.compare(otherDateTime);
  }
  /**
   *  Returns the match data from matching dateTimeRE against the datetime string.
   *  Also sets this.precision.
   */


  _getMatchData() {
    return super._getMatchData(dateTimeRE, 5);
  }
  /**
   *  Returns an array of the pieces of the date time string passed into the
   *  constructor, for use in constructing lower precision versions of the
   *  date time. The returned array will contain separate elements for the year,
   *  month, day, hour, minutes, seconds, and milliseconds (or as many of those
   *  are as present).  The length of the returned array will therefore be an
   *  indication of the precision.  It will not include the timezone.
   */


  _getTimeParts() {
    if (!this.timeParts) {
      let timeMatchData = this._getMatchData();

      let year = timeMatchData[0];
      this.timeParts = [year];
      var month = timeMatchData[1];

      if (month) {
        // Remove other information from year
        this.timeParts[0] = year.slice(0, year.length - month.length);
        this.timeParts[1] = month;
        let day = timeMatchData[2];

        if (day) {
          // Remove day information from month
          this.timeParts[1] = month.slice(0, month.length - day.length);
          this.timeParts[2] = day;
          let time = timeMatchData[3];

          if (time) {
            // Remove time from day
            this.timeParts[2] = day.slice(0, day.length - time.length);
            if (time[0] === 'T') // remove T from hour
              timeMatchData[3] = time.slice(1);
            this.timeParts = this.timeParts.concat(super._getTimeParts(timeMatchData.slice(3)));
          }
        }
      }
    }

    return this.timeParts;
  }
  /**
   *  Returns a new Date object for a time equal to what this time would be if
   *  the string passed into the constructor had the given precision.
   * @param precision the new precision, which is assumed to be less than
   *  or equal to the current precision.
   */


  _dateAtPrecision(precision) {
    var timeParts = this._getTimeParts();

    var timezoneOffset = this._getMatchData()[7]; // Get the date object first at the current precision.


    var thisPrecision = this._getPrecision();

    var year = parseInt(timeParts[0]);
    var month = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) - 1 : 0;
    var day = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 1;
    var hour = thisPrecision > 2 ? parseInt(timeParts[3]) : 0;
    var minutes = thisPrecision > 3 ? parseInt(timeParts[4].slice(1)) : 0;
    var seconds = thisPrecision > 4 ? parseInt(timeParts[5].slice(1)) : 0;
    var ms = timeParts.length > 6 ? parseInt(timeParts[6].slice(1)) : 0;

    var d = this._createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset);

    if (precision < thisPrecision) {
      // Adjust the precision
      year = d.getFullYear();
      month = precision > 0 ? d.getMonth() : 0;
      day = precision > 1 ? d.getDate() : 1;
      hour = precision > 2 ? d.getHours() : 0;
      minutes = precision > 3 ? d.getMinutes() : 0; // Here the precision will always be less than the maximum
      // due to the condition in the if statement: "precision < thisPrecision"

      d = new Date(year, month, day, hour, minutes);
    }

    return d;
  }

}
/**
 *  Tests str to see if it is convertible to a DateTime.
 * @return If str is convertible to a DateTime, returns an FP_DateTime;
 *  otherwise returns null.
 */


FP_DateTime.checkString = function (str) {
  let d = new FP_DateTime(str);
  if (!d._getMatchData()) d = null;
  return d;
};
/**
 *  A map from FHIRPath time units to the internal DateTime "precision" number.
 */


FP_DateTime._timeUnitToDatePrecision = {
  "year": 0,
  "month": 1,
  "week": 2,
  // wk is just 7*d
  "day": 2,
  "hour": 3,
  "minute": 4,
  "second": 5,
  "millisecond": 6
};
/**
 *  The inverse of _timeUnitToDatePrecision.
 */

FP_DateTime._datePrecisionToTimeUnit = ["year", "month", "day", "hour", "minute", "second", "millisecond"];

class FP_Time extends FP_TimeBase {
  /**
   *  Constructs an FP_Time, assuming dateStr is valid.  If you don't know
   *  whether a string is a valid DateTime, use FP_Time.checkString instead.
   */
  constructor(timeStr) {
    if (timeStr[0] == 'T') timeStr = timeStr.slice(1);
    super(timeStr);
  }
  /**
   *  Returns -1, 0, or 1 if this time is less then, equal to, or greater
   *  than otherTime.  Comparisons are made at the lesser of the two time
   *  precisions.
   */


  compare(otherTime) {
    if (!(otherTime instanceof FP_Time)) throw 'Invalid comparison of a time with something else';
    return super.compare(otherTime);
  }
  /**
   *  Returns a new Date object for a time equal to what this time would be if
   *  the string passed into the constructor had the given precision.
   *  The "date" portion of the returned Date object is not meaningful, and
   *  should be ignored.
   * @param precision the new precision, which is assumed to be less than the
   *  or equal to the current precision.  A precision of 0 means the hour.
   */


  _dateAtPrecision(precision) {
    var timeParts = this._getTimeParts();

    var timezoneOffset = this._getMatchData()[4]; // Get the date object first at the current precision.


    var thisPrecision = this._getPrecision();

    var year = 2010; // Have to pick some year for the date object

    var month = 0;
    var day = 1;
    var hour = parseInt(timeParts[0]);
    var minutes = thisPrecision > 0 ? parseInt(timeParts[1].slice(1)) : 0;
    var seconds = thisPrecision > 1 ? parseInt(timeParts[2].slice(1)) : 0;
    var ms = timeParts.length > 3 ? parseInt(timeParts[3].slice(1)) : 0;

    var d = this._createDate(year, month, day, hour, minutes, seconds, ms, timezoneOffset);

    if (timezoneOffset) {
      // Keep the date the same (in the local timezone), so it is not a relevant
      // factor when comparing different times.
      d.setYear(year);
      d.setMonth(month);
      d.setDate(day);
    }

    if (precision < thisPrecision) {
      // Adjust the precision
      hour = d.getHours();
      minutes = precision > 0 ? d.getMinutes() : 0; // Here the precision will always be less than the maximum
      // due to the condition in the if statement: "precision < thisPrecision"

      d = new Date(year, month, day, hour, minutes);
    }

    return d;
  }
  /**
   *  Returns the match data from matching timeRE against the time string.
   *  Also sets this.precision.
   */


  _getMatchData() {
    return super._getMatchData(timeRE, 2);
  }
  /**
   *  Returns an array of the pieces of the time string passed into the
   *  constructor, for use in constructing lower precision versions of the
   *  time. The returned array will contain separate elements for the hour,
   *  minutes, seconds, and milliseconds (or as many of those are as present).
   *  The length of the returned array will therefore be an indication of the
   *  precision.  It will not include the timezone.
   */


  _getTimeParts() {
    if (!this.timeParts) {
      this.timeParts = super._getTimeParts(this._getMatchData());
    }

    return this.timeParts;
  }

}
/**
 *  Tests str to see if it is convertible to a Time.
 * @return If str is convertible to a Time, returns an FP_Time;
 *  otherwise returns null.
 */


FP_Time.checkString = function (str) {
  let d = new FP_Time(str);
  if (!d._getMatchData()) d = null;
  return d;
};
/**
 *  A map from FHIRPath time units to the internal DateTime "precision" number.
 */


FP_Time._timeUnitToDatePrecision = {
  "hour": 0,
  "minute": 1,
  "second": 2,
  "millisecond": 3
};
/**
 *  The inverse of _timeUnitToDatePrecision.
 */

FP_Time._datePrecisionToTimeUnit = ["hour", "minute", "second", "millisecond"];
/**
 *  Returns either the given number or a string with the number prefixed by
 *  zeros if the given number is less than the given length.
 * @param num the nubmer to format
 * @param len the number of returned digits.  For now this must either be 2 or
 *  3. (Optional-- default is 2).
 */

function formatNum(num, len) {
  // Could use String.repeat, but that requires convertin num to an string first
  // to get its length.  This might be slightly faster given that we only need 2
  // or three 3 digit return values.
  var rtn = num;
  if (len === 3 && num < 100) rtn = '0' + num;
  if (num < 10) rtn = '0' + rtn;
  return rtn;
}
/**
 *  Formats the given date object into an ISO8601 datetime string, expressing it
 *  in the local timezone.
 * @date the date to format
 * @precision the precision at which to terminate string string.  (This is
 *  optional). If present, it will be an integer into the matching components of
 *  dateTimeRE.
 * @return a string in ISO8601 format.
 */


FP_DateTime.isoDateTime = function (date, precision) {
  if (precision === undefined) precision = 5; // maximum
  // YYYY-MM-DDTHH:mm:ss.sss[+-]HH:mm
  // Note:  Date.toISOString sets the timezone at 'Z', which I did not want.
  // Actually, I wanted to keep the original timezone given in the constructor,
  // but that is difficult due to daylight savings time changes.  (For instance,
  // if you add 6 months, the timezone offset could change).

  var rtn = '' + date.getFullYear();

  if (precision > 0) {
    rtn += '-' + formatNum(date.getMonth() + 1);

    if (precision > 1) {
      rtn += '-' + formatNum(date.getDate());

      if (precision > 2) {
        rtn += 'T' + FP_DateTime.isoTime(date, precision - 3);
      }
    }
  } // FHIRPath STU1 does not allow a timezone offset on a dateTime that does not
  // have a time part (except that the grammar allows 'Z', which is
  // inconsistent).


  if (precision > 2) {
    // Note:  getTimezoneoffset returns the offset for the local system at the
    // given date.
    var tzOffset = date.getTimezoneOffset(); // tzOffset is a number of minutes, and is positive for negative timezones,
    // and negative for positive timezones.

    var tzSign = tzOffset < 0 ? '+' : '-';
    tzOffset = Math.abs(tzOffset);
    var tzMin = tzOffset % 60;
    var tzHour = (tzOffset - tzMin) / 60;
    rtn += tzSign + formatNum(tzHour) + ':' + formatNum(tzMin);
  }

  return rtn;
};
/**
 *  Returns a time string in ISO format at the given precision level.
 * @date the date to format
 * @precision the precision at which to terminate string.  (This is
 *  optional). If present, it will be an integer into the matching components of
 *  timeRE.
 * @return a string in ISO 8601 format.
 */


FP_DateTime.isoTime = function (date, precision) {
  if (precision === undefined) precision = 2; // maximum

  let rtn = '' + formatNum(date.getHours());

  if (precision > 0) {
    rtn += ':' + formatNum(date.getMinutes());

    if (precision > 1) {
      rtn += ':' + formatNum(date.getSeconds());
      if (date.getMilliseconds()) rtn += '.' + formatNum(date.getMilliseconds(), 3);
    }
  }

  return rtn;
};

class FP_Date extends FP_DateTime {
  /**
   * Constructs an FP_Date, assuming dateStr is valid.  If you don't know
   * whether a string is a valid Date, use FP_Date.checkString instead.
   */
  constructor(dateStr) {
    super(dateStr);
  }
  /**
   * Returns the match data from matching dateRE against the date string.
   * Also sets this.precision.
   */


  _getMatchData() {
    return FP_TimeBase.prototype._getMatchData.apply(this, [dateRE, 2]);
  }

}
/**
 * Tests str to see if it is convertible to a Date.
 * @return If str is convertible to a Date, returns an FP_Date;
 *  otherwise returns null.
 */


FP_Date.checkString = function (str) {
  let d = new FP_Date(str);
  if (!d._getMatchData()) d = null;
  return d;
};
/**
 * Returns a date string in ISO format at the given precision level.
 * @date the date to format
 * @precision the precision at which to terminate string.  (This is
 *  optional). If present, it will be an integer into the matching components of
 *  dateTimeRE.
 * @return a string in ISO8601 format.
 */


FP_Date.isoDate = function (date, precision) {
  if (precision === undefined || precision > 2) precision = 2;
  return FP_DateTime.isoDateTime(date, precision);
};
/**
 *  A class that represents a node in a FHIR resource, with path and possibly type
 *  information.
 */


class ResourceNode {
  /**
   *  Constructs a instance for the given node ("data") of a resource.  If the
   *  data is the top-level node of a resouce, the path and type parameters will
   *  be ignored in favor of the resource's resourceType field.
   * @param data the node's data or value (which might be an object with
   *  sub-nodes, an array, or FHIR data type)
   * @param path the node's path in the resource (e.g. Patient.name).  If the
   *  data's type can be determined from data, that will take precedence over
   *  this parameter.
   * @param _data additional data stored in a property named with "_" prepended,
   *  see https://www.hl7.org/fhir/element.html#json for details.
   */
  constructor(data, path, _data) {
    // If data is a resource (maybe a contained resource) reset the path
    // information to the resource type.
    if (data?.resourceType) path = data.resourceType;
    this.path = path;
    this.data = data;
    this._data = _data || {};
  }
  /**
   * Returns resource node type info.
   * @return {TypeInfo}
   */


  getTypeInfo() {
    const namespace = TypeInfo.FHIR;

    if (/^System\.(.*)$/.test(this.path)) {
      return new TypeInfo({
        namespace: TypeInfo.System,
        name: RegExp.$1
      });
    } else if (this.path.indexOf('.') === -1) {
      return new TypeInfo({
        namespace,
        name: this.path
      });
    }

    if (!TypeInfo.model) {
      return TypeInfo.createByValueInNamespace({
        namespace,
        value: this.data
      });
    }

    return new TypeInfo({
      namespace,
      name: 'BackboneElement'
    });
  }

  toJSON() {
    return JSON.stringify(this.data);
  }
  /**
   * Converts a resource node value to an instance of the FHIRPath system type
   * (FP_Quantity, FP_Date, FP_DateTime, or FP_Time) for use in evaluating
   * a FHIRPath expression if the node path matches the specified type in the
   * model and when conversion is possible, otherwise returns the data as is.
   * Throws an exception if the data is a Quantity that has a comparator.
   * The Mapping from FHIR Quantity to FHIRPath System.Quantity is explained here:
   * https://www.hl7.org/fhir/fhirpath.html#quantity
   * this.data is not changed, but converted value is returned.
   * @return {FP_Type|any}
   */


  convertData() {
    var data = this.data;

    switch (this.path) {
      case 'Quantity':
        if (data?.system === ucumSystemUrl) {
          if (typeof data.value === 'number' && typeof data.code === 'string') {
            if (data.comparator !== undefined) throw new Error('Cannot convert a FHIR.Quantity that has a comparator');
            data = new FP_Quantity(data.value, FP_Quantity.mapUCUMCodeToTimeUnits[data.code] || '\'' + data.code + '\'');
          }
        }

        break;

      case 'date':
        data = FP_Date.checkString(data) || data;
        break;

      case 'dateTime':
        data = FP_DateTime.checkString(data) || data;
        break;

      case 'time':
        data = FP_Time.checkString(data) || data;
    }

    return data;
  }

}
/**
 *  Returns a ResourceNode for the given data node, checking first to see if the
 *  given node is already a ResourceNode.  Takes the same arguments as the
 *  constructor for ResourceNode.
 */


ResourceNode.makeResNode = function (data, path, _data) {
  return data instanceof ResourceNode ? data : new ResourceNode(data, path, _data);
};
/**
 * Object class defining type information.
 * Used for minimal type support.
 * (see http://hl7.org/fhirpath/#types-and-reflection)
 */


class TypeInfo {
  constructor({
    name,
    namespace
  }) {
    this.name = name;
    this.namespace = namespace;
  } // The "model" data object specific to a domain, e.g. R4.


  static model = null;
  /**
   * Checks for equality with another TypeInfo object, or that another TypeInfo
   * object specifies a superclass for the type specified by this object.
   * @param {TypeInfo} other
   * @return {boolean}
   */

  is(other) {
    if (other instanceof TypeInfo && (!this.namespace || !other.namespace || this.namespace === other.namespace)) {
      if (TypeInfo.model && (!this.namespace || this.namespace === TypeInfo.FHIR)) {
        let name = this.name;

        do {
          if (name === other.name) {
            return true;
          }
        } while (name = TypeInfo.model.type2Parent[name]);
      } else {
        return this.name === other.name;
      }
    }

    return false;
  }

} // Available namespaces:


TypeInfo.System = 'System';
TypeInfo.FHIR = 'FHIR';
/**
 * Creates new TypeInfo object for specified namespace and value
 * @param {String} namespace
 * @param {*} value
 * @return {TypeInfo}
 */

TypeInfo.createByValueInNamespace = function ({
  namespace,
  value
}) {
  let name = typeof value;

  if (Number.isInteger(value)) {
    name = 'integer';
  } else if (name === "number") {
    name = 'decimal';
  } else if (value instanceof FP_DateTime) {
    name = 'dateTime';
  } else if (value instanceof FP_Time) {
    name = 'time';
  } else if (value instanceof FP_Quantity) {
    name = 'Quantity';
  }

  if (namespace === TypeInfo.System) {
    name = name.replace(/^\w/, c => c.toUpperCase());
  } // TODO: currently can return name = 'object" or "Object" which is probably wrong


  return new TypeInfo({
    namespace,
    name
  });
};
/**
 * Retrieves TypeInfo by value
 * @param {*} value
 * @return {TypeInfo}
 */


TypeInfo.fromValue = function (value) {
  return value instanceof ResourceNode ? value.getTypeInfo() : TypeInfo.createByValueInNamespace({
    namespace: TypeInfo.System,
    value
  });
};
/**
 * Basic "type()" function implementation
 * (see http://hl7.org/fhirpath/#reflection)
 * @param {Array<*>} coll - input collection
 * @return {Array<*>}
 */


function typeFn(coll) {
  return coll.map(value => {
    return TypeInfo.fromValue(value);
  });
}
/**
 * Implementation of function "is(type : type specifier)" and operator "is"
 * (see http://hl7.org/fhirpath/#is-type-specifier)
 * @param {Array<*>} coll - input collection
 * @param {TypeInfo} typeInfo
 * @return {boolean|[]}
 */


function isFn(coll, typeInfo) {
  if (coll.length === 0) {
    return [];
  }

  if (coll.length > 1) {
    throw new Error("Expected singleton on left side of 'is', got " + JSON.stringify(coll));
  }

  return TypeInfo.fromValue(coll[0]).is(typeInfo);
}
/**
 * Implementation of function "as(type : type specifier)" and operator "as"
 * (see http://hl7.org/fhirpath/#as-type-specifier)
 * @param {Array<*>} coll - input collection
 * @param {TypeInfo} typeInfo
 * @return {Array<*>}
 */


function asFn(coll, typeInfo) {
  if (coll.length === 0) {
    return [];
  }

  if (coll.length > 1) {
    throw new Error("Expected singleton on left side of 'as', got " + JSON.stringify(coll));
  }

  return TypeInfo.fromValue(coll[0]).is(typeInfo) ? coll : [];
}

module.exports = {
  FP_Type: FP_Type,
  FP_TimeBase: FP_TimeBase,
  FP_Date: FP_Date,
  FP_DateTime: FP_DateTime,
  FP_Time: FP_Time,
  FP_Quantity: FP_Quantity,
  timeRE: timeRE,
  dateTimeRE: dateTimeRE,
  ResourceNode: ResourceNode,
  TypeInfo: TypeInfo,
  typeFn,
  isFn,
  asFn
};

/***/ }),
/* 57 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMilliseconds = __webpack_require__(58);

var MILLISECONDS_IN_MINUTE = 60000;
/**
 * @category Minute Helpers
 * @summary Add the specified number of minutes to the given date.
 *
 * @description
 * Add the specified number of minutes to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of minutes to be added
 * @returns {Date} the new date with the minutes added
 *
 * @example
 * // Add 30 minutes to 10 July 2014 12:00:00:
 * var result = addMinutes(new Date(2014, 6, 10, 12, 0), 30)
 * //=> Thu Jul 10 2014 12:30:00
 */

function addMinutes(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
}

module.exports = addMinutes;

/***/ }),
/* 58 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(59);
/**
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added
 * @returns {Date} the new date with the milliseconds added
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */


function addMilliseconds(dirtyDate, dirtyAmount) {
  var timestamp = parse(dirtyDate).getTime();
  var amount = Number(dirtyAmount);
  return new Date(timestamp + amount);
}

module.exports = addMilliseconds;

/***/ }),
/* 59 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var getTimezoneOffsetInMilliseconds = __webpack_require__(60);

var isDate = __webpack_require__(61);

var MILLISECONDS_IN_HOUR = 3600000;
var MILLISECONDS_IN_MINUTE = 60000;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var parseTokenDateTimeDelimeter = /[T ]/;
var parseTokenPlainTime = /:/; // year tokens

var parseTokenYY = /^(\d{2})$/;
var parseTokensYYY = [/^([+-]\d{2})$/, // 0 additional digits
/^([+-]\d{3})$/, // 1 additional digit
/^([+-]\d{4})$/ // 2 additional digits
];
var parseTokenYYYY = /^(\d{4})/;
var parseTokensYYYYY = [/^([+-]\d{4})/, // 0 additional digits
/^([+-]\d{5})/, // 1 additional digit
/^([+-]\d{6})/ // 2 additional digits
]; // date tokens

var parseTokenMM = /^-(\d{2})$/;
var parseTokenDDD = /^-?(\d{3})$/;
var parseTokenMMDD = /^-?(\d{2})-?(\d{2})$/;
var parseTokenWww = /^-?W(\d{2})$/;
var parseTokenWwwD = /^-?W(\d{2})-?(\d{1})$/; // time tokens

var parseTokenHH = /^(\d{2}([.,]\d*)?)$/;
var parseTokenHHMM = /^(\d{2}):?(\d{2}([.,]\d*)?)$/;
var parseTokenHHMMSS = /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/; // timezone tokens

var parseTokenTimezone = /([Z+-].*)$/;
var parseTokenTimezoneZ = /^(Z)$/;
var parseTokenTimezoneHH = /^([+-])(\d{2})$/;
var parseTokenTimezoneHHMM = /^([+-])(\d{2}):?(\d{2})$/;
/**
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If an argument is a string, the function tries to parse it.
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If all above fails, the function passes the given argument to Date constructor.
 *
 * @param {Date|String|Number} argument - the value to convert
 * @param {Object} [options] - the object with options
 * @param {0 | 1 | 2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * var result = parse('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Parse string '+02014101',
 * // if the additional number of digits in the extended year format is 1:
 * var result = parse('+02014101', {additionalDigits: 1})
 * //=> Fri Apr 11 2014 00:00:00
 */

function parse(argument, dirtyOptions) {
  if (isDate(argument)) {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument !== 'string') {
    return new Date(argument);
  }

  var options = dirtyOptions || {};
  var additionalDigits = options.additionalDigits;

  if (additionalDigits == null) {
    additionalDigits = DEFAULT_ADDITIONAL_DIGITS;
  } else {
    additionalDigits = Number(additionalDigits);
  }

  var dateStrings = splitDateString(argument);
  var parseYearResult = parseYear(dateStrings.date, additionalDigits);
  var year = parseYearResult.year;
  var restDateString = parseYearResult.restDateString;
  var date = parseDate(restDateString, year);

  if (date) {
    var timestamp = date.getTime();
    var time = 0;
    var offset;

    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
    }

    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone) * MILLISECONDS_IN_MINUTE;
    } else {
      var fullTime = timestamp + time;
      var fullTimeDate = new Date(fullTime);
      offset = getTimezoneOffsetInMilliseconds(fullTimeDate); // Adjust time when it's coming from DST

      var fullTimeDateNextDay = new Date(fullTime);
      fullTimeDateNextDay.setDate(fullTimeDate.getDate() + 1);
      var offsetDiff = getTimezoneOffsetInMilliseconds(fullTimeDateNextDay) - getTimezoneOffsetInMilliseconds(fullTimeDate);

      if (offsetDiff > 0) {
        offset += offsetDiff;
      }
    }

    return new Date(timestamp + time + offset);
  } else {
    return new Date(argument);
  }
}

function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(parseTokenDateTimeDelimeter);
  var timeString;

  if (parseTokenPlainTime.test(array[0])) {
    dateStrings.date = null;
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
  }

  if (timeString) {
    var token = parseTokenTimezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  var parseTokenYYY = parseTokensYYY[additionalDigits];
  var parseTokenYYYYY = parseTokensYYYYY[additionalDigits];
  var token; // YYYY or YYYYY

  token = parseTokenYYYY.exec(dateString) || parseTokenYYYYY.exec(dateString);

  if (token) {
    var yearString = token[1];
    return {
      year: parseInt(yearString, 10),
      restDateString: dateString.slice(yearString.length)
    };
  } // YY or YYY


  token = parseTokenYY.exec(dateString) || parseTokenYYY.exec(dateString);

  if (token) {
    var centuryString = token[1];
    return {
      year: parseInt(centuryString, 10) * 100,
      restDateString: dateString.slice(centuryString.length)
    };
  } // Invalid ISO-formatted year


  return {
    year: null
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) {
    return null;
  }

  var token;
  var date;
  var month;
  var week; // YYYY

  if (dateString.length === 0) {
    date = new Date(0);
    date.setUTCFullYear(year);
    return date;
  } // YYYY-MM


  token = parseTokenMM.exec(dateString);

  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    date.setUTCFullYear(year, month);
    return date;
  } // YYYY-DDD or YYYYDDD


  token = parseTokenDDD.exec(dateString);

  if (token) {
    date = new Date(0);
    var dayOfYear = parseInt(token[1], 10);
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  } // YYYY-MM-DD or YYYYMMDD


  token = parseTokenMMDD.exec(dateString);

  if (token) {
    date = new Date(0);
    month = parseInt(token[1], 10) - 1;
    var day = parseInt(token[2], 10);
    date.setUTCFullYear(year, month, day);
    return date;
  } // YYYY-Www or YYYYWww


  token = parseTokenWww.exec(dateString);

  if (token) {
    week = parseInt(token[1], 10) - 1;
    return dayOfISOYear(year, week);
  } // YYYY-Www-D or YYYYWwwD


  token = parseTokenWwwD.exec(dateString);

  if (token) {
    week = parseInt(token[1], 10) - 1;
    var dayOfWeek = parseInt(token[2], 10) - 1;
    return dayOfISOYear(year, week, dayOfWeek);
  } // Invalid ISO-formatted date


  return null;
}

function parseTime(timeString) {
  var token;
  var hours;
  var minutes; // hh

  token = parseTokenHH.exec(timeString);

  if (token) {
    hours = parseFloat(token[1].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR;
  } // hh:mm or hhmm


  token = parseTokenHHMM.exec(timeString);

  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
  } // hh:mm:ss or hhmmss


  token = parseTokenHHMMSS.exec(timeString);

  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    var seconds = parseFloat(token[3].replace(',', '.'));
    return hours % 24 * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;
  } // Invalid ISO-formatted time


  return null;
}

function parseTimezone(timezoneString) {
  var token;
  var absoluteOffset; // Z

  token = parseTokenTimezoneZ.exec(timezoneString);

  if (token) {
    return 0;
  } // hh


  token = parseTokenTimezoneHH.exec(timezoneString);

  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60;
    return token[1] === '+' ? -absoluteOffset : absoluteOffset;
  } // hh:mm or hhmm


  token = parseTokenTimezoneHHMM.exec(timezoneString);

  if (token) {
    absoluteOffset = parseInt(token[2], 10) * 60 + parseInt(token[3], 10);
    return token[1] === '+' ? -absoluteOffset : absoluteOffset;
  }

  return 0;
}

function dayOfISOYear(isoYear, week, day) {
  week = week || 0;
  day = day || 0;
  var date = new Date(0);
  date.setUTCFullYear(isoYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

module.exports = parse;

/***/ }),
/* 60 */
/***/ (function(module) {

var MILLISECONDS_IN_MINUTE = 60000;
/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */

module.exports = function getTimezoneOffsetInMilliseconds(dirtyDate) {
  var date = new Date(dirtyDate.getTime());
  var baseTimezoneOffset = date.getTimezoneOffset();
  date.setSeconds(0, 0);
  var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
  return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
};

/***/ }),
/* 61 */
/***/ (function(module) {

/**
 * @category Common Helpers
 * @summary Is the given argument an instance of Date?
 *
 * @description
 * Is the given argument an instance of Date?
 *
 * @param {*} argument - the argument to check
 * @returns {Boolean} the given argument is an instance of Date
 *
 * @example
 * // Is 'mayonnaise' a Date?
 * var result = isDate('mayonnaise')
 * //=> false
 */
function isDate(argument) {
  return argument instanceof Date;
}

module.exports = isDate;

/***/ }),
/* 62 */
/***/ (function(module) {

"use strict";
module.exports = LForms.ucumPkg;

/***/ }),
/* 63 */
/***/ (function(module) {

let numberFns = {}; // Returns the number of digits in the number after the decimal point, ignoring
// trailing zeros.

function decimalPlaces(x) {
  // Based on https://stackoverflow.com/a/9539746/360782
  // Make sure it is a number and use the builtin number -> string.
  const s = "" + +x,
        match = /(\d+)(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/.exec(s); // NaN or Infinity or integer.
  // We arbitrarily decide that Infinity is integral.

  if (!match) {
    return 0;
  } // Count the number of digits in the fraction and subtract the
  // exponent to simulate moving the decimal point left by exponent places.
  // 1.234e+2 has 1 fraction digit and '234'.length -  2 == 1
  // 1.234e-2 has 5 fraction digit and '234'.length - -2 == 5
  //var wholeNum = match[1];


  const fraction = match[2],
        exponent = match[3];
  return Math.max(0, // lower limit.
  (fraction === '0' ? 0 : (fraction || '').length // fraction length
  ) - (exponent || 0)); // exponent
}
/**
 *  Rounds a number to the specified number of decimal places.
 * @param x the decimal number to be rounded
 * @param n the (maximum) number of decimal places to preserve.  (The result
 *  could contain fewer if the decimal digits in x contain zeros).
 */


function roundToDecimalPlaces(x, n) {
  const scale = Math.pow(10, n);
  return Math.round(x * scale) / scale;
}
/**
 *  The smallest representable number in FHIRPath.
 */


const PRECISION_STEP = 1e-8;
/**
 *  Rounds a number to the nearest multiple of PRECISION_STEP.
 */

const roundToMaxPrecision = numberFns.roundToMaxPrecision = function (x) {
  return Math.round(x / PRECISION_STEP) * PRECISION_STEP;
};
/**
 * Determines numbers equivalence
 * @param {number} actual
 * @param {number} expected
 * @return {boolean}
 */


numberFns.isEquivalent = function (actual, expected) {
  if (Number.isInteger(actual) && Number.isInteger(expected)) {
    return actual === expected;
  }

  const prec = Math.min(decimalPlaces(actual), decimalPlaces(expected));

  if (prec === 0) {
    return Math.round(actual) === Math.round(expected);
  } else {
    // Note: parseFloat(0.00000011).toPrecision(7) ===  "1.100000e-7"
    // It does # of significant digits, not decimal places.
    return roundToDecimalPlaces(actual, prec) === roundToDecimalPlaces(expected, prec);
  }
};
/**
 * Determines numbers equality
 * @param {number} actual
 * @param {number} expected
 * @return {boolean}
 */


numberFns.isEqual = function (actual, expected) {
  return roundToMaxPrecision(actual) === roundToMaxPrecision(expected);
};

module.exports = numberFns;

/***/ }),
/* 64 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMonths = __webpack_require__(65);
/**
 * @category Year Helpers
 * @summary Add the specified number of years to the given date.
 *
 * @description
 * Add the specified number of years to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of years to be added
 * @returns {Date} the new date with the years added
 *
 * @example
 * // Add 5 years to 1 September 2014:
 * var result = addYears(new Date(2014, 8, 1), 5)
 * //=> Sun Sep 01 2019 00:00:00
 */


function addYears(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}

module.exports = addYears;

/***/ }),
/* 65 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(59);

var getDaysInMonth = __webpack_require__(66);
/**
 * @category Month Helpers
 * @summary Add the specified number of months to the given date.
 *
 * @description
 * Add the specified number of months to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of months to be added
 * @returns {Date} the new date with the months added
 *
 * @example
 * // Add 5 months to 1 September 2014:
 * var result = addMonths(new Date(2014, 8, 1), 5)
 * //=> Sun Feb 01 2015 00:00:00
 */


function addMonths(dirtyDate, dirtyAmount) {
  var date = parse(dirtyDate);
  var amount = Number(dirtyAmount);
  var desiredMonth = date.getMonth() + amount;
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(date.getFullYear(), desiredMonth, 1);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth); // Set the last day of the new month
  // if the original date was the last day of the longer month

  date.setMonth(desiredMonth, Math.min(daysInMonth, date.getDate()));
  return date;
}

module.exports = addMonths;

/***/ }),
/* 66 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(59);
/**
 * @category Month Helpers
 * @summary Get the number of days in a month of the given date.
 *
 * @description
 * Get the number of days in a month of the given date.
 *
 * @param {Date|String|Number} date - the given date
 * @returns {Number} the number of days in a month
 *
 * @example
 * // How many days are in February 2000?
 * var result = getDaysInMonth(new Date(2000, 1))
 * //=> 29
 */


function getDaysInMonth(dirtyDate) {
  var date = parse(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}

module.exports = getDaysInMonth;

/***/ }),
/* 67 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addDays = __webpack_require__(68);
/**
 * @category Week Helpers
 * @summary Add the specified number of weeks to the given date.
 *
 * @description
 * Add the specified number of week to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of weeks to be added
 * @returns {Date} the new date with the weeks added
 *
 * @example
 * // Add 4 weeks to 1 September 2014:
 * var result = addWeeks(new Date(2014, 8, 1), 4)
 * //=> Mon Sep 29 2014 00:00:00
 */


function addWeeks(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  var days = amount * 7;
  return addDays(dirtyDate, days);
}

module.exports = addWeeks;

/***/ }),
/* 68 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var parse = __webpack_require__(59);
/**
 * @category Day Helpers
 * @summary Add the specified number of days to the given date.
 *
 * @description
 * Add the specified number of days to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of days to be added
 * @returns {Date} the new date with the days added
 *
 * @example
 * // Add 10 days to 1 September 2014:
 * var result = addDays(new Date(2014, 8, 1), 10)
 * //=> Thu Sep 11 2014 00:00:00
 */


function addDays(dirtyDate, dirtyAmount) {
  var date = parse(dirtyDate);
  var amount = Number(dirtyAmount);
  date.setDate(date.getDate() + amount);
  return date;
}

module.exports = addDays;

/***/ }),
/* 69 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMilliseconds = __webpack_require__(58);

var MILLISECONDS_IN_HOUR = 3600000;
/**
 * @category Hour Helpers
 * @summary Add the specified number of hours to the given date.
 *
 * @description
 * Add the specified number of hours to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of hours to be added
 * @returns {Date} the new date with the hours added
 *
 * @example
 * // Add 2 hours to 10 July 2014 23:00:00:
 * var result = addHours(new Date(2014, 6, 10, 23, 0), 2)
 * //=> Fri Jul 11 2014 01:00:00
 */

function addHours(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * MILLISECONDS_IN_HOUR);
}

module.exports = addHours;

/***/ }),
/* 70 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var addMilliseconds = __webpack_require__(58);
/**
 * @category Second Helpers
 * @summary Add the specified number of seconds to the given date.
 *
 * @description
 * Add the specified number of seconds to the given date.
 *
 * @param {Date|String|Number} date - the date to be changed
 * @param {Number} amount - the amount of seconds to be added
 * @returns {Date} the new date with the seconds added
 *
 * @example
 * // Add 30 seconds to 10 July 2014 12:45:00:
 * var result = addSeconds(new Date(2014, 6, 10, 12, 45, 0), 30)
 * //=> Thu Jul 10 2014 12:45:30
 */


function addSeconds(dirtyDate, dirtyAmount) {
  var amount = Number(dirtyAmount);
  return addMilliseconds(dirtyDate, amount * 1000);
}

module.exports = addSeconds;

/***/ }),
/* 71 */
/***/ (function() {

// Binding the function Array.prototype.slice.call for convert Array-like objects/collections to a new Array.
const slice = Function.prototype.call.bind(Array.prototype.slice); // isInteger (not in IE)
// From Mozilla docs

Number.isInteger = Number.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};

if (!String.prototype.startsWith) {
  // From Mozilla docs with little changes
  Object.defineProperty(String.prototype, 'startsWith', {
    value: function (searchString, position) {
      position = position || 0;
      return this.indexOf(searchString, position) === position;
    }
  });
}

if (!String.prototype.endsWith) {
  // From Mozilla docs with little changes
  Object.defineProperty(String.prototype, 'endsWith', {
    value: function (searchString, position) {
      var subjectString = this.toString();

      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }

      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
  });
}

if (!String.prototype.includes) {
  Object.defineProperty(String.prototype, 'includes', {
    value: function () {
      return this.indexOf.apply(this, arguments) !== -1;
    }
  });
}

if (!Object.assign) {
  // From Mozilla docs with little changes
  Object.defineProperty(Object, 'assign', {
    value: function (target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      return slice(arguments, 1).reduce(function (to, nextSource) {
        Object.keys(Object(nextSource)).forEach(function (nextKey) {
          to[nextKey] = nextSource[nextKey];
        });
        return to;
      }, Object(target));
    }
  });
}

/***/ }),
/* 72 */
/***/ (function(module) {

// These are values that should not change during an evaluation of a FHIRPath
// expression (e.g. the return value of today(), per the spec.)  They are
// constant during at least one evaluation.
module.exports = {
  /**
   *  Resets the constants.  Should be called when before the engine starts its
   *  processing.
   */
  reset: function () {
    this.nowDate = new Date(); // a Date object representing "now"

    this.today = null;
    this.now = null;
    this.timeOfDay = null;
    this.localTimezoneOffset = null;
  },

  /**
   *  The cached value of today().
   */
  today: null,

  /**
   *  The cached value of now().
   */
  now: null,

  /**
   *  The cached value of timeOfDay().
   */
  timeOfDay: null
};

/***/ }),
/* 73 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Existence functions (5.1 in the
// specification).
const util = __webpack_require__(55);

const {
  whereMacro,
  distinctFn
} = __webpack_require__(74);

const misc = __webpack_require__(76);

const hashObject = __webpack_require__(75);

const engine = {};
engine.emptyFn = util.isEmpty;

engine.notFn = function (coll) {
  let d = misc.singleton(coll, 'Boolean');
  return typeof d === 'boolean' ? !d : [];
};

engine.existsMacro = function (coll, expr) {
  var vec = coll;

  if (expr) {
    return engine.existsMacro(whereMacro(coll, expr));
  }

  return !util.isEmpty(vec);
};

engine.allMacro = function (coll, expr) {
  for (let i = 0, len = coll.length; i < len; ++i) {
    this.$index = i;

    if (!util.isTrue(expr(coll[i]))) {
      return [false];
    }
  }

  return [true];
};

engine.allTrueFn = function (x) {
  let rtn = true;

  for (let i = 0, len = x.length; i < len && rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "allTrue");
    rtn = xi === true;
  }

  return [rtn];
};

engine.anyTrueFn = function (x) {
  let rtn = false;

  for (let i = 0, len = x.length; i < len && !rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "anyTrue");
    rtn = xi === true;
  }

  return [rtn];
};

engine.allFalseFn = function (x) {
  let rtn = true;

  for (let i = 0, len = x.length; i < len && rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "allFalse");
    rtn = xi === false;
  }

  return [rtn];
};

engine.anyFalseFn = function (x) {
  let rtn = false;

  for (let i = 0, len = x.length; i < len && !rtn; ++i) {
    let xi = util.assertType(x[i], ["boolean"], "anyFalse");
    rtn = xi === false;
  }

  return [rtn];
};
/**
 *  Returns true if coll1 is a subset of coll2.
 */


function subsetOf(coll1, coll2) {
  const coll1Length = coll1.length;
  let rtn = coll1Length <= coll2.length;

  if (rtn && coll1Length) {
    const c2Hash = coll2.reduce((hash, item) => {
      hash[hashObject(item)] = true;
      return hash;
    }, {});
    rtn = !coll1.some(item => !c2Hash[hashObject(item)]);
  }

  return rtn;
}

engine.subsetOfFn = function (coll1, coll2) {
  return [subsetOf(coll1, coll2)];
};

engine.supersetOfFn = function (coll1, coll2) {
  return [subsetOf(coll2, coll1)];
};

engine.isDistinctFn = function (x) {
  return [x.length === distinctFn(x).length];
};

module.exports = engine;

/***/ }),
/* 74 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Contains the FHIRPath Filtering and Projection functions.  (Section 5.2 of
// the FHIRPath 1.0.0 specification).

/**
 *  Adds the filtering and projection functions to the given FHIRPath engine.
 */
const util = __webpack_require__(55);

const {
  TypeInfo,
  ResourceNode
} = __webpack_require__(56);

const hashObject = __webpack_require__(75);

var engine = {};

engine.whereMacro = function (parentData, expr) {
  if (parentData !== false && !parentData) {
    return [];
  }

  return util.flatten(parentData.filter((x, i) => {
    this.$index = i;
    return expr(x)[0];
  }));
};

engine.extension = function (parentData, url) {
  if (parentData !== false && !parentData || !url) {
    return [];
  }

  return util.flatten(parentData.map((x, i) => {
    this.$index = i;
    const extensions = x && (x.data && x.data.extension || x._data && x._data.extension);

    if (extensions) {
      return extensions.filter(extension => extension.url === url).map(x => ResourceNode.makeResNode(x, 'Extension'));
    }

    return [];
  }));
};

engine.selectMacro = function (data, expr) {
  if (data !== false && !data) {
    return [];
  }

  return util.flatten(data.map((x, i) => {
    this.$index = i;
    return expr(x);
  }));
};

engine.repeatMacro = function (parentData, expr) {
  if (parentData !== false && !parentData) {
    return [];
  }

  let res = [];
  const unique = {};
  const length = parentData.length;

  for (let i = 0; i < length; ++i) {
    let newItems = parentData[i];

    do {
      newItems = expr(newItems).filter(item => {
        const key = hashObject(item);
        const isUnique = !unique[key];

        if (isUnique) {
          unique[key] = true;
        }

        return isUnique;
      });
    } while (res.length < res.push.apply(res, newItems));
  }

  return res;
}; //TODO: behavior on object?


engine.singleFn = function (x) {
  if (x.length == 1) {
    return x;
  } else if (x.length == 0) {
    return [];
  } else {
    //TODO: should throw error?
    return {
      $status: "error",
      $error: "Expected single"
    };
  }
};

engine.firstFn = function (x) {
  return x[0];
};

engine.lastFn = function (x) {
  return x[x.length - 1];
};

engine.tailFn = function (x) {
  return x.slice(1, x.length);
};

engine.takeFn = function (x, n) {
  return x.slice(0, n);
};

engine.skipFn = function (x, num) {
  return x.slice(num, x.length);
};

engine.ofTypeFn = function (coll, typeInfo) {
  return coll.filter(value => {
    return TypeInfo.fromValue(value).is(typeInfo);
  });
};

engine.distinctFn = function (x) {
  let unique = []; // Since this requires a deep equals, use a hash table (on JSON strings) for
  // efficiency.

  if (x.length > 0) {
    let uniqueHash = {};

    for (let i = 0, len = x.length; i < len; ++i) {
      let xObj = x[i];
      let xStr = hashObject(xObj);

      if (!uniqueHash[xStr]) {
        unique.push(xObj);
        uniqueHash[xStr] = true;
      }
    }
  }

  return unique;
};

module.exports = engine;

/***/ }),
/* 75 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const ucumUtils = (__webpack_require__(62).UcumLhcUtils.getInstance)();

const {
  roundToMaxPrecision
} = __webpack_require__(63);

const {
  valDataConverted
} = __webpack_require__(55);

const {
  FP_Type,
  FP_Quantity
} = __webpack_require__(56);
/**
 *  Returns a JSON version of the given object, but with the object's keys
 *  in sorted order (or at least stable order,
 *  see https://stackoverflow.com/a/35810961/360782) and the values in
 *  unified forms, e.g. "1 year" is converted to the same value as "12 months",
 *  "3 'min'" is converted to the same value as "120 'sec'".
 *  This function is used instead of deepEqual for optimization when you need
 *  to compare many objects.
 */


function hashObject(obj) {
  return JSON.stringify(prepareObject(obj));
}
/**
 * Brings an object to the unified form so that it can be serialized to JSON to
 * compare with other objects according to https://hl7.org/fhirpath/#equals
 * This function is following the logic from deepEqual (if changes are needed
 * here they are likely also needed there).
 */


function prepareObject(value) {
  value = valDataConverted(value);

  if (typeof value === 'number') {
    return roundToMaxPrecision(value);
  } else if (value instanceof Date) {
    return value.toISOString();
  }

  if (value instanceof FP_Quantity) {
    const magnitude = FP_Quantity._yearMonthConversionFactor[value.unit];

    if (magnitude) {
      return '_!yearMonth!_:' + magnitude * value.value;
    } else {
      const ucumQuantity = FP_Quantity.toUcumQuantity(value.value, value.unit);
      const unit = ucumUtils.getSpecifiedUnit(ucumQuantity.unit).unit;
      return '_!' + unit.property_ + '!_:' + unit.magnitude_ * ucumQuantity.value;
    }
  } else if (value instanceof FP_Type) {
    return value.toString();
  } else if (typeof value === 'object') {
    return Array.isArray(value) ? value.map(prepareObject) : Object.keys(value).sort().reduce((o, key) => {
      const v = value[key];
      o[key] = prepareObject(v);
      return o;
    }, {});
  }

  return value;
}

module.exports = hashObject;

/***/ }),
/* 76 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Existence functions (5.1 in the
// specification).
var util = __webpack_require__(55);

var types = __webpack_require__(56);

const {
  FP_Quantity
} = types;
var engine = {};

engine.iifMacro = function (data, cond, ok, fail) {
  if (util.isTrue(cond(data))) {
    return ok(data);
  } else {
    return fail ? fail(data) : [];
  }
};

engine.traceFn = function (x, label) {
  console.log("TRACE:[" + (label || "") + "]", JSON.stringify(x, null, " "));
  return x;
};

var intRegex = /^[+-]?\d+$/;

engine.toInteger = function (coll) {
  if (coll.length !== 1) {
    return [];
  }

  var v = util.valData(coll[0]);

  if (v === false) {
    return 0;
  }

  if (v === true) {
    return 1;
  }

  if (typeof v === "number") {
    if (Number.isInteger(v)) {
      return v;
    } else {
      return [];
    }
  }

  if (typeof v === "string" && intRegex.test(v)) {
    return parseInt(v);
  }

  return [];
};

const quantityRegex = /^((\+|-)?\d+(\.\d+)?)\s*(('[^']+')|([a-zA-Z]+))?$/,
      quantityRegexMap = {
  value: 1,
  unit: 5,
  time: 6
};

engine.toQuantity = function (coll, toUnit) {
  let result; // Surround UCUM unit code in the toUnit parameter with single quotes

  if (toUnit && !FP_Quantity.mapTimeUnitsToUCUMCode[toUnit]) {
    toUnit = `'${toUnit}'`;
  }

  if (coll.length > 1) {
    throw new Error("Could not convert to quantity: input collection contains multiple items");
  } else if (coll.length === 1) {
    var v = util.valDataConverted(coll[0]);
    let quantityRegexRes;

    if (typeof v === "number") {
      result = new FP_Quantity(v, '\'1\'');
    } else if (v instanceof FP_Quantity) {
      result = v;
    } else if (typeof v === 'boolean') {
      result = new FP_Quantity(v ? 1 : 0, '\'1\'');
    } else if (typeof v === "string" && (quantityRegexRes = quantityRegex.exec(v))) {
      const value = quantityRegexRes[quantityRegexMap.value],
            unit = quantityRegexRes[quantityRegexMap.unit],
            time = quantityRegexRes[quantityRegexMap.time]; // UCUM unit code in the input string must be surrounded with single quotes

      if (!time || FP_Quantity.mapTimeUnitsToUCUMCode[time]) {
        result = new FP_Quantity(Number(value), unit || time || '\'1\'');
      }
    }

    if (result && toUnit && result.unit !== toUnit) {
      result = FP_Quantity.convUnitTo(result.unit, result.value, toUnit);
    }
  }

  return result || [];
};

var numRegex = /^[+-]?\d+(\.\d+)?$/;

engine.toDecimal = function (coll) {
  if (coll.length !== 1) {
    return [];
  }

  var v = util.valData(coll[0]);

  if (v === false) {
    return 0;
  }

  if (v === true) {
    return 1.0;
  }

  if (typeof v === "number") {
    return v;
  }

  if (typeof v === "string" && numRegex.test(v)) {
    return parseFloat(v);
  }

  return [];
};

engine.toString = function (coll) {
  if (coll.length !== 1) {
    return [];
  }

  var v = util.valDataConverted(coll[0]);
  return v.toString();
};
/**
 *  Defines a function on engine called to+timeType (e.g., toDateTime, etc.).
 * @param timeType The string name of a class for a time type (e.g. "FP_DateTime").
 */


function defineTimeConverter(timeType) {
  let timeName = timeType.slice(3); // Remove 'FP_'

  engine['to' + timeName] = function (coll) {
    var rtn = [];
    if (coll.length > 1) throw Error('to ' + timeName + ' called for a collection of length ' + coll.length);

    if (coll.length === 1) {
      var t = types[timeType].checkString(util.valData(coll[0]));
      if (t) rtn = t;
    }

    return rtn;
  };
}

defineTimeConverter('FP_Date');
defineTimeConverter('FP_DateTime');
defineTimeConverter('FP_Time'); // Possible string values convertible to the true boolean value

const trueStrings = ['true', 't', 'yes', 'y', '1', '1.0'].reduce((acc, val) => {
  acc[val] = true;
  return acc;
}, {}); // Possible string values convertible to the false boolean value

const falseStrings = ['false', 'f', 'no', 'n', '0', '0.0'].reduce((acc, val) => {
  acc[val] = true;
  return acc;
}, {});

engine.toBoolean = function (coll) {
  if (coll.length !== 1) {
    return [];
  }

  const v = util.valData(coll[0]);

  switch (typeof v) {
    case 'boolean':
      return v;

    case 'number':
      if (v === 1) {
        return true;
      }

      if (v === 0) {
        return false;
      }

      break;

    case 'string':
      // eslint-disable-next-line no-case-declarations
      const lowerCaseValue = v.toLowerCase();

      if (trueStrings[lowerCaseValue]) {
        return true;
      }

      if (falseStrings[lowerCaseValue]) {
        return false;
      }

  }

  return [];
};
/**
 * Creates function that checks if toFunction returns specified type
 * @param {function(coll: array): <type|[]>} toFunction
 * @param {string|class} type - specifies type, for example: 'string' or FP_Quantity
 * @return {function(coll: array)}
 */


engine.createConvertsToFn = function (toFunction, type) {
  if (typeof type === 'string') {
    return function (coll) {
      if (coll.length !== 1) {
        return [];
      }

      return typeof toFunction(coll) === type;
    };
  }

  return function (coll) {
    if (coll.length !== 1) {
      return [];
    }

    return toFunction(coll) instanceof type;
  };
};

const singletonEvalByType = {
  "Integer": function (coll) {
    const d = util.valData(coll[0]);

    if (Number.isInteger(d)) {
      return d;
    }
  },
  "Boolean": function (coll) {
    const d = util.valData(coll[0]);

    if (d === true || d === false) {
      return d;
    } else if (coll.length === 1) {
      return true;
    }
  },
  "Number": function (coll) {
    const d = util.valData(coll[0]);

    if (typeof d === "number") {
      return d;
    }
  },
  "String": function (coll) {
    const d = util.valData(coll[0]);

    if (typeof d === "string") {
      return d;
    }
  }
};
/**
 * Converts a collection to a singleton of the specified type.
 * The result can be an empty array if input collection is empty.
 * See http://hl7.org/fhirpath/#singleton-evaluation-of-collections for details.
 * @param {Array} coll - collection
 * @param {string} type - 'Integer', 'Boolean', 'Number' or 'String'
 * @throws {Error}  if there is more than one item in input collection,
 *   or an item that is not a specified type
 * @return {*|[]} the value of specified type or empty array
 */

engine.singleton = function (coll, type) {
  if (coll.length > 1) {
    throw new Error("Unexpected collection" + JSON.stringify(coll) + "; expected singleton of type " + type);
  } else if (coll.length === 0) {
    return [];
  }

  const toSingleton = singletonEvalByType[type];

  if (toSingleton) {
    const value = toSingleton(coll);

    if (value !== undefined) {
      return value;
    }

    throw new Error(`Expected ${type.toLowerCase()}, but got: ${JSON.stringify(coll)}`);
  }

  throw new Error('Not supported type ' + type);
};

module.exports = engine;

/***/ }),
/* 77 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Contains the FHIRPath Aggregate functions.
// (Section 7 of the FHIRPath 2.0.0 (N1) specification).
let engine = {};

const math = __webpack_require__(78);

const equality = __webpack_require__(79);

const util = __webpack_require__(55);

engine.aggregateMacro = function (data, expr, initialValue) {
  return data.reduce((total, x, i) => {
    this.$index = i;
    return this.$total = expr(x);
  }, this.$total = initialValue);
};

engine.countFn = function (x) {
  if (x && x.length) {
    return x.length;
  } else {
    return 0;
  }
}; // Shortcut for "value.aggregate($this+$total, 0)"


engine.sumFn = function (data) {
  return engine.aggregateMacro.apply(this, [data, $this => {
    return math.plus(util.arraify($this), util.arraify(this.$total));
  }, 0]);
}; // Shortcut for "value.aggregate(iif($total.empty(), $this, iif($this < $total, $this, $total)))"


engine.minFn = function (data) {
  return engine.aggregateMacro.apply(this, [data, curr => {
    const $this = util.arraify(curr);
    const $total = util.arraify(this.$total);
    return util.isEmpty($total) ? $this : equality.lt($this, $total) ? $this : $total;
  }]);
}; // Shortcut for "value.aggregate(iif($total.empty(), $this, iif($this > $total, $this, $total)))"


engine.maxFn = function (data) {
  return engine.aggregateMacro.apply(this, [data, curr => {
    const $this = util.arraify(curr);
    const $total = util.arraify(this.$total);
    return util.isEmpty($total) ? $this : equality.gt($this, $total) ? $this : $total;
  }]);
}; // Shortcut for "value.sum()/value.count()"


engine.avgFn = function (data) {
  return math.div(engine.sumFn(data), engine.countFn(data));
};

module.exports = engine;

/***/ }),
/* 78 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Math functions.
var types = __webpack_require__(56);

let {
  FP_TimeBase,
  FP_Quantity
} = types;

const util = __webpack_require__(55);
/**
 *  Adds the math functions to the given FHIRPath engine.
 */


var engine = {};

function ensureNumberSingleton(x) {
  let d = util.valData(x);

  if (typeof d !== 'number') {
    if (d.length == 1 && typeof (d = util.valData(d[0])) === 'number') {
      return d;
    } else {
      throw new Error("Expected number, but got " + JSON.stringify(d || x));
    }
  } else return d;
}

function isEmpty(x) {
  if (typeof x == 'number') {
    return false;
  }

  return x.length == 0;
}

engine.amp = function (x, y) {
  return (x || "") + (y || "");
}; //HACK: for only polymorphic function
//  Actually, "minus" is now also polymorphic


engine.plus = function (xs, ys) {
  if (xs.length == 1 && ys.length == 1) {
    var x = util.valDataConverted(xs[0]);
    var y = util.valDataConverted(ys[0]); // In the future, this and other functions might need to return ResourceNode
    // to preserve the type information (integer vs decimal, and maybe decimal
    // vs string if decimals are represented as strings), in order to support
    // "as" and "is", but that support is deferred for now.

    if (typeof x == "string" && typeof y == "string") {
      return x + y;
    }

    if (typeof x == "number" && typeof y == "number") {
      return x + y;
    }

    if (x instanceof FP_TimeBase && y instanceof FP_Quantity) {
      return x.plus(y);
    }
  }

  throw new Error("Cannot " + JSON.stringify(xs) + " + " + JSON.stringify(ys));
};

engine.minus = function (xs, ys) {
  if (xs.length == 1 && ys.length == 1) {
    var x = util.valDataConverted(xs[0]);
    var y = util.valDataConverted(ys[0]);
    if (typeof x == "number" && typeof y == "number") return x - y;
    if (x instanceof FP_TimeBase && y instanceof FP_Quantity) return x.plus(new FP_Quantity(-y.value, y.unit));
  }

  throw new Error("Cannot " + JSON.stringify(xs) + " - " + JSON.stringify(ys));
};

engine.mul = function (x, y) {
  return x * y;
};

engine.div = function (x, y) {
  if (y === 0) return [];
  return x / y;
};

engine.intdiv = function (x, y) {
  if (y === 0) return [];
  return Math.floor(x / y);
};

engine.mod = function (x, y) {
  if (y === 0) return [];
  return x % y;
};

engine.abs = function (x) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    return Math.abs(num);
  }
};

engine.ceiling = function (x) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    return Math.ceil(num);
  }
};

engine.exp = function (x) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    return Math.exp(num);
  }
};

engine.floor = function (x) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    return Math.floor(num);
  }
};

engine.ln = function (x) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    return Math.log(num);
  }
};

engine.log = function (x, base) {
  if (isEmpty(x) || isEmpty(base)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    let num2 = ensureNumberSingleton(base);
    return Math.log(num) / Math.log(num2);
  }
};

engine.power = function (x, degree) {
  if (isEmpty(x) || isEmpty(degree)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    let num2 = ensureNumberSingleton(degree);

    if (num < 0 && Math.floor(num2) != num2) {
      return [];
    } else {
      return Math.pow(num, num2);
    }
  }
};

engine.round = function (x, acc) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);

    if (isEmpty(acc)) {
      return Math.round(num);
    } else {
      let num2 = ensureNumberSingleton(acc);
      let degree = Math.pow(10, num2);
      return Math.round(num * degree) / degree;
    }
  }
};

engine.sqrt = function (x) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);

    if (num < 0) {
      return [];
    } else {
      return Math.sqrt(num);
    }
  }
};

engine.truncate = function (x) {
  if (isEmpty(x)) {
    return [];
  } else {
    let num = ensureNumberSingleton(x);
    return Math.trunc(num);
  }
};

module.exports = engine;

/***/ }),
/* 79 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to handle the FHIRPath Math functions.
var util = __webpack_require__(55);

var deepEqual = __webpack_require__(80);

var types = __webpack_require__(56);

const FP_Type = types.FP_Type;
const FP_Date = types.FP_Date;
const FP_DateTime = types.FP_DateTime;
var engine = {};

function equality(x, y) {
  if (util.isEmpty(x) || util.isEmpty(y)) {
    return [];
  }

  return deepEqual(x, y);
}

function equivalence(x, y) {
  if (util.isEmpty(x) && util.isEmpty(y)) {
    return [true];
  }

  if (util.isEmpty(x) || util.isEmpty(y)) {
    return [];
  }

  return deepEqual(x, y, {
    fuzzy: true
  });
}

engine.equal = function (a, b) {
  return equality(a, b);
};

engine.unequal = function (a, b) {
  var eq = equality(a, b);
  return eq === undefined ? undefined : !eq;
};

engine.equival = function (a, b) {
  return equivalence(a, b);
};

engine.unequival = function (a, b) {
  return !equivalence(a, b);
};
/**
 *  Checks that the types of a and b are suitable for comparison in an
 *  inequality expression.  It is assumed that a check has already been made
 *  that there is at least one value in a and b.
 * @param a the left side of the inequality expression (which should be an array of
 *  one value).
 * @param b the right side of the inequality expression (which should be an array of
 *  one value).
 * @return the singleton values of the arrays a, and b.  If one was an FP_Type
 *  and the other was convertible, the coverted value will be retureed.
 */


function typecheck(a, b) {
  util.assertAtMostOne(a, "Singleton was expected");
  util.assertAtMostOne(b, "Singleton was expected");
  a = util.valDataConverted(a[0]);
  b = util.valDataConverted(b[0]);
  let lClass = a.constructor === FP_Date ? FP_DateTime : a.constructor;
  let rClass = b.constructor === FP_Date ? FP_DateTime : b.constructor;

  if (lClass !== rClass) {
    util.raiseError('Type of "' + a + '" (' + lClass.name + ') did not match type of "' + b + '" (' + rClass.name + ')', 'InequalityExpression');
  }

  return [a, b];
}

engine.lt = function (a, b) {
  if (!a.length || !b.length) return [];
  const [a0, b0] = typecheck(a, b);

  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare < 0;
  }

  return a0 < b0;
};

engine.gt = function (a, b) {
  if (!a.length || !b.length) return [];
  const [a0, b0] = typecheck(a, b);

  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare > 0;
  }

  return a0 > b0;
};

engine.lte = function (a, b) {
  if (!a.length || !b.length) return [];
  const [a0, b0] = typecheck(a, b);

  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare <= 0;
  }

  return a0 <= b0;
};

engine.gte = function (a, b) {
  if (!a.length || !b.length) return [];
  const [a0, b0] = typecheck(a, b);

  if (a0 instanceof FP_Type) {
    const compare = a0.compare(b0);
    return compare === null ? [] : compare >= 0;
  }

  return a0 >= b0;
};

module.exports = engine;

/***/ }),
/* 80 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Originally copied from node-deep-equal
// (https://github.com/substack/node-deep-equal), with modifications.
// For the license for node-deep-equal, see the bottom of this file.
var types = __webpack_require__(56);

var FP_Type = types.FP_Type;

var util = __webpack_require__(55);

var numbers = __webpack_require__(63);

var pSlice = Array.prototype.slice;
var objectKeys = Object.keys;

var isArguments = function (object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

function isString(myVar) {
  return typeof myVar === 'string' || myVar instanceof String;
}

function isNumber(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}

function normalizeStr(x) {
  return x.toUpperCase().replace(/\s+/, ' ');
}
/**
 * Performs a deep comparison between two values to determine if they are equal.
 * When you need to compare many objects, you can use hashObject instead for
 * optimization (if changes are needed here, they are likely also needed there).
 * @param {any} actual - one of the comparing objects
 * @param {any} expected - one of the comparing objects
 * @param {Object} [opts] - comparison options
 * @param {boolean} [opts.fuzzy] - false (by default), if comparing objects for
 *   equality (see https://hl7.org/fhirpath/#equals).
 *   true, if comparing objects for equivalence
 *   (see https://hl7.org/fhirpath/#equivalent).
 * @return {boolean}
 */


function deepEqual(actual, expected, opts) {
  actual = util.valDataConverted(actual);
  expected = util.valDataConverted(expected);
  if (!opts) opts = {}; // 7.1. All identical values are equivalent, as determined by ===.

  if (actual === expected) {
    return true;
  }

  if (opts.fuzzy) {
    if (isString(actual) && isString(expected)) {
      return normalizeStr(actual) == normalizeStr(expected);
    }

    if (isNumber(actual) && isNumber(expected)) {
      return numbers.isEquivalent(actual, expected);
    }
  } else {
    // !opts.fuzzy
    // If these are numbers, they need to be rounded to the maximum supported
    // precision to remove floating point arithmetic errors (e.g. 0.1+0.1+0.1 should
    // equal 0.3) before comparing.
    if (typeof actual === 'number' && typeof expected === 'number') {
      return numbers.isEqual(actual, expected);
    }
  }

  if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return actual === expected;
  } else {
    var actualIsFPT = actual instanceof FP_Type;
    var expectedIsFPT = expected instanceof FP_Type;

    if (actualIsFPT && expectedIsFPT) {
      // if both are FP_Type
      return opts.fuzzy ? actual.equivalentTo(expected) : actual.equals(expected); // May return undefined
    } else if (actualIsFPT || expectedIsFPT) {
      // if only one is an FP_Type
      return false;
    } // 7.4. For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.


    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false; // an identical 'prototype' property.

  if (a.prototype !== b.prototype) return false; //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.

  if (isArguments(a) || isArguments(b)) {
    a = isArguments(a) ? pSlice.call(a) : a;
    b = isArguments(b) ? pSlice.call(b) : b;
    return deepEqual(a, b, opts);
  }

  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {
    //happens when one is a string literal and the other isn't
    return false;
  } // having the same number of owned properties (keys incorporates
  // hasOwnProperty)


  if (ka.length != kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  // If the length of the array is one, return the value of deepEqual (which can
  // be "undefined".


  if (ka.length === 1) {
    key = ka[0];
    return deepEqual(a[key], b[key], opts);
  }

  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }

  return typeof a === typeof b;
}

module.exports = deepEqual; // The license for node-deep-equal, on which the above code is based, is as
// follows:
//
// This software is released under the MIT license:
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/***/ }),
/* 81 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Combining functions.
const combineFns = {};

const {
  distinctFn
} = __webpack_require__(74);

const hashObject = __webpack_require__(75);

combineFns.union = function (coll1, coll2) {
  return distinctFn(coll1.concat(coll2));
};

combineFns.combineFn = function (coll1, coll2) {
  return coll1.concat(coll2);
};

combineFns.intersect = function (coll1, coll2) {
  let result = [];
  const coll1Length = coll1.length;
  let uncheckedLength = coll2.length;

  if (coll1Length && uncheckedLength) {
    let coll2hash = {};
    coll2.forEach(item => {
      const hash = hashObject(item);

      if (coll2hash[hash]) {
        uncheckedLength--;
      } else {
        coll2hash[hash] = true;
      }
    });

    for (let i = 0; i < coll1Length && uncheckedLength > 0; ++i) {
      let item = coll1[i];
      let hash = hashObject(item);

      if (coll2hash[hash]) {
        result.push(item);
        coll2hash[hash] = false;
        uncheckedLength--;
      }
    }
  }

  return result;
};

module.exports = combineFns;

/***/ }),
/* 82 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// This file holds code to hande the FHIRPath Math functions.
var deepEqual = __webpack_require__(80);

var engine = {}; // b is assumed to have one element and it tests whether b[0] is in a

function containsImpl(a, b) {
  if (b.length == 0) {
    return true;
  }

  for (var i = 0; i < a.length; i++) {
    if (deepEqual(a[i], b[0])) {
      return true;
    }
  }

  return false;
}

engine.contains = function (a, b) {
  if (b.length == 0) {
    return [];
  }

  if (a.length == 0) {
    return false;
  }

  if (b.length > 1) {
    throw new Error("Expected singleton on right side of contains, got " + JSON.stringify(b));
  }

  return containsImpl(a, b);
};

engine.in = function (a, b) {
  if (a.length == 0) {
    return [];
  }

  if (b.length == 0) {
    return false;
  }

  if (a.length > 1) {
    throw new Error("Expected singleton on right side of in, got " + JSON.stringify(b));
  }

  return containsImpl(b, a);
};

module.exports = engine;

/***/ }),
/* 83 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const util = __webpack_require__(55);

const misc = __webpack_require__(76);

const engine = {}; // Cache for rewritten RegExp patterns

const cachedRegExp = {};
/**
 * Rewrites RegExp pattern to support single-line mode (dotAll) in IE11:
 * To do that we replace "." with "[^]" in source RegExp pattern,
 * except where "." is escaped or is inside unescaped [].
 * Another way to do the same is using package regexpu-core
 * or packages regjsparser/regjsgen.
 * @param {string} pattern - source RegExp pattern
 * @return {string}
 */

function rewritePatternForDotAll(pattern) {
  if (!cachedRegExp[pattern]) {
    cachedRegExp[pattern] = pattern.replace(/\./g, (_, offset, entirePattern) => {
      // The preceding part of the string
      const precedingPart = entirePattern.substr(0, offset); // The preceding part of the string without escaped characters: '\', '[' or ']'

      const cleanPrecedingPart = precedingPart.replace(/\\\\/g, '').replace(/\\[\][]/g, ''); // Check if '.' is escaped

      const escaped = cleanPrecedingPart[cleanPrecedingPart.length - 1] === '\\'; // The last index of unescaped '['

      const lastIndexOfOpenBracket = cleanPrecedingPart.lastIndexOf('['); // The last index of unescaped ']'

      const lastIndexOfCloseBracket = cleanPrecedingPart.lastIndexOf(']');
      return escaped || lastIndexOfOpenBracket > lastIndexOfCloseBracket ? '.' : '[^]';
    });
  }

  return cachedRegExp[pattern];
}

engine.indexOf = function (coll, substr) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.indexOf(substr);
};

engine.substring = function (coll, start, length) {
  const str = misc.singleton(coll, 'String');

  if (util.isEmpty(str) || util.isEmpty(start) || start < 0 || start >= str.length) {
    return [];
  }

  if (length === undefined || util.isEmpty(length)) {
    return str.substring(start);
  }

  return str.substring(start, start + length);
};

engine.startsWith = function (coll, prefix) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(prefix) || util.isEmpty(str) ? [] : str.startsWith(prefix);
};

engine.endsWith = function (coll, postfix) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(postfix) || util.isEmpty(str) ? [] : str.endsWith(postfix);
};

engine.containsFn = function (coll, substr) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(substr) || util.isEmpty(str) ? [] : str.includes(substr);
};

engine.upper = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.toUpperCase();
};

engine.lower = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.toLowerCase();
}; // Check if dotAll is supported.
// See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll for details.


const dotAllIsSupported = new RegExp('').dotAll === false;

if (dotAllIsSupported) {
  engine.matches = function (coll, regex) {
    const str = misc.singleton(coll, 'String');

    if (util.isEmpty(regex) || util.isEmpty(str)) {
      return [];
    }

    const reg = new RegExp(regex, 's');
    return reg.test(str);
  };
} else {
  engine.matches = function (coll, regex) {
    const str = misc.singleton(coll, 'String');

    if (util.isEmpty(regex) || util.isEmpty(str)) {
      return [];
    }

    const reg = new RegExp(rewritePatternForDotAll(regex));
    return reg.test(str);
  };
}

engine.replace = function (coll, pattern, repl) {
  const str = misc.singleton(coll, 'String');

  if (util.isEmpty(pattern) || util.isEmpty(repl) || util.isEmpty(str)) {
    return [];
  }

  const reg = new RegExp(util.escapeStringForRegExp(pattern), 'g');
  return str.replace(reg, repl);
};

engine.replaceMatches = function (coll, regex, repl) {
  const str = misc.singleton(coll, 'String');

  if (util.isEmpty(regex) || util.isEmpty(repl) || util.isEmpty(str)) {
    return [];
  }

  const reg = new RegExp(regex, 'g');
  return str.replace(reg, repl);
};

engine.length = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.length;
};

engine.toChars = function (coll) {
  const str = misc.singleton(coll, 'String');
  return util.isEmpty(str) ? [] : str.split('');
};

module.exports = engine;

/***/ }),
/* 84 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

const util = __webpack_require__(55);

const {
  ResourceNode
} = __webpack_require__(56);

let makeResNode = ResourceNode.makeResNode;
var engine = {};

engine.children = function (coll) {
  let model = this.model; // "this" is the context object

  return coll.reduce(function (acc, x) {
    let d = util.valData(x);
    x = makeResNode(x);

    if (typeof d === 'object') {
      for (var prop of Object.keys(d)) {
        var v = d[prop];
        var childPath = x.path + '.' + prop;

        if (model) {
          let defPath = model.pathsDefinedElsewhere[childPath];
          if (defPath) childPath = defPath;
        }

        if (Array.isArray(v)) {
          acc.push.apply(acc, v.map(n => makeResNode(n, childPath)));
        } else {
          acc.push(makeResNode(v, childPath));
        }
      }

      return acc;
    } else {
      return acc;
    }
  }, []);
};

engine.descendants = function (coll) {
  var ch = engine.children.call(this, coll); // "this" is the context object

  var res = [];

  while (ch.length > 0) {
    res.push.apply(res, ch);
    ch = engine.children.call(this, ch);
  }

  return res;
};

module.exports = engine;

/***/ }),
/* 85 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var engine = {};

const types = __webpack_require__(56);

const constants = __webpack_require__(72);

const FP_Date = types.FP_Date;
const FP_DateTime = types.FP_DateTime;
const FP_Time = types.FP_Time;
/**
 *  Implements FHIRPath now().
 */

engine.now = function () {
  if (!constants.now) {
    // return new FP_DateTime((new Date()).toISOString());
    // The above would construct an FP_DateTime with a timezone of "Z", which
    // would not make a difference for computation, but if the end result of an
    // expression is "now()", then it would look different when output to a user.
    // Construct it ourselves to preserve timezone
    var now = constants.nowDate; // a JS Date

    var isoStr = FP_DateTime.isoDateTime(now);
    constants.now = new FP_DateTime(isoStr);
  }

  return constants.now;
};
/**
 *  Implements FHIRPath today().  See comments in now(). This does not
 *  include a timezone offset.
 */


engine.today = function () {
  if (!constants.today) {
    // Construct the string ourselves to preserve timezone
    var now = constants.nowDate; // a JS Date

    var isoStr = FP_Date.isoDate(now);
    constants.today = new FP_Date(isoStr);
  }

  return constants.today;
};
/**
 *  Implements FHIRPath timeOfDay().  See comments in now(). This does not
 *  include a timezone offset.
 */


engine.timeOfDay = function () {
  if (!constants.timeOfDay) {
    // Construct the string ourselves to preserve timezone
    const now = constants.nowDate; // a JS Date

    const isoStr = FP_DateTime.isoTime(now);
    constants.timeOfDay = new FP_Time(isoStr);
  }

  return constants.timeOfDay;
};

module.exports = engine;

/***/ }),
/* 86 */
/***/ (function(module) {

var engine = {};

engine.orOp = function (a, b) {
  if (Array.isArray(b)) {
    if (a === true) {
      return true;
    } else if (a === false) {
      return [];
    } else if (Array.isArray(a)) {
      return [];
    }
  }

  if (Array.isArray(a)) {
    if (b === true) {
      return true;
    } else {
      return [];
    }
  }

  return a || b;
};

engine.andOp = function (a, b) {
  if (Array.isArray(b)) {
    if (a === true) {
      return [];
    } else if (a === false) {
      return false;
    } else if (Array.isArray(a)) {
      return [];
    }
  }

  if (Array.isArray(a)) {
    if (b === true) {
      return [];
    } else {
      return false;
    }
  }

  return a && b;
};

engine.xorOp = function (a, b) {
  // If a or b are arrays, they must be the empty set.
  // In that case, the result is always the empty set.
  if (Array.isArray(a) || Array.isArray(b)) return [];
  return a && !b || !a && b;
};

engine.impliesOp = function (a, b) {
  if (Array.isArray(b)) {
    if (a === true) {
      return [];
    } else if (a === false) {
      return true;
    } else if (Array.isArray(a)) {
      return [];
    }
  }

  if (Array.isArray(a)) {
    if (b === true) {
      return true;
    } else {
      return [];
    }
  }

  if (a === false) {
    return true;
  }

  return a && b;
};

module.exports = engine;

/***/ }),
/* 87 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/**
 *  Exports the FHIR model data for R4.  This is an internal structure that
 *  will likely evolve as more FHIR specific processing is added.
 */
module.exports = {
  /**
   *  A hash of resource element paths (e.g. Observation.value) that are known
   *  to point to fiels that are choice types.
   */
  choiceTypePaths: __webpack_require__(88),

  /**
   *  A hash from paths to the path for which their content is defined, e.g.
   *  Questionnaire.item.item -> Questionnaire.item.
   */
  pathsDefinedElsewhere: __webpack_require__(89),

  /**
   * Mapping data types to parent data types.
   */
  type2Parent: __webpack_require__(90),

  /**
   * Mapping paths to data types.
   */
  path2Type: __webpack_require__(91)
};

/***/ }),
/* 88 */
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"ActivityDefinition.product":["Reference","CodeableConcept"],"ActivityDefinition.subject":["CodeableConcept","Reference"],"ActivityDefinition.timing":["Timing","DateTime","Age","Period","Range","Duration"],"AllergyIntolerance.onset":["DateTime","Age","Period","Range","String"],"Annotation.author":["Reference","String"],"AuditEvent.entity.detail.value":["String","Base64Binary"],"BiologicallyDerivedProduct.collection.collected":["DateTime","Period"],"BiologicallyDerivedProduct.manipulation.time":["DateTime","Period"],"BiologicallyDerivedProduct.processing.time":["DateTime","Period"],"CarePlan.activity.detail.product":["CodeableConcept","Reference"],"CarePlan.activity.detail.scheduled":["Timing","Period","String"],"ChargeItem.occurrence":["DateTime","Period","Timing"],"ChargeItem.product":["Reference","CodeableConcept"],"Claim.accident.location":["Address","Reference"],"Claim.diagnosis.diagnosis":["CodeableConcept","Reference"],"Claim.item.location":["CodeableConcept","Address","Reference"],"Claim.item.serviced":["Date","Period"],"Claim.procedure.procedure":["CodeableConcept","Reference"],"Claim.supportingInfo.timing":["Date","Period"],"Claim.supportingInfo.value":["Boolean","String","Quantity","Attachment","Reference"],"ClaimResponse.addItem.location":["CodeableConcept","Address","Reference"],"ClaimResponse.addItem.serviced":["Date","Period"],"ClinicalImpression.effective":["DateTime","Period"],"CodeSystem.concept.property.value":["Code","Coding","String","Integer","Boolean","DateTime","Decimal"],"Communication.payload.content":["String","Attachment","Reference"],"CommunicationRequest.occurrence":["DateTime","Period"],"CommunicationRequest.payload.content":["String","Attachment","Reference"],"Composition.relatesTo.target":["Identifier","Reference"],"ConceptMap.source":["Uri","Canonical"],"ConceptMap.target":["Uri","Canonical"],"Condition.abatement":["DateTime","Age","Period","Range","String"],"Condition.onset":["DateTime","Age","Period","Range","String"],"Consent.source":["Attachment","Reference"],"Contract.friendly.content":["Attachment","Reference"],"Contract.legal.content":["Attachment","Reference"],"Contract.legallyBinding":["Attachment","Reference"],"Contract.rule.content":["Attachment","Reference"],"Contract.term.action.occurrence":["DateTime","Period","Timing"],"Contract.term.asset.valuedItem.entity":["CodeableConcept","Reference"],"Contract.term.offer.answer.value":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Uri","Attachment","Coding","Quantity","Reference"],"Contract.term.topic":["CodeableConcept","Reference"],"Contract.topic":["CodeableConcept","Reference"],"Coverage.costToBeneficiary.value":["Quantity","Money"],"CoverageEligibilityRequest.item.diagnosis.diagnosis":["CodeableConcept","Reference"],"CoverageEligibilityRequest.serviced":["Date","Period"],"CoverageEligibilityResponse.insurance.item.benefit.allowed":["UnsignedInt","String","Money"],"CoverageEligibilityResponse.insurance.item.benefit.used":["UnsignedInt","String","Money"],"CoverageEligibilityResponse.serviced":["Date","Period"],"DataRequirement.dateFilter.value":["DateTime","Period","Duration"],"DataRequirement.subject":["CodeableConcept","Reference"],"DetectedIssue.identified":["DateTime","Period"],"DeviceDefinition.manufacturer":["String","Reference"],"DeviceRequest.code":["Reference","CodeableConcept"],"DeviceRequest.occurrence":["DateTime","Period","Timing"],"DeviceRequest.parameter.value":["CodeableConcept","Quantity","Range","Boolean"],"DeviceUseStatement.timing":["Timing","Period","DateTime"],"DiagnosticReport.effective":["DateTime","Period"],"Dosage.asNeeded":["Boolean","CodeableConcept"],"Dosage.doseAndRate.dose":["Range","Quantity"],"Dosage.doseAndRate.rate":["Ratio","Range","Quantity"],"ElementDefinition.defaultValue":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"ElementDefinition.example.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"ElementDefinition.extension.value":["CodeableConcept","Canonical"],"ElementDefinition.fixed":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"ElementDefinition.maxValue":["Date","DateTime","Instant","Time","Decimal","Integer","PositiveInt","UnsignedInt","Quantity"],"ElementDefinition.minValue":["Date","DateTime","Instant","Time","Decimal","Integer","PositiveInt","UnsignedInt","Quantity"],"ElementDefinition.pattern":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"EventDefinition.subject":["CodeableConcept","Reference"],"EvidenceVariable.characteristic.definition":["Reference","Canonical","CodeableConcept","Expression","DataRequirement","TriggerDefinition"],"EvidenceVariable.characteristic.participantEffective":["DateTime","Period","Duration","Timing"],"ExplanationOfBenefit.accident.location":["Address","Reference"],"ExplanationOfBenefit.addItem.location":["CodeableConcept","Address","Reference"],"ExplanationOfBenefit.addItem.serviced":["Date","Period"],"ExplanationOfBenefit.benefitBalance.financial.allowed":["UnsignedInt","String","Money"],"ExplanationOfBenefit.benefitBalance.financial.used":["UnsignedInt","Money"],"ExplanationOfBenefit.diagnosis.diagnosis":["CodeableConcept","Reference"],"ExplanationOfBenefit.item.location":["CodeableConcept","Address","Reference"],"ExplanationOfBenefit.item.serviced":["Date","Period"],"ExplanationOfBenefit.procedure.procedure":["CodeableConcept","Reference"],"ExplanationOfBenefit.supportingInfo.timing":["Date","Period"],"ExplanationOfBenefit.supportingInfo.value":["Boolean","String","Quantity","Attachment","Reference"],"Extension.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"FamilyMemberHistory.age":["Age","Range","String"],"FamilyMemberHistory.born":["Period","Date","String"],"FamilyMemberHistory.condition.onset":["Age","Range","Period","String"],"FamilyMemberHistory.deceased":["Boolean","Age","Range","Date","String"],"Goal.start":["Date","CodeableConcept"],"Goal.target.detail":["Quantity","Range","CodeableConcept","String","Boolean","Integer","Ratio"],"Goal.target.due":["Date","Duration"],"Group.characteristic.value":["CodeableConcept","Boolean","Quantity","Range","Reference"],"GuidanceResponse.module":["Uri","Canonical","CodeableConcept"],"Immunization.occurrence":["DateTime","String"],"Immunization.protocolApplied.doseNumber":["PositiveInt","String"],"Immunization.protocolApplied.seriesDoses":["PositiveInt","String"],"ImmunizationEvaluation.doseNumber":["PositiveInt","String"],"ImmunizationEvaluation.seriesDoses":["PositiveInt","String"],"ImmunizationRecommendation.recommendation.doseNumber":["PositiveInt","String"],"ImmunizationRecommendation.recommendation.seriesDoses":["PositiveInt","String"],"ImplementationGuide.definition.page.name":["Url","Reference"],"ImplementationGuide.definition.resource.example":["Boolean","Canonical"],"ImplementationGuide.manifest.resource.example":["Boolean","Canonical"],"Invoice.lineItem.chargeItem":["Reference","CodeableConcept"],"Library.subject":["CodeableConcept","Reference"],"Measure.subject":["CodeableConcept","Reference"],"Media.created":["DateTime","Period"],"Medication.ingredient.item":["CodeableConcept","Reference"],"MedicationAdministration.dosage.rate":["Ratio","Quantity"],"MedicationAdministration.effective":["DateTime","Period"],"MedicationAdministration.medication":["CodeableConcept","Reference"],"MedicationDispense.medication":["CodeableConcept","Reference"],"MedicationDispense.statusReason":["CodeableConcept","Reference"],"MedicationKnowledge.administrationGuidelines.indication":["CodeableConcept","Reference"],"MedicationKnowledge.administrationGuidelines.patientCharacteristics.characteristic":["CodeableConcept","Quantity"],"MedicationKnowledge.drugCharacteristic.value":["CodeableConcept","String","Quantity","Base64Binary"],"MedicationKnowledge.ingredient.item":["CodeableConcept","Reference"],"MedicationRequest.medication":["CodeableConcept","Reference"],"MedicationRequest.reported":["Boolean","Reference"],"MedicationRequest.substitution.allowed":["Boolean","CodeableConcept"],"MedicationStatement.effective":["DateTime","Period"],"MedicationStatement.medication":["CodeableConcept","Reference"],"MedicinalProduct.specialDesignation.indication":["CodeableConcept","Reference"],"MedicinalProductAuthorization.procedure.date":["Period","DateTime"],"MedicinalProductContraindication.otherTherapy.medication":["CodeableConcept","Reference"],"MedicinalProductIndication.otherTherapy.medication":["CodeableConcept","Reference"],"MedicinalProductInteraction.interactant.item":["Reference","CodeableConcept"],"MessageDefinition.event":["Coding","Uri"],"MessageHeader.event":["Coding","Uri"],"NutritionOrder.enteralFormula.administration.rate":["Quantity","Ratio"],"Observation.component.value":["Quantity","CodeableConcept","String","Boolean","Integer","Range","Ratio","SampledData","Time","DateTime","Period"],"Observation.effective":["DateTime","Period","Timing","Instant"],"Observation.value":["Quantity","CodeableConcept","String","Boolean","Integer","Range","Ratio","SampledData","Time","DateTime","Period"],"Parameters.parameter.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"Patient.deceased":["Boolean","DateTime"],"Patient.multipleBirth":["Boolean","Integer"],"PlanDefinition.action.definition":["Canonical","Uri"],"PlanDefinition.action.relatedAction.offset":["Duration","Range"],"PlanDefinition.action.subject":["CodeableConcept","Reference"],"PlanDefinition.action.timing":["DateTime","Age","Period","Duration","Range","Timing"],"PlanDefinition.goal.target.detail":["Quantity","Range","CodeableConcept"],"PlanDefinition.subject":["CodeableConcept","Reference"],"Population.age":["Range","CodeableConcept"],"Procedure.performed":["DateTime","Period","String","Age","Range"],"Provenance.occurred":["Period","DateTime"],"Questionnaire.item.answerOption.value":["Integer","Date","Time","String","Coding","Reference"],"Questionnaire.item.enableWhen.answer":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Coding","Quantity","Reference"],"Questionnaire.item.initial.value":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Uri","Attachment","Coding","Quantity","Reference"],"QuestionnaireResponse.item.answer.value":["Boolean","Decimal","Integer","Date","DateTime","Time","String","Uri","Attachment","Coding","Quantity","Reference"],"RequestGroup.action.relatedAction.offset":["Duration","Range"],"RequestGroup.action.timing":["DateTime","Age","Period","Duration","Range","Timing"],"ResearchDefinition.subject":["CodeableConcept","Reference"],"ResearchElementDefinition.characteristic.definition":["CodeableConcept","Canonical","Expression","DataRequirement"],"ResearchElementDefinition.characteristic.participantEffective":["DateTime","Period","Duration","Timing"],"ResearchElementDefinition.characteristic.studyEffective":["DateTime","Period","Duration","Timing"],"ResearchElementDefinition.subject":["CodeableConcept","Reference"],"RiskAssessment.occurrence":["DateTime","Period"],"RiskAssessment.prediction.probability":["Decimal","Range"],"RiskAssessment.prediction.when":["Period","Range"],"ServiceRequest.asNeeded":["Boolean","CodeableConcept"],"ServiceRequest.occurrence":["DateTime","Period","Timing"],"ServiceRequest.quantity":["Quantity","Ratio","Range"],"Specimen.collection.collected":["DateTime","Period"],"Specimen.collection.fastingStatus":["CodeableConcept","Duration"],"Specimen.container.additive":["CodeableConcept","Reference"],"Specimen.processing.time":["DateTime","Period"],"SpecimenDefinition.typeTested.container.additive.additive":["CodeableConcept","Reference"],"SpecimenDefinition.typeTested.container.minimumVolume":["Quantity","String"],"StructureMap.group.rule.source.defaultValue":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"StructureMap.group.rule.target.parameter.value":["Id","String","Boolean","Integer","Decimal"],"Substance.ingredient.substance":["CodeableConcept","Reference"],"SubstanceAmount.amount":["Quantity","Range","String"],"SubstanceReferenceInformation.target.amount":["Quantity","Range","String"],"SubstanceSpecification.moiety.amount":["Quantity","String"],"SubstanceSpecification.property.amount":["Quantity","String"],"SubstanceSpecification.property.definingSubstance":["Reference","CodeableConcept"],"SubstanceSpecification.relationship.amount":["Quantity","Range","Ratio","String"],"SubstanceSpecification.relationship.substance":["Reference","CodeableConcept"],"SupplyDelivery.occurrence":["DateTime","Period","Timing"],"SupplyDelivery.suppliedItem.item":["CodeableConcept","Reference"],"SupplyRequest.item":["CodeableConcept","Reference"],"SupplyRequest.occurrence":["DateTime","Period","Timing"],"SupplyRequest.parameter.value":["CodeableConcept","Quantity","Range","Boolean"],"Task.input.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"Task.output.value":["Base64Binary","Boolean","Canonical","Code","Date","DateTime","Decimal","Id","Instant","Integer","Markdown","Oid","PositiveInt","String","Time","UnsignedInt","Uri","Url","Uuid","Address","Age","Annotation","Attachment","CodeableConcept","Coding","ContactPoint","Count","Distance","Duration","HumanName","Identifier","Money","Period","Quantity","Range","Ratio","Reference","SampledData","Signature","Timing","ContactDetail","Contributor","DataRequirement","Expression","ParameterDefinition","RelatedArtifact","TriggerDefinition","UsageContext","Dosage","Meta"],"Timing.repeat.bounds":["Duration","Range","Period"],"TriggerDefinition.timing":["Timing","Reference","Date","DateTime"],"UsageContext.value":["CodeableConcept","Quantity","Range","Reference"],"ValueSet.expansion.parameter.value":["String","Boolean","Integer","Decimal","Uri","Code","DateTime"]}');

/***/ }),
/* 89 */
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"Bundle.entry.link":"Bundle.link","CapabilityStatement.rest.operation":"CapabilityStatement.rest.resource.operation","CapabilityStatement.rest.searchParam":"CapabilityStatement.rest.resource.searchParam","ChargeItemDefinition.propertyGroup.applicability":"ChargeItemDefinition.applicability","ClaimResponse.addItem.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.addItem.detail.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.addItem.detail.subDetail.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.item.detail.adjudication":"ClaimResponse.item.adjudication","ClaimResponse.item.detail.subDetail.adjudication":"ClaimResponse.item.adjudication","CodeSystem.concept.concept":"CodeSystem.concept","Composition.section.section":"Composition.section","ConceptMap.group.element.target.product":"ConceptMap.group.element.target.dependsOn","Consent.provision.provision":"Consent.provision","Contract.term.asset.answer":"Contract.term.offer.answer","Contract.term.group":"Contract.term","ExampleScenario.process.step.alternative.step":"ExampleScenario.process.step","ExampleScenario.process.step.operation.request":"ExampleScenario.instance.containedInstance","ExampleScenario.process.step.operation.response":"ExampleScenario.instance.containedInstance","ExampleScenario.process.step.process":"ExampleScenario.process","ExplanationOfBenefit.addItem.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.addItem.detail.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.addItem.detail.subDetail.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.item.detail.adjudication":"ExplanationOfBenefit.item.adjudication","ExplanationOfBenefit.item.detail.subDetail.adjudication":"ExplanationOfBenefit.item.adjudication","GraphDefinition.link.target.link":"GraphDefinition.link","ImplementationGuide.definition.page.page":"ImplementationGuide.definition.page","Invoice.totalPriceComponent":"Invoice.lineItem.priceComponent","MedicinalProductAuthorization.procedure.application":"MedicinalProductAuthorization.procedure","MedicinalProductIngredient.substance.strength":"MedicinalProductIngredient.specifiedSubstance.strength","MedicinalProductPackaged.packageItem.packageItem":"MedicinalProductPackaged.packageItem","Observation.component.referenceRange":"Observation.referenceRange","OperationDefinition.parameter.part":"OperationDefinition.parameter","Parameters.parameter.part":"Parameters.parameter","PlanDefinition.action.action":"PlanDefinition.action","Provenance.entity.agent":"Provenance.agent","Questionnaire.item.item":"Questionnaire.item","QuestionnaireResponse.item.answer.item":"QuestionnaireResponse.item","QuestionnaireResponse.item.item":"QuestionnaireResponse.item","RequestGroup.action.action":"RequestGroup.action","StructureMap.group.rule.rule":"StructureMap.group.rule","SubstanceSpecification.molecularWeight":"SubstanceSpecification.structure.isotope.molecularWeight","SubstanceSpecification.name.synonym":"SubstanceSpecification.name","SubstanceSpecification.name.translation":"SubstanceSpecification.name","SubstanceSpecification.structure.molecularWeight":"SubstanceSpecification.structure.isotope.molecularWeight","TestReport.teardown.action.operation":"TestReport.setup.action.operation","TestReport.test.action.assert":"TestReport.setup.action.assert","TestReport.test.action.operation":"TestReport.setup.action.operation","TestScript.teardown.action.operation":"TestScript.setup.action.operation","TestScript.test.action.assert":"TestScript.setup.action.assert","TestScript.test.action.operation":"TestScript.setup.action.operation","ValueSet.compose.exclude":"ValueSet.compose.include","ValueSet.expansion.contains.contains":"ValueSet.expansion.contains","ValueSet.expansion.contains.designation":"ValueSet.compose.include.concept.designation"}');

/***/ }),
/* 90 */
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"Account":"DomainResource","ActivityDefinition":"DomainResource","Address":"Element","AdverseEvent":"DomainResource","Age":"Quantity","AllergyIntolerance":"DomainResource","Annotation":"Element","Appointment":"DomainResource","AppointmentResponse":"DomainResource","Attachment":"Element","AuditEvent":"DomainResource","BackboneElement":"Element","Basic":"DomainResource","Binary":"Resource","BiologicallyDerivedProduct":"DomainResource","BodyStructure":"DomainResource","Bundle":"Resource","CapabilityStatement":"DomainResource","CarePlan":"DomainResource","CareTeam":"DomainResource","CatalogEntry":"DomainResource","ChargeItem":"DomainResource","ChargeItemDefinition":"DomainResource","Claim":"DomainResource","ClaimResponse":"DomainResource","ClinicalImpression":"DomainResource","CodeSystem":"DomainResource","CodeableConcept":"Element","Coding":"Element","Communication":"DomainResource","CommunicationRequest":"DomainResource","CompartmentDefinition":"DomainResource","Composition":"DomainResource","ConceptMap":"DomainResource","Condition":"DomainResource","Consent":"DomainResource","ContactDetail":"Element","ContactPoint":"Element","Contract":"DomainResource","Contributor":"Element","Count":"Quantity","Coverage":"DomainResource","CoverageEligibilityRequest":"DomainResource","CoverageEligibilityResponse":"DomainResource","DataRequirement":"Element","DetectedIssue":"DomainResource","Device":"DomainResource","DeviceDefinition":"DomainResource","DeviceMetric":"DomainResource","DeviceRequest":"DomainResource","DeviceUseStatement":"DomainResource","DiagnosticReport":"DomainResource","Distance":"Quantity","DocumentManifest":"DomainResource","DocumentReference":"DomainResource","DomainResource":"Resource","Dosage":"BackboneElement","Duration":"Quantity","EffectEvidenceSynthesis":"DomainResource","ElementDefinition":"BackboneElement","Encounter":"DomainResource","Endpoint":"DomainResource","EnrollmentRequest":"DomainResource","EnrollmentResponse":"DomainResource","EpisodeOfCare":"DomainResource","EventDefinition":"DomainResource","Evidence":"DomainResource","EvidenceVariable":"DomainResource","ExampleScenario":"DomainResource","ExplanationOfBenefit":"DomainResource","Expression":"Element","Extension":"Element","FamilyMemberHistory":"DomainResource","Flag":"DomainResource","Goal":"DomainResource","GraphDefinition":"DomainResource","Group":"DomainResource","GuidanceResponse":"DomainResource","HealthcareService":"DomainResource","HumanName":"Element","Identifier":"Element","ImagingStudy":"DomainResource","Immunization":"DomainResource","ImmunizationEvaluation":"DomainResource","ImmunizationRecommendation":"DomainResource","ImplementationGuide":"DomainResource","InsurancePlan":"DomainResource","Invoice":"DomainResource","Library":"DomainResource","Linkage":"DomainResource","List":"DomainResource","Location":"DomainResource","MarketingStatus":"BackboneElement","Measure":"DomainResource","MeasureReport":"DomainResource","Media":"DomainResource","Medication":"DomainResource","MedicationAdministration":"DomainResource","MedicationDispense":"DomainResource","MedicationKnowledge":"DomainResource","MedicationRequest":"DomainResource","MedicationStatement":"DomainResource","MedicinalProduct":"DomainResource","MedicinalProductAuthorization":"DomainResource","MedicinalProductContraindication":"DomainResource","MedicinalProductIndication":"DomainResource","MedicinalProductIngredient":"DomainResource","MedicinalProductInteraction":"DomainResource","MedicinalProductManufactured":"DomainResource","MedicinalProductPackaged":"DomainResource","MedicinalProductPharmaceutical":"DomainResource","MedicinalProductUndesirableEffect":"DomainResource","MessageDefinition":"DomainResource","MessageHeader":"DomainResource","Meta":"Element","MolecularSequence":"DomainResource","Money":"Element","MoneyQuantity":"Quantity","NamingSystem":"DomainResource","Narrative":"Element","NutritionOrder":"DomainResource","Observation":"DomainResource","ObservationDefinition":"DomainResource","OperationDefinition":"DomainResource","OperationOutcome":"DomainResource","Organization":"DomainResource","OrganizationAffiliation":"DomainResource","ParameterDefinition":"Element","Parameters":"Resource","Patient":"DomainResource","PaymentNotice":"DomainResource","PaymentReconciliation":"DomainResource","Period":"Element","Person":"DomainResource","PlanDefinition":"DomainResource","Population":"BackboneElement","Practitioner":"DomainResource","PractitionerRole":"DomainResource","Procedure":"DomainResource","ProdCharacteristic":"BackboneElement","ProductShelfLife":"BackboneElement","Provenance":"DomainResource","Quantity":"Element","Questionnaire":"DomainResource","QuestionnaireResponse":"DomainResource","Range":"Element","Ratio":"Element","Reference":"Element","RelatedArtifact":"Element","RelatedPerson":"DomainResource","RequestGroup":"DomainResource","ResearchDefinition":"DomainResource","ResearchElementDefinition":"DomainResource","ResearchStudy":"DomainResource","ResearchSubject":"DomainResource","RiskAssessment":"DomainResource","RiskEvidenceSynthesis":"DomainResource","SampledData":"Element","Schedule":"DomainResource","SearchParameter":"DomainResource","ServiceRequest":"DomainResource","Signature":"Element","SimpleQuantity":"Quantity","Slot":"DomainResource","Specimen":"DomainResource","SpecimenDefinition":"DomainResource","StructureDefinition":"DomainResource","StructureMap":"DomainResource","Subscription":"DomainResource","Substance":"DomainResource","SubstanceAmount":"BackboneElement","SubstanceNucleicAcid":"DomainResource","SubstancePolymer":"DomainResource","SubstanceProtein":"DomainResource","SubstanceReferenceInformation":"DomainResource","SubstanceSourceMaterial":"DomainResource","SubstanceSpecification":"DomainResource","SupplyDelivery":"DomainResource","SupplyRequest":"DomainResource","Task":"DomainResource","TerminologyCapabilities":"DomainResource","TestReport":"DomainResource","TestScript":"DomainResource","Timing":"BackboneElement","TriggerDefinition":"Element","UsageContext":"Element","ValueSet":"DomainResource","VerificationResult":"DomainResource","VisionPrescription":"DomainResource","base64Binary":"Element","boolean":"Element","canonical":"uri","code":"string","date":"Element","dateTime":"Element","decimal":"Element","id":"string","instant":"Element","integer":"Element","markdown":"string","oid":"uri","positiveInt":"integer","string":"Element","time":"Element","unsignedInt":"integer","uri":"Element","url":"uri","uuid":"uri","xhtml":"Element"}');

/***/ }),
/* 91 */
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"Account.contained":"Resource","Account.coverage.coverage":"Reference","Account.coverage.extension":"Extension","Account.coverage.id":"System.String","Account.coverage.modifierExtension":"Extension","Account.coverage.priority":"positiveInt","Account.description":"string","Account.extension":"Extension","Account.guarantor.extension":"Extension","Account.guarantor.id":"System.String","Account.guarantor.modifierExtension":"Extension","Account.guarantor.onHold":"boolean","Account.guarantor.party":"Reference","Account.guarantor.period":"Period","Account.id":"System.String","Account.identifier":"Identifier","Account.implicitRules":"uri","Account.language":"code","Account.meta":"Meta","Account.modifierExtension":"Extension","Account.name":"string","Account.owner":"Reference","Account.partOf":"Reference","Account.servicePeriod":"Period","Account.status":"code","Account.subject":"Reference","Account.text":"Narrative","Account.type":"CodeableConcept","ActivityDefinition.approvalDate":"date","ActivityDefinition.author":"ContactDetail","ActivityDefinition.bodySite":"CodeableConcept","ActivityDefinition.code":"CodeableConcept","ActivityDefinition.contact":"ContactDetail","ActivityDefinition.contained":"Resource","ActivityDefinition.copyright":"markdown","ActivityDefinition.date":"dateTime","ActivityDefinition.description":"markdown","ActivityDefinition.doNotPerform":"boolean","ActivityDefinition.dosage":"Dosage","ActivityDefinition.dynamicValue.expression":"Expression","ActivityDefinition.dynamicValue.extension":"Extension","ActivityDefinition.dynamicValue.id":"System.String","ActivityDefinition.dynamicValue.modifierExtension":"Extension","ActivityDefinition.dynamicValue.path":"string","ActivityDefinition.editor":"ContactDetail","ActivityDefinition.effectivePeriod":"Period","ActivityDefinition.endorser":"ContactDetail","ActivityDefinition.experimental":"boolean","ActivityDefinition.extension":"Extension","ActivityDefinition.id":"System.String","ActivityDefinition.identifier":"Identifier","ActivityDefinition.implicitRules":"uri","ActivityDefinition.intent":"code","ActivityDefinition.jurisdiction":"CodeableConcept","ActivityDefinition.kind":"code","ActivityDefinition.language":"code","ActivityDefinition.lastReviewDate":"date","ActivityDefinition.library":"canonical","ActivityDefinition.location":"Reference","ActivityDefinition.meta":"Meta","ActivityDefinition.modifierExtension":"Extension","ActivityDefinition.name":"string","ActivityDefinition.observationRequirement":"Reference","ActivityDefinition.observationResultRequirement":"Reference","ActivityDefinition.participant.extension":"Extension","ActivityDefinition.participant.id":"System.String","ActivityDefinition.participant.modifierExtension":"Extension","ActivityDefinition.participant.role":"CodeableConcept","ActivityDefinition.participant.type":"code","ActivityDefinition.priority":"code","ActivityDefinition.productCodeableConcept":"CodeableConcept","ActivityDefinition.productReference":"Reference","ActivityDefinition.profile":"canonical","ActivityDefinition.publisher":"string","ActivityDefinition.purpose":"markdown","ActivityDefinition.quantity":"Quantity","ActivityDefinition.relatedArtifact":"RelatedArtifact","ActivityDefinition.reviewer":"ContactDetail","ActivityDefinition.specimenRequirement":"Reference","ActivityDefinition.status":"code","ActivityDefinition.subjectCodeableConcept":"CodeableConcept","ActivityDefinition.subjectReference":"Reference","ActivityDefinition.subtitle":"string","ActivityDefinition.text":"Narrative","ActivityDefinition.timingAge":"Age","ActivityDefinition.timingDateTime":"dateTime","ActivityDefinition.timingDuration":"Duration","ActivityDefinition.timingPeriod":"Period","ActivityDefinition.timingRange":"Range","ActivityDefinition.timingTiming":"Timing","ActivityDefinition.title":"string","ActivityDefinition.topic":"CodeableConcept","ActivityDefinition.transform":"canonical","ActivityDefinition.url":"uri","ActivityDefinition.usage":"string","ActivityDefinition.useContext":"UsageContext","ActivityDefinition.version":"string","Address.city":"string","Address.country":"string","Address.district":"string","Address.extension":"Extension","Address.id":"System.String","Address.line":"string","Address.period":"Period","Address.postalCode":"string","Address.state":"string","Address.text":"string","Address.type":"code","Address.use":"code","AdverseEvent.actuality":"code","AdverseEvent.category":"CodeableConcept","AdverseEvent.contained":"Resource","AdverseEvent.contributor":"Reference","AdverseEvent.date":"dateTime","AdverseEvent.detected":"dateTime","AdverseEvent.encounter":"Reference","AdverseEvent.event":"CodeableConcept","AdverseEvent.extension":"Extension","AdverseEvent.id":"System.String","AdverseEvent.identifier":"Identifier","AdverseEvent.implicitRules":"uri","AdverseEvent.language":"code","AdverseEvent.location":"Reference","AdverseEvent.meta":"Meta","AdverseEvent.modifierExtension":"Extension","AdverseEvent.outcome":"CodeableConcept","AdverseEvent.recordedDate":"dateTime","AdverseEvent.recorder":"Reference","AdverseEvent.referenceDocument":"Reference","AdverseEvent.resultingCondition":"Reference","AdverseEvent.seriousness":"CodeableConcept","AdverseEvent.severity":"CodeableConcept","AdverseEvent.study":"Reference","AdverseEvent.subject":"Reference","AdverseEvent.subjectMedicalHistory":"Reference","AdverseEvent.suspectEntity.causality.assessment":"CodeableConcept","AdverseEvent.suspectEntity.causality.author":"Reference","AdverseEvent.suspectEntity.causality.extension":"Extension","AdverseEvent.suspectEntity.causality.id":"System.String","AdverseEvent.suspectEntity.causality.method":"CodeableConcept","AdverseEvent.suspectEntity.causality.modifierExtension":"Extension","AdverseEvent.suspectEntity.causality.productRelatedness":"string","AdverseEvent.suspectEntity.extension":"Extension","AdverseEvent.suspectEntity.id":"System.String","AdverseEvent.suspectEntity.instance":"Reference","AdverseEvent.suspectEntity.modifierExtension":"Extension","AdverseEvent.text":"Narrative","Age.code":"code","Age.comparator":"code","Age.extension":"Extension","Age.id":"System.String","Age.system":"uri","Age.unit":"string","Age.value":"decimal","AllergyIntolerance.asserter":"Reference","AllergyIntolerance.category":"code","AllergyIntolerance.clinicalStatus":"CodeableConcept","AllergyIntolerance.code":"CodeableConcept","AllergyIntolerance.contained":"Resource","AllergyIntolerance.criticality":"code","AllergyIntolerance.encounter":"Reference","AllergyIntolerance.extension":"Extension","AllergyIntolerance.id":"System.String","AllergyIntolerance.identifier":"Identifier","AllergyIntolerance.implicitRules":"uri","AllergyIntolerance.language":"code","AllergyIntolerance.lastOccurrence":"dateTime","AllergyIntolerance.meta":"Meta","AllergyIntolerance.modifierExtension":"Extension","AllergyIntolerance.note":"Annotation","AllergyIntolerance.onsetAge":"Age","AllergyIntolerance.onsetDateTime":"dateTime","AllergyIntolerance.onsetPeriod":"Period","AllergyIntolerance.onsetRange":"Range","AllergyIntolerance.onsetString":"string","AllergyIntolerance.patient":"Reference","AllergyIntolerance.reaction.description":"string","AllergyIntolerance.reaction.exposureRoute":"CodeableConcept","AllergyIntolerance.reaction.extension":"Extension","AllergyIntolerance.reaction.id":"System.String","AllergyIntolerance.reaction.manifestation":"CodeableConcept","AllergyIntolerance.reaction.modifierExtension":"Extension","AllergyIntolerance.reaction.note":"Annotation","AllergyIntolerance.reaction.onset":"dateTime","AllergyIntolerance.reaction.severity":"code","AllergyIntolerance.reaction.substance":"CodeableConcept","AllergyIntolerance.recordedDate":"dateTime","AllergyIntolerance.recorder":"Reference","AllergyIntolerance.text":"Narrative","AllergyIntolerance.type":"code","AllergyIntolerance.verificationStatus":"CodeableConcept","Annotation.authorReference":"Reference","Annotation.authorString":"string","Annotation.extension":"Extension","Annotation.id":"System.String","Annotation.text":"markdown","Annotation.time":"dateTime","Appointment.appointmentType":"CodeableConcept","Appointment.basedOn":"Reference","Appointment.cancelationReason":"CodeableConcept","Appointment.comment":"string","Appointment.contained":"Resource","Appointment.created":"dateTime","Appointment.description":"string","Appointment.end":"instant","Appointment.extension":"Extension","Appointment.id":"System.String","Appointment.identifier":"Identifier","Appointment.implicitRules":"uri","Appointment.language":"code","Appointment.meta":"Meta","Appointment.minutesDuration":"positiveInt","Appointment.modifierExtension":"Extension","Appointment.participant.actor":"Reference","Appointment.participant.extension":"Extension","Appointment.participant.id":"System.String","Appointment.participant.modifierExtension":"Extension","Appointment.participant.period":"Period","Appointment.participant.required":"code","Appointment.participant.status":"code","Appointment.participant.type":"CodeableConcept","Appointment.patientInstruction":"string","Appointment.priority":"unsignedInt","Appointment.reasonCode":"CodeableConcept","Appointment.reasonReference":"Reference","Appointment.requestedPeriod":"Period","Appointment.serviceCategory":"CodeableConcept","Appointment.serviceType":"CodeableConcept","Appointment.slot":"Reference","Appointment.specialty":"CodeableConcept","Appointment.start":"instant","Appointment.status":"code","Appointment.supportingInformation":"Reference","Appointment.text":"Narrative","AppointmentResponse.actor":"Reference","AppointmentResponse.appointment":"Reference","AppointmentResponse.comment":"string","AppointmentResponse.contained":"Resource","AppointmentResponse.end":"instant","AppointmentResponse.extension":"Extension","AppointmentResponse.id":"System.String","AppointmentResponse.identifier":"Identifier","AppointmentResponse.implicitRules":"uri","AppointmentResponse.language":"code","AppointmentResponse.meta":"Meta","AppointmentResponse.modifierExtension":"Extension","AppointmentResponse.participantStatus":"code","AppointmentResponse.participantType":"CodeableConcept","AppointmentResponse.start":"instant","AppointmentResponse.text":"Narrative","Attachment.contentType":"code","Attachment.creation":"dateTime","Attachment.data":"base64Binary","Attachment.extension":"Extension","Attachment.hash":"base64Binary","Attachment.id":"System.String","Attachment.language":"code","Attachment.size":"unsignedInt","Attachment.title":"string","Attachment.url":"url","AuditEvent.action":"code","AuditEvent.agent.altId":"string","AuditEvent.agent.extension":"Extension","AuditEvent.agent.id":"System.String","AuditEvent.agent.location":"Reference","AuditEvent.agent.media":"Coding","AuditEvent.agent.modifierExtension":"Extension","AuditEvent.agent.name":"string","AuditEvent.agent.network.address":"string","AuditEvent.agent.network.extension":"Extension","AuditEvent.agent.network.id":"System.String","AuditEvent.agent.network.modifierExtension":"Extension","AuditEvent.agent.network.type":"code","AuditEvent.agent.policy":"uri","AuditEvent.agent.purposeOfUse":"CodeableConcept","AuditEvent.agent.requestor":"boolean","AuditEvent.agent.role":"CodeableConcept","AuditEvent.agent.type":"CodeableConcept","AuditEvent.agent.who":"Reference","AuditEvent.contained":"Resource","AuditEvent.entity.description":"string","AuditEvent.entity.detail.extension":"Extension","AuditEvent.entity.detail.id":"System.String","AuditEvent.entity.detail.modifierExtension":"Extension","AuditEvent.entity.detail.type":"string","AuditEvent.entity.detail.valueBase64Binary":"base64Binary","AuditEvent.entity.detail.valueString":"string","AuditEvent.entity.extension":"Extension","AuditEvent.entity.id":"System.String","AuditEvent.entity.lifecycle":"Coding","AuditEvent.entity.modifierExtension":"Extension","AuditEvent.entity.name":"string","AuditEvent.entity.query":"base64Binary","AuditEvent.entity.role":"Coding","AuditEvent.entity.securityLabel":"Coding","AuditEvent.entity.type":"Coding","AuditEvent.entity.what":"Reference","AuditEvent.extension":"Extension","AuditEvent.id":"System.String","AuditEvent.implicitRules":"uri","AuditEvent.language":"code","AuditEvent.meta":"Meta","AuditEvent.modifierExtension":"Extension","AuditEvent.outcome":"code","AuditEvent.outcomeDesc":"string","AuditEvent.period":"Period","AuditEvent.purposeOfEvent":"CodeableConcept","AuditEvent.recorded":"instant","AuditEvent.source.extension":"Extension","AuditEvent.source.id":"System.String","AuditEvent.source.modifierExtension":"Extension","AuditEvent.source.observer":"Reference","AuditEvent.source.site":"string","AuditEvent.source.type":"Coding","AuditEvent.subtype":"Coding","AuditEvent.text":"Narrative","AuditEvent.type":"Coding","BackboneElement.extension":"Extension","BackboneElement.id":"System.String","BackboneElement.modifierExtension":"Extension","Basic.author":"Reference","Basic.code":"CodeableConcept","Basic.contained":"Resource","Basic.created":"date","Basic.extension":"Extension","Basic.id":"System.String","Basic.identifier":"Identifier","Basic.implicitRules":"uri","Basic.language":"code","Basic.meta":"Meta","Basic.modifierExtension":"Extension","Basic.subject":"Reference","Basic.text":"Narrative","Binary.contentType":"code","Binary.data":"base64Binary","Binary.id":"System.String","Binary.implicitRules":"uri","Binary.language":"code","Binary.meta":"Meta","Binary.securityContext":"Reference","BiologicallyDerivedProduct.collection.collectedDateTime":"dateTime","BiologicallyDerivedProduct.collection.collectedPeriod":"Period","BiologicallyDerivedProduct.collection.collector":"Reference","BiologicallyDerivedProduct.collection.extension":"Extension","BiologicallyDerivedProduct.collection.id":"System.String","BiologicallyDerivedProduct.collection.modifierExtension":"Extension","BiologicallyDerivedProduct.collection.source":"Reference","BiologicallyDerivedProduct.contained":"Resource","BiologicallyDerivedProduct.extension":"Extension","BiologicallyDerivedProduct.id":"System.String","BiologicallyDerivedProduct.identifier":"Identifier","BiologicallyDerivedProduct.implicitRules":"uri","BiologicallyDerivedProduct.language":"code","BiologicallyDerivedProduct.manipulation.description":"string","BiologicallyDerivedProduct.manipulation.extension":"Extension","BiologicallyDerivedProduct.manipulation.id":"System.String","BiologicallyDerivedProduct.manipulation.modifierExtension":"Extension","BiologicallyDerivedProduct.manipulation.timeDateTime":"dateTime","BiologicallyDerivedProduct.manipulation.timePeriod":"Period","BiologicallyDerivedProduct.meta":"Meta","BiologicallyDerivedProduct.modifierExtension":"Extension","BiologicallyDerivedProduct.parent":"Reference","BiologicallyDerivedProduct.processing.additive":"Reference","BiologicallyDerivedProduct.processing.description":"string","BiologicallyDerivedProduct.processing.extension":"Extension","BiologicallyDerivedProduct.processing.id":"System.String","BiologicallyDerivedProduct.processing.modifierExtension":"Extension","BiologicallyDerivedProduct.processing.procedure":"CodeableConcept","BiologicallyDerivedProduct.processing.timeDateTime":"dateTime","BiologicallyDerivedProduct.processing.timePeriod":"Period","BiologicallyDerivedProduct.productCategory":"code","BiologicallyDerivedProduct.productCode":"CodeableConcept","BiologicallyDerivedProduct.quantity":"integer","BiologicallyDerivedProduct.request":"Reference","BiologicallyDerivedProduct.status":"code","BiologicallyDerivedProduct.storage.description":"string","BiologicallyDerivedProduct.storage.duration":"Period","BiologicallyDerivedProduct.storage.extension":"Extension","BiologicallyDerivedProduct.storage.id":"System.String","BiologicallyDerivedProduct.storage.modifierExtension":"Extension","BiologicallyDerivedProduct.storage.scale":"code","BiologicallyDerivedProduct.storage.temperature":"decimal","BiologicallyDerivedProduct.text":"Narrative","BodyStructure.active":"boolean","BodyStructure.contained":"Resource","BodyStructure.description":"string","BodyStructure.extension":"Extension","BodyStructure.id":"System.String","BodyStructure.identifier":"Identifier","BodyStructure.image":"Attachment","BodyStructure.implicitRules":"uri","BodyStructure.language":"code","BodyStructure.location":"CodeableConcept","BodyStructure.locationQualifier":"CodeableConcept","BodyStructure.meta":"Meta","BodyStructure.modifierExtension":"Extension","BodyStructure.morphology":"CodeableConcept","BodyStructure.patient":"Reference","BodyStructure.text":"Narrative","Bundle.entry.extension":"Extension","Bundle.entry.fullUrl":"uri","Bundle.entry.id":"System.String","Bundle.entry.modifierExtension":"Extension","Bundle.entry.request.extension":"Extension","Bundle.entry.request.id":"System.String","Bundle.entry.request.ifMatch":"string","Bundle.entry.request.ifModifiedSince":"instant","Bundle.entry.request.ifNoneExist":"string","Bundle.entry.request.ifNoneMatch":"string","Bundle.entry.request.method":"code","Bundle.entry.request.modifierExtension":"Extension","Bundle.entry.request.url":"uri","Bundle.entry.resource":"Resource","Bundle.entry.response.etag":"string","Bundle.entry.response.extension":"Extension","Bundle.entry.response.id":"System.String","Bundle.entry.response.lastModified":"instant","Bundle.entry.response.location":"uri","Bundle.entry.response.modifierExtension":"Extension","Bundle.entry.response.outcome":"Resource","Bundle.entry.response.status":"string","Bundle.entry.search.extension":"Extension","Bundle.entry.search.id":"System.String","Bundle.entry.search.mode":"code","Bundle.entry.search.modifierExtension":"Extension","Bundle.entry.search.score":"decimal","Bundle.id":"System.String","Bundle.identifier":"Identifier","Bundle.implicitRules":"uri","Bundle.language":"code","Bundle.link.extension":"Extension","Bundle.link.id":"System.String","Bundle.link.modifierExtension":"Extension","Bundle.link.relation":"string","Bundle.link.url":"uri","Bundle.meta":"Meta","Bundle.signature":"Signature","Bundle.timestamp":"instant","Bundle.total":"unsignedInt","Bundle.type":"code","CapabilityStatement.contact":"ContactDetail","CapabilityStatement.contained":"Resource","CapabilityStatement.copyright":"markdown","CapabilityStatement.date":"dateTime","CapabilityStatement.description":"markdown","CapabilityStatement.document.documentation":"markdown","CapabilityStatement.document.extension":"Extension","CapabilityStatement.document.id":"System.String","CapabilityStatement.document.mode":"code","CapabilityStatement.document.modifierExtension":"Extension","CapabilityStatement.document.profile":"canonical","CapabilityStatement.experimental":"boolean","CapabilityStatement.extension":"Extension","CapabilityStatement.fhirVersion":"code","CapabilityStatement.format":"code","CapabilityStatement.id":"System.String","CapabilityStatement.implementation.custodian":"Reference","CapabilityStatement.implementation.description":"string","CapabilityStatement.implementation.extension":"Extension","CapabilityStatement.implementation.id":"System.String","CapabilityStatement.implementation.modifierExtension":"Extension","CapabilityStatement.implementation.url":"url","CapabilityStatement.implementationGuide":"canonical","CapabilityStatement.implicitRules":"uri","CapabilityStatement.imports":"canonical","CapabilityStatement.instantiates":"canonical","CapabilityStatement.jurisdiction":"CodeableConcept","CapabilityStatement.kind":"code","CapabilityStatement.language":"code","CapabilityStatement.messaging.documentation":"markdown","CapabilityStatement.messaging.endpoint.address":"url","CapabilityStatement.messaging.endpoint.extension":"Extension","CapabilityStatement.messaging.endpoint.id":"System.String","CapabilityStatement.messaging.endpoint.modifierExtension":"Extension","CapabilityStatement.messaging.endpoint.protocol":"Coding","CapabilityStatement.messaging.extension":"Extension","CapabilityStatement.messaging.id":"System.String","CapabilityStatement.messaging.modifierExtension":"Extension","CapabilityStatement.messaging.reliableCache":"unsignedInt","CapabilityStatement.messaging.supportedMessage.definition":"canonical","CapabilityStatement.messaging.supportedMessage.extension":"Extension","CapabilityStatement.messaging.supportedMessage.id":"System.String","CapabilityStatement.messaging.supportedMessage.mode":"code","CapabilityStatement.messaging.supportedMessage.modifierExtension":"Extension","CapabilityStatement.meta":"Meta","CapabilityStatement.modifierExtension":"Extension","CapabilityStatement.name":"string","CapabilityStatement.patchFormat":"code","CapabilityStatement.publisher":"string","CapabilityStatement.purpose":"markdown","CapabilityStatement.rest.compartment":"canonical","CapabilityStatement.rest.documentation":"markdown","CapabilityStatement.rest.extension":"Extension","CapabilityStatement.rest.id":"System.String","CapabilityStatement.rest.interaction.code":"code","CapabilityStatement.rest.interaction.documentation":"markdown","CapabilityStatement.rest.interaction.extension":"Extension","CapabilityStatement.rest.interaction.id":"System.String","CapabilityStatement.rest.interaction.modifierExtension":"Extension","CapabilityStatement.rest.mode":"code","CapabilityStatement.rest.modifierExtension":"Extension","CapabilityStatement.rest.resource.conditionalCreate":"boolean","CapabilityStatement.rest.resource.conditionalDelete":"code","CapabilityStatement.rest.resource.conditionalRead":"code","CapabilityStatement.rest.resource.conditionalUpdate":"boolean","CapabilityStatement.rest.resource.documentation":"markdown","CapabilityStatement.rest.resource.extension":"Extension","CapabilityStatement.rest.resource.id":"System.String","CapabilityStatement.rest.resource.interaction.code":"code","CapabilityStatement.rest.resource.interaction.documentation":"markdown","CapabilityStatement.rest.resource.interaction.extension":"Extension","CapabilityStatement.rest.resource.interaction.id":"System.String","CapabilityStatement.rest.resource.interaction.modifierExtension":"Extension","CapabilityStatement.rest.resource.modifierExtension":"Extension","CapabilityStatement.rest.resource.operation.definition":"canonical","CapabilityStatement.rest.resource.operation.documentation":"markdown","CapabilityStatement.rest.resource.operation.extension":"Extension","CapabilityStatement.rest.resource.operation.id":"System.String","CapabilityStatement.rest.resource.operation.modifierExtension":"Extension","CapabilityStatement.rest.resource.operation.name":"string","CapabilityStatement.rest.resource.profile":"canonical","CapabilityStatement.rest.resource.readHistory":"boolean","CapabilityStatement.rest.resource.referencePolicy":"code","CapabilityStatement.rest.resource.searchInclude":"string","CapabilityStatement.rest.resource.searchParam.definition":"canonical","CapabilityStatement.rest.resource.searchParam.documentation":"markdown","CapabilityStatement.rest.resource.searchParam.extension":"Extension","CapabilityStatement.rest.resource.searchParam.id":"System.String","CapabilityStatement.rest.resource.searchParam.modifierExtension":"Extension","CapabilityStatement.rest.resource.searchParam.name":"string","CapabilityStatement.rest.resource.searchParam.type":"code","CapabilityStatement.rest.resource.searchRevInclude":"string","CapabilityStatement.rest.resource.supportedProfile":"canonical","CapabilityStatement.rest.resource.type":"code","CapabilityStatement.rest.resource.updateCreate":"boolean","CapabilityStatement.rest.resource.versioning":"code","CapabilityStatement.rest.security.cors":"boolean","CapabilityStatement.rest.security.description":"markdown","CapabilityStatement.rest.security.extension":"Extension","CapabilityStatement.rest.security.id":"System.String","CapabilityStatement.rest.security.modifierExtension":"Extension","CapabilityStatement.rest.security.service":"CodeableConcept","CapabilityStatement.software.extension":"Extension","CapabilityStatement.software.id":"System.String","CapabilityStatement.software.modifierExtension":"Extension","CapabilityStatement.software.name":"string","CapabilityStatement.software.releaseDate":"dateTime","CapabilityStatement.software.version":"string","CapabilityStatement.status":"code","CapabilityStatement.text":"Narrative","CapabilityStatement.title":"string","CapabilityStatement.url":"uri","CapabilityStatement.useContext":"UsageContext","CapabilityStatement.version":"string","CarePlan.activity.detail.code":"CodeableConcept","CarePlan.activity.detail.dailyAmount":"Quantity","CarePlan.activity.detail.description":"string","CarePlan.activity.detail.doNotPerform":"boolean","CarePlan.activity.detail.extension":"Extension","CarePlan.activity.detail.goal":"Reference","CarePlan.activity.detail.id":"System.String","CarePlan.activity.detail.instantiatesCanonical":"canonical","CarePlan.activity.detail.instantiatesUri":"uri","CarePlan.activity.detail.kind":"code","CarePlan.activity.detail.location":"Reference","CarePlan.activity.detail.modifierExtension":"Extension","CarePlan.activity.detail.performer":"Reference","CarePlan.activity.detail.productCodeableConcept":"CodeableConcept","CarePlan.activity.detail.productReference":"Reference","CarePlan.activity.detail.quantity":"Quantity","CarePlan.activity.detail.reasonCode":"CodeableConcept","CarePlan.activity.detail.reasonReference":"Reference","CarePlan.activity.detail.scheduledPeriod":"Period","CarePlan.activity.detail.scheduledString":"string","CarePlan.activity.detail.scheduledTiming":"Timing","CarePlan.activity.detail.status":"code","CarePlan.activity.detail.statusReason":"CodeableConcept","CarePlan.activity.extension":"Extension","CarePlan.activity.id":"System.String","CarePlan.activity.modifierExtension":"Extension","CarePlan.activity.outcomeCodeableConcept":"CodeableConcept","CarePlan.activity.outcomeReference":"Reference","CarePlan.activity.progress":"Annotation","CarePlan.activity.reference":"Reference","CarePlan.addresses":"Reference","CarePlan.author":"Reference","CarePlan.basedOn":"Reference","CarePlan.careTeam":"Reference","CarePlan.category":"CodeableConcept","CarePlan.contained":"Resource","CarePlan.contributor":"Reference","CarePlan.created":"dateTime","CarePlan.description":"string","CarePlan.encounter":"Reference","CarePlan.extension":"Extension","CarePlan.goal":"Reference","CarePlan.id":"System.String","CarePlan.identifier":"Identifier","CarePlan.implicitRules":"uri","CarePlan.instantiatesCanonical":"canonical","CarePlan.instantiatesUri":"uri","CarePlan.intent":"code","CarePlan.language":"code","CarePlan.meta":"Meta","CarePlan.modifierExtension":"Extension","CarePlan.note":"Annotation","CarePlan.partOf":"Reference","CarePlan.period":"Period","CarePlan.replaces":"Reference","CarePlan.status":"code","CarePlan.subject":"Reference","CarePlan.supportingInfo":"Reference","CarePlan.text":"Narrative","CarePlan.title":"string","CareTeam.category":"CodeableConcept","CareTeam.contained":"Resource","CareTeam.encounter":"Reference","CareTeam.extension":"Extension","CareTeam.id":"System.String","CareTeam.identifier":"Identifier","CareTeam.implicitRules":"uri","CareTeam.language":"code","CareTeam.managingOrganization":"Reference","CareTeam.meta":"Meta","CareTeam.modifierExtension":"Extension","CareTeam.name":"string","CareTeam.note":"Annotation","CareTeam.participant.extension":"Extension","CareTeam.participant.id":"System.String","CareTeam.participant.member":"Reference","CareTeam.participant.modifierExtension":"Extension","CareTeam.participant.onBehalfOf":"Reference","CareTeam.participant.period":"Period","CareTeam.participant.role":"CodeableConcept","CareTeam.period":"Period","CareTeam.reasonCode":"CodeableConcept","CareTeam.reasonReference":"Reference","CareTeam.status":"code","CareTeam.subject":"Reference","CareTeam.telecom":"ContactPoint","CareTeam.text":"Narrative","CatalogEntry.additionalCharacteristic":"CodeableConcept","CatalogEntry.additionalClassification":"CodeableConcept","CatalogEntry.additionalIdentifier":"Identifier","CatalogEntry.classification":"CodeableConcept","CatalogEntry.contained":"Resource","CatalogEntry.extension":"Extension","CatalogEntry.id":"System.String","CatalogEntry.identifier":"Identifier","CatalogEntry.implicitRules":"uri","CatalogEntry.language":"code","CatalogEntry.lastUpdated":"dateTime","CatalogEntry.meta":"Meta","CatalogEntry.modifierExtension":"Extension","CatalogEntry.orderable":"boolean","CatalogEntry.referencedItem":"Reference","CatalogEntry.relatedEntry.extension":"Extension","CatalogEntry.relatedEntry.id":"System.String","CatalogEntry.relatedEntry.item":"Reference","CatalogEntry.relatedEntry.modifierExtension":"Extension","CatalogEntry.relatedEntry.relationtype":"code","CatalogEntry.status":"code","CatalogEntry.text":"Narrative","CatalogEntry.type":"CodeableConcept","CatalogEntry.validTo":"dateTime","CatalogEntry.validityPeriod":"Period","ChargeItem.account":"Reference","ChargeItem.bodysite":"CodeableConcept","ChargeItem.code":"CodeableConcept","ChargeItem.contained":"Resource","ChargeItem.context":"Reference","ChargeItem.costCenter":"Reference","ChargeItem.definitionCanonical":"canonical","ChargeItem.definitionUri":"uri","ChargeItem.enteredDate":"dateTime","ChargeItem.enterer":"Reference","ChargeItem.extension":"Extension","ChargeItem.factorOverride":"decimal","ChargeItem.id":"System.String","ChargeItem.identifier":"Identifier","ChargeItem.implicitRules":"uri","ChargeItem.language":"code","ChargeItem.meta":"Meta","ChargeItem.modifierExtension":"Extension","ChargeItem.note":"Annotation","ChargeItem.occurrenceDateTime":"dateTime","ChargeItem.occurrencePeriod":"Period","ChargeItem.occurrenceTiming":"Timing","ChargeItem.overrideReason":"string","ChargeItem.partOf":"Reference","ChargeItem.performer.actor":"Reference","ChargeItem.performer.extension":"Extension","ChargeItem.performer.function":"CodeableConcept","ChargeItem.performer.id":"System.String","ChargeItem.performer.modifierExtension":"Extension","ChargeItem.performingOrganization":"Reference","ChargeItem.priceOverride":"Money","ChargeItem.productCodeableConcept":"CodeableConcept","ChargeItem.productReference":"Reference","ChargeItem.quantity":"Quantity","ChargeItem.reason":"CodeableConcept","ChargeItem.requestingOrganization":"Reference","ChargeItem.service":"Reference","ChargeItem.status":"code","ChargeItem.subject":"Reference","ChargeItem.supportingInformation":"Reference","ChargeItem.text":"Narrative","ChargeItemDefinition.applicability.description":"string","ChargeItemDefinition.applicability.expression":"string","ChargeItemDefinition.applicability.extension":"Extension","ChargeItemDefinition.applicability.id":"System.String","ChargeItemDefinition.applicability.language":"string","ChargeItemDefinition.applicability.modifierExtension":"Extension","ChargeItemDefinition.approvalDate":"date","ChargeItemDefinition.code":"CodeableConcept","ChargeItemDefinition.contact":"ContactDetail","ChargeItemDefinition.contained":"Resource","ChargeItemDefinition.copyright":"markdown","ChargeItemDefinition.date":"dateTime","ChargeItemDefinition.derivedFromUri":"uri","ChargeItemDefinition.description":"markdown","ChargeItemDefinition.effectivePeriod":"Period","ChargeItemDefinition.experimental":"boolean","ChargeItemDefinition.extension":"Extension","ChargeItemDefinition.id":"System.String","ChargeItemDefinition.identifier":"Identifier","ChargeItemDefinition.implicitRules":"uri","ChargeItemDefinition.instance":"Reference","ChargeItemDefinition.jurisdiction":"CodeableConcept","ChargeItemDefinition.language":"code","ChargeItemDefinition.lastReviewDate":"date","ChargeItemDefinition.meta":"Meta","ChargeItemDefinition.modifierExtension":"Extension","ChargeItemDefinition.partOf":"canonical","ChargeItemDefinition.propertyGroup.extension":"Extension","ChargeItemDefinition.propertyGroup.id":"System.String","ChargeItemDefinition.propertyGroup.modifierExtension":"Extension","ChargeItemDefinition.propertyGroup.priceComponent.amount":"Money","ChargeItemDefinition.propertyGroup.priceComponent.code":"CodeableConcept","ChargeItemDefinition.propertyGroup.priceComponent.extension":"Extension","ChargeItemDefinition.propertyGroup.priceComponent.factor":"decimal","ChargeItemDefinition.propertyGroup.priceComponent.id":"System.String","ChargeItemDefinition.propertyGroup.priceComponent.modifierExtension":"Extension","ChargeItemDefinition.propertyGroup.priceComponent.type":"code","ChargeItemDefinition.publisher":"string","ChargeItemDefinition.replaces":"canonical","ChargeItemDefinition.status":"code","ChargeItemDefinition.text":"Narrative","ChargeItemDefinition.title":"string","ChargeItemDefinition.url":"uri","ChargeItemDefinition.useContext":"UsageContext","ChargeItemDefinition.version":"string","Claim.accident.date":"date","Claim.accident.extension":"Extension","Claim.accident.id":"System.String","Claim.accident.locationAddress":"Address","Claim.accident.locationReference":"Reference","Claim.accident.modifierExtension":"Extension","Claim.accident.type":"CodeableConcept","Claim.billablePeriod":"Period","Claim.careTeam.extension":"Extension","Claim.careTeam.id":"System.String","Claim.careTeam.modifierExtension":"Extension","Claim.careTeam.provider":"Reference","Claim.careTeam.qualification":"CodeableConcept","Claim.careTeam.responsible":"boolean","Claim.careTeam.role":"CodeableConcept","Claim.careTeam.sequence":"positiveInt","Claim.contained":"Resource","Claim.created":"dateTime","Claim.diagnosis.diagnosisCodeableConcept":"CodeableConcept","Claim.diagnosis.diagnosisReference":"Reference","Claim.diagnosis.extension":"Extension","Claim.diagnosis.id":"System.String","Claim.diagnosis.modifierExtension":"Extension","Claim.diagnosis.onAdmission":"CodeableConcept","Claim.diagnosis.packageCode":"CodeableConcept","Claim.diagnosis.sequence":"positiveInt","Claim.diagnosis.type":"CodeableConcept","Claim.enterer":"Reference","Claim.extension":"Extension","Claim.facility":"Reference","Claim.fundsReserve":"CodeableConcept","Claim.id":"System.String","Claim.identifier":"Identifier","Claim.implicitRules":"uri","Claim.insurance.businessArrangement":"string","Claim.insurance.claimResponse":"Reference","Claim.insurance.coverage":"Reference","Claim.insurance.extension":"Extension","Claim.insurance.focal":"boolean","Claim.insurance.id":"System.String","Claim.insurance.identifier":"Identifier","Claim.insurance.modifierExtension":"Extension","Claim.insurance.preAuthRef":"string","Claim.insurance.sequence":"positiveInt","Claim.insurer":"Reference","Claim.item.bodySite":"CodeableConcept","Claim.item.careTeamSequence":"positiveInt","Claim.item.category":"CodeableConcept","Claim.item.detail.category":"CodeableConcept","Claim.item.detail.extension":"Extension","Claim.item.detail.factor":"decimal","Claim.item.detail.id":"System.String","Claim.item.detail.modifier":"CodeableConcept","Claim.item.detail.modifierExtension":"Extension","Claim.item.detail.net":"Money","Claim.item.detail.productOrService":"CodeableConcept","Claim.item.detail.programCode":"CodeableConcept","Claim.item.detail.quantity":"Quantity","Claim.item.detail.revenue":"CodeableConcept","Claim.item.detail.sequence":"positiveInt","Claim.item.detail.subDetail.category":"CodeableConcept","Claim.item.detail.subDetail.extension":"Extension","Claim.item.detail.subDetail.factor":"decimal","Claim.item.detail.subDetail.id":"System.String","Claim.item.detail.subDetail.modifier":"CodeableConcept","Claim.item.detail.subDetail.modifierExtension":"Extension","Claim.item.detail.subDetail.net":"Money","Claim.item.detail.subDetail.productOrService":"CodeableConcept","Claim.item.detail.subDetail.programCode":"CodeableConcept","Claim.item.detail.subDetail.quantity":"Quantity","Claim.item.detail.subDetail.revenue":"CodeableConcept","Claim.item.detail.subDetail.sequence":"positiveInt","Claim.item.detail.subDetail.udi":"Reference","Claim.item.detail.subDetail.unitPrice":"Money","Claim.item.detail.udi":"Reference","Claim.item.detail.unitPrice":"Money","Claim.item.diagnosisSequence":"positiveInt","Claim.item.encounter":"Reference","Claim.item.extension":"Extension","Claim.item.factor":"decimal","Claim.item.id":"System.String","Claim.item.informationSequence":"positiveInt","Claim.item.locationAddress":"Address","Claim.item.locationCodeableConcept":"CodeableConcept","Claim.item.locationReference":"Reference","Claim.item.modifier":"CodeableConcept","Claim.item.modifierExtension":"Extension","Claim.item.net":"Money","Claim.item.procedureSequence":"positiveInt","Claim.item.productOrService":"CodeableConcept","Claim.item.programCode":"CodeableConcept","Claim.item.quantity":"Quantity","Claim.item.revenue":"CodeableConcept","Claim.item.sequence":"positiveInt","Claim.item.servicedDate":"date","Claim.item.servicedPeriod":"Period","Claim.item.subSite":"CodeableConcept","Claim.item.udi":"Reference","Claim.item.unitPrice":"Money","Claim.language":"code","Claim.meta":"Meta","Claim.modifierExtension":"Extension","Claim.originalPrescription":"Reference","Claim.patient":"Reference","Claim.payee.extension":"Extension","Claim.payee.id":"System.String","Claim.payee.modifierExtension":"Extension","Claim.payee.party":"Reference","Claim.payee.type":"CodeableConcept","Claim.prescription":"Reference","Claim.priority":"CodeableConcept","Claim.procedure.date":"dateTime","Claim.procedure.extension":"Extension","Claim.procedure.id":"System.String","Claim.procedure.modifierExtension":"Extension","Claim.procedure.procedureCodeableConcept":"CodeableConcept","Claim.procedure.procedureReference":"Reference","Claim.procedure.sequence":"positiveInt","Claim.procedure.type":"CodeableConcept","Claim.procedure.udi":"Reference","Claim.provider":"Reference","Claim.referral":"Reference","Claim.related.claim":"Reference","Claim.related.extension":"Extension","Claim.related.id":"System.String","Claim.related.modifierExtension":"Extension","Claim.related.reference":"Identifier","Claim.related.relationship":"CodeableConcept","Claim.status":"code","Claim.subType":"CodeableConcept","Claim.supportingInfo.category":"CodeableConcept","Claim.supportingInfo.code":"CodeableConcept","Claim.supportingInfo.extension":"Extension","Claim.supportingInfo.id":"System.String","Claim.supportingInfo.modifierExtension":"Extension","Claim.supportingInfo.reason":"CodeableConcept","Claim.supportingInfo.sequence":"positiveInt","Claim.supportingInfo.timingDate":"date","Claim.supportingInfo.timingPeriod":"Period","Claim.supportingInfo.valueAttachment":"Attachment","Claim.supportingInfo.valueBoolean":"boolean","Claim.supportingInfo.valueQuantity":"Quantity","Claim.supportingInfo.valueReference":"Reference","Claim.supportingInfo.valueString":"string","Claim.text":"Narrative","Claim.total":"Money","Claim.type":"CodeableConcept","Claim.use":"code","ClaimResponse.addItem.bodySite":"CodeableConcept","ClaimResponse.addItem.detail.extension":"Extension","ClaimResponse.addItem.detail.factor":"decimal","ClaimResponse.addItem.detail.id":"System.String","ClaimResponse.addItem.detail.modifier":"CodeableConcept","ClaimResponse.addItem.detail.modifierExtension":"Extension","ClaimResponse.addItem.detail.net":"Money","ClaimResponse.addItem.detail.noteNumber":"positiveInt","ClaimResponse.addItem.detail.productOrService":"CodeableConcept","ClaimResponse.addItem.detail.quantity":"Quantity","ClaimResponse.addItem.detail.subDetail.extension":"Extension","ClaimResponse.addItem.detail.subDetail.factor":"decimal","ClaimResponse.addItem.detail.subDetail.id":"System.String","ClaimResponse.addItem.detail.subDetail.modifier":"CodeableConcept","ClaimResponse.addItem.detail.subDetail.modifierExtension":"Extension","ClaimResponse.addItem.detail.subDetail.net":"Money","ClaimResponse.addItem.detail.subDetail.noteNumber":"positiveInt","ClaimResponse.addItem.detail.subDetail.productOrService":"CodeableConcept","ClaimResponse.addItem.detail.subDetail.quantity":"Quantity","ClaimResponse.addItem.detail.subDetail.unitPrice":"Money","ClaimResponse.addItem.detail.unitPrice":"Money","ClaimResponse.addItem.detailSequence":"positiveInt","ClaimResponse.addItem.extension":"Extension","ClaimResponse.addItem.factor":"decimal","ClaimResponse.addItem.id":"System.String","ClaimResponse.addItem.itemSequence":"positiveInt","ClaimResponse.addItem.locationAddress":"Address","ClaimResponse.addItem.locationCodeableConcept":"CodeableConcept","ClaimResponse.addItem.locationReference":"Reference","ClaimResponse.addItem.modifier":"CodeableConcept","ClaimResponse.addItem.modifierExtension":"Extension","ClaimResponse.addItem.net":"Money","ClaimResponse.addItem.noteNumber":"positiveInt","ClaimResponse.addItem.productOrService":"CodeableConcept","ClaimResponse.addItem.programCode":"CodeableConcept","ClaimResponse.addItem.provider":"Reference","ClaimResponse.addItem.quantity":"Quantity","ClaimResponse.addItem.servicedDate":"date","ClaimResponse.addItem.servicedPeriod":"Period","ClaimResponse.addItem.subSite":"CodeableConcept","ClaimResponse.addItem.subdetailSequence":"positiveInt","ClaimResponse.addItem.unitPrice":"Money","ClaimResponse.communicationRequest":"Reference","ClaimResponse.contained":"Resource","ClaimResponse.created":"dateTime","ClaimResponse.disposition":"string","ClaimResponse.error.code":"CodeableConcept","ClaimResponse.error.detailSequence":"positiveInt","ClaimResponse.error.extension":"Extension","ClaimResponse.error.id":"System.String","ClaimResponse.error.itemSequence":"positiveInt","ClaimResponse.error.modifierExtension":"Extension","ClaimResponse.error.subDetailSequence":"positiveInt","ClaimResponse.extension":"Extension","ClaimResponse.form":"Attachment","ClaimResponse.formCode":"CodeableConcept","ClaimResponse.fundsReserve":"CodeableConcept","ClaimResponse.id":"System.String","ClaimResponse.identifier":"Identifier","ClaimResponse.implicitRules":"uri","ClaimResponse.insurance.businessArrangement":"string","ClaimResponse.insurance.claimResponse":"Reference","ClaimResponse.insurance.coverage":"Reference","ClaimResponse.insurance.extension":"Extension","ClaimResponse.insurance.focal":"boolean","ClaimResponse.insurance.id":"System.String","ClaimResponse.insurance.modifierExtension":"Extension","ClaimResponse.insurance.sequence":"positiveInt","ClaimResponse.insurer":"Reference","ClaimResponse.item.adjudication.amount":"Money","ClaimResponse.item.adjudication.category":"CodeableConcept","ClaimResponse.item.adjudication.extension":"Extension","ClaimResponse.item.adjudication.id":"System.String","ClaimResponse.item.adjudication.modifierExtension":"Extension","ClaimResponse.item.adjudication.reason":"CodeableConcept","ClaimResponse.item.adjudication.value":"decimal","ClaimResponse.item.detail.detailSequence":"positiveInt","ClaimResponse.item.detail.extension":"Extension","ClaimResponse.item.detail.id":"System.String","ClaimResponse.item.detail.modifierExtension":"Extension","ClaimResponse.item.detail.noteNumber":"positiveInt","ClaimResponse.item.detail.subDetail.extension":"Extension","ClaimResponse.item.detail.subDetail.id":"System.String","ClaimResponse.item.detail.subDetail.modifierExtension":"Extension","ClaimResponse.item.detail.subDetail.noteNumber":"positiveInt","ClaimResponse.item.detail.subDetail.subDetailSequence":"positiveInt","ClaimResponse.item.extension":"Extension","ClaimResponse.item.id":"System.String","ClaimResponse.item.itemSequence":"positiveInt","ClaimResponse.item.modifierExtension":"Extension","ClaimResponse.item.noteNumber":"positiveInt","ClaimResponse.language":"code","ClaimResponse.meta":"Meta","ClaimResponse.modifierExtension":"Extension","ClaimResponse.outcome":"code","ClaimResponse.patient":"Reference","ClaimResponse.payeeType":"CodeableConcept","ClaimResponse.payment.adjustment":"Money","ClaimResponse.payment.adjustmentReason":"CodeableConcept","ClaimResponse.payment.amount":"Money","ClaimResponse.payment.date":"date","ClaimResponse.payment.extension":"Extension","ClaimResponse.payment.id":"System.String","ClaimResponse.payment.identifier":"Identifier","ClaimResponse.payment.modifierExtension":"Extension","ClaimResponse.payment.type":"CodeableConcept","ClaimResponse.preAuthPeriod":"Period","ClaimResponse.preAuthRef":"string","ClaimResponse.processNote.extension":"Extension","ClaimResponse.processNote.id":"System.String","ClaimResponse.processNote.language":"CodeableConcept","ClaimResponse.processNote.modifierExtension":"Extension","ClaimResponse.processNote.number":"positiveInt","ClaimResponse.processNote.text":"string","ClaimResponse.processNote.type":"code","ClaimResponse.request":"Reference","ClaimResponse.requestor":"Reference","ClaimResponse.status":"code","ClaimResponse.subType":"CodeableConcept","ClaimResponse.text":"Narrative","ClaimResponse.total.amount":"Money","ClaimResponse.total.category":"CodeableConcept","ClaimResponse.total.extension":"Extension","ClaimResponse.total.id":"System.String","ClaimResponse.total.modifierExtension":"Extension","ClaimResponse.type":"CodeableConcept","ClaimResponse.use":"code","ClinicalImpression.assessor":"Reference","ClinicalImpression.code":"CodeableConcept","ClinicalImpression.contained":"Resource","ClinicalImpression.date":"dateTime","ClinicalImpression.description":"string","ClinicalImpression.effectiveDateTime":"dateTime","ClinicalImpression.effectivePeriod":"Period","ClinicalImpression.encounter":"Reference","ClinicalImpression.extension":"Extension","ClinicalImpression.finding.basis":"string","ClinicalImpression.finding.extension":"Extension","ClinicalImpression.finding.id":"System.String","ClinicalImpression.finding.itemCodeableConcept":"CodeableConcept","ClinicalImpression.finding.itemReference":"Reference","ClinicalImpression.finding.modifierExtension":"Extension","ClinicalImpression.id":"System.String","ClinicalImpression.identifier":"Identifier","ClinicalImpression.implicitRules":"uri","ClinicalImpression.investigation.code":"CodeableConcept","ClinicalImpression.investigation.extension":"Extension","ClinicalImpression.investigation.id":"System.String","ClinicalImpression.investigation.item":"Reference","ClinicalImpression.investigation.modifierExtension":"Extension","ClinicalImpression.language":"code","ClinicalImpression.meta":"Meta","ClinicalImpression.modifierExtension":"Extension","ClinicalImpression.note":"Annotation","ClinicalImpression.previous":"Reference","ClinicalImpression.problem":"Reference","ClinicalImpression.prognosisCodeableConcept":"CodeableConcept","ClinicalImpression.prognosisReference":"Reference","ClinicalImpression.protocol":"uri","ClinicalImpression.status":"code","ClinicalImpression.statusReason":"CodeableConcept","ClinicalImpression.subject":"Reference","ClinicalImpression.summary":"string","ClinicalImpression.supportingInfo":"Reference","ClinicalImpression.text":"Narrative","CodeSystem.caseSensitive":"boolean","CodeSystem.compositional":"boolean","CodeSystem.concept.code":"code","CodeSystem.concept.definition":"string","CodeSystem.concept.designation.extension":"Extension","CodeSystem.concept.designation.id":"System.String","CodeSystem.concept.designation.language":"code","CodeSystem.concept.designation.modifierExtension":"Extension","CodeSystem.concept.designation.use":"Coding","CodeSystem.concept.designation.value":"string","CodeSystem.concept.display":"string","CodeSystem.concept.extension":"Extension","CodeSystem.concept.id":"System.String","CodeSystem.concept.modifierExtension":"Extension","CodeSystem.concept.property.code":"code","CodeSystem.concept.property.extension":"Extension","CodeSystem.concept.property.id":"System.String","CodeSystem.concept.property.modifierExtension":"Extension","CodeSystem.concept.property.valueBoolean":"boolean","CodeSystem.concept.property.valueCode":"code","CodeSystem.concept.property.valueCoding":"Coding","CodeSystem.concept.property.valueDateTime":"dateTime","CodeSystem.concept.property.valueDecimal":"decimal","CodeSystem.concept.property.valueInteger":"integer","CodeSystem.concept.property.valueString":"string","CodeSystem.contact":"ContactDetail","CodeSystem.contained":"Resource","CodeSystem.content":"code","CodeSystem.copyright":"markdown","CodeSystem.count":"unsignedInt","CodeSystem.date":"dateTime","CodeSystem.description":"markdown","CodeSystem.experimental":"boolean","CodeSystem.extension":"Extension","CodeSystem.filter.code":"code","CodeSystem.filter.description":"string","CodeSystem.filter.extension":"Extension","CodeSystem.filter.id":"System.String","CodeSystem.filter.modifierExtension":"Extension","CodeSystem.filter.operator":"code","CodeSystem.filter.value":"string","CodeSystem.hierarchyMeaning":"code","CodeSystem.id":"System.String","CodeSystem.identifier":"Identifier","CodeSystem.implicitRules":"uri","CodeSystem.jurisdiction":"CodeableConcept","CodeSystem.language":"code","CodeSystem.meta":"Meta","CodeSystem.modifierExtension":"Extension","CodeSystem.name":"string","CodeSystem.property.code":"code","CodeSystem.property.description":"string","CodeSystem.property.extension":"Extension","CodeSystem.property.id":"System.String","CodeSystem.property.modifierExtension":"Extension","CodeSystem.property.type":"code","CodeSystem.property.uri":"uri","CodeSystem.publisher":"string","CodeSystem.purpose":"markdown","CodeSystem.status":"code","CodeSystem.supplements":"canonical","CodeSystem.text":"Narrative","CodeSystem.title":"string","CodeSystem.url":"uri","CodeSystem.useContext":"UsageContext","CodeSystem.valueSet":"canonical","CodeSystem.version":"string","CodeSystem.versionNeeded":"boolean","CodeableConcept.coding":"Coding","CodeableConcept.extension":"Extension","CodeableConcept.id":"System.String","CodeableConcept.text":"string","Coding.code":"code","Coding.display":"string","Coding.extension":"Extension","Coding.id":"System.String","Coding.system":"uri","Coding.userSelected":"boolean","Coding.version":"string","Communication.about":"Reference","Communication.basedOn":"Reference","Communication.category":"CodeableConcept","Communication.contained":"Resource","Communication.encounter":"Reference","Communication.extension":"Extension","Communication.id":"System.String","Communication.identifier":"Identifier","Communication.implicitRules":"uri","Communication.inResponseTo":"Reference","Communication.instantiatesCanonical":"canonical","Communication.instantiatesUri":"uri","Communication.language":"code","Communication.medium":"CodeableConcept","Communication.meta":"Meta","Communication.modifierExtension":"Extension","Communication.note":"Annotation","Communication.partOf":"Reference","Communication.payload.contentAttachment":"Attachment","Communication.payload.contentReference":"Reference","Communication.payload.contentString":"string","Communication.payload.extension":"Extension","Communication.payload.id":"System.String","Communication.payload.modifierExtension":"Extension","Communication.priority":"code","Communication.reasonCode":"CodeableConcept","Communication.reasonReference":"Reference","Communication.received":"dateTime","Communication.recipient":"Reference","Communication.sender":"Reference","Communication.sent":"dateTime","Communication.status":"code","Communication.statusReason":"CodeableConcept","Communication.subject":"Reference","Communication.text":"Narrative","Communication.topic":"CodeableConcept","CommunicationRequest.about":"Reference","CommunicationRequest.authoredOn":"dateTime","CommunicationRequest.basedOn":"Reference","CommunicationRequest.category":"CodeableConcept","CommunicationRequest.contained":"Resource","CommunicationRequest.doNotPerform":"boolean","CommunicationRequest.encounter":"Reference","CommunicationRequest.extension":"Extension","CommunicationRequest.groupIdentifier":"Identifier","CommunicationRequest.id":"System.String","CommunicationRequest.identifier":"Identifier","CommunicationRequest.implicitRules":"uri","CommunicationRequest.language":"code","CommunicationRequest.medium":"CodeableConcept","CommunicationRequest.meta":"Meta","CommunicationRequest.modifierExtension":"Extension","CommunicationRequest.note":"Annotation","CommunicationRequest.occurrenceDateTime":"dateTime","CommunicationRequest.occurrencePeriod":"Period","CommunicationRequest.payload.contentAttachment":"Attachment","CommunicationRequest.payload.contentReference":"Reference","CommunicationRequest.payload.contentString":"string","CommunicationRequest.payload.extension":"Extension","CommunicationRequest.payload.id":"System.String","CommunicationRequest.payload.modifierExtension":"Extension","CommunicationRequest.priority":"code","CommunicationRequest.reasonCode":"CodeableConcept","CommunicationRequest.reasonReference":"Reference","CommunicationRequest.recipient":"Reference","CommunicationRequest.replaces":"Reference","CommunicationRequest.requester":"Reference","CommunicationRequest.sender":"Reference","CommunicationRequest.status":"code","CommunicationRequest.statusReason":"CodeableConcept","CommunicationRequest.subject":"Reference","CommunicationRequest.text":"Narrative","CompartmentDefinition.code":"code","CompartmentDefinition.contact":"ContactDetail","CompartmentDefinition.contained":"Resource","CompartmentDefinition.date":"dateTime","CompartmentDefinition.description":"markdown","CompartmentDefinition.experimental":"boolean","CompartmentDefinition.extension":"Extension","CompartmentDefinition.id":"System.String","CompartmentDefinition.implicitRules":"uri","CompartmentDefinition.language":"code","CompartmentDefinition.meta":"Meta","CompartmentDefinition.modifierExtension":"Extension","CompartmentDefinition.name":"string","CompartmentDefinition.publisher":"string","CompartmentDefinition.purpose":"markdown","CompartmentDefinition.resource.code":"code","CompartmentDefinition.resource.documentation":"string","CompartmentDefinition.resource.extension":"Extension","CompartmentDefinition.resource.id":"System.String","CompartmentDefinition.resource.modifierExtension":"Extension","CompartmentDefinition.resource.param":"string","CompartmentDefinition.search":"boolean","CompartmentDefinition.status":"code","CompartmentDefinition.text":"Narrative","CompartmentDefinition.url":"uri","CompartmentDefinition.useContext":"UsageContext","CompartmentDefinition.version":"string","Composition.attester.extension":"Extension","Composition.attester.id":"System.String","Composition.attester.mode":"code","Composition.attester.modifierExtension":"Extension","Composition.attester.party":"Reference","Composition.attester.time":"dateTime","Composition.author":"Reference","Composition.category":"CodeableConcept","Composition.confidentiality":"code","Composition.contained":"Resource","Composition.custodian":"Reference","Composition.date":"dateTime","Composition.encounter":"Reference","Composition.event.code":"CodeableConcept","Composition.event.detail":"Reference","Composition.event.extension":"Extension","Composition.event.id":"System.String","Composition.event.modifierExtension":"Extension","Composition.event.period":"Period","Composition.extension":"Extension","Composition.id":"System.String","Composition.identifier":"Identifier","Composition.implicitRules":"uri","Composition.language":"code","Composition.meta":"Meta","Composition.modifierExtension":"Extension","Composition.relatesTo.code":"code","Composition.relatesTo.extension":"Extension","Composition.relatesTo.id":"System.String","Composition.relatesTo.modifierExtension":"Extension","Composition.relatesTo.targetIdentifier":"Identifier","Composition.relatesTo.targetReference":"Reference","Composition.section.author":"Reference","Composition.section.code":"CodeableConcept","Composition.section.emptyReason":"CodeableConcept","Composition.section.entry":"Reference","Composition.section.extension":"Extension","Composition.section.focus":"Reference","Composition.section.id":"System.String","Composition.section.mode":"code","Composition.section.modifierExtension":"Extension","Composition.section.orderedBy":"CodeableConcept","Composition.section.text":"Narrative","Composition.section.title":"string","Composition.status":"code","Composition.subject":"Reference","Composition.text":"Narrative","Composition.title":"string","Composition.type":"CodeableConcept","ConceptMap.contact":"ContactDetail","ConceptMap.contained":"Resource","ConceptMap.copyright":"markdown","ConceptMap.date":"dateTime","ConceptMap.description":"markdown","ConceptMap.experimental":"boolean","ConceptMap.extension":"Extension","ConceptMap.group.element.code":"code","ConceptMap.group.element.display":"string","ConceptMap.group.element.extension":"Extension","ConceptMap.group.element.id":"System.String","ConceptMap.group.element.modifierExtension":"Extension","ConceptMap.group.element.target.code":"code","ConceptMap.group.element.target.comment":"string","ConceptMap.group.element.target.dependsOn.display":"string","ConceptMap.group.element.target.dependsOn.extension":"Extension","ConceptMap.group.element.target.dependsOn.id":"System.String","ConceptMap.group.element.target.dependsOn.modifierExtension":"Extension","ConceptMap.group.element.target.dependsOn.property":"uri","ConceptMap.group.element.target.dependsOn.system":"canonical","ConceptMap.group.element.target.dependsOn.value":"string","ConceptMap.group.element.target.display":"string","ConceptMap.group.element.target.equivalence":"code","ConceptMap.group.element.target.extension":"Extension","ConceptMap.group.element.target.id":"System.String","ConceptMap.group.element.target.modifierExtension":"Extension","ConceptMap.group.extension":"Extension","ConceptMap.group.id":"System.String","ConceptMap.group.modifierExtension":"Extension","ConceptMap.group.source":"uri","ConceptMap.group.sourceVersion":"string","ConceptMap.group.target":"uri","ConceptMap.group.targetVersion":"string","ConceptMap.group.unmapped.code":"code","ConceptMap.group.unmapped.display":"string","ConceptMap.group.unmapped.extension":"Extension","ConceptMap.group.unmapped.id":"System.String","ConceptMap.group.unmapped.mode":"code","ConceptMap.group.unmapped.modifierExtension":"Extension","ConceptMap.group.unmapped.url":"canonical","ConceptMap.id":"System.String","ConceptMap.identifier":"Identifier","ConceptMap.implicitRules":"uri","ConceptMap.jurisdiction":"CodeableConcept","ConceptMap.language":"code","ConceptMap.meta":"Meta","ConceptMap.modifierExtension":"Extension","ConceptMap.name":"string","ConceptMap.publisher":"string","ConceptMap.purpose":"markdown","ConceptMap.sourceCanonical":"canonical","ConceptMap.sourceUri":"uri","ConceptMap.status":"code","ConceptMap.targetCanonical":"canonical","ConceptMap.targetUri":"uri","ConceptMap.text":"Narrative","ConceptMap.title":"string","ConceptMap.url":"uri","ConceptMap.useContext":"UsageContext","ConceptMap.version":"string","Condition.abatementAge":"Age","Condition.abatementDateTime":"dateTime","Condition.abatementPeriod":"Period","Condition.abatementRange":"Range","Condition.abatementString":"string","Condition.asserter":"Reference","Condition.bodySite":"CodeableConcept","Condition.category":"CodeableConcept","Condition.clinicalStatus":"CodeableConcept","Condition.code":"CodeableConcept","Condition.contained":"Resource","Condition.encounter":"Reference","Condition.evidence.code":"CodeableConcept","Condition.evidence.detail":"Reference","Condition.evidence.extension":"Extension","Condition.evidence.id":"System.String","Condition.evidence.modifierExtension":"Extension","Condition.extension":"Extension","Condition.id":"System.String","Condition.identifier":"Identifier","Condition.implicitRules":"uri","Condition.language":"code","Condition.meta":"Meta","Condition.modifierExtension":"Extension","Condition.note":"Annotation","Condition.onsetAge":"Age","Condition.onsetDateTime":"dateTime","Condition.onsetPeriod":"Period","Condition.onsetRange":"Range","Condition.onsetString":"string","Condition.recordedDate":"dateTime","Condition.recorder":"Reference","Condition.severity":"CodeableConcept","Condition.stage.assessment":"Reference","Condition.stage.extension":"Extension","Condition.stage.id":"System.String","Condition.stage.modifierExtension":"Extension","Condition.stage.summary":"CodeableConcept","Condition.stage.type":"CodeableConcept","Condition.subject":"Reference","Condition.text":"Narrative","Condition.verificationStatus":"CodeableConcept","Consent.category":"CodeableConcept","Consent.contained":"Resource","Consent.dateTime":"dateTime","Consent.extension":"Extension","Consent.id":"System.String","Consent.identifier":"Identifier","Consent.implicitRules":"uri","Consent.language":"code","Consent.meta":"Meta","Consent.modifierExtension":"Extension","Consent.organization":"Reference","Consent.patient":"Reference","Consent.performer":"Reference","Consent.policy.authority":"uri","Consent.policy.extension":"Extension","Consent.policy.id":"System.String","Consent.policy.modifierExtension":"Extension","Consent.policy.uri":"uri","Consent.policyRule":"CodeableConcept","Consent.provision.action":"CodeableConcept","Consent.provision.actor.extension":"Extension","Consent.provision.actor.id":"System.String","Consent.provision.actor.modifierExtension":"Extension","Consent.provision.actor.reference":"Reference","Consent.provision.actor.role":"CodeableConcept","Consent.provision.class":"Coding","Consent.provision.code":"CodeableConcept","Consent.provision.data.extension":"Extension","Consent.provision.data.id":"System.String","Consent.provision.data.meaning":"code","Consent.provision.data.modifierExtension":"Extension","Consent.provision.data.reference":"Reference","Consent.provision.dataPeriod":"Period","Consent.provision.extension":"Extension","Consent.provision.id":"System.String","Consent.provision.modifierExtension":"Extension","Consent.provision.period":"Period","Consent.provision.purpose":"Coding","Consent.provision.securityLabel":"Coding","Consent.provision.type":"code","Consent.scope":"CodeableConcept","Consent.sourceAttachment":"Attachment","Consent.sourceReference":"Reference","Consent.status":"code","Consent.text":"Narrative","Consent.verification.extension":"Extension","Consent.verification.id":"System.String","Consent.verification.modifierExtension":"Extension","Consent.verification.verificationDate":"dateTime","Consent.verification.verified":"boolean","Consent.verification.verifiedWith":"Reference","ContactDetail.extension":"Extension","ContactDetail.id":"System.String","ContactDetail.name":"string","ContactDetail.telecom":"ContactPoint","ContactPoint.extension":"Extension","ContactPoint.id":"System.String","ContactPoint.period":"Period","ContactPoint.rank":"positiveInt","ContactPoint.system":"code","ContactPoint.use":"code","ContactPoint.value":"string","Contract.alias":"string","Contract.applies":"Period","Contract.author":"Reference","Contract.authority":"Reference","Contract.contained":"Resource","Contract.contentDefinition.copyright":"markdown","Contract.contentDefinition.extension":"Extension","Contract.contentDefinition.id":"System.String","Contract.contentDefinition.modifierExtension":"Extension","Contract.contentDefinition.publicationDate":"dateTime","Contract.contentDefinition.publicationStatus":"code","Contract.contentDefinition.publisher":"Reference","Contract.contentDefinition.subType":"CodeableConcept","Contract.contentDefinition.type":"CodeableConcept","Contract.contentDerivative":"CodeableConcept","Contract.domain":"Reference","Contract.expirationType":"CodeableConcept","Contract.extension":"Extension","Contract.friendly.contentAttachment":"Attachment","Contract.friendly.contentReference":"Reference","Contract.friendly.extension":"Extension","Contract.friendly.id":"System.String","Contract.friendly.modifierExtension":"Extension","Contract.id":"System.String","Contract.identifier":"Identifier","Contract.implicitRules":"uri","Contract.instantiatesCanonical":"Reference","Contract.instantiatesUri":"uri","Contract.issued":"dateTime","Contract.language":"code","Contract.legal.contentAttachment":"Attachment","Contract.legal.contentReference":"Reference","Contract.legal.extension":"Extension","Contract.legal.id":"System.String","Contract.legal.modifierExtension":"Extension","Contract.legalState":"CodeableConcept","Contract.legallyBindingAttachment":"Attachment","Contract.legallyBindingReference":"Reference","Contract.meta":"Meta","Contract.modifierExtension":"Extension","Contract.name":"string","Contract.relevantHistory":"Reference","Contract.rule.contentAttachment":"Attachment","Contract.rule.contentReference":"Reference","Contract.rule.extension":"Extension","Contract.rule.id":"System.String","Contract.rule.modifierExtension":"Extension","Contract.scope":"CodeableConcept","Contract.signer.extension":"Extension","Contract.signer.id":"System.String","Contract.signer.modifierExtension":"Extension","Contract.signer.party":"Reference","Contract.signer.signature":"Signature","Contract.signer.type":"Coding","Contract.site":"Reference","Contract.status":"code","Contract.subType":"CodeableConcept","Contract.subject":"Reference","Contract.subtitle":"string","Contract.supportingInfo":"Reference","Contract.term.action.context":"Reference","Contract.term.action.contextLinkId":"string","Contract.term.action.doNotPerform":"boolean","Contract.term.action.extension":"Extension","Contract.term.action.id":"System.String","Contract.term.action.intent":"CodeableConcept","Contract.term.action.linkId":"string","Contract.term.action.modifierExtension":"Extension","Contract.term.action.note":"Annotation","Contract.term.action.occurrenceDateTime":"dateTime","Contract.term.action.occurrencePeriod":"Period","Contract.term.action.occurrenceTiming":"Timing","Contract.term.action.performer":"Reference","Contract.term.action.performerLinkId":"string","Contract.term.action.performerRole":"CodeableConcept","Contract.term.action.performerType":"CodeableConcept","Contract.term.action.reason":"string","Contract.term.action.reasonCode":"CodeableConcept","Contract.term.action.reasonLinkId":"string","Contract.term.action.reasonReference":"Reference","Contract.term.action.requester":"Reference","Contract.term.action.requesterLinkId":"string","Contract.term.action.securityLabelNumber":"unsignedInt","Contract.term.action.status":"CodeableConcept","Contract.term.action.subject.extension":"Extension","Contract.term.action.subject.id":"System.String","Contract.term.action.subject.modifierExtension":"Extension","Contract.term.action.subject.reference":"Reference","Contract.term.action.subject.role":"CodeableConcept","Contract.term.action.type":"CodeableConcept","Contract.term.applies":"Period","Contract.term.asset.condition":"string","Contract.term.asset.context.code":"CodeableConcept","Contract.term.asset.context.extension":"Extension","Contract.term.asset.context.id":"System.String","Contract.term.asset.context.modifierExtension":"Extension","Contract.term.asset.context.reference":"Reference","Contract.term.asset.context.text":"string","Contract.term.asset.extension":"Extension","Contract.term.asset.id":"System.String","Contract.term.asset.linkId":"string","Contract.term.asset.modifierExtension":"Extension","Contract.term.asset.period":"Period","Contract.term.asset.periodType":"CodeableConcept","Contract.term.asset.relationship":"Coding","Contract.term.asset.scope":"CodeableConcept","Contract.term.asset.securityLabelNumber":"unsignedInt","Contract.term.asset.subtype":"CodeableConcept","Contract.term.asset.text":"string","Contract.term.asset.type":"CodeableConcept","Contract.term.asset.typeReference":"Reference","Contract.term.asset.usePeriod":"Period","Contract.term.asset.valuedItem.effectiveTime":"dateTime","Contract.term.asset.valuedItem.entityCodeableConcept":"CodeableConcept","Contract.term.asset.valuedItem.entityReference":"Reference","Contract.term.asset.valuedItem.extension":"Extension","Contract.term.asset.valuedItem.factor":"decimal","Contract.term.asset.valuedItem.id":"System.String","Contract.term.asset.valuedItem.identifier":"Identifier","Contract.term.asset.valuedItem.linkId":"string","Contract.term.asset.valuedItem.modifierExtension":"Extension","Contract.term.asset.valuedItem.net":"Money","Contract.term.asset.valuedItem.payment":"string","Contract.term.asset.valuedItem.paymentDate":"dateTime","Contract.term.asset.valuedItem.points":"decimal","Contract.term.asset.valuedItem.quantity":"Quantity","Contract.term.asset.valuedItem.recipient":"Reference","Contract.term.asset.valuedItem.responsible":"Reference","Contract.term.asset.valuedItem.securityLabelNumber":"unsignedInt","Contract.term.asset.valuedItem.unitPrice":"Money","Contract.term.extension":"Extension","Contract.term.id":"System.String","Contract.term.identifier":"Identifier","Contract.term.issued":"dateTime","Contract.term.modifierExtension":"Extension","Contract.term.offer.answer.extension":"Extension","Contract.term.offer.answer.id":"System.String","Contract.term.offer.answer.modifierExtension":"Extension","Contract.term.offer.answer.valueAttachment":"Attachment","Contract.term.offer.answer.valueBoolean":"boolean","Contract.term.offer.answer.valueCoding":"Coding","Contract.term.offer.answer.valueDate":"date","Contract.term.offer.answer.valueDateTime":"dateTime","Contract.term.offer.answer.valueDecimal":"decimal","Contract.term.offer.answer.valueInteger":"integer","Contract.term.offer.answer.valueQuantity":"Quantity","Contract.term.offer.answer.valueReference":"Reference","Contract.term.offer.answer.valueString":"string","Contract.term.offer.answer.valueTime":"time","Contract.term.offer.answer.valueUri":"uri","Contract.term.offer.decision":"CodeableConcept","Contract.term.offer.decisionMode":"CodeableConcept","Contract.term.offer.extension":"Extension","Contract.term.offer.id":"System.String","Contract.term.offer.identifier":"Identifier","Contract.term.offer.linkId":"string","Contract.term.offer.modifierExtension":"Extension","Contract.term.offer.party.extension":"Extension","Contract.term.offer.party.id":"System.String","Contract.term.offer.party.modifierExtension":"Extension","Contract.term.offer.party.reference":"Reference","Contract.term.offer.party.role":"CodeableConcept","Contract.term.offer.securityLabelNumber":"unsignedInt","Contract.term.offer.text":"string","Contract.term.offer.topic":"Reference","Contract.term.offer.type":"CodeableConcept","Contract.term.securityLabel.category":"Coding","Contract.term.securityLabel.classification":"Coding","Contract.term.securityLabel.control":"Coding","Contract.term.securityLabel.extension":"Extension","Contract.term.securityLabel.id":"System.String","Contract.term.securityLabel.modifierExtension":"Extension","Contract.term.securityLabel.number":"unsignedInt","Contract.term.subType":"CodeableConcept","Contract.term.text":"string","Contract.term.topicCodeableConcept":"CodeableConcept","Contract.term.topicReference":"Reference","Contract.term.type":"CodeableConcept","Contract.text":"Narrative","Contract.title":"string","Contract.topicCodeableConcept":"CodeableConcept","Contract.topicReference":"Reference","Contract.type":"CodeableConcept","Contract.url":"uri","Contract.version":"string","Contributor.contact":"ContactDetail","Contributor.extension":"Extension","Contributor.id":"System.String","Contributor.name":"string","Contributor.type":"code","Count.code":"code","Count.comparator":"code","Count.extension":"Extension","Count.id":"System.String","Count.system":"uri","Count.unit":"string","Count.value":"decimal","Coverage.beneficiary":"Reference","Coverage.class.extension":"Extension","Coverage.class.id":"System.String","Coverage.class.modifierExtension":"Extension","Coverage.class.name":"string","Coverage.class.type":"CodeableConcept","Coverage.class.value":"string","Coverage.contained":"Resource","Coverage.contract":"Reference","Coverage.costToBeneficiary.exception.extension":"Extension","Coverage.costToBeneficiary.exception.id":"System.String","Coverage.costToBeneficiary.exception.modifierExtension":"Extension","Coverage.costToBeneficiary.exception.period":"Period","Coverage.costToBeneficiary.exception.type":"CodeableConcept","Coverage.costToBeneficiary.extension":"Extension","Coverage.costToBeneficiary.id":"System.String","Coverage.costToBeneficiary.modifierExtension":"Extension","Coverage.costToBeneficiary.type":"CodeableConcept","Coverage.costToBeneficiary.valueMoney":"Money","Coverage.costToBeneficiary.valueQuantity":"Quantity","Coverage.dependent":"string","Coverage.extension":"Extension","Coverage.id":"System.String","Coverage.identifier":"Identifier","Coverage.implicitRules":"uri","Coverage.language":"code","Coverage.meta":"Meta","Coverage.modifierExtension":"Extension","Coverage.network":"string","Coverage.order":"positiveInt","Coverage.payor":"Reference","Coverage.period":"Period","Coverage.policyHolder":"Reference","Coverage.relationship":"CodeableConcept","Coverage.status":"code","Coverage.subrogation":"boolean","Coverage.subscriber":"Reference","Coverage.subscriberId":"string","Coverage.text":"Narrative","Coverage.type":"CodeableConcept","CoverageEligibilityRequest.contained":"Resource","CoverageEligibilityRequest.created":"dateTime","CoverageEligibilityRequest.enterer":"Reference","CoverageEligibilityRequest.extension":"Extension","CoverageEligibilityRequest.facility":"Reference","CoverageEligibilityRequest.id":"System.String","CoverageEligibilityRequest.identifier":"Identifier","CoverageEligibilityRequest.implicitRules":"uri","CoverageEligibilityRequest.insurance.businessArrangement":"string","CoverageEligibilityRequest.insurance.coverage":"Reference","CoverageEligibilityRequest.insurance.extension":"Extension","CoverageEligibilityRequest.insurance.focal":"boolean","CoverageEligibilityRequest.insurance.id":"System.String","CoverageEligibilityRequest.insurance.modifierExtension":"Extension","CoverageEligibilityRequest.insurer":"Reference","CoverageEligibilityRequest.item.category":"CodeableConcept","CoverageEligibilityRequest.item.detail":"Reference","CoverageEligibilityRequest.item.diagnosis.diagnosisCodeableConcept":"CodeableConcept","CoverageEligibilityRequest.item.diagnosis.diagnosisReference":"Reference","CoverageEligibilityRequest.item.diagnosis.extension":"Extension","CoverageEligibilityRequest.item.diagnosis.id":"System.String","CoverageEligibilityRequest.item.diagnosis.modifierExtension":"Extension","CoverageEligibilityRequest.item.extension":"Extension","CoverageEligibilityRequest.item.facility":"Reference","CoverageEligibilityRequest.item.id":"System.String","CoverageEligibilityRequest.item.modifier":"CodeableConcept","CoverageEligibilityRequest.item.modifierExtension":"Extension","CoverageEligibilityRequest.item.productOrService":"CodeableConcept","CoverageEligibilityRequest.item.provider":"Reference","CoverageEligibilityRequest.item.quantity":"Quantity","CoverageEligibilityRequest.item.supportingInfoSequence":"positiveInt","CoverageEligibilityRequest.item.unitPrice":"Money","CoverageEligibilityRequest.language":"code","CoverageEligibilityRequest.meta":"Meta","CoverageEligibilityRequest.modifierExtension":"Extension","CoverageEligibilityRequest.patient":"Reference","CoverageEligibilityRequest.priority":"CodeableConcept","CoverageEligibilityRequest.provider":"Reference","CoverageEligibilityRequest.purpose":"code","CoverageEligibilityRequest.servicedDate":"date","CoverageEligibilityRequest.servicedPeriod":"Period","CoverageEligibilityRequest.status":"code","CoverageEligibilityRequest.supportingInfo.appliesToAll":"boolean","CoverageEligibilityRequest.supportingInfo.extension":"Extension","CoverageEligibilityRequest.supportingInfo.id":"System.String","CoverageEligibilityRequest.supportingInfo.information":"Reference","CoverageEligibilityRequest.supportingInfo.modifierExtension":"Extension","CoverageEligibilityRequest.supportingInfo.sequence":"positiveInt","CoverageEligibilityRequest.text":"Narrative","CoverageEligibilityResponse.contained":"Resource","CoverageEligibilityResponse.created":"dateTime","CoverageEligibilityResponse.disposition":"string","CoverageEligibilityResponse.error.code":"CodeableConcept","CoverageEligibilityResponse.error.extension":"Extension","CoverageEligibilityResponse.error.id":"System.String","CoverageEligibilityResponse.error.modifierExtension":"Extension","CoverageEligibilityResponse.extension":"Extension","CoverageEligibilityResponse.form":"CodeableConcept","CoverageEligibilityResponse.id":"System.String","CoverageEligibilityResponse.identifier":"Identifier","CoverageEligibilityResponse.implicitRules":"uri","CoverageEligibilityResponse.insurance.benefitPeriod":"Period","CoverageEligibilityResponse.insurance.coverage":"Reference","CoverageEligibilityResponse.insurance.extension":"Extension","CoverageEligibilityResponse.insurance.id":"System.String","CoverageEligibilityResponse.insurance.inforce":"boolean","CoverageEligibilityResponse.insurance.item.authorizationRequired":"boolean","CoverageEligibilityResponse.insurance.item.authorizationSupporting":"CodeableConcept","CoverageEligibilityResponse.insurance.item.authorizationUrl":"uri","CoverageEligibilityResponse.insurance.item.benefit.allowedMoney":"Money","CoverageEligibilityResponse.insurance.item.benefit.allowedString":"string","CoverageEligibilityResponse.insurance.item.benefit.allowedUnsignedInt":"unsignedInt","CoverageEligibilityResponse.insurance.item.benefit.extension":"Extension","CoverageEligibilityResponse.insurance.item.benefit.id":"System.String","CoverageEligibilityResponse.insurance.item.benefit.modifierExtension":"Extension","CoverageEligibilityResponse.insurance.item.benefit.type":"CodeableConcept","CoverageEligibilityResponse.insurance.item.benefit.usedMoney":"Money","CoverageEligibilityResponse.insurance.item.benefit.usedString":"string","CoverageEligibilityResponse.insurance.item.benefit.usedUnsignedInt":"unsignedInt","CoverageEligibilityResponse.insurance.item.category":"CodeableConcept","CoverageEligibilityResponse.insurance.item.description":"string","CoverageEligibilityResponse.insurance.item.excluded":"boolean","CoverageEligibilityResponse.insurance.item.extension":"Extension","CoverageEligibilityResponse.insurance.item.id":"System.String","CoverageEligibilityResponse.insurance.item.modifier":"CodeableConcept","CoverageEligibilityResponse.insurance.item.modifierExtension":"Extension","CoverageEligibilityResponse.insurance.item.name":"string","CoverageEligibilityResponse.insurance.item.network":"CodeableConcept","CoverageEligibilityResponse.insurance.item.productOrService":"CodeableConcept","CoverageEligibilityResponse.insurance.item.provider":"Reference","CoverageEligibilityResponse.insurance.item.term":"CodeableConcept","CoverageEligibilityResponse.insurance.item.unit":"CodeableConcept","CoverageEligibilityResponse.insurance.modifierExtension":"Extension","CoverageEligibilityResponse.insurer":"Reference","CoverageEligibilityResponse.language":"code","CoverageEligibilityResponse.meta":"Meta","CoverageEligibilityResponse.modifierExtension":"Extension","CoverageEligibilityResponse.outcome":"code","CoverageEligibilityResponse.patient":"Reference","CoverageEligibilityResponse.preAuthRef":"string","CoverageEligibilityResponse.purpose":"code","CoverageEligibilityResponse.request":"Reference","CoverageEligibilityResponse.requestor":"Reference","CoverageEligibilityResponse.servicedDate":"date","CoverageEligibilityResponse.servicedPeriod":"Period","CoverageEligibilityResponse.status":"code","CoverageEligibilityResponse.text":"Narrative","DataRequirement.codeFilter.code":"Coding","DataRequirement.codeFilter.extension":"Extension","DataRequirement.codeFilter.id":"System.String","DataRequirement.codeFilter.path":"string","DataRequirement.codeFilter.searchParam":"string","DataRequirement.codeFilter.valueSet":"canonical","DataRequirement.dateFilter.extension":"Extension","DataRequirement.dateFilter.id":"System.String","DataRequirement.dateFilter.path":"string","DataRequirement.dateFilter.searchParam":"string","DataRequirement.dateFilter.valueDateTime":"dateTime","DataRequirement.dateFilter.valueDuration":"Duration","DataRequirement.dateFilter.valuePeriod":"Period","DataRequirement.extension":"Extension","DataRequirement.id":"System.String","DataRequirement.limit":"positiveInt","DataRequirement.mustSupport":"string","DataRequirement.profile":"canonical","DataRequirement.sort.direction":"code","DataRequirement.sort.extension":"Extension","DataRequirement.sort.id":"System.String","DataRequirement.sort.path":"string","DataRequirement.subjectCodeableConcept":"CodeableConcept","DataRequirement.subjectReference":"Reference","DataRequirement.type":"code","DetectedIssue.author":"Reference","DetectedIssue.code":"CodeableConcept","DetectedIssue.contained":"Resource","DetectedIssue.detail":"string","DetectedIssue.evidence.code":"CodeableConcept","DetectedIssue.evidence.detail":"Reference","DetectedIssue.evidence.extension":"Extension","DetectedIssue.evidence.id":"System.String","DetectedIssue.evidence.modifierExtension":"Extension","DetectedIssue.extension":"Extension","DetectedIssue.id":"System.String","DetectedIssue.identifiedDateTime":"dateTime","DetectedIssue.identifiedPeriod":"Period","DetectedIssue.identifier":"Identifier","DetectedIssue.implicated":"Reference","DetectedIssue.implicitRules":"uri","DetectedIssue.language":"code","DetectedIssue.meta":"Meta","DetectedIssue.mitigation.action":"CodeableConcept","DetectedIssue.mitigation.author":"Reference","DetectedIssue.mitigation.date":"dateTime","DetectedIssue.mitigation.extension":"Extension","DetectedIssue.mitigation.id":"System.String","DetectedIssue.mitigation.modifierExtension":"Extension","DetectedIssue.modifierExtension":"Extension","DetectedIssue.patient":"Reference","DetectedIssue.reference":"uri","DetectedIssue.severity":"code","DetectedIssue.status":"code","DetectedIssue.text":"Narrative","Device.contact":"ContactPoint","Device.contained":"Resource","Device.definition":"Reference","Device.deviceName.extension":"Extension","Device.deviceName.id":"System.String","Device.deviceName.modifierExtension":"Extension","Device.deviceName.name":"string","Device.deviceName.type":"code","Device.distinctIdentifier":"string","Device.expirationDate":"dateTime","Device.extension":"Extension","Device.id":"System.String","Device.identifier":"Identifier","Device.implicitRules":"uri","Device.language":"code","Device.location":"Reference","Device.lotNumber":"string","Device.manufactureDate":"dateTime","Device.manufacturer":"string","Device.meta":"Meta","Device.modelNumber":"string","Device.modifierExtension":"Extension","Device.note":"Annotation","Device.owner":"Reference","Device.parent":"Reference","Device.partNumber":"string","Device.patient":"Reference","Device.property.extension":"Extension","Device.property.id":"System.String","Device.property.modifierExtension":"Extension","Device.property.type":"CodeableConcept","Device.property.valueCode":"CodeableConcept","Device.property.valueQuantity":"Quantity","Device.safety":"CodeableConcept","Device.serialNumber":"string","Device.specialization.extension":"Extension","Device.specialization.id":"System.String","Device.specialization.modifierExtension":"Extension","Device.specialization.systemType":"CodeableConcept","Device.specialization.version":"string","Device.status":"code","Device.statusReason":"CodeableConcept","Device.text":"Narrative","Device.type":"CodeableConcept","Device.udiCarrier.carrierAIDC":"base64Binary","Device.udiCarrier.carrierHRF":"string","Device.udiCarrier.deviceIdentifier":"string","Device.udiCarrier.entryType":"code","Device.udiCarrier.extension":"Extension","Device.udiCarrier.id":"System.String","Device.udiCarrier.issuer":"uri","Device.udiCarrier.jurisdiction":"uri","Device.udiCarrier.modifierExtension":"Extension","Device.url":"uri","Device.version.component":"Identifier","Device.version.extension":"Extension","Device.version.id":"System.String","Device.version.modifierExtension":"Extension","Device.version.type":"CodeableConcept","Device.version.value":"string","DeviceDefinition.capability.description":"CodeableConcept","DeviceDefinition.capability.extension":"Extension","DeviceDefinition.capability.id":"System.String","DeviceDefinition.capability.modifierExtension":"Extension","DeviceDefinition.capability.type":"CodeableConcept","DeviceDefinition.contact":"ContactPoint","DeviceDefinition.contained":"Resource","DeviceDefinition.deviceName.extension":"Extension","DeviceDefinition.deviceName.id":"System.String","DeviceDefinition.deviceName.modifierExtension":"Extension","DeviceDefinition.deviceName.name":"string","DeviceDefinition.deviceName.type":"code","DeviceDefinition.extension":"Extension","DeviceDefinition.id":"System.String","DeviceDefinition.identifier":"Identifier","DeviceDefinition.implicitRules":"uri","DeviceDefinition.language":"code","DeviceDefinition.languageCode":"CodeableConcept","DeviceDefinition.manufacturerReference":"Reference","DeviceDefinition.manufacturerString":"string","DeviceDefinition.material.allergenicIndicator":"boolean","DeviceDefinition.material.alternate":"boolean","DeviceDefinition.material.extension":"Extension","DeviceDefinition.material.id":"System.String","DeviceDefinition.material.modifierExtension":"Extension","DeviceDefinition.material.substance":"CodeableConcept","DeviceDefinition.meta":"Meta","DeviceDefinition.modelNumber":"string","DeviceDefinition.modifierExtension":"Extension","DeviceDefinition.note":"Annotation","DeviceDefinition.onlineInformation":"uri","DeviceDefinition.owner":"Reference","DeviceDefinition.parentDevice":"Reference","DeviceDefinition.physicalCharacteristics":"ProdCharacteristic","DeviceDefinition.property.extension":"Extension","DeviceDefinition.property.id":"System.String","DeviceDefinition.property.modifierExtension":"Extension","DeviceDefinition.property.type":"CodeableConcept","DeviceDefinition.property.valueCode":"CodeableConcept","DeviceDefinition.property.valueQuantity":"Quantity","DeviceDefinition.quantity":"Quantity","DeviceDefinition.safety":"CodeableConcept","DeviceDefinition.shelfLifeStorage":"ProductShelfLife","DeviceDefinition.specialization.extension":"Extension","DeviceDefinition.specialization.id":"System.String","DeviceDefinition.specialization.modifierExtension":"Extension","DeviceDefinition.specialization.systemType":"string","DeviceDefinition.specialization.version":"string","DeviceDefinition.text":"Narrative","DeviceDefinition.type":"CodeableConcept","DeviceDefinition.udiDeviceIdentifier.deviceIdentifier":"string","DeviceDefinition.udiDeviceIdentifier.extension":"Extension","DeviceDefinition.udiDeviceIdentifier.id":"System.String","DeviceDefinition.udiDeviceIdentifier.issuer":"uri","DeviceDefinition.udiDeviceIdentifier.jurisdiction":"uri","DeviceDefinition.udiDeviceIdentifier.modifierExtension":"Extension","DeviceDefinition.url":"uri","DeviceDefinition.version":"string","DeviceMetric.calibration.extension":"Extension","DeviceMetric.calibration.id":"System.String","DeviceMetric.calibration.modifierExtension":"Extension","DeviceMetric.calibration.state":"code","DeviceMetric.calibration.time":"instant","DeviceMetric.calibration.type":"code","DeviceMetric.category":"code","DeviceMetric.color":"code","DeviceMetric.contained":"Resource","DeviceMetric.extension":"Extension","DeviceMetric.id":"System.String","DeviceMetric.identifier":"Identifier","DeviceMetric.implicitRules":"uri","DeviceMetric.language":"code","DeviceMetric.measurementPeriod":"Timing","DeviceMetric.meta":"Meta","DeviceMetric.modifierExtension":"Extension","DeviceMetric.operationalStatus":"code","DeviceMetric.parent":"Reference","DeviceMetric.source":"Reference","DeviceMetric.text":"Narrative","DeviceMetric.type":"CodeableConcept","DeviceMetric.unit":"CodeableConcept","DeviceRequest.authoredOn":"dateTime","DeviceRequest.basedOn":"Reference","DeviceRequest.codeCodeableConcept":"CodeableConcept","DeviceRequest.codeReference":"Reference","DeviceRequest.contained":"Resource","DeviceRequest.encounter":"Reference","DeviceRequest.extension":"Extension","DeviceRequest.groupIdentifier":"Identifier","DeviceRequest.id":"System.String","DeviceRequest.identifier":"Identifier","DeviceRequest.implicitRules":"uri","DeviceRequest.instantiatesCanonical":"canonical","DeviceRequest.instantiatesUri":"uri","DeviceRequest.insurance":"Reference","DeviceRequest.intent":"code","DeviceRequest.language":"code","DeviceRequest.meta":"Meta","DeviceRequest.modifierExtension":"Extension","DeviceRequest.note":"Annotation","DeviceRequest.occurrenceDateTime":"dateTime","DeviceRequest.occurrencePeriod":"Period","DeviceRequest.occurrenceTiming":"Timing","DeviceRequest.parameter.code":"CodeableConcept","DeviceRequest.parameter.extension":"Extension","DeviceRequest.parameter.id":"System.String","DeviceRequest.parameter.modifierExtension":"Extension","DeviceRequest.parameter.valueBoolean":"boolean","DeviceRequest.parameter.valueCodeableConcept":"CodeableConcept","DeviceRequest.parameter.valueQuantity":"Quantity","DeviceRequest.parameter.valueRange":"Range","DeviceRequest.performer":"Reference","DeviceRequest.performerType":"CodeableConcept","DeviceRequest.priorRequest":"Reference","DeviceRequest.priority":"code","DeviceRequest.reasonCode":"CodeableConcept","DeviceRequest.reasonReference":"Reference","DeviceRequest.relevantHistory":"Reference","DeviceRequest.requester":"Reference","DeviceRequest.status":"code","DeviceRequest.subject":"Reference","DeviceRequest.supportingInfo":"Reference","DeviceRequest.text":"Narrative","DeviceUseStatement.basedOn":"Reference","DeviceUseStatement.bodySite":"CodeableConcept","DeviceUseStatement.contained":"Resource","DeviceUseStatement.derivedFrom":"Reference","DeviceUseStatement.device":"Reference","DeviceUseStatement.extension":"Extension","DeviceUseStatement.id":"System.String","DeviceUseStatement.identifier":"Identifier","DeviceUseStatement.implicitRules":"uri","DeviceUseStatement.language":"code","DeviceUseStatement.meta":"Meta","DeviceUseStatement.modifierExtension":"Extension","DeviceUseStatement.note":"Annotation","DeviceUseStatement.reasonCode":"CodeableConcept","DeviceUseStatement.reasonReference":"Reference","DeviceUseStatement.recordedOn":"dateTime","DeviceUseStatement.source":"Reference","DeviceUseStatement.status":"code","DeviceUseStatement.subject":"Reference","DeviceUseStatement.text":"Narrative","DeviceUseStatement.timingDateTime":"dateTime","DeviceUseStatement.timingPeriod":"Period","DeviceUseStatement.timingTiming":"Timing","DiagnosticReport.basedOn":"Reference","DiagnosticReport.category":"CodeableConcept","DiagnosticReport.code":"CodeableConcept","DiagnosticReport.conclusion":"string","DiagnosticReport.conclusionCode":"CodeableConcept","DiagnosticReport.contained":"Resource","DiagnosticReport.effectiveDateTime":"dateTime","DiagnosticReport.effectivePeriod":"Period","DiagnosticReport.encounter":"Reference","DiagnosticReport.extension":"Extension","DiagnosticReport.id":"System.String","DiagnosticReport.identifier":"Identifier","DiagnosticReport.imagingStudy":"Reference","DiagnosticReport.implicitRules":"uri","DiagnosticReport.issued":"instant","DiagnosticReport.language":"code","DiagnosticReport.media.comment":"string","DiagnosticReport.media.extension":"Extension","DiagnosticReport.media.id":"System.String","DiagnosticReport.media.link":"Reference","DiagnosticReport.media.modifierExtension":"Extension","DiagnosticReport.meta":"Meta","DiagnosticReport.modifierExtension":"Extension","DiagnosticReport.performer":"Reference","DiagnosticReport.presentedForm":"Attachment","DiagnosticReport.result":"Reference","DiagnosticReport.resultsInterpreter":"Reference","DiagnosticReport.specimen":"Reference","DiagnosticReport.status":"code","DiagnosticReport.subject":"Reference","DiagnosticReport.text":"Narrative","Distance.code":"code","Distance.comparator":"code","Distance.extension":"Extension","Distance.id":"System.String","Distance.system":"uri","Distance.unit":"string","Distance.value":"decimal","DocumentManifest.author":"Reference","DocumentManifest.contained":"Resource","DocumentManifest.content":"Reference","DocumentManifest.created":"dateTime","DocumentManifest.description":"string","DocumentManifest.extension":"Extension","DocumentManifest.id":"System.String","DocumentManifest.identifier":"Identifier","DocumentManifest.implicitRules":"uri","DocumentManifest.language":"code","DocumentManifest.masterIdentifier":"Identifier","DocumentManifest.meta":"Meta","DocumentManifest.modifierExtension":"Extension","DocumentManifest.recipient":"Reference","DocumentManifest.related.extension":"Extension","DocumentManifest.related.id":"System.String","DocumentManifest.related.identifier":"Identifier","DocumentManifest.related.modifierExtension":"Extension","DocumentManifest.related.ref":"Reference","DocumentManifest.source":"uri","DocumentManifest.status":"code","DocumentManifest.subject":"Reference","DocumentManifest.text":"Narrative","DocumentManifest.type":"CodeableConcept","DocumentReference.authenticator":"Reference","DocumentReference.author":"Reference","DocumentReference.category":"CodeableConcept","DocumentReference.contained":"Resource","DocumentReference.content.attachment":"Attachment","DocumentReference.content.extension":"Extension","DocumentReference.content.format":"Coding","DocumentReference.content.id":"System.String","DocumentReference.content.modifierExtension":"Extension","DocumentReference.context.encounter":"Reference","DocumentReference.context.event":"CodeableConcept","DocumentReference.context.extension":"Extension","DocumentReference.context.facilityType":"CodeableConcept","DocumentReference.context.id":"System.String","DocumentReference.context.modifierExtension":"Extension","DocumentReference.context.period":"Period","DocumentReference.context.practiceSetting":"CodeableConcept","DocumentReference.context.related":"Reference","DocumentReference.context.sourcePatientInfo":"Reference","DocumentReference.custodian":"Reference","DocumentReference.date":"instant","DocumentReference.description":"string","DocumentReference.docStatus":"code","DocumentReference.extension":"Extension","DocumentReference.id":"System.String","DocumentReference.identifier":"Identifier","DocumentReference.implicitRules":"uri","DocumentReference.language":"code","DocumentReference.masterIdentifier":"Identifier","DocumentReference.meta":"Meta","DocumentReference.modifierExtension":"Extension","DocumentReference.relatesTo.code":"code","DocumentReference.relatesTo.extension":"Extension","DocumentReference.relatesTo.id":"System.String","DocumentReference.relatesTo.modifierExtension":"Extension","DocumentReference.relatesTo.target":"Reference","DocumentReference.securityLabel":"CodeableConcept","DocumentReference.status":"code","DocumentReference.subject":"Reference","DocumentReference.text":"Narrative","DocumentReference.type":"CodeableConcept","DomainResource.contained":"Resource","DomainResource.extension":"Extension","DomainResource.id":"System.String","DomainResource.implicitRules":"uri","DomainResource.language":"code","DomainResource.meta":"Meta","DomainResource.modifierExtension":"Extension","DomainResource.text":"Narrative","Dosage.additionalInstruction":"CodeableConcept","Dosage.asNeededBoolean":"boolean","Dosage.asNeededCodeableConcept":"CodeableConcept","Dosage.doseAndRate.doseQuantity":"Quantity","Dosage.doseAndRate.doseRange":"Range","Dosage.doseAndRate.extension":"Extension","Dosage.doseAndRate.id":"System.String","Dosage.doseAndRate.rateQuantity":"Quantity","Dosage.doseAndRate.rateRange":"Range","Dosage.doseAndRate.rateRatio":"Ratio","Dosage.doseAndRate.type":"CodeableConcept","Dosage.extension":"Extension","Dosage.id":"System.String","Dosage.maxDosePerAdministration":"Quantity","Dosage.maxDosePerLifetime":"Quantity","Dosage.maxDosePerPeriod":"Ratio","Dosage.method":"CodeableConcept","Dosage.modifierExtension":"Extension","Dosage.patientInstruction":"string","Dosage.route":"CodeableConcept","Dosage.sequence":"integer","Dosage.site":"CodeableConcept","Dosage.text":"string","Dosage.timing":"Timing","Duration.code":"code","Duration.comparator":"code","Duration.extension":"Extension","Duration.id":"System.String","Duration.system":"uri","Duration.unit":"string","Duration.value":"decimal","EffectEvidenceSynthesis.approvalDate":"date","EffectEvidenceSynthesis.author":"ContactDetail","EffectEvidenceSynthesis.certainty.certaintySubcomponent.extension":"Extension","EffectEvidenceSynthesis.certainty.certaintySubcomponent.id":"System.String","EffectEvidenceSynthesis.certainty.certaintySubcomponent.modifierExtension":"Extension","EffectEvidenceSynthesis.certainty.certaintySubcomponent.note":"Annotation","EffectEvidenceSynthesis.certainty.certaintySubcomponent.rating":"CodeableConcept","EffectEvidenceSynthesis.certainty.certaintySubcomponent.type":"CodeableConcept","EffectEvidenceSynthesis.certainty.extension":"Extension","EffectEvidenceSynthesis.certainty.id":"System.String","EffectEvidenceSynthesis.certainty.modifierExtension":"Extension","EffectEvidenceSynthesis.certainty.note":"Annotation","EffectEvidenceSynthesis.certainty.rating":"CodeableConcept","EffectEvidenceSynthesis.contact":"ContactDetail","EffectEvidenceSynthesis.contained":"Resource","EffectEvidenceSynthesis.copyright":"markdown","EffectEvidenceSynthesis.date":"dateTime","EffectEvidenceSynthesis.description":"markdown","EffectEvidenceSynthesis.editor":"ContactDetail","EffectEvidenceSynthesis.effectEstimate.description":"string","EffectEvidenceSynthesis.effectEstimate.extension":"Extension","EffectEvidenceSynthesis.effectEstimate.id":"System.String","EffectEvidenceSynthesis.effectEstimate.modifierExtension":"Extension","EffectEvidenceSynthesis.effectEstimate.precisionEstimate.extension":"Extension","EffectEvidenceSynthesis.effectEstimate.precisionEstimate.from":"decimal","EffectEvidenceSynthesis.effectEstimate.precisionEstimate.id":"System.String","EffectEvidenceSynthesis.effectEstimate.precisionEstimate.level":"decimal","EffectEvidenceSynthesis.effectEstimate.precisionEstimate.modifierExtension":"Extension","EffectEvidenceSynthesis.effectEstimate.precisionEstimate.to":"decimal","EffectEvidenceSynthesis.effectEstimate.precisionEstimate.type":"CodeableConcept","EffectEvidenceSynthesis.effectEstimate.type":"CodeableConcept","EffectEvidenceSynthesis.effectEstimate.unitOfMeasure":"CodeableConcept","EffectEvidenceSynthesis.effectEstimate.value":"decimal","EffectEvidenceSynthesis.effectEstimate.variantState":"CodeableConcept","EffectEvidenceSynthesis.effectivePeriod":"Period","EffectEvidenceSynthesis.endorser":"ContactDetail","EffectEvidenceSynthesis.exposure":"Reference","EffectEvidenceSynthesis.exposureAlternative":"Reference","EffectEvidenceSynthesis.extension":"Extension","EffectEvidenceSynthesis.id":"System.String","EffectEvidenceSynthesis.identifier":"Identifier","EffectEvidenceSynthesis.implicitRules":"uri","EffectEvidenceSynthesis.jurisdiction":"CodeableConcept","EffectEvidenceSynthesis.language":"code","EffectEvidenceSynthesis.lastReviewDate":"date","EffectEvidenceSynthesis.meta":"Meta","EffectEvidenceSynthesis.modifierExtension":"Extension","EffectEvidenceSynthesis.name":"string","EffectEvidenceSynthesis.note":"Annotation","EffectEvidenceSynthesis.outcome":"Reference","EffectEvidenceSynthesis.population":"Reference","EffectEvidenceSynthesis.publisher":"string","EffectEvidenceSynthesis.relatedArtifact":"RelatedArtifact","EffectEvidenceSynthesis.resultsByExposure.description":"string","EffectEvidenceSynthesis.resultsByExposure.exposureState":"code","EffectEvidenceSynthesis.resultsByExposure.extension":"Extension","EffectEvidenceSynthesis.resultsByExposure.id":"System.String","EffectEvidenceSynthesis.resultsByExposure.modifierExtension":"Extension","EffectEvidenceSynthesis.resultsByExposure.riskEvidenceSynthesis":"Reference","EffectEvidenceSynthesis.resultsByExposure.variantState":"CodeableConcept","EffectEvidenceSynthesis.reviewer":"ContactDetail","EffectEvidenceSynthesis.sampleSize.description":"string","EffectEvidenceSynthesis.sampleSize.extension":"Extension","EffectEvidenceSynthesis.sampleSize.id":"System.String","EffectEvidenceSynthesis.sampleSize.modifierExtension":"Extension","EffectEvidenceSynthesis.sampleSize.numberOfParticipants":"integer","EffectEvidenceSynthesis.sampleSize.numberOfStudies":"integer","EffectEvidenceSynthesis.status":"code","EffectEvidenceSynthesis.studyType":"CodeableConcept","EffectEvidenceSynthesis.synthesisType":"CodeableConcept","EffectEvidenceSynthesis.text":"Narrative","EffectEvidenceSynthesis.title":"string","EffectEvidenceSynthesis.topic":"CodeableConcept","EffectEvidenceSynthesis.url":"uri","EffectEvidenceSynthesis.useContext":"UsageContext","EffectEvidenceSynthesis.version":"string","Element.extension":"Extension","Element.id":"System.String","ElementDefinition.alias":"string","ElementDefinition.base.extension":"Extension","ElementDefinition.base.id":"System.String","ElementDefinition.base.max":"string","ElementDefinition.base.min":"unsignedInt","ElementDefinition.base.path":"string","ElementDefinition.binding.description":"string","ElementDefinition.binding.extension":"Extension","ElementDefinition.binding.id":"System.String","ElementDefinition.binding.strength":"code","ElementDefinition.binding.valueSet":"canonical","ElementDefinition.code":"Coding","ElementDefinition.comment":"markdown","ElementDefinition.condition":"id","ElementDefinition.constraint.expression":"string","ElementDefinition.constraint.extension":"Extension","ElementDefinition.constraint.human":"string","ElementDefinition.constraint.id":"System.String","ElementDefinition.constraint.key":"id","ElementDefinition.constraint.requirements":"string","ElementDefinition.constraint.severity":"code","ElementDefinition.constraint.source":"canonical","ElementDefinition.constraint.xpath":"string","ElementDefinition.contentReference":"uri","ElementDefinition.defaultValueAddress":"Address","ElementDefinition.defaultValueAge":"Age","ElementDefinition.defaultValueAnnotation":"Annotation","ElementDefinition.defaultValueAttachment":"Attachment","ElementDefinition.defaultValueBase64Binary":"base64Binary","ElementDefinition.defaultValueBoolean":"boolean","ElementDefinition.defaultValueCanonical":"canonical","ElementDefinition.defaultValueCode":"code","ElementDefinition.defaultValueCodeableConcept":"CodeableConcept","ElementDefinition.defaultValueCoding":"Coding","ElementDefinition.defaultValueContactDetail":"ContactDetail","ElementDefinition.defaultValueContactPoint":"ContactPoint","ElementDefinition.defaultValueContributor":"Contributor","ElementDefinition.defaultValueCount":"Count","ElementDefinition.defaultValueDataRequirement":"DataRequirement","ElementDefinition.defaultValueDate":"date","ElementDefinition.defaultValueDateTime":"dateTime","ElementDefinition.defaultValueDecimal":"decimal","ElementDefinition.defaultValueDistance":"Distance","ElementDefinition.defaultValueDosage":"Dosage","ElementDefinition.defaultValueDuration":"Duration","ElementDefinition.defaultValueExpression":"Expression","ElementDefinition.defaultValueHumanName":"HumanName","ElementDefinition.defaultValueId":"id","ElementDefinition.defaultValueIdentifier":"Identifier","ElementDefinition.defaultValueInstant":"instant","ElementDefinition.defaultValueInteger":"integer","ElementDefinition.defaultValueMarkdown":"markdown","ElementDefinition.defaultValueMeta":"Meta","ElementDefinition.defaultValueMoney":"Money","ElementDefinition.defaultValueOid":"oid","ElementDefinition.defaultValueParameterDefinition":"ParameterDefinition","ElementDefinition.defaultValuePeriod":"Period","ElementDefinition.defaultValuePositiveInt":"positiveInt","ElementDefinition.defaultValueQuantity":"Quantity","ElementDefinition.defaultValueRange":"Range","ElementDefinition.defaultValueRatio":"Ratio","ElementDefinition.defaultValueReference":"Reference","ElementDefinition.defaultValueRelatedArtifact":"RelatedArtifact","ElementDefinition.defaultValueSampledData":"SampledData","ElementDefinition.defaultValueSignature":"Signature","ElementDefinition.defaultValueString":"string","ElementDefinition.defaultValueTime":"time","ElementDefinition.defaultValueTiming":"Timing","ElementDefinition.defaultValueTriggerDefinition":"TriggerDefinition","ElementDefinition.defaultValueUnsignedInt":"unsignedInt","ElementDefinition.defaultValueUri":"uri","ElementDefinition.defaultValueUrl":"url","ElementDefinition.defaultValueUsageContext":"UsageContext","ElementDefinition.defaultValueUuid":"uuid","ElementDefinition.definition":"markdown","ElementDefinition.example.extension":"Extension","ElementDefinition.example.id":"System.String","ElementDefinition.example.label":"string","ElementDefinition.example.valueAddress":"Address","ElementDefinition.example.valueAge":"Age","ElementDefinition.example.valueAnnotation":"Annotation","ElementDefinition.example.valueAttachment":"Attachment","ElementDefinition.example.valueBase64Binary":"base64Binary","ElementDefinition.example.valueBoolean":"boolean","ElementDefinition.example.valueCanonical":"canonical","ElementDefinition.example.valueCode":"code","ElementDefinition.example.valueCodeableConcept":"CodeableConcept","ElementDefinition.example.valueCoding":"Coding","ElementDefinition.example.valueContactDetail":"ContactDetail","ElementDefinition.example.valueContactPoint":"ContactPoint","ElementDefinition.example.valueContributor":"Contributor","ElementDefinition.example.valueCount":"Count","ElementDefinition.example.valueDataRequirement":"DataRequirement","ElementDefinition.example.valueDate":"date","ElementDefinition.example.valueDateTime":"dateTime","ElementDefinition.example.valueDecimal":"decimal","ElementDefinition.example.valueDistance":"Distance","ElementDefinition.example.valueDosage":"Dosage","ElementDefinition.example.valueDuration":"Duration","ElementDefinition.example.valueExpression":"Expression","ElementDefinition.example.valueHumanName":"HumanName","ElementDefinition.example.valueId":"id","ElementDefinition.example.valueIdentifier":"Identifier","ElementDefinition.example.valueInstant":"instant","ElementDefinition.example.valueInteger":"integer","ElementDefinition.example.valueMarkdown":"markdown","ElementDefinition.example.valueMeta":"Meta","ElementDefinition.example.valueMoney":"Money","ElementDefinition.example.valueOid":"oid","ElementDefinition.example.valueParameterDefinition":"ParameterDefinition","ElementDefinition.example.valuePeriod":"Period","ElementDefinition.example.valuePositiveInt":"positiveInt","ElementDefinition.example.valueQuantity":"Quantity","ElementDefinition.example.valueRange":"Range","ElementDefinition.example.valueRatio":"Ratio","ElementDefinition.example.valueReference":"Reference","ElementDefinition.example.valueRelatedArtifact":"RelatedArtifact","ElementDefinition.example.valueSampledData":"SampledData","ElementDefinition.example.valueSignature":"Signature","ElementDefinition.example.valueString":"string","ElementDefinition.example.valueTime":"time","ElementDefinition.example.valueTiming":"Timing","ElementDefinition.example.valueTriggerDefinition":"TriggerDefinition","ElementDefinition.example.valueUnsignedInt":"unsignedInt","ElementDefinition.example.valueUri":"uri","ElementDefinition.example.valueUrl":"url","ElementDefinition.example.valueUsageContext":"UsageContext","ElementDefinition.example.valueUuid":"uuid","ElementDefinition.extension":"Extension","ElementDefinition.extension.extension":"Extension","ElementDefinition.extension.id":"System.String","ElementDefinition.extension.url":"System.String","ElementDefinition.extension.valueCanonical":"canonical","ElementDefinition.extension.valueCodeableConcept":"CodeableConcept","ElementDefinition.extension.valueString":"string","ElementDefinition.fixedAddress":"Address","ElementDefinition.fixedAge":"Age","ElementDefinition.fixedAnnotation":"Annotation","ElementDefinition.fixedAttachment":"Attachment","ElementDefinition.fixedBase64Binary":"base64Binary","ElementDefinition.fixedBoolean":"boolean","ElementDefinition.fixedCanonical":"canonical","ElementDefinition.fixedCode":"code","ElementDefinition.fixedCodeableConcept":"CodeableConcept","ElementDefinition.fixedCoding":"Coding","ElementDefinition.fixedContactDetail":"ContactDetail","ElementDefinition.fixedContactPoint":"ContactPoint","ElementDefinition.fixedContributor":"Contributor","ElementDefinition.fixedCount":"Count","ElementDefinition.fixedDataRequirement":"DataRequirement","ElementDefinition.fixedDate":"date","ElementDefinition.fixedDateTime":"dateTime","ElementDefinition.fixedDecimal":"decimal","ElementDefinition.fixedDistance":"Distance","ElementDefinition.fixedDosage":"Dosage","ElementDefinition.fixedDuration":"Duration","ElementDefinition.fixedExpression":"Expression","ElementDefinition.fixedHumanName":"HumanName","ElementDefinition.fixedId":"id","ElementDefinition.fixedIdentifier":"Identifier","ElementDefinition.fixedInstant":"instant","ElementDefinition.fixedInteger":"integer","ElementDefinition.fixedMarkdown":"markdown","ElementDefinition.fixedMeta":"Meta","ElementDefinition.fixedMoney":"Money","ElementDefinition.fixedOid":"oid","ElementDefinition.fixedParameterDefinition":"ParameterDefinition","ElementDefinition.fixedPeriod":"Period","ElementDefinition.fixedPositiveInt":"positiveInt","ElementDefinition.fixedQuantity":"Quantity","ElementDefinition.fixedRange":"Range","ElementDefinition.fixedRatio":"Ratio","ElementDefinition.fixedReference":"Reference","ElementDefinition.fixedRelatedArtifact":"RelatedArtifact","ElementDefinition.fixedSampledData":"SampledData","ElementDefinition.fixedSignature":"Signature","ElementDefinition.fixedString":"string","ElementDefinition.fixedTime":"time","ElementDefinition.fixedTiming":"Timing","ElementDefinition.fixedTriggerDefinition":"TriggerDefinition","ElementDefinition.fixedUnsignedInt":"unsignedInt","ElementDefinition.fixedUri":"uri","ElementDefinition.fixedUrl":"url","ElementDefinition.fixedUsageContext":"UsageContext","ElementDefinition.fixedUuid":"uuid","ElementDefinition.id":"System.String","ElementDefinition.isModifier":"boolean","ElementDefinition.isModifierReason":"string","ElementDefinition.isSummary":"boolean","ElementDefinition.label":"string","ElementDefinition.mapping.comment":"string","ElementDefinition.mapping.extension":"Extension","ElementDefinition.mapping.id":"System.String","ElementDefinition.mapping.identity":"id","ElementDefinition.mapping.language":"code","ElementDefinition.mapping.map":"string","ElementDefinition.max":"string","ElementDefinition.maxLength":"integer","ElementDefinition.maxValueDate":"date","ElementDefinition.maxValueDateTime":"dateTime","ElementDefinition.maxValueDecimal":"decimal","ElementDefinition.maxValueInstant":"instant","ElementDefinition.maxValueInteger":"integer","ElementDefinition.maxValuePositiveInt":"positiveInt","ElementDefinition.maxValueQuantity":"Quantity","ElementDefinition.maxValueTime":"time","ElementDefinition.maxValueUnsignedInt":"unsignedInt","ElementDefinition.meaningWhenMissing":"markdown","ElementDefinition.min":"unsignedInt","ElementDefinition.minValueDate":"date","ElementDefinition.minValueDateTime":"dateTime","ElementDefinition.minValueDecimal":"decimal","ElementDefinition.minValueInstant":"instant","ElementDefinition.minValueInteger":"integer","ElementDefinition.minValuePositiveInt":"positiveInt","ElementDefinition.minValueQuantity":"Quantity","ElementDefinition.minValueTime":"time","ElementDefinition.minValueUnsignedInt":"unsignedInt","ElementDefinition.modifierExtension":"Extension","ElementDefinition.mustSupport":"boolean","ElementDefinition.orderMeaning":"string","ElementDefinition.path":"string","ElementDefinition.patternAddress":"Address","ElementDefinition.patternAge":"Age","ElementDefinition.patternAnnotation":"Annotation","ElementDefinition.patternAttachment":"Attachment","ElementDefinition.patternBase64Binary":"base64Binary","ElementDefinition.patternBoolean":"boolean","ElementDefinition.patternCanonical":"canonical","ElementDefinition.patternCode":"code","ElementDefinition.patternCodeableConcept":"CodeableConcept","ElementDefinition.patternCoding":"Coding","ElementDefinition.patternContactDetail":"ContactDetail","ElementDefinition.patternContactPoint":"ContactPoint","ElementDefinition.patternContributor":"Contributor","ElementDefinition.patternCount":"Count","ElementDefinition.patternDataRequirement":"DataRequirement","ElementDefinition.patternDate":"date","ElementDefinition.patternDateTime":"dateTime","ElementDefinition.patternDecimal":"decimal","ElementDefinition.patternDistance":"Distance","ElementDefinition.patternDosage":"Dosage","ElementDefinition.patternDuration":"Duration","ElementDefinition.patternExpression":"Expression","ElementDefinition.patternHumanName":"HumanName","ElementDefinition.patternId":"id","ElementDefinition.patternIdentifier":"Identifier","ElementDefinition.patternInstant":"instant","ElementDefinition.patternInteger":"integer","ElementDefinition.patternMarkdown":"markdown","ElementDefinition.patternMeta":"Meta","ElementDefinition.patternMoney":"Money","ElementDefinition.patternOid":"oid","ElementDefinition.patternParameterDefinition":"ParameterDefinition","ElementDefinition.patternPeriod":"Period","ElementDefinition.patternPositiveInt":"positiveInt","ElementDefinition.patternQuantity":"Quantity","ElementDefinition.patternRange":"Range","ElementDefinition.patternRatio":"Ratio","ElementDefinition.patternReference":"Reference","ElementDefinition.patternRelatedArtifact":"RelatedArtifact","ElementDefinition.patternSampledData":"SampledData","ElementDefinition.patternSignature":"Signature","ElementDefinition.patternString":"string","ElementDefinition.patternTime":"time","ElementDefinition.patternTiming":"Timing","ElementDefinition.patternTriggerDefinition":"TriggerDefinition","ElementDefinition.patternUnsignedInt":"unsignedInt","ElementDefinition.patternUri":"uri","ElementDefinition.patternUrl":"url","ElementDefinition.patternUsageContext":"UsageContext","ElementDefinition.patternUuid":"uuid","ElementDefinition.representation":"code","ElementDefinition.requirements":"markdown","ElementDefinition.short":"string","ElementDefinition.sliceIsConstraining":"boolean","ElementDefinition.sliceName":"string","ElementDefinition.slicing.description":"string","ElementDefinition.slicing.discriminator.extension":"Extension","ElementDefinition.slicing.discriminator.id":"System.String","ElementDefinition.slicing.discriminator.path":"string","ElementDefinition.slicing.discriminator.type":"code","ElementDefinition.slicing.extension":"Extension","ElementDefinition.slicing.id":"System.String","ElementDefinition.slicing.ordered":"boolean","ElementDefinition.slicing.rules":"code","ElementDefinition.type.aggregation":"code","ElementDefinition.type.code":"uri","ElementDefinition.type.extension":"Extension","ElementDefinition.type.id":"System.String","ElementDefinition.type.profile":"canonical","ElementDefinition.type.targetProfile":"canonical","ElementDefinition.type.versioning":"code","Encounter.account":"Reference","Encounter.appointment":"Reference","Encounter.basedOn":"Reference","Encounter.class":"Coding","Encounter.classHistory.class":"Coding","Encounter.classHistory.extension":"Extension","Encounter.classHistory.id":"System.String","Encounter.classHistory.modifierExtension":"Extension","Encounter.classHistory.period":"Period","Encounter.contained":"Resource","Encounter.diagnosis.condition":"Reference","Encounter.diagnosis.extension":"Extension","Encounter.diagnosis.id":"System.String","Encounter.diagnosis.modifierExtension":"Extension","Encounter.diagnosis.rank":"positiveInt","Encounter.diagnosis.use":"CodeableConcept","Encounter.episodeOfCare":"Reference","Encounter.extension":"Extension","Encounter.hospitalization.admitSource":"CodeableConcept","Encounter.hospitalization.destination":"Reference","Encounter.hospitalization.dietPreference":"CodeableConcept","Encounter.hospitalization.dischargeDisposition":"CodeableConcept","Encounter.hospitalization.extension":"Extension","Encounter.hospitalization.id":"System.String","Encounter.hospitalization.modifierExtension":"Extension","Encounter.hospitalization.origin":"Reference","Encounter.hospitalization.preAdmissionIdentifier":"Identifier","Encounter.hospitalization.reAdmission":"CodeableConcept","Encounter.hospitalization.specialArrangement":"CodeableConcept","Encounter.hospitalization.specialCourtesy":"CodeableConcept","Encounter.id":"System.String","Encounter.identifier":"Identifier","Encounter.implicitRules":"uri","Encounter.language":"code","Encounter.length":"Duration","Encounter.location.extension":"Extension","Encounter.location.id":"System.String","Encounter.location.location":"Reference","Encounter.location.modifierExtension":"Extension","Encounter.location.period":"Period","Encounter.location.physicalType":"CodeableConcept","Encounter.location.status":"code","Encounter.meta":"Meta","Encounter.modifierExtension":"Extension","Encounter.partOf":"Reference","Encounter.participant.extension":"Extension","Encounter.participant.id":"System.String","Encounter.participant.individual":"Reference","Encounter.participant.modifierExtension":"Extension","Encounter.participant.period":"Period","Encounter.participant.type":"CodeableConcept","Encounter.period":"Period","Encounter.priority":"CodeableConcept","Encounter.reasonCode":"CodeableConcept","Encounter.reasonReference":"Reference","Encounter.serviceProvider":"Reference","Encounter.serviceType":"CodeableConcept","Encounter.status":"code","Encounter.statusHistory.extension":"Extension","Encounter.statusHistory.id":"System.String","Encounter.statusHistory.modifierExtension":"Extension","Encounter.statusHistory.period":"Period","Encounter.statusHistory.status":"code","Encounter.subject":"Reference","Encounter.text":"Narrative","Encounter.type":"CodeableConcept","Endpoint.address":"url","Endpoint.connectionType":"Coding","Endpoint.contact":"ContactPoint","Endpoint.contained":"Resource","Endpoint.extension":"Extension","Endpoint.header":"string","Endpoint.id":"System.String","Endpoint.identifier":"Identifier","Endpoint.implicitRules":"uri","Endpoint.language":"code","Endpoint.managingOrganization":"Reference","Endpoint.meta":"Meta","Endpoint.modifierExtension":"Extension","Endpoint.name":"string","Endpoint.payloadMimeType":"code","Endpoint.payloadType":"CodeableConcept","Endpoint.period":"Period","Endpoint.status":"code","Endpoint.text":"Narrative","EnrollmentRequest.candidate":"Reference","EnrollmentRequest.contained":"Resource","EnrollmentRequest.coverage":"Reference","EnrollmentRequest.created":"dateTime","EnrollmentRequest.extension":"Extension","EnrollmentRequest.id":"System.String","EnrollmentRequest.identifier":"Identifier","EnrollmentRequest.implicitRules":"uri","EnrollmentRequest.insurer":"Reference","EnrollmentRequest.language":"code","EnrollmentRequest.meta":"Meta","EnrollmentRequest.modifierExtension":"Extension","EnrollmentRequest.provider":"Reference","EnrollmentRequest.status":"code","EnrollmentRequest.text":"Narrative","EnrollmentResponse.contained":"Resource","EnrollmentResponse.created":"dateTime","EnrollmentResponse.disposition":"string","EnrollmentResponse.extension":"Extension","EnrollmentResponse.id":"System.String","EnrollmentResponse.identifier":"Identifier","EnrollmentResponse.implicitRules":"uri","EnrollmentResponse.language":"code","EnrollmentResponse.meta":"Meta","EnrollmentResponse.modifierExtension":"Extension","EnrollmentResponse.organization":"Reference","EnrollmentResponse.outcome":"code","EnrollmentResponse.request":"Reference","EnrollmentResponse.requestProvider":"Reference","EnrollmentResponse.status":"code","EnrollmentResponse.text":"Narrative","EpisodeOfCare.account":"Reference","EpisodeOfCare.careManager":"Reference","EpisodeOfCare.contained":"Resource","EpisodeOfCare.diagnosis.condition":"Reference","EpisodeOfCare.diagnosis.extension":"Extension","EpisodeOfCare.diagnosis.id":"System.String","EpisodeOfCare.diagnosis.modifierExtension":"Extension","EpisodeOfCare.diagnosis.rank":"positiveInt","EpisodeOfCare.diagnosis.role":"CodeableConcept","EpisodeOfCare.extension":"Extension","EpisodeOfCare.id":"System.String","EpisodeOfCare.identifier":"Identifier","EpisodeOfCare.implicitRules":"uri","EpisodeOfCare.language":"code","EpisodeOfCare.managingOrganization":"Reference","EpisodeOfCare.meta":"Meta","EpisodeOfCare.modifierExtension":"Extension","EpisodeOfCare.patient":"Reference","EpisodeOfCare.period":"Period","EpisodeOfCare.referralRequest":"Reference","EpisodeOfCare.status":"code","EpisodeOfCare.statusHistory.extension":"Extension","EpisodeOfCare.statusHistory.id":"System.String","EpisodeOfCare.statusHistory.modifierExtension":"Extension","EpisodeOfCare.statusHistory.period":"Period","EpisodeOfCare.statusHistory.status":"code","EpisodeOfCare.team":"Reference","EpisodeOfCare.text":"Narrative","EpisodeOfCare.type":"CodeableConcept","EventDefinition.approvalDate":"date","EventDefinition.author":"ContactDetail","EventDefinition.contact":"ContactDetail","EventDefinition.contained":"Resource","EventDefinition.copyright":"markdown","EventDefinition.date":"dateTime","EventDefinition.description":"markdown","EventDefinition.editor":"ContactDetail","EventDefinition.effectivePeriod":"Period","EventDefinition.endorser":"ContactDetail","EventDefinition.experimental":"boolean","EventDefinition.extension":"Extension","EventDefinition.id":"System.String","EventDefinition.identifier":"Identifier","EventDefinition.implicitRules":"uri","EventDefinition.jurisdiction":"CodeableConcept","EventDefinition.language":"code","EventDefinition.lastReviewDate":"date","EventDefinition.meta":"Meta","EventDefinition.modifierExtension":"Extension","EventDefinition.name":"string","EventDefinition.publisher":"string","EventDefinition.purpose":"markdown","EventDefinition.relatedArtifact":"RelatedArtifact","EventDefinition.reviewer":"ContactDetail","EventDefinition.status":"code","EventDefinition.subjectCodeableConcept":"CodeableConcept","EventDefinition.subjectReference":"Reference","EventDefinition.subtitle":"string","EventDefinition.text":"Narrative","EventDefinition.title":"string","EventDefinition.topic":"CodeableConcept","EventDefinition.trigger":"TriggerDefinition","EventDefinition.url":"uri","EventDefinition.usage":"string","EventDefinition.useContext":"UsageContext","EventDefinition.version":"string","Evidence.approvalDate":"date","Evidence.author":"ContactDetail","Evidence.contact":"ContactDetail","Evidence.contained":"Resource","Evidence.copyright":"markdown","Evidence.date":"dateTime","Evidence.description":"markdown","Evidence.editor":"ContactDetail","Evidence.effectivePeriod":"Period","Evidence.endorser":"ContactDetail","Evidence.exposureBackground":"Reference","Evidence.exposureVariant":"Reference","Evidence.extension":"Extension","Evidence.id":"System.String","Evidence.identifier":"Identifier","Evidence.implicitRules":"uri","Evidence.jurisdiction":"CodeableConcept","Evidence.language":"code","Evidence.lastReviewDate":"date","Evidence.meta":"Meta","Evidence.modifierExtension":"Extension","Evidence.name":"string","Evidence.note":"Annotation","Evidence.outcome":"Reference","Evidence.publisher":"string","Evidence.relatedArtifact":"RelatedArtifact","Evidence.reviewer":"ContactDetail","Evidence.shortTitle":"string","Evidence.status":"code","Evidence.subtitle":"string","Evidence.text":"Narrative","Evidence.title":"string","Evidence.topic":"CodeableConcept","Evidence.url":"uri","Evidence.useContext":"UsageContext","Evidence.version":"string","EvidenceVariable.approvalDate":"date","EvidenceVariable.author":"ContactDetail","EvidenceVariable.characteristic.definitionCanonical":"canonical","EvidenceVariable.characteristic.definitionCodeableConcept":"CodeableConcept","EvidenceVariable.characteristic.definitionDataRequirement":"DataRequirement","EvidenceVariable.characteristic.definitionExpression":"Expression","EvidenceVariable.characteristic.definitionReference":"Reference","EvidenceVariable.characteristic.definitionTriggerDefinition":"TriggerDefinition","EvidenceVariable.characteristic.description":"string","EvidenceVariable.characteristic.exclude":"boolean","EvidenceVariable.characteristic.extension":"Extension","EvidenceVariable.characteristic.groupMeasure":"code","EvidenceVariable.characteristic.id":"System.String","EvidenceVariable.characteristic.modifierExtension":"Extension","EvidenceVariable.characteristic.participantEffectiveDateTime":"dateTime","EvidenceVariable.characteristic.participantEffectiveDuration":"Duration","EvidenceVariable.characteristic.participantEffectivePeriod":"Period","EvidenceVariable.characteristic.participantEffectiveTiming":"Timing","EvidenceVariable.characteristic.timeFromStart":"Duration","EvidenceVariable.characteristic.usageContext":"UsageContext","EvidenceVariable.contact":"ContactDetail","EvidenceVariable.contained":"Resource","EvidenceVariable.copyright":"markdown","EvidenceVariable.date":"dateTime","EvidenceVariable.description":"markdown","EvidenceVariable.editor":"ContactDetail","EvidenceVariable.effectivePeriod":"Period","EvidenceVariable.endorser":"ContactDetail","EvidenceVariable.extension":"Extension","EvidenceVariable.id":"System.String","EvidenceVariable.identifier":"Identifier","EvidenceVariable.implicitRules":"uri","EvidenceVariable.jurisdiction":"CodeableConcept","EvidenceVariable.language":"code","EvidenceVariable.lastReviewDate":"date","EvidenceVariable.meta":"Meta","EvidenceVariable.modifierExtension":"Extension","EvidenceVariable.name":"string","EvidenceVariable.note":"Annotation","EvidenceVariable.publisher":"string","EvidenceVariable.relatedArtifact":"RelatedArtifact","EvidenceVariable.reviewer":"ContactDetail","EvidenceVariable.shortTitle":"string","EvidenceVariable.status":"code","EvidenceVariable.subtitle":"string","EvidenceVariable.text":"Narrative","EvidenceVariable.title":"string","EvidenceVariable.topic":"CodeableConcept","EvidenceVariable.type":"code","EvidenceVariable.url":"uri","EvidenceVariable.useContext":"UsageContext","EvidenceVariable.version":"string","ExampleScenario.actor.actorId":"string","ExampleScenario.actor.description":"markdown","ExampleScenario.actor.extension":"Extension","ExampleScenario.actor.id":"System.String","ExampleScenario.actor.modifierExtension":"Extension","ExampleScenario.actor.name":"string","ExampleScenario.actor.type":"code","ExampleScenario.contact":"ContactDetail","ExampleScenario.contained":"Resource","ExampleScenario.copyright":"markdown","ExampleScenario.date":"dateTime","ExampleScenario.experimental":"boolean","ExampleScenario.extension":"Extension","ExampleScenario.id":"System.String","ExampleScenario.identifier":"Identifier","ExampleScenario.implicitRules":"uri","ExampleScenario.instance.containedInstance.extension":"Extension","ExampleScenario.instance.containedInstance.id":"System.String","ExampleScenario.instance.containedInstance.modifierExtension":"Extension","ExampleScenario.instance.containedInstance.resourceId":"string","ExampleScenario.instance.containedInstance.versionId":"string","ExampleScenario.instance.description":"markdown","ExampleScenario.instance.extension":"Extension","ExampleScenario.instance.id":"System.String","ExampleScenario.instance.modifierExtension":"Extension","ExampleScenario.instance.name":"string","ExampleScenario.instance.resourceId":"string","ExampleScenario.instance.resourceType":"code","ExampleScenario.instance.version.description":"markdown","ExampleScenario.instance.version.extension":"Extension","ExampleScenario.instance.version.id":"System.String","ExampleScenario.instance.version.modifierExtension":"Extension","ExampleScenario.instance.version.versionId":"string","ExampleScenario.jurisdiction":"CodeableConcept","ExampleScenario.language":"code","ExampleScenario.meta":"Meta","ExampleScenario.modifierExtension":"Extension","ExampleScenario.name":"string","ExampleScenario.process.description":"markdown","ExampleScenario.process.extension":"Extension","ExampleScenario.process.id":"System.String","ExampleScenario.process.modifierExtension":"Extension","ExampleScenario.process.postConditions":"markdown","ExampleScenario.process.preConditions":"markdown","ExampleScenario.process.step.alternative.description":"markdown","ExampleScenario.process.step.alternative.extension":"Extension","ExampleScenario.process.step.alternative.id":"System.String","ExampleScenario.process.step.alternative.modifierExtension":"Extension","ExampleScenario.process.step.alternative.title":"string","ExampleScenario.process.step.extension":"Extension","ExampleScenario.process.step.id":"System.String","ExampleScenario.process.step.modifierExtension":"Extension","ExampleScenario.process.step.operation.description":"markdown","ExampleScenario.process.step.operation.extension":"Extension","ExampleScenario.process.step.operation.id":"System.String","ExampleScenario.process.step.operation.initiator":"string","ExampleScenario.process.step.operation.initiatorActive":"boolean","ExampleScenario.process.step.operation.modifierExtension":"Extension","ExampleScenario.process.step.operation.name":"string","ExampleScenario.process.step.operation.number":"string","ExampleScenario.process.step.operation.receiver":"string","ExampleScenario.process.step.operation.receiverActive":"boolean","ExampleScenario.process.step.operation.type":"string","ExampleScenario.process.step.pause":"boolean","ExampleScenario.process.title":"string","ExampleScenario.publisher":"string","ExampleScenario.purpose":"markdown","ExampleScenario.status":"code","ExampleScenario.text":"Narrative","ExampleScenario.url":"uri","ExampleScenario.useContext":"UsageContext","ExampleScenario.version":"string","ExampleScenario.workflow":"canonical","ExplanationOfBenefit.accident.date":"date","ExplanationOfBenefit.accident.extension":"Extension","ExplanationOfBenefit.accident.id":"System.String","ExplanationOfBenefit.accident.locationAddress":"Address","ExplanationOfBenefit.accident.locationReference":"Reference","ExplanationOfBenefit.accident.modifierExtension":"Extension","ExplanationOfBenefit.accident.type":"CodeableConcept","ExplanationOfBenefit.addItem.bodySite":"CodeableConcept","ExplanationOfBenefit.addItem.detail.extension":"Extension","ExplanationOfBenefit.addItem.detail.factor":"decimal","ExplanationOfBenefit.addItem.detail.id":"System.String","ExplanationOfBenefit.addItem.detail.modifier":"CodeableConcept","ExplanationOfBenefit.addItem.detail.modifierExtension":"Extension","ExplanationOfBenefit.addItem.detail.net":"Money","ExplanationOfBenefit.addItem.detail.noteNumber":"positiveInt","ExplanationOfBenefit.addItem.detail.productOrService":"CodeableConcept","ExplanationOfBenefit.addItem.detail.quantity":"Quantity","ExplanationOfBenefit.addItem.detail.subDetail.extension":"Extension","ExplanationOfBenefit.addItem.detail.subDetail.factor":"decimal","ExplanationOfBenefit.addItem.detail.subDetail.id":"System.String","ExplanationOfBenefit.addItem.detail.subDetail.modifier":"CodeableConcept","ExplanationOfBenefit.addItem.detail.subDetail.modifierExtension":"Extension","ExplanationOfBenefit.addItem.detail.subDetail.net":"Money","ExplanationOfBenefit.addItem.detail.subDetail.noteNumber":"positiveInt","ExplanationOfBenefit.addItem.detail.subDetail.productOrService":"CodeableConcept","ExplanationOfBenefit.addItem.detail.subDetail.quantity":"Quantity","ExplanationOfBenefit.addItem.detail.subDetail.unitPrice":"Money","ExplanationOfBenefit.addItem.detail.unitPrice":"Money","ExplanationOfBenefit.addItem.detailSequence":"positiveInt","ExplanationOfBenefit.addItem.extension":"Extension","ExplanationOfBenefit.addItem.factor":"decimal","ExplanationOfBenefit.addItem.id":"System.String","ExplanationOfBenefit.addItem.itemSequence":"positiveInt","ExplanationOfBenefit.addItem.locationAddress":"Address","ExplanationOfBenefit.addItem.locationCodeableConcept":"CodeableConcept","ExplanationOfBenefit.addItem.locationReference":"Reference","ExplanationOfBenefit.addItem.modifier":"CodeableConcept","ExplanationOfBenefit.addItem.modifierExtension":"Extension","ExplanationOfBenefit.addItem.net":"Money","ExplanationOfBenefit.addItem.noteNumber":"positiveInt","ExplanationOfBenefit.addItem.productOrService":"CodeableConcept","ExplanationOfBenefit.addItem.programCode":"CodeableConcept","ExplanationOfBenefit.addItem.provider":"Reference","ExplanationOfBenefit.addItem.quantity":"Quantity","ExplanationOfBenefit.addItem.servicedDate":"date","ExplanationOfBenefit.addItem.servicedPeriod":"Period","ExplanationOfBenefit.addItem.subDetailSequence":"positiveInt","ExplanationOfBenefit.addItem.subSite":"CodeableConcept","ExplanationOfBenefit.addItem.unitPrice":"Money","ExplanationOfBenefit.benefitBalance.category":"CodeableConcept","ExplanationOfBenefit.benefitBalance.description":"string","ExplanationOfBenefit.benefitBalance.excluded":"boolean","ExplanationOfBenefit.benefitBalance.extension":"Extension","ExplanationOfBenefit.benefitBalance.financial.allowedMoney":"Money","ExplanationOfBenefit.benefitBalance.financial.allowedString":"string","ExplanationOfBenefit.benefitBalance.financial.allowedUnsignedInt":"unsignedInt","ExplanationOfBenefit.benefitBalance.financial.extension":"Extension","ExplanationOfBenefit.benefitBalance.financial.id":"System.String","ExplanationOfBenefit.benefitBalance.financial.modifierExtension":"Extension","ExplanationOfBenefit.benefitBalance.financial.type":"CodeableConcept","ExplanationOfBenefit.benefitBalance.financial.usedMoney":"Money","ExplanationOfBenefit.benefitBalance.financial.usedUnsignedInt":"unsignedInt","ExplanationOfBenefit.benefitBalance.id":"System.String","ExplanationOfBenefit.benefitBalance.modifierExtension":"Extension","ExplanationOfBenefit.benefitBalance.name":"string","ExplanationOfBenefit.benefitBalance.network":"CodeableConcept","ExplanationOfBenefit.benefitBalance.term":"CodeableConcept","ExplanationOfBenefit.benefitBalance.unit":"CodeableConcept","ExplanationOfBenefit.benefitPeriod":"Period","ExplanationOfBenefit.billablePeriod":"Period","ExplanationOfBenefit.careTeam.extension":"Extension","ExplanationOfBenefit.careTeam.id":"System.String","ExplanationOfBenefit.careTeam.modifierExtension":"Extension","ExplanationOfBenefit.careTeam.provider":"Reference","ExplanationOfBenefit.careTeam.qualification":"CodeableConcept","ExplanationOfBenefit.careTeam.responsible":"boolean","ExplanationOfBenefit.careTeam.role":"CodeableConcept","ExplanationOfBenefit.careTeam.sequence":"positiveInt","ExplanationOfBenefit.claim":"Reference","ExplanationOfBenefit.claimResponse":"Reference","ExplanationOfBenefit.contained":"Resource","ExplanationOfBenefit.created":"dateTime","ExplanationOfBenefit.diagnosis.diagnosisCodeableConcept":"CodeableConcept","ExplanationOfBenefit.diagnosis.diagnosisReference":"Reference","ExplanationOfBenefit.diagnosis.extension":"Extension","ExplanationOfBenefit.diagnosis.id":"System.String","ExplanationOfBenefit.diagnosis.modifierExtension":"Extension","ExplanationOfBenefit.diagnosis.onAdmission":"CodeableConcept","ExplanationOfBenefit.diagnosis.packageCode":"CodeableConcept","ExplanationOfBenefit.diagnosis.sequence":"positiveInt","ExplanationOfBenefit.diagnosis.type":"CodeableConcept","ExplanationOfBenefit.disposition":"string","ExplanationOfBenefit.enterer":"Reference","ExplanationOfBenefit.extension":"Extension","ExplanationOfBenefit.facility":"Reference","ExplanationOfBenefit.form":"Attachment","ExplanationOfBenefit.formCode":"CodeableConcept","ExplanationOfBenefit.fundsReserve":"CodeableConcept","ExplanationOfBenefit.fundsReserveRequested":"CodeableConcept","ExplanationOfBenefit.id":"System.String","ExplanationOfBenefit.identifier":"Identifier","ExplanationOfBenefit.implicitRules":"uri","ExplanationOfBenefit.insurance.coverage":"Reference","ExplanationOfBenefit.insurance.extension":"Extension","ExplanationOfBenefit.insurance.focal":"boolean","ExplanationOfBenefit.insurance.id":"System.String","ExplanationOfBenefit.insurance.modifierExtension":"Extension","ExplanationOfBenefit.insurance.preAuthRef":"string","ExplanationOfBenefit.insurer":"Reference","ExplanationOfBenefit.item.adjudication.amount":"Money","ExplanationOfBenefit.item.adjudication.category":"CodeableConcept","ExplanationOfBenefit.item.adjudication.extension":"Extension","ExplanationOfBenefit.item.adjudication.id":"System.String","ExplanationOfBenefit.item.adjudication.modifierExtension":"Extension","ExplanationOfBenefit.item.adjudication.reason":"CodeableConcept","ExplanationOfBenefit.item.adjudication.value":"decimal","ExplanationOfBenefit.item.bodySite":"CodeableConcept","ExplanationOfBenefit.item.careTeamSequence":"positiveInt","ExplanationOfBenefit.item.category":"CodeableConcept","ExplanationOfBenefit.item.detail.category":"CodeableConcept","ExplanationOfBenefit.item.detail.extension":"Extension","ExplanationOfBenefit.item.detail.factor":"decimal","ExplanationOfBenefit.item.detail.id":"System.String","ExplanationOfBenefit.item.detail.modifier":"CodeableConcept","ExplanationOfBenefit.item.detail.modifierExtension":"Extension","ExplanationOfBenefit.item.detail.net":"Money","ExplanationOfBenefit.item.detail.noteNumber":"positiveInt","ExplanationOfBenefit.item.detail.productOrService":"CodeableConcept","ExplanationOfBenefit.item.detail.programCode":"CodeableConcept","ExplanationOfBenefit.item.detail.quantity":"Quantity","ExplanationOfBenefit.item.detail.revenue":"CodeableConcept","ExplanationOfBenefit.item.detail.sequence":"positiveInt","ExplanationOfBenefit.item.detail.subDetail.category":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.extension":"Extension","ExplanationOfBenefit.item.detail.subDetail.factor":"decimal","ExplanationOfBenefit.item.detail.subDetail.id":"System.String","ExplanationOfBenefit.item.detail.subDetail.modifier":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.modifierExtension":"Extension","ExplanationOfBenefit.item.detail.subDetail.net":"Money","ExplanationOfBenefit.item.detail.subDetail.noteNumber":"positiveInt","ExplanationOfBenefit.item.detail.subDetail.productOrService":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.programCode":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.quantity":"Quantity","ExplanationOfBenefit.item.detail.subDetail.revenue":"CodeableConcept","ExplanationOfBenefit.item.detail.subDetail.sequence":"positiveInt","ExplanationOfBenefit.item.detail.subDetail.udi":"Reference","ExplanationOfBenefit.item.detail.subDetail.unitPrice":"Money","ExplanationOfBenefit.item.detail.udi":"Reference","ExplanationOfBenefit.item.detail.unitPrice":"Money","ExplanationOfBenefit.item.diagnosisSequence":"positiveInt","ExplanationOfBenefit.item.encounter":"Reference","ExplanationOfBenefit.item.extension":"Extension","ExplanationOfBenefit.item.factor":"decimal","ExplanationOfBenefit.item.id":"System.String","ExplanationOfBenefit.item.informationSequence":"positiveInt","ExplanationOfBenefit.item.locationAddress":"Address","ExplanationOfBenefit.item.locationCodeableConcept":"CodeableConcept","ExplanationOfBenefit.item.locationReference":"Reference","ExplanationOfBenefit.item.modifier":"CodeableConcept","ExplanationOfBenefit.item.modifierExtension":"Extension","ExplanationOfBenefit.item.net":"Money","ExplanationOfBenefit.item.noteNumber":"positiveInt","ExplanationOfBenefit.item.procedureSequence":"positiveInt","ExplanationOfBenefit.item.productOrService":"CodeableConcept","ExplanationOfBenefit.item.programCode":"CodeableConcept","ExplanationOfBenefit.item.quantity":"Quantity","ExplanationOfBenefit.item.revenue":"CodeableConcept","ExplanationOfBenefit.item.sequence":"positiveInt","ExplanationOfBenefit.item.servicedDate":"date","ExplanationOfBenefit.item.servicedPeriod":"Period","ExplanationOfBenefit.item.subSite":"CodeableConcept","ExplanationOfBenefit.item.udi":"Reference","ExplanationOfBenefit.item.unitPrice":"Money","ExplanationOfBenefit.language":"code","ExplanationOfBenefit.meta":"Meta","ExplanationOfBenefit.modifierExtension":"Extension","ExplanationOfBenefit.originalPrescription":"Reference","ExplanationOfBenefit.outcome":"code","ExplanationOfBenefit.patient":"Reference","ExplanationOfBenefit.payee.extension":"Extension","ExplanationOfBenefit.payee.id":"System.String","ExplanationOfBenefit.payee.modifierExtension":"Extension","ExplanationOfBenefit.payee.party":"Reference","ExplanationOfBenefit.payee.type":"CodeableConcept","ExplanationOfBenefit.payment.adjustment":"Money","ExplanationOfBenefit.payment.adjustmentReason":"CodeableConcept","ExplanationOfBenefit.payment.amount":"Money","ExplanationOfBenefit.payment.date":"date","ExplanationOfBenefit.payment.extension":"Extension","ExplanationOfBenefit.payment.id":"System.String","ExplanationOfBenefit.payment.identifier":"Identifier","ExplanationOfBenefit.payment.modifierExtension":"Extension","ExplanationOfBenefit.payment.type":"CodeableConcept","ExplanationOfBenefit.preAuthRef":"string","ExplanationOfBenefit.preAuthRefPeriod":"Period","ExplanationOfBenefit.precedence":"positiveInt","ExplanationOfBenefit.prescription":"Reference","ExplanationOfBenefit.priority":"CodeableConcept","ExplanationOfBenefit.procedure.date":"dateTime","ExplanationOfBenefit.procedure.extension":"Extension","ExplanationOfBenefit.procedure.id":"System.String","ExplanationOfBenefit.procedure.modifierExtension":"Extension","ExplanationOfBenefit.procedure.procedureCodeableConcept":"CodeableConcept","ExplanationOfBenefit.procedure.procedureReference":"Reference","ExplanationOfBenefit.procedure.sequence":"positiveInt","ExplanationOfBenefit.procedure.type":"CodeableConcept","ExplanationOfBenefit.procedure.udi":"Reference","ExplanationOfBenefit.processNote.extension":"Extension","ExplanationOfBenefit.processNote.id":"System.String","ExplanationOfBenefit.processNote.language":"CodeableConcept","ExplanationOfBenefit.processNote.modifierExtension":"Extension","ExplanationOfBenefit.processNote.number":"positiveInt","ExplanationOfBenefit.processNote.text":"string","ExplanationOfBenefit.processNote.type":"code","ExplanationOfBenefit.provider":"Reference","ExplanationOfBenefit.referral":"Reference","ExplanationOfBenefit.related.claim":"Reference","ExplanationOfBenefit.related.extension":"Extension","ExplanationOfBenefit.related.id":"System.String","ExplanationOfBenefit.related.modifierExtension":"Extension","ExplanationOfBenefit.related.reference":"Identifier","ExplanationOfBenefit.related.relationship":"CodeableConcept","ExplanationOfBenefit.status":"code","ExplanationOfBenefit.subType":"CodeableConcept","ExplanationOfBenefit.supportingInfo.category":"CodeableConcept","ExplanationOfBenefit.supportingInfo.code":"CodeableConcept","ExplanationOfBenefit.supportingInfo.extension":"Extension","ExplanationOfBenefit.supportingInfo.id":"System.String","ExplanationOfBenefit.supportingInfo.modifierExtension":"Extension","ExplanationOfBenefit.supportingInfo.reason":"Coding","ExplanationOfBenefit.supportingInfo.sequence":"positiveInt","ExplanationOfBenefit.supportingInfo.timingDate":"date","ExplanationOfBenefit.supportingInfo.timingPeriod":"Period","ExplanationOfBenefit.supportingInfo.valueAttachment":"Attachment","ExplanationOfBenefit.supportingInfo.valueBoolean":"boolean","ExplanationOfBenefit.supportingInfo.valueQuantity":"Quantity","ExplanationOfBenefit.supportingInfo.valueReference":"Reference","ExplanationOfBenefit.supportingInfo.valueString":"string","ExplanationOfBenefit.text":"Narrative","ExplanationOfBenefit.total.amount":"Money","ExplanationOfBenefit.total.category":"CodeableConcept","ExplanationOfBenefit.total.extension":"Extension","ExplanationOfBenefit.total.id":"System.String","ExplanationOfBenefit.total.modifierExtension":"Extension","ExplanationOfBenefit.type":"CodeableConcept","ExplanationOfBenefit.use":"code","Expression.description":"string","Expression.expression":"string","Expression.extension":"Extension","Expression.id":"System.String","Expression.language":"code","Expression.name":"id","Expression.reference":"uri","Extension.extension":"Extension","Extension.id":"System.String","Extension.url":"System.String","Extension.valueAddress":"Address","Extension.valueAge":"Age","Extension.valueAnnotation":"Annotation","Extension.valueAttachment":"Attachment","Extension.valueBase64Binary":"base64Binary","Extension.valueBoolean":"boolean","Extension.valueCanonical":"canonical","Extension.valueCode":"code","Extension.valueCodeableConcept":"CodeableConcept","Extension.valueCoding":"Coding","Extension.valueContactDetail":"ContactDetail","Extension.valueContactPoint":"ContactPoint","Extension.valueContributor":"Contributor","Extension.valueCount":"Count","Extension.valueDataRequirement":"DataRequirement","Extension.valueDate":"date","Extension.valueDateTime":"dateTime","Extension.valueDecimal":"decimal","Extension.valueDistance":"Distance","Extension.valueDosage":"Dosage","Extension.valueDuration":"Duration","Extension.valueExpression":"Expression","Extension.valueHumanName":"HumanName","Extension.valueId":"id","Extension.valueIdentifier":"Identifier","Extension.valueInstant":"instant","Extension.valueInteger":"integer","Extension.valueMarkdown":"markdown","Extension.valueMeta":"Meta","Extension.valueMoney":"Money","Extension.valueOid":"oid","Extension.valueParameterDefinition":"ParameterDefinition","Extension.valuePeriod":"Period","Extension.valuePositiveInt":"positiveInt","Extension.valueQuantity":"Quantity","Extension.valueRange":"Range","Extension.valueRatio":"Ratio","Extension.valueReference":"Reference","Extension.valueRelatedArtifact":"RelatedArtifact","Extension.valueSampledData":"SampledData","Extension.valueSignature":"Signature","Extension.valueString":"string","Extension.valueTime":"time","Extension.valueTiming":"Timing","Extension.valueTriggerDefinition":"TriggerDefinition","Extension.valueUnsignedInt":"unsignedInt","Extension.valueUri":"uri","Extension.valueUrl":"url","Extension.valueUsageContext":"UsageContext","Extension.valueUuid":"uuid","FamilyMemberHistory.ageAge":"Age","FamilyMemberHistory.ageRange":"Range","FamilyMemberHistory.ageString":"string","FamilyMemberHistory.bornDate":"date","FamilyMemberHistory.bornPeriod":"Period","FamilyMemberHistory.bornString":"string","FamilyMemberHistory.condition.code":"CodeableConcept","FamilyMemberHistory.condition.contributedToDeath":"boolean","FamilyMemberHistory.condition.extension":"Extension","FamilyMemberHistory.condition.id":"System.String","FamilyMemberHistory.condition.modifierExtension":"Extension","FamilyMemberHistory.condition.note":"Annotation","FamilyMemberHistory.condition.onsetAge":"Age","FamilyMemberHistory.condition.onsetPeriod":"Period","FamilyMemberHistory.condition.onsetRange":"Range","FamilyMemberHistory.condition.onsetString":"string","FamilyMemberHistory.condition.outcome":"CodeableConcept","FamilyMemberHistory.contained":"Resource","FamilyMemberHistory.dataAbsentReason":"CodeableConcept","FamilyMemberHistory.date":"dateTime","FamilyMemberHistory.deceasedAge":"Age","FamilyMemberHistory.deceasedBoolean":"boolean","FamilyMemberHistory.deceasedDate":"date","FamilyMemberHistory.deceasedRange":"Range","FamilyMemberHistory.deceasedString":"string","FamilyMemberHistory.estimatedAge":"boolean","FamilyMemberHistory.extension":"Extension","FamilyMemberHistory.id":"System.String","FamilyMemberHistory.identifier":"Identifier","FamilyMemberHistory.implicitRules":"uri","FamilyMemberHistory.instantiatesCanonical":"canonical","FamilyMemberHistory.instantiatesUri":"uri","FamilyMemberHistory.language":"code","FamilyMemberHistory.meta":"Meta","FamilyMemberHistory.modifierExtension":"Extension","FamilyMemberHistory.name":"string","FamilyMemberHistory.note":"Annotation","FamilyMemberHistory.patient":"Reference","FamilyMemberHistory.reasonCode":"CodeableConcept","FamilyMemberHistory.reasonReference":"Reference","FamilyMemberHistory.relationship":"CodeableConcept","FamilyMemberHistory.sex":"CodeableConcept","FamilyMemberHistory.status":"code","FamilyMemberHistory.text":"Narrative","Flag.author":"Reference","Flag.category":"CodeableConcept","Flag.code":"CodeableConcept","Flag.contained":"Resource","Flag.encounter":"Reference","Flag.extension":"Extension","Flag.id":"System.String","Flag.identifier":"Identifier","Flag.implicitRules":"uri","Flag.language":"code","Flag.meta":"Meta","Flag.modifierExtension":"Extension","Flag.period":"Period","Flag.status":"code","Flag.subject":"Reference","Flag.text":"Narrative","Goal.achievementStatus":"CodeableConcept","Goal.addresses":"Reference","Goal.category":"CodeableConcept","Goal.contained":"Resource","Goal.description":"CodeableConcept","Goal.expressedBy":"Reference","Goal.extension":"Extension","Goal.id":"System.String","Goal.identifier":"Identifier","Goal.implicitRules":"uri","Goal.language":"code","Goal.lifecycleStatus":"code","Goal.meta":"Meta","Goal.modifierExtension":"Extension","Goal.note":"Annotation","Goal.outcomeCode":"CodeableConcept","Goal.outcomeReference":"Reference","Goal.priority":"CodeableConcept","Goal.startCodeableConcept":"CodeableConcept","Goal.startDate":"date","Goal.statusDate":"date","Goal.statusReason":"string","Goal.subject":"Reference","Goal.target.detailBoolean":"boolean","Goal.target.detailCodeableConcept":"CodeableConcept","Goal.target.detailInteger":"integer","Goal.target.detailQuantity":"Quantity","Goal.target.detailRange":"Range","Goal.target.detailRatio":"Ratio","Goal.target.detailString":"string","Goal.target.dueDate":"date","Goal.target.dueDuration":"Duration","Goal.target.extension":"Extension","Goal.target.id":"System.String","Goal.target.measure":"CodeableConcept","Goal.target.modifierExtension":"Extension","Goal.text":"Narrative","GraphDefinition.contact":"ContactDetail","GraphDefinition.contained":"Resource","GraphDefinition.date":"dateTime","GraphDefinition.description":"markdown","GraphDefinition.experimental":"boolean","GraphDefinition.extension":"Extension","GraphDefinition.id":"System.String","GraphDefinition.implicitRules":"uri","GraphDefinition.jurisdiction":"CodeableConcept","GraphDefinition.language":"code","GraphDefinition.link.description":"string","GraphDefinition.link.extension":"Extension","GraphDefinition.link.id":"System.String","GraphDefinition.link.max":"string","GraphDefinition.link.min":"integer","GraphDefinition.link.modifierExtension":"Extension","GraphDefinition.link.path":"string","GraphDefinition.link.sliceName":"string","GraphDefinition.link.target.compartment.code":"code","GraphDefinition.link.target.compartment.description":"string","GraphDefinition.link.target.compartment.expression":"string","GraphDefinition.link.target.compartment.extension":"Extension","GraphDefinition.link.target.compartment.id":"System.String","GraphDefinition.link.target.compartment.modifierExtension":"Extension","GraphDefinition.link.target.compartment.rule":"code","GraphDefinition.link.target.compartment.use":"code","GraphDefinition.link.target.extension":"Extension","GraphDefinition.link.target.id":"System.String","GraphDefinition.link.target.modifierExtension":"Extension","GraphDefinition.link.target.params":"string","GraphDefinition.link.target.profile":"canonical","GraphDefinition.link.target.type":"code","GraphDefinition.meta":"Meta","GraphDefinition.modifierExtension":"Extension","GraphDefinition.name":"string","GraphDefinition.profile":"canonical","GraphDefinition.publisher":"string","GraphDefinition.purpose":"markdown","GraphDefinition.start":"code","GraphDefinition.status":"code","GraphDefinition.text":"Narrative","GraphDefinition.url":"uri","GraphDefinition.useContext":"UsageContext","GraphDefinition.version":"string","Group.active":"boolean","Group.actual":"boolean","Group.characteristic.code":"CodeableConcept","Group.characteristic.exclude":"boolean","Group.characteristic.extension":"Extension","Group.characteristic.id":"System.String","Group.characteristic.modifierExtension":"Extension","Group.characteristic.period":"Period","Group.characteristic.valueBoolean":"boolean","Group.characteristic.valueCodeableConcept":"CodeableConcept","Group.characteristic.valueQuantity":"Quantity","Group.characteristic.valueRange":"Range","Group.characteristic.valueReference":"Reference","Group.code":"CodeableConcept","Group.contained":"Resource","Group.extension":"Extension","Group.id":"System.String","Group.identifier":"Identifier","Group.implicitRules":"uri","Group.language":"code","Group.managingEntity":"Reference","Group.member.entity":"Reference","Group.member.extension":"Extension","Group.member.id":"System.String","Group.member.inactive":"boolean","Group.member.modifierExtension":"Extension","Group.member.period":"Period","Group.meta":"Meta","Group.modifierExtension":"Extension","Group.name":"string","Group.quantity":"unsignedInt","Group.text":"Narrative","Group.type":"code","GuidanceResponse.contained":"Resource","GuidanceResponse.dataRequirement":"DataRequirement","GuidanceResponse.encounter":"Reference","GuidanceResponse.evaluationMessage":"Reference","GuidanceResponse.extension":"Extension","GuidanceResponse.id":"System.String","GuidanceResponse.identifier":"Identifier","GuidanceResponse.implicitRules":"uri","GuidanceResponse.language":"code","GuidanceResponse.meta":"Meta","GuidanceResponse.modifierExtension":"Extension","GuidanceResponse.moduleCanonical":"canonical","GuidanceResponse.moduleCodeableConcept":"CodeableConcept","GuidanceResponse.moduleUri":"uri","GuidanceResponse.note":"Annotation","GuidanceResponse.occurrenceDateTime":"dateTime","GuidanceResponse.outputParameters":"Reference","GuidanceResponse.performer":"Reference","GuidanceResponse.reasonCode":"CodeableConcept","GuidanceResponse.reasonReference":"Reference","GuidanceResponse.requestIdentifier":"Identifier","GuidanceResponse.result":"Reference","GuidanceResponse.status":"code","GuidanceResponse.subject":"Reference","GuidanceResponse.text":"Narrative","HealthcareService.active":"boolean","HealthcareService.appointmentRequired":"boolean","HealthcareService.availabilityExceptions":"string","HealthcareService.availableTime.allDay":"boolean","HealthcareService.availableTime.availableEndTime":"time","HealthcareService.availableTime.availableStartTime":"time","HealthcareService.availableTime.daysOfWeek":"code","HealthcareService.availableTime.extension":"Extension","HealthcareService.availableTime.id":"System.String","HealthcareService.availableTime.modifierExtension":"Extension","HealthcareService.category":"CodeableConcept","HealthcareService.characteristic":"CodeableConcept","HealthcareService.comment":"string","HealthcareService.communication":"CodeableConcept","HealthcareService.contained":"Resource","HealthcareService.coverageArea":"Reference","HealthcareService.eligibility.code":"CodeableConcept","HealthcareService.eligibility.comment":"markdown","HealthcareService.eligibility.extension":"Extension","HealthcareService.eligibility.id":"System.String","HealthcareService.eligibility.modifierExtension":"Extension","HealthcareService.endpoint":"Reference","HealthcareService.extension":"Extension","HealthcareService.extraDetails":"markdown","HealthcareService.id":"System.String","HealthcareService.identifier":"Identifier","HealthcareService.implicitRules":"uri","HealthcareService.language":"code","HealthcareService.location":"Reference","HealthcareService.meta":"Meta","HealthcareService.modifierExtension":"Extension","HealthcareService.name":"string","HealthcareService.notAvailable.description":"string","HealthcareService.notAvailable.during":"Period","HealthcareService.notAvailable.extension":"Extension","HealthcareService.notAvailable.id":"System.String","HealthcareService.notAvailable.modifierExtension":"Extension","HealthcareService.photo":"Attachment","HealthcareService.program":"CodeableConcept","HealthcareService.providedBy":"Reference","HealthcareService.referralMethod":"CodeableConcept","HealthcareService.serviceProvisionCode":"CodeableConcept","HealthcareService.specialty":"CodeableConcept","HealthcareService.telecom":"ContactPoint","HealthcareService.text":"Narrative","HealthcareService.type":"CodeableConcept","HumanName.extension":"Extension","HumanName.family":"string","HumanName.given":"string","HumanName.id":"System.String","HumanName.period":"Period","HumanName.prefix":"string","HumanName.suffix":"string","HumanName.text":"string","HumanName.use":"code","Identifier.assigner":"Reference","Identifier.extension":"Extension","Identifier.id":"System.String","Identifier.period":"Period","Identifier.system":"uri","Identifier.type":"CodeableConcept","Identifier.use":"code","Identifier.value":"string","ImagingStudy.basedOn":"Reference","ImagingStudy.contained":"Resource","ImagingStudy.description":"string","ImagingStudy.encounter":"Reference","ImagingStudy.endpoint":"Reference","ImagingStudy.extension":"Extension","ImagingStudy.id":"System.String","ImagingStudy.identifier":"Identifier","ImagingStudy.implicitRules":"uri","ImagingStudy.interpreter":"Reference","ImagingStudy.language":"code","ImagingStudy.location":"Reference","ImagingStudy.meta":"Meta","ImagingStudy.modality":"Coding","ImagingStudy.modifierExtension":"Extension","ImagingStudy.note":"Annotation","ImagingStudy.numberOfInstances":"unsignedInt","ImagingStudy.numberOfSeries":"unsignedInt","ImagingStudy.procedureCode":"CodeableConcept","ImagingStudy.procedureReference":"Reference","ImagingStudy.reasonCode":"CodeableConcept","ImagingStudy.reasonReference":"Reference","ImagingStudy.referrer":"Reference","ImagingStudy.series.bodySite":"Coding","ImagingStudy.series.description":"string","ImagingStudy.series.endpoint":"Reference","ImagingStudy.series.extension":"Extension","ImagingStudy.series.id":"System.String","ImagingStudy.series.instance.extension":"Extension","ImagingStudy.series.instance.id":"System.String","ImagingStudy.series.instance.modifierExtension":"Extension","ImagingStudy.series.instance.number":"unsignedInt","ImagingStudy.series.instance.sopClass":"Coding","ImagingStudy.series.instance.title":"string","ImagingStudy.series.instance.uid":"id","ImagingStudy.series.laterality":"Coding","ImagingStudy.series.modality":"Coding","ImagingStudy.series.modifierExtension":"Extension","ImagingStudy.series.number":"unsignedInt","ImagingStudy.series.numberOfInstances":"unsignedInt","ImagingStudy.series.performer.actor":"Reference","ImagingStudy.series.performer.extension":"Extension","ImagingStudy.series.performer.function":"CodeableConcept","ImagingStudy.series.performer.id":"System.String","ImagingStudy.series.performer.modifierExtension":"Extension","ImagingStudy.series.specimen":"Reference","ImagingStudy.series.started":"dateTime","ImagingStudy.series.uid":"id","ImagingStudy.started":"dateTime","ImagingStudy.status":"code","ImagingStudy.subject":"Reference","ImagingStudy.text":"Narrative","Immunization.contained":"Resource","Immunization.doseQuantity":"Quantity","Immunization.education.documentType":"string","Immunization.education.extension":"Extension","Immunization.education.id":"System.String","Immunization.education.modifierExtension":"Extension","Immunization.education.presentationDate":"dateTime","Immunization.education.publicationDate":"dateTime","Immunization.education.reference":"uri","Immunization.encounter":"Reference","Immunization.expirationDate":"date","Immunization.extension":"Extension","Immunization.fundingSource":"CodeableConcept","Immunization.id":"System.String","Immunization.identifier":"Identifier","Immunization.implicitRules":"uri","Immunization.isSubpotent":"boolean","Immunization.language":"code","Immunization.location":"Reference","Immunization.lotNumber":"string","Immunization.manufacturer":"Reference","Immunization.meta":"Meta","Immunization.modifierExtension":"Extension","Immunization.note":"Annotation","Immunization.occurrenceDateTime":"dateTime","Immunization.occurrenceString":"string","Immunization.patient":"Reference","Immunization.performer.actor":"Reference","Immunization.performer.extension":"Extension","Immunization.performer.function":"CodeableConcept","Immunization.performer.id":"System.String","Immunization.performer.modifierExtension":"Extension","Immunization.primarySource":"boolean","Immunization.programEligibility":"CodeableConcept","Immunization.protocolApplied.authority":"Reference","Immunization.protocolApplied.doseNumberPositiveInt":"positiveInt","Immunization.protocolApplied.doseNumberString":"string","Immunization.protocolApplied.extension":"Extension","Immunization.protocolApplied.id":"System.String","Immunization.protocolApplied.modifierExtension":"Extension","Immunization.protocolApplied.series":"string","Immunization.protocolApplied.seriesDosesPositiveInt":"positiveInt","Immunization.protocolApplied.seriesDosesString":"string","Immunization.protocolApplied.targetDisease":"CodeableConcept","Immunization.reaction.date":"dateTime","Immunization.reaction.detail":"Reference","Immunization.reaction.extension":"Extension","Immunization.reaction.id":"System.String","Immunization.reaction.modifierExtension":"Extension","Immunization.reaction.reported":"boolean","Immunization.reasonCode":"CodeableConcept","Immunization.reasonReference":"Reference","Immunization.recorded":"dateTime","Immunization.reportOrigin":"CodeableConcept","Immunization.route":"CodeableConcept","Immunization.site":"CodeableConcept","Immunization.status":"code","Immunization.statusReason":"CodeableConcept","Immunization.subpotentReason":"CodeableConcept","Immunization.text":"Narrative","Immunization.vaccineCode":"CodeableConcept","ImmunizationEvaluation.authority":"Reference","ImmunizationEvaluation.contained":"Resource","ImmunizationEvaluation.date":"dateTime","ImmunizationEvaluation.description":"string","ImmunizationEvaluation.doseNumberPositiveInt":"positiveInt","ImmunizationEvaluation.doseNumberString":"string","ImmunizationEvaluation.doseStatus":"CodeableConcept","ImmunizationEvaluation.doseStatusReason":"CodeableConcept","ImmunizationEvaluation.extension":"Extension","ImmunizationEvaluation.id":"System.String","ImmunizationEvaluation.identifier":"Identifier","ImmunizationEvaluation.immunizationEvent":"Reference","ImmunizationEvaluation.implicitRules":"uri","ImmunizationEvaluation.language":"code","ImmunizationEvaluation.meta":"Meta","ImmunizationEvaluation.modifierExtension":"Extension","ImmunizationEvaluation.patient":"Reference","ImmunizationEvaluation.series":"string","ImmunizationEvaluation.seriesDosesPositiveInt":"positiveInt","ImmunizationEvaluation.seriesDosesString":"string","ImmunizationEvaluation.status":"code","ImmunizationEvaluation.targetDisease":"CodeableConcept","ImmunizationEvaluation.text":"Narrative","ImmunizationRecommendation.authority":"Reference","ImmunizationRecommendation.contained":"Resource","ImmunizationRecommendation.date":"dateTime","ImmunizationRecommendation.extension":"Extension","ImmunizationRecommendation.id":"System.String","ImmunizationRecommendation.identifier":"Identifier","ImmunizationRecommendation.implicitRules":"uri","ImmunizationRecommendation.language":"code","ImmunizationRecommendation.meta":"Meta","ImmunizationRecommendation.modifierExtension":"Extension","ImmunizationRecommendation.patient":"Reference","ImmunizationRecommendation.recommendation.contraindicatedVaccineCode":"CodeableConcept","ImmunizationRecommendation.recommendation.dateCriterion.code":"CodeableConcept","ImmunizationRecommendation.recommendation.dateCriterion.extension":"Extension","ImmunizationRecommendation.recommendation.dateCriterion.id":"System.String","ImmunizationRecommendation.recommendation.dateCriterion.modifierExtension":"Extension","ImmunizationRecommendation.recommendation.dateCriterion.value":"dateTime","ImmunizationRecommendation.recommendation.description":"string","ImmunizationRecommendation.recommendation.doseNumberPositiveInt":"positiveInt","ImmunizationRecommendation.recommendation.doseNumberString":"string","ImmunizationRecommendation.recommendation.extension":"Extension","ImmunizationRecommendation.recommendation.forecastReason":"CodeableConcept","ImmunizationRecommendation.recommendation.forecastStatus":"CodeableConcept","ImmunizationRecommendation.recommendation.id":"System.String","ImmunizationRecommendation.recommendation.modifierExtension":"Extension","ImmunizationRecommendation.recommendation.series":"string","ImmunizationRecommendation.recommendation.seriesDosesPositiveInt":"positiveInt","ImmunizationRecommendation.recommendation.seriesDosesString":"string","ImmunizationRecommendation.recommendation.supportingImmunization":"Reference","ImmunizationRecommendation.recommendation.supportingPatientInformation":"Reference","ImmunizationRecommendation.recommendation.targetDisease":"CodeableConcept","ImmunizationRecommendation.recommendation.vaccineCode":"CodeableConcept","ImmunizationRecommendation.text":"Narrative","ImplementationGuide.contact":"ContactDetail","ImplementationGuide.contained":"Resource","ImplementationGuide.copyright":"markdown","ImplementationGuide.date":"dateTime","ImplementationGuide.definition.extension":"Extension","ImplementationGuide.definition.grouping.description":"string","ImplementationGuide.definition.grouping.extension":"Extension","ImplementationGuide.definition.grouping.id":"System.String","ImplementationGuide.definition.grouping.modifierExtension":"Extension","ImplementationGuide.definition.grouping.name":"string","ImplementationGuide.definition.id":"System.String","ImplementationGuide.definition.modifierExtension":"Extension","ImplementationGuide.definition.page.extension":"Extension","ImplementationGuide.definition.page.generation":"code","ImplementationGuide.definition.page.id":"System.String","ImplementationGuide.definition.page.modifierExtension":"Extension","ImplementationGuide.definition.page.nameReference":"Reference","ImplementationGuide.definition.page.nameUrl":"url","ImplementationGuide.definition.page.title":"string","ImplementationGuide.definition.parameter.code":"code","ImplementationGuide.definition.parameter.extension":"Extension","ImplementationGuide.definition.parameter.id":"System.String","ImplementationGuide.definition.parameter.modifierExtension":"Extension","ImplementationGuide.definition.parameter.value":"string","ImplementationGuide.definition.resource.description":"string","ImplementationGuide.definition.resource.exampleBoolean":"boolean","ImplementationGuide.definition.resource.exampleCanonical":"canonical","ImplementationGuide.definition.resource.extension":"Extension","ImplementationGuide.definition.resource.fhirVersion":"code","ImplementationGuide.definition.resource.groupingId":"id","ImplementationGuide.definition.resource.id":"System.String","ImplementationGuide.definition.resource.modifierExtension":"Extension","ImplementationGuide.definition.resource.name":"string","ImplementationGuide.definition.resource.reference":"Reference","ImplementationGuide.definition.template.code":"code","ImplementationGuide.definition.template.extension":"Extension","ImplementationGuide.definition.template.id":"System.String","ImplementationGuide.definition.template.modifierExtension":"Extension","ImplementationGuide.definition.template.scope":"string","ImplementationGuide.definition.template.source":"string","ImplementationGuide.dependsOn.extension":"Extension","ImplementationGuide.dependsOn.id":"System.String","ImplementationGuide.dependsOn.modifierExtension":"Extension","ImplementationGuide.dependsOn.packageId":"id","ImplementationGuide.dependsOn.uri":"canonical","ImplementationGuide.dependsOn.version":"string","ImplementationGuide.description":"markdown","ImplementationGuide.experimental":"boolean","ImplementationGuide.extension":"Extension","ImplementationGuide.fhirVersion":"code","ImplementationGuide.global.extension":"Extension","ImplementationGuide.global.id":"System.String","ImplementationGuide.global.modifierExtension":"Extension","ImplementationGuide.global.profile":"canonical","ImplementationGuide.global.type":"code","ImplementationGuide.id":"System.String","ImplementationGuide.implicitRules":"uri","ImplementationGuide.jurisdiction":"CodeableConcept","ImplementationGuide.language":"code","ImplementationGuide.license":"code","ImplementationGuide.manifest.extension":"Extension","ImplementationGuide.manifest.id":"System.String","ImplementationGuide.manifest.image":"string","ImplementationGuide.manifest.modifierExtension":"Extension","ImplementationGuide.manifest.other":"string","ImplementationGuide.manifest.page.anchor":"string","ImplementationGuide.manifest.page.extension":"Extension","ImplementationGuide.manifest.page.id":"System.String","ImplementationGuide.manifest.page.modifierExtension":"Extension","ImplementationGuide.manifest.page.name":"string","ImplementationGuide.manifest.page.title":"string","ImplementationGuide.manifest.rendering":"url","ImplementationGuide.manifest.resource.exampleBoolean":"boolean","ImplementationGuide.manifest.resource.exampleCanonical":"canonical","ImplementationGuide.manifest.resource.extension":"Extension","ImplementationGuide.manifest.resource.id":"System.String","ImplementationGuide.manifest.resource.modifierExtension":"Extension","ImplementationGuide.manifest.resource.reference":"Reference","ImplementationGuide.manifest.resource.relativePath":"url","ImplementationGuide.meta":"Meta","ImplementationGuide.modifierExtension":"Extension","ImplementationGuide.name":"string","ImplementationGuide.packageId":"id","ImplementationGuide.publisher":"string","ImplementationGuide.status":"code","ImplementationGuide.text":"Narrative","ImplementationGuide.title":"string","ImplementationGuide.url":"uri","ImplementationGuide.useContext":"UsageContext","ImplementationGuide.version":"string","InsurancePlan.administeredBy":"Reference","InsurancePlan.alias":"string","InsurancePlan.contact.address":"Address","InsurancePlan.contact.extension":"Extension","InsurancePlan.contact.id":"System.String","InsurancePlan.contact.modifierExtension":"Extension","InsurancePlan.contact.name":"HumanName","InsurancePlan.contact.purpose":"CodeableConcept","InsurancePlan.contact.telecom":"ContactPoint","InsurancePlan.contained":"Resource","InsurancePlan.coverage.benefit.extension":"Extension","InsurancePlan.coverage.benefit.id":"System.String","InsurancePlan.coverage.benefit.limit.code":"CodeableConcept","InsurancePlan.coverage.benefit.limit.extension":"Extension","InsurancePlan.coverage.benefit.limit.id":"System.String","InsurancePlan.coverage.benefit.limit.modifierExtension":"Extension","InsurancePlan.coverage.benefit.limit.value":"Quantity","InsurancePlan.coverage.benefit.modifierExtension":"Extension","InsurancePlan.coverage.benefit.requirement":"string","InsurancePlan.coverage.benefit.type":"CodeableConcept","InsurancePlan.coverage.extension":"Extension","InsurancePlan.coverage.id":"System.String","InsurancePlan.coverage.modifierExtension":"Extension","InsurancePlan.coverage.network":"Reference","InsurancePlan.coverage.type":"CodeableConcept","InsurancePlan.coverageArea":"Reference","InsurancePlan.endpoint":"Reference","InsurancePlan.extension":"Extension","InsurancePlan.id":"System.String","InsurancePlan.identifier":"Identifier","InsurancePlan.implicitRules":"uri","InsurancePlan.language":"code","InsurancePlan.meta":"Meta","InsurancePlan.modifierExtension":"Extension","InsurancePlan.name":"string","InsurancePlan.network":"Reference","InsurancePlan.ownedBy":"Reference","InsurancePlan.period":"Period","InsurancePlan.plan.coverageArea":"Reference","InsurancePlan.plan.extension":"Extension","InsurancePlan.plan.generalCost.comment":"string","InsurancePlan.plan.generalCost.cost":"Money","InsurancePlan.plan.generalCost.extension":"Extension","InsurancePlan.plan.generalCost.groupSize":"positiveInt","InsurancePlan.plan.generalCost.id":"System.String","InsurancePlan.plan.generalCost.modifierExtension":"Extension","InsurancePlan.plan.generalCost.type":"CodeableConcept","InsurancePlan.plan.id":"System.String","InsurancePlan.plan.identifier":"Identifier","InsurancePlan.plan.modifierExtension":"Extension","InsurancePlan.plan.network":"Reference","InsurancePlan.plan.specificCost.benefit.cost.applicability":"CodeableConcept","InsurancePlan.plan.specificCost.benefit.cost.extension":"Extension","InsurancePlan.plan.specificCost.benefit.cost.id":"System.String","InsurancePlan.plan.specificCost.benefit.cost.modifierExtension":"Extension","InsurancePlan.plan.specificCost.benefit.cost.qualifiers":"CodeableConcept","InsurancePlan.plan.specificCost.benefit.cost.type":"CodeableConcept","InsurancePlan.plan.specificCost.benefit.cost.value":"Quantity","InsurancePlan.plan.specificCost.benefit.extension":"Extension","InsurancePlan.plan.specificCost.benefit.id":"System.String","InsurancePlan.plan.specificCost.benefit.modifierExtension":"Extension","InsurancePlan.plan.specificCost.benefit.type":"CodeableConcept","InsurancePlan.plan.specificCost.category":"CodeableConcept","InsurancePlan.plan.specificCost.extension":"Extension","InsurancePlan.plan.specificCost.id":"System.String","InsurancePlan.plan.specificCost.modifierExtension":"Extension","InsurancePlan.plan.type":"CodeableConcept","InsurancePlan.status":"code","InsurancePlan.text":"Narrative","InsurancePlan.type":"CodeableConcept","Invoice.account":"Reference","Invoice.cancelledReason":"string","Invoice.contained":"Resource","Invoice.date":"dateTime","Invoice.extension":"Extension","Invoice.id":"System.String","Invoice.identifier":"Identifier","Invoice.implicitRules":"uri","Invoice.issuer":"Reference","Invoice.language":"code","Invoice.lineItem.chargeItemCodeableConcept":"CodeableConcept","Invoice.lineItem.chargeItemReference":"Reference","Invoice.lineItem.extension":"Extension","Invoice.lineItem.id":"System.String","Invoice.lineItem.modifierExtension":"Extension","Invoice.lineItem.priceComponent.amount":"Money","Invoice.lineItem.priceComponent.code":"CodeableConcept","Invoice.lineItem.priceComponent.extension":"Extension","Invoice.lineItem.priceComponent.factor":"decimal","Invoice.lineItem.priceComponent.id":"System.String","Invoice.lineItem.priceComponent.modifierExtension":"Extension","Invoice.lineItem.priceComponent.type":"code","Invoice.lineItem.sequence":"positiveInt","Invoice.meta":"Meta","Invoice.modifierExtension":"Extension","Invoice.note":"Annotation","Invoice.participant.actor":"Reference","Invoice.participant.extension":"Extension","Invoice.participant.id":"System.String","Invoice.participant.modifierExtension":"Extension","Invoice.participant.role":"CodeableConcept","Invoice.paymentTerms":"markdown","Invoice.recipient":"Reference","Invoice.status":"code","Invoice.subject":"Reference","Invoice.text":"Narrative","Invoice.totalGross":"Money","Invoice.totalNet":"Money","Invoice.type":"CodeableConcept","Library.approvalDate":"date","Library.author":"ContactDetail","Library.contact":"ContactDetail","Library.contained":"Resource","Library.content":"Attachment","Library.copyright":"markdown","Library.dataRequirement":"DataRequirement","Library.date":"dateTime","Library.description":"markdown","Library.editor":"ContactDetail","Library.effectivePeriod":"Period","Library.endorser":"ContactDetail","Library.experimental":"boolean","Library.extension":"Extension","Library.id":"System.String","Library.identifier":"Identifier","Library.implicitRules":"uri","Library.jurisdiction":"CodeableConcept","Library.language":"code","Library.lastReviewDate":"date","Library.meta":"Meta","Library.modifierExtension":"Extension","Library.name":"string","Library.parameter":"ParameterDefinition","Library.publisher":"string","Library.purpose":"markdown","Library.relatedArtifact":"RelatedArtifact","Library.reviewer":"ContactDetail","Library.status":"code","Library.subjectCodeableConcept":"CodeableConcept","Library.subjectReference":"Reference","Library.subtitle":"string","Library.text":"Narrative","Library.title":"string","Library.topic":"CodeableConcept","Library.type":"CodeableConcept","Library.url":"uri","Library.usage":"string","Library.useContext":"UsageContext","Library.version":"string","Linkage.active":"boolean","Linkage.author":"Reference","Linkage.contained":"Resource","Linkage.extension":"Extension","Linkage.id":"System.String","Linkage.implicitRules":"uri","Linkage.item.extension":"Extension","Linkage.item.id":"System.String","Linkage.item.modifierExtension":"Extension","Linkage.item.resource":"Reference","Linkage.item.type":"code","Linkage.language":"code","Linkage.meta":"Meta","Linkage.modifierExtension":"Extension","Linkage.text":"Narrative","List.code":"CodeableConcept","List.contained":"Resource","List.date":"dateTime","List.emptyReason":"CodeableConcept","List.encounter":"Reference","List.entry.date":"dateTime","List.entry.deleted":"boolean","List.entry.extension":"Extension","List.entry.flag":"CodeableConcept","List.entry.id":"System.String","List.entry.item":"Reference","List.entry.modifierExtension":"Extension","List.extension":"Extension","List.id":"System.String","List.identifier":"Identifier","List.implicitRules":"uri","List.language":"code","List.meta":"Meta","List.mode":"code","List.modifierExtension":"Extension","List.note":"Annotation","List.orderedBy":"CodeableConcept","List.source":"Reference","List.status":"code","List.subject":"Reference","List.text":"Narrative","List.title":"string","Location.address":"Address","Location.alias":"string","Location.availabilityExceptions":"string","Location.contained":"Resource","Location.description":"string","Location.endpoint":"Reference","Location.extension":"Extension","Location.hoursOfOperation.allDay":"boolean","Location.hoursOfOperation.closingTime":"time","Location.hoursOfOperation.daysOfWeek":"code","Location.hoursOfOperation.extension":"Extension","Location.hoursOfOperation.id":"System.String","Location.hoursOfOperation.modifierExtension":"Extension","Location.hoursOfOperation.openingTime":"time","Location.id":"System.String","Location.identifier":"Identifier","Location.implicitRules":"uri","Location.language":"code","Location.managingOrganization":"Reference","Location.meta":"Meta","Location.mode":"code","Location.modifierExtension":"Extension","Location.name":"string","Location.operationalStatus":"Coding","Location.partOf":"Reference","Location.physicalType":"CodeableConcept","Location.position.altitude":"decimal","Location.position.extension":"Extension","Location.position.id":"System.String","Location.position.latitude":"decimal","Location.position.longitude":"decimal","Location.position.modifierExtension":"Extension","Location.status":"code","Location.telecom":"ContactPoint","Location.text":"Narrative","Location.type":"CodeableConcept","MarketingStatus.country":"CodeableConcept","MarketingStatus.dateRange":"Period","MarketingStatus.extension":"Extension","MarketingStatus.id":"System.String","MarketingStatus.jurisdiction":"CodeableConcept","MarketingStatus.modifierExtension":"Extension","MarketingStatus.restoreDate":"dateTime","MarketingStatus.status":"CodeableConcept","Measure.approvalDate":"date","Measure.author":"ContactDetail","Measure.clinicalRecommendationStatement":"markdown","Measure.compositeScoring":"CodeableConcept","Measure.contact":"ContactDetail","Measure.contained":"Resource","Measure.copyright":"markdown","Measure.date":"dateTime","Measure.definition":"markdown","Measure.description":"markdown","Measure.disclaimer":"markdown","Measure.editor":"ContactDetail","Measure.effectivePeriod":"Period","Measure.endorser":"ContactDetail","Measure.experimental":"boolean","Measure.extension":"Extension","Measure.group.code":"CodeableConcept","Measure.group.description":"string","Measure.group.extension":"Extension","Measure.group.id":"System.String","Measure.group.modifierExtension":"Extension","Measure.group.population.code":"CodeableConcept","Measure.group.population.criteria":"Expression","Measure.group.population.description":"string","Measure.group.population.extension":"Extension","Measure.group.population.id":"System.String","Measure.group.population.modifierExtension":"Extension","Measure.group.stratifier.code":"CodeableConcept","Measure.group.stratifier.component.code":"CodeableConcept","Measure.group.stratifier.component.criteria":"Expression","Measure.group.stratifier.component.description":"string","Measure.group.stratifier.component.extension":"Extension","Measure.group.stratifier.component.id":"System.String","Measure.group.stratifier.component.modifierExtension":"Extension","Measure.group.stratifier.criteria":"Expression","Measure.group.stratifier.description":"string","Measure.group.stratifier.extension":"Extension","Measure.group.stratifier.id":"System.String","Measure.group.stratifier.modifierExtension":"Extension","Measure.guidance":"markdown","Measure.id":"System.String","Measure.identifier":"Identifier","Measure.implicitRules":"uri","Measure.improvementNotation":"CodeableConcept","Measure.jurisdiction":"CodeableConcept","Measure.language":"code","Measure.lastReviewDate":"date","Measure.library":"canonical","Measure.meta":"Meta","Measure.modifierExtension":"Extension","Measure.name":"string","Measure.publisher":"string","Measure.purpose":"markdown","Measure.rateAggregation":"string","Measure.rationale":"markdown","Measure.relatedArtifact":"RelatedArtifact","Measure.reviewer":"ContactDetail","Measure.riskAdjustment":"string","Measure.scoring":"CodeableConcept","Measure.status":"code","Measure.subjectCodeableConcept":"CodeableConcept","Measure.subjectReference":"Reference","Measure.subtitle":"string","Measure.supplementalData.code":"CodeableConcept","Measure.supplementalData.criteria":"Expression","Measure.supplementalData.description":"string","Measure.supplementalData.extension":"Extension","Measure.supplementalData.id":"System.String","Measure.supplementalData.modifierExtension":"Extension","Measure.supplementalData.usage":"CodeableConcept","Measure.text":"Narrative","Measure.title":"string","Measure.topic":"CodeableConcept","Measure.type":"CodeableConcept","Measure.url":"uri","Measure.usage":"string","Measure.useContext":"UsageContext","Measure.version":"string","MeasureReport.contained":"Resource","MeasureReport.date":"dateTime","MeasureReport.evaluatedResource":"Reference","MeasureReport.extension":"Extension","MeasureReport.group.code":"CodeableConcept","MeasureReport.group.extension":"Extension","MeasureReport.group.id":"System.String","MeasureReport.group.measureScore":"Quantity","MeasureReport.group.modifierExtension":"Extension","MeasureReport.group.population.code":"CodeableConcept","MeasureReport.group.population.count":"integer","MeasureReport.group.population.extension":"Extension","MeasureReport.group.population.id":"System.String","MeasureReport.group.population.modifierExtension":"Extension","MeasureReport.group.population.subjectResults":"Reference","MeasureReport.group.stratifier.code":"CodeableConcept","MeasureReport.group.stratifier.extension":"Extension","MeasureReport.group.stratifier.id":"System.String","MeasureReport.group.stratifier.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum.component.code":"CodeableConcept","MeasureReport.group.stratifier.stratum.component.extension":"Extension","MeasureReport.group.stratifier.stratum.component.id":"System.String","MeasureReport.group.stratifier.stratum.component.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum.component.value":"CodeableConcept","MeasureReport.group.stratifier.stratum.extension":"Extension","MeasureReport.group.stratifier.stratum.id":"System.String","MeasureReport.group.stratifier.stratum.measureScore":"Quantity","MeasureReport.group.stratifier.stratum.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum.population.code":"CodeableConcept","MeasureReport.group.stratifier.stratum.population.count":"integer","MeasureReport.group.stratifier.stratum.population.extension":"Extension","MeasureReport.group.stratifier.stratum.population.id":"System.String","MeasureReport.group.stratifier.stratum.population.modifierExtension":"Extension","MeasureReport.group.stratifier.stratum.population.subjectResults":"Reference","MeasureReport.group.stratifier.stratum.value":"CodeableConcept","MeasureReport.id":"System.String","MeasureReport.identifier":"Identifier","MeasureReport.implicitRules":"uri","MeasureReport.improvementNotation":"CodeableConcept","MeasureReport.language":"code","MeasureReport.measure":"canonical","MeasureReport.meta":"Meta","MeasureReport.modifierExtension":"Extension","MeasureReport.period":"Period","MeasureReport.reporter":"Reference","MeasureReport.status":"code","MeasureReport.subject":"Reference","MeasureReport.text":"Narrative","MeasureReport.type":"code","Media.basedOn":"Reference","Media.bodySite":"CodeableConcept","Media.contained":"Resource","Media.content":"Attachment","Media.createdDateTime":"dateTime","Media.createdPeriod":"Period","Media.device":"Reference","Media.deviceName":"string","Media.duration":"decimal","Media.encounter":"Reference","Media.extension":"Extension","Media.frames":"positiveInt","Media.height":"positiveInt","Media.id":"System.String","Media.identifier":"Identifier","Media.implicitRules":"uri","Media.issued":"instant","Media.language":"code","Media.meta":"Meta","Media.modality":"CodeableConcept","Media.modifierExtension":"Extension","Media.note":"Annotation","Media.operator":"Reference","Media.partOf":"Reference","Media.reasonCode":"CodeableConcept","Media.status":"code","Media.subject":"Reference","Media.text":"Narrative","Media.type":"CodeableConcept","Media.view":"CodeableConcept","Media.width":"positiveInt","Medication.amount":"Ratio","Medication.batch.expirationDate":"dateTime","Medication.batch.extension":"Extension","Medication.batch.id":"System.String","Medication.batch.lotNumber":"string","Medication.batch.modifierExtension":"Extension","Medication.code":"CodeableConcept","Medication.contained":"Resource","Medication.extension":"Extension","Medication.form":"CodeableConcept","Medication.id":"System.String","Medication.identifier":"Identifier","Medication.implicitRules":"uri","Medication.ingredient.extension":"Extension","Medication.ingredient.id":"System.String","Medication.ingredient.isActive":"boolean","Medication.ingredient.itemCodeableConcept":"CodeableConcept","Medication.ingredient.itemReference":"Reference","Medication.ingredient.modifierExtension":"Extension","Medication.ingredient.strength":"Ratio","Medication.language":"code","Medication.manufacturer":"Reference","Medication.meta":"Meta","Medication.modifierExtension":"Extension","Medication.status":"code","Medication.text":"Narrative","MedicationAdministration.category":"CodeableConcept","MedicationAdministration.contained":"Resource","MedicationAdministration.context":"Reference","MedicationAdministration.device":"Reference","MedicationAdministration.dosage.dose":"Quantity","MedicationAdministration.dosage.extension":"Extension","MedicationAdministration.dosage.id":"System.String","MedicationAdministration.dosage.method":"CodeableConcept","MedicationAdministration.dosage.modifierExtension":"Extension","MedicationAdministration.dosage.rateQuantity":"Quantity","MedicationAdministration.dosage.rateRatio":"Ratio","MedicationAdministration.dosage.route":"CodeableConcept","MedicationAdministration.dosage.site":"CodeableConcept","MedicationAdministration.dosage.text":"string","MedicationAdministration.effectiveDateTime":"dateTime","MedicationAdministration.effectivePeriod":"Period","MedicationAdministration.eventHistory":"Reference","MedicationAdministration.extension":"Extension","MedicationAdministration.id":"System.String","MedicationAdministration.identifier":"Identifier","MedicationAdministration.implicitRules":"uri","MedicationAdministration.instantiates":"uri","MedicationAdministration.language":"code","MedicationAdministration.medicationCodeableConcept":"CodeableConcept","MedicationAdministration.medicationReference":"Reference","MedicationAdministration.meta":"Meta","MedicationAdministration.modifierExtension":"Extension","MedicationAdministration.note":"Annotation","MedicationAdministration.partOf":"Reference","MedicationAdministration.performer.actor":"Reference","MedicationAdministration.performer.extension":"Extension","MedicationAdministration.performer.function":"CodeableConcept","MedicationAdministration.performer.id":"System.String","MedicationAdministration.performer.modifierExtension":"Extension","MedicationAdministration.reasonCode":"CodeableConcept","MedicationAdministration.reasonReference":"Reference","MedicationAdministration.request":"Reference","MedicationAdministration.status":"code","MedicationAdministration.statusReason":"CodeableConcept","MedicationAdministration.subject":"Reference","MedicationAdministration.supportingInformation":"Reference","MedicationAdministration.text":"Narrative","MedicationDispense.authorizingPrescription":"Reference","MedicationDispense.category":"CodeableConcept","MedicationDispense.contained":"Resource","MedicationDispense.context":"Reference","MedicationDispense.daysSupply":"Quantity","MedicationDispense.destination":"Reference","MedicationDispense.detectedIssue":"Reference","MedicationDispense.dosageInstruction":"Dosage","MedicationDispense.eventHistory":"Reference","MedicationDispense.extension":"Extension","MedicationDispense.id":"System.String","MedicationDispense.identifier":"Identifier","MedicationDispense.implicitRules":"uri","MedicationDispense.language":"code","MedicationDispense.location":"Reference","MedicationDispense.medicationCodeableConcept":"CodeableConcept","MedicationDispense.medicationReference":"Reference","MedicationDispense.meta":"Meta","MedicationDispense.modifierExtension":"Extension","MedicationDispense.note":"Annotation","MedicationDispense.partOf":"Reference","MedicationDispense.performer.actor":"Reference","MedicationDispense.performer.extension":"Extension","MedicationDispense.performer.function":"CodeableConcept","MedicationDispense.performer.id":"System.String","MedicationDispense.performer.modifierExtension":"Extension","MedicationDispense.quantity":"Quantity","MedicationDispense.receiver":"Reference","MedicationDispense.status":"code","MedicationDispense.statusReasonCodeableConcept":"CodeableConcept","MedicationDispense.statusReasonReference":"Reference","MedicationDispense.subject":"Reference","MedicationDispense.substitution.extension":"Extension","MedicationDispense.substitution.id":"System.String","MedicationDispense.substitution.modifierExtension":"Extension","MedicationDispense.substitution.reason":"CodeableConcept","MedicationDispense.substitution.responsibleParty":"Reference","MedicationDispense.substitution.type":"CodeableConcept","MedicationDispense.substitution.wasSubstituted":"boolean","MedicationDispense.supportingInformation":"Reference","MedicationDispense.text":"Narrative","MedicationDispense.type":"CodeableConcept","MedicationDispense.whenHandedOver":"dateTime","MedicationDispense.whenPrepared":"dateTime","MedicationKnowledge.administrationGuidelines.dosage.dosage":"Dosage","MedicationKnowledge.administrationGuidelines.dosage.extension":"Extension","MedicationKnowledge.administrationGuidelines.dosage.id":"System.String","MedicationKnowledge.administrationGuidelines.dosage.modifierExtension":"Extension","MedicationKnowledge.administrationGuidelines.dosage.type":"CodeableConcept","MedicationKnowledge.administrationGuidelines.extension":"Extension","MedicationKnowledge.administrationGuidelines.id":"System.String","MedicationKnowledge.administrationGuidelines.indicationCodeableConcept":"CodeableConcept","MedicationKnowledge.administrationGuidelines.indicationReference":"Reference","MedicationKnowledge.administrationGuidelines.modifierExtension":"Extension","MedicationKnowledge.administrationGuidelines.patientCharacteristics.characteristicCodeableConcept":"CodeableConcept","MedicationKnowledge.administrationGuidelines.patientCharacteristics.characteristicQuantity":"Quantity","MedicationKnowledge.administrationGuidelines.patientCharacteristics.extension":"Extension","MedicationKnowledge.administrationGuidelines.patientCharacteristics.id":"System.String","MedicationKnowledge.administrationGuidelines.patientCharacteristics.modifierExtension":"Extension","MedicationKnowledge.administrationGuidelines.patientCharacteristics.value":"string","MedicationKnowledge.amount":"Quantity","MedicationKnowledge.associatedMedication":"Reference","MedicationKnowledge.code":"CodeableConcept","MedicationKnowledge.contained":"Resource","MedicationKnowledge.contraindication":"Reference","MedicationKnowledge.cost.cost":"Money","MedicationKnowledge.cost.extension":"Extension","MedicationKnowledge.cost.id":"System.String","MedicationKnowledge.cost.modifierExtension":"Extension","MedicationKnowledge.cost.source":"string","MedicationKnowledge.cost.type":"CodeableConcept","MedicationKnowledge.doseForm":"CodeableConcept","MedicationKnowledge.drugCharacteristic.extension":"Extension","MedicationKnowledge.drugCharacteristic.id":"System.String","MedicationKnowledge.drugCharacteristic.modifierExtension":"Extension","MedicationKnowledge.drugCharacteristic.type":"CodeableConcept","MedicationKnowledge.drugCharacteristic.valueBase64Binary":"base64Binary","MedicationKnowledge.drugCharacteristic.valueCodeableConcept":"CodeableConcept","MedicationKnowledge.drugCharacteristic.valueQuantity":"Quantity","MedicationKnowledge.drugCharacteristic.valueString":"string","MedicationKnowledge.extension":"Extension","MedicationKnowledge.id":"System.String","MedicationKnowledge.implicitRules":"uri","MedicationKnowledge.ingredient.extension":"Extension","MedicationKnowledge.ingredient.id":"System.String","MedicationKnowledge.ingredient.isActive":"boolean","MedicationKnowledge.ingredient.itemCodeableConcept":"CodeableConcept","MedicationKnowledge.ingredient.itemReference":"Reference","MedicationKnowledge.ingredient.modifierExtension":"Extension","MedicationKnowledge.ingredient.strength":"Ratio","MedicationKnowledge.intendedRoute":"CodeableConcept","MedicationKnowledge.kinetics.areaUnderCurve":"Quantity","MedicationKnowledge.kinetics.extension":"Extension","MedicationKnowledge.kinetics.halfLifePeriod":"Duration","MedicationKnowledge.kinetics.id":"System.String","MedicationKnowledge.kinetics.lethalDose50":"Quantity","MedicationKnowledge.kinetics.modifierExtension":"Extension","MedicationKnowledge.language":"code","MedicationKnowledge.manufacturer":"Reference","MedicationKnowledge.medicineClassification.classification":"CodeableConcept","MedicationKnowledge.medicineClassification.extension":"Extension","MedicationKnowledge.medicineClassification.id":"System.String","MedicationKnowledge.medicineClassification.modifierExtension":"Extension","MedicationKnowledge.medicineClassification.type":"CodeableConcept","MedicationKnowledge.meta":"Meta","MedicationKnowledge.modifierExtension":"Extension","MedicationKnowledge.monitoringProgram.extension":"Extension","MedicationKnowledge.monitoringProgram.id":"System.String","MedicationKnowledge.monitoringProgram.modifierExtension":"Extension","MedicationKnowledge.monitoringProgram.name":"string","MedicationKnowledge.monitoringProgram.type":"CodeableConcept","MedicationKnowledge.monograph.extension":"Extension","MedicationKnowledge.monograph.id":"System.String","MedicationKnowledge.monograph.modifierExtension":"Extension","MedicationKnowledge.monograph.source":"Reference","MedicationKnowledge.monograph.type":"CodeableConcept","MedicationKnowledge.packaging.extension":"Extension","MedicationKnowledge.packaging.id":"System.String","MedicationKnowledge.packaging.modifierExtension":"Extension","MedicationKnowledge.packaging.quantity":"Quantity","MedicationKnowledge.packaging.type":"CodeableConcept","MedicationKnowledge.preparationInstruction":"markdown","MedicationKnowledge.productType":"CodeableConcept","MedicationKnowledge.regulatory.extension":"Extension","MedicationKnowledge.regulatory.id":"System.String","MedicationKnowledge.regulatory.maxDispense.extension":"Extension","MedicationKnowledge.regulatory.maxDispense.id":"System.String","MedicationKnowledge.regulatory.maxDispense.modifierExtension":"Extension","MedicationKnowledge.regulatory.maxDispense.period":"Duration","MedicationKnowledge.regulatory.maxDispense.quantity":"Quantity","MedicationKnowledge.regulatory.modifierExtension":"Extension","MedicationKnowledge.regulatory.regulatoryAuthority":"Reference","MedicationKnowledge.regulatory.schedule.extension":"Extension","MedicationKnowledge.regulatory.schedule.id":"System.String","MedicationKnowledge.regulatory.schedule.modifierExtension":"Extension","MedicationKnowledge.regulatory.schedule.schedule":"CodeableConcept","MedicationKnowledge.regulatory.substitution.allowed":"boolean","MedicationKnowledge.regulatory.substitution.extension":"Extension","MedicationKnowledge.regulatory.substitution.id":"System.String","MedicationKnowledge.regulatory.substitution.modifierExtension":"Extension","MedicationKnowledge.regulatory.substitution.type":"CodeableConcept","MedicationKnowledge.relatedMedicationKnowledge.extension":"Extension","MedicationKnowledge.relatedMedicationKnowledge.id":"System.String","MedicationKnowledge.relatedMedicationKnowledge.modifierExtension":"Extension","MedicationKnowledge.relatedMedicationKnowledge.reference":"Reference","MedicationKnowledge.relatedMedicationKnowledge.type":"CodeableConcept","MedicationKnowledge.status":"code","MedicationKnowledge.synonym":"string","MedicationKnowledge.text":"Narrative","MedicationRequest.authoredOn":"dateTime","MedicationRequest.basedOn":"Reference","MedicationRequest.category":"CodeableConcept","MedicationRequest.contained":"Resource","MedicationRequest.courseOfTherapyType":"CodeableConcept","MedicationRequest.detectedIssue":"Reference","MedicationRequest.dispenseRequest.dispenseInterval":"Duration","MedicationRequest.dispenseRequest.expectedSupplyDuration":"Duration","MedicationRequest.dispenseRequest.extension":"Extension","MedicationRequest.dispenseRequest.id":"System.String","MedicationRequest.dispenseRequest.initialFill.duration":"Duration","MedicationRequest.dispenseRequest.initialFill.extension":"Extension","MedicationRequest.dispenseRequest.initialFill.id":"System.String","MedicationRequest.dispenseRequest.initialFill.modifierExtension":"Extension","MedicationRequest.dispenseRequest.initialFill.quantity":"Quantity","MedicationRequest.dispenseRequest.modifierExtension":"Extension","MedicationRequest.dispenseRequest.numberOfRepeatsAllowed":"unsignedInt","MedicationRequest.dispenseRequest.performer":"Reference","MedicationRequest.dispenseRequest.quantity":"Quantity","MedicationRequest.dispenseRequest.validityPeriod":"Period","MedicationRequest.doNotPerform":"boolean","MedicationRequest.dosageInstruction":"Dosage","MedicationRequest.encounter":"Reference","MedicationRequest.eventHistory":"Reference","MedicationRequest.extension":"Extension","MedicationRequest.groupIdentifier":"Identifier","MedicationRequest.id":"System.String","MedicationRequest.identifier":"Identifier","MedicationRequest.implicitRules":"uri","MedicationRequest.instantiatesCanonical":"canonical","MedicationRequest.instantiatesUri":"uri","MedicationRequest.insurance":"Reference","MedicationRequest.intent":"code","MedicationRequest.language":"code","MedicationRequest.medicationCodeableConcept":"CodeableConcept","MedicationRequest.medicationReference":"Reference","MedicationRequest.meta":"Meta","MedicationRequest.modifierExtension":"Extension","MedicationRequest.note":"Annotation","MedicationRequest.performer":"Reference","MedicationRequest.performerType":"CodeableConcept","MedicationRequest.priorPrescription":"Reference","MedicationRequest.priority":"code","MedicationRequest.reasonCode":"CodeableConcept","MedicationRequest.reasonReference":"Reference","MedicationRequest.recorder":"Reference","MedicationRequest.reportedBoolean":"boolean","MedicationRequest.reportedReference":"Reference","MedicationRequest.requester":"Reference","MedicationRequest.status":"code","MedicationRequest.statusReason":"CodeableConcept","MedicationRequest.subject":"Reference","MedicationRequest.substitution.allowedBoolean":"boolean","MedicationRequest.substitution.allowedCodeableConcept":"CodeableConcept","MedicationRequest.substitution.extension":"Extension","MedicationRequest.substitution.id":"System.String","MedicationRequest.substitution.modifierExtension":"Extension","MedicationRequest.substitution.reason":"CodeableConcept","MedicationRequest.supportingInformation":"Reference","MedicationRequest.text":"Narrative","MedicationStatement.basedOn":"Reference","MedicationStatement.category":"CodeableConcept","MedicationStatement.contained":"Resource","MedicationStatement.context":"Reference","MedicationStatement.dateAsserted":"dateTime","MedicationStatement.derivedFrom":"Reference","MedicationStatement.dosage":"Dosage","MedicationStatement.effectiveDateTime":"dateTime","MedicationStatement.effectivePeriod":"Period","MedicationStatement.extension":"Extension","MedicationStatement.id":"System.String","MedicationStatement.identifier":"Identifier","MedicationStatement.implicitRules":"uri","MedicationStatement.informationSource":"Reference","MedicationStatement.language":"code","MedicationStatement.medicationCodeableConcept":"CodeableConcept","MedicationStatement.medicationReference":"Reference","MedicationStatement.meta":"Meta","MedicationStatement.modifierExtension":"Extension","MedicationStatement.note":"Annotation","MedicationStatement.partOf":"Reference","MedicationStatement.reasonCode":"CodeableConcept","MedicationStatement.reasonReference":"Reference","MedicationStatement.status":"code","MedicationStatement.statusReason":"CodeableConcept","MedicationStatement.subject":"Reference","MedicationStatement.text":"Narrative","MedicinalProduct.additionalMonitoringIndicator":"CodeableConcept","MedicinalProduct.attachedDocument":"Reference","MedicinalProduct.clinicalTrial":"Reference","MedicinalProduct.combinedPharmaceuticalDoseForm":"CodeableConcept","MedicinalProduct.contact":"Reference","MedicinalProduct.contained":"Resource","MedicinalProduct.crossReference":"Identifier","MedicinalProduct.domain":"Coding","MedicinalProduct.extension":"Extension","MedicinalProduct.id":"System.String","MedicinalProduct.identifier":"Identifier","MedicinalProduct.implicitRules":"uri","MedicinalProduct.language":"code","MedicinalProduct.legalStatusOfSupply":"CodeableConcept","MedicinalProduct.manufacturingBusinessOperation.authorisationReferenceNumber":"Identifier","MedicinalProduct.manufacturingBusinessOperation.confidentialityIndicator":"CodeableConcept","MedicinalProduct.manufacturingBusinessOperation.effectiveDate":"dateTime","MedicinalProduct.manufacturingBusinessOperation.extension":"Extension","MedicinalProduct.manufacturingBusinessOperation.id":"System.String","MedicinalProduct.manufacturingBusinessOperation.manufacturer":"Reference","MedicinalProduct.manufacturingBusinessOperation.modifierExtension":"Extension","MedicinalProduct.manufacturingBusinessOperation.operationType":"CodeableConcept","MedicinalProduct.manufacturingBusinessOperation.regulator":"Reference","MedicinalProduct.marketingStatus":"MarketingStatus","MedicinalProduct.masterFile":"Reference","MedicinalProduct.meta":"Meta","MedicinalProduct.modifierExtension":"Extension","MedicinalProduct.name.countryLanguage.country":"CodeableConcept","MedicinalProduct.name.countryLanguage.extension":"Extension","MedicinalProduct.name.countryLanguage.id":"System.String","MedicinalProduct.name.countryLanguage.jurisdiction":"CodeableConcept","MedicinalProduct.name.countryLanguage.language":"CodeableConcept","MedicinalProduct.name.countryLanguage.modifierExtension":"Extension","MedicinalProduct.name.extension":"Extension","MedicinalProduct.name.id":"System.String","MedicinalProduct.name.modifierExtension":"Extension","MedicinalProduct.name.namePart.extension":"Extension","MedicinalProduct.name.namePart.id":"System.String","MedicinalProduct.name.namePart.modifierExtension":"Extension","MedicinalProduct.name.namePart.part":"string","MedicinalProduct.name.namePart.type":"Coding","MedicinalProduct.name.productName":"string","MedicinalProduct.packagedMedicinalProduct":"Reference","MedicinalProduct.paediatricUseIndicator":"CodeableConcept","MedicinalProduct.pharmaceuticalProduct":"Reference","MedicinalProduct.productClassification":"CodeableConcept","MedicinalProduct.specialDesignation.date":"dateTime","MedicinalProduct.specialDesignation.extension":"Extension","MedicinalProduct.specialDesignation.id":"System.String","MedicinalProduct.specialDesignation.identifier":"Identifier","MedicinalProduct.specialDesignation.indicationCodeableConcept":"CodeableConcept","MedicinalProduct.specialDesignation.indicationReference":"Reference","MedicinalProduct.specialDesignation.intendedUse":"CodeableConcept","MedicinalProduct.specialDesignation.modifierExtension":"Extension","MedicinalProduct.specialDesignation.species":"CodeableConcept","MedicinalProduct.specialDesignation.status":"CodeableConcept","MedicinalProduct.specialDesignation.type":"CodeableConcept","MedicinalProduct.specialMeasures":"string","MedicinalProduct.text":"Narrative","MedicinalProduct.type":"CodeableConcept","MedicinalProductAuthorization.contained":"Resource","MedicinalProductAuthorization.country":"CodeableConcept","MedicinalProductAuthorization.dataExclusivityPeriod":"Period","MedicinalProductAuthorization.dateOfFirstAuthorization":"dateTime","MedicinalProductAuthorization.extension":"Extension","MedicinalProductAuthorization.holder":"Reference","MedicinalProductAuthorization.id":"System.String","MedicinalProductAuthorization.identifier":"Identifier","MedicinalProductAuthorization.implicitRules":"uri","MedicinalProductAuthorization.internationalBirthDate":"dateTime","MedicinalProductAuthorization.jurisdiction":"CodeableConcept","MedicinalProductAuthorization.jurisdictionalAuthorization.country":"CodeableConcept","MedicinalProductAuthorization.jurisdictionalAuthorization.extension":"Extension","MedicinalProductAuthorization.jurisdictionalAuthorization.id":"System.String","MedicinalProductAuthorization.jurisdictionalAuthorization.identifier":"Identifier","MedicinalProductAuthorization.jurisdictionalAuthorization.jurisdiction":"CodeableConcept","MedicinalProductAuthorization.jurisdictionalAuthorization.legalStatusOfSupply":"CodeableConcept","MedicinalProductAuthorization.jurisdictionalAuthorization.modifierExtension":"Extension","MedicinalProductAuthorization.jurisdictionalAuthorization.validityPeriod":"Period","MedicinalProductAuthorization.language":"code","MedicinalProductAuthorization.legalBasis":"CodeableConcept","MedicinalProductAuthorization.meta":"Meta","MedicinalProductAuthorization.modifierExtension":"Extension","MedicinalProductAuthorization.procedure.dateDateTime":"dateTime","MedicinalProductAuthorization.procedure.datePeriod":"Period","MedicinalProductAuthorization.procedure.extension":"Extension","MedicinalProductAuthorization.procedure.id":"System.String","MedicinalProductAuthorization.procedure.identifier":"Identifier","MedicinalProductAuthorization.procedure.modifierExtension":"Extension","MedicinalProductAuthorization.procedure.type":"CodeableConcept","MedicinalProductAuthorization.regulator":"Reference","MedicinalProductAuthorization.restoreDate":"dateTime","MedicinalProductAuthorization.status":"CodeableConcept","MedicinalProductAuthorization.statusDate":"dateTime","MedicinalProductAuthorization.subject":"Reference","MedicinalProductAuthorization.text":"Narrative","MedicinalProductAuthorization.validityPeriod":"Period","MedicinalProductContraindication.comorbidity":"CodeableConcept","MedicinalProductContraindication.contained":"Resource","MedicinalProductContraindication.disease":"CodeableConcept","MedicinalProductContraindication.diseaseStatus":"CodeableConcept","MedicinalProductContraindication.extension":"Extension","MedicinalProductContraindication.id":"System.String","MedicinalProductContraindication.implicitRules":"uri","MedicinalProductContraindication.language":"code","MedicinalProductContraindication.meta":"Meta","MedicinalProductContraindication.modifierExtension":"Extension","MedicinalProductContraindication.otherTherapy.extension":"Extension","MedicinalProductContraindication.otherTherapy.id":"System.String","MedicinalProductContraindication.otherTherapy.medicationCodeableConcept":"CodeableConcept","MedicinalProductContraindication.otherTherapy.medicationReference":"Reference","MedicinalProductContraindication.otherTherapy.modifierExtension":"Extension","MedicinalProductContraindication.otherTherapy.therapyRelationshipType":"CodeableConcept","MedicinalProductContraindication.population":"Population","MedicinalProductContraindication.subject":"Reference","MedicinalProductContraindication.text":"Narrative","MedicinalProductContraindication.therapeuticIndication":"Reference","MedicinalProductIndication.comorbidity":"CodeableConcept","MedicinalProductIndication.contained":"Resource","MedicinalProductIndication.diseaseStatus":"CodeableConcept","MedicinalProductIndication.diseaseSymptomProcedure":"CodeableConcept","MedicinalProductIndication.duration":"Quantity","MedicinalProductIndication.extension":"Extension","MedicinalProductIndication.id":"System.String","MedicinalProductIndication.implicitRules":"uri","MedicinalProductIndication.intendedEffect":"CodeableConcept","MedicinalProductIndication.language":"code","MedicinalProductIndication.meta":"Meta","MedicinalProductIndication.modifierExtension":"Extension","MedicinalProductIndication.otherTherapy.extension":"Extension","MedicinalProductIndication.otherTherapy.id":"System.String","MedicinalProductIndication.otherTherapy.medicationCodeableConcept":"CodeableConcept","MedicinalProductIndication.otherTherapy.medicationReference":"Reference","MedicinalProductIndication.otherTherapy.modifierExtension":"Extension","MedicinalProductIndication.otherTherapy.therapyRelationshipType":"CodeableConcept","MedicinalProductIndication.population":"Population","MedicinalProductIndication.subject":"Reference","MedicinalProductIndication.text":"Narrative","MedicinalProductIndication.undesirableEffect":"Reference","MedicinalProductIngredient.allergenicIndicator":"boolean","MedicinalProductIngredient.contained":"Resource","MedicinalProductIngredient.extension":"Extension","MedicinalProductIngredient.id":"System.String","MedicinalProductIngredient.identifier":"Identifier","MedicinalProductIngredient.implicitRules":"uri","MedicinalProductIngredient.language":"code","MedicinalProductIngredient.manufacturer":"Reference","MedicinalProductIngredient.meta":"Meta","MedicinalProductIngredient.modifierExtension":"Extension","MedicinalProductIngredient.role":"CodeableConcept","MedicinalProductIngredient.specifiedSubstance.code":"CodeableConcept","MedicinalProductIngredient.specifiedSubstance.confidentiality":"CodeableConcept","MedicinalProductIngredient.specifiedSubstance.extension":"Extension","MedicinalProductIngredient.specifiedSubstance.group":"CodeableConcept","MedicinalProductIngredient.specifiedSubstance.id":"System.String","MedicinalProductIngredient.specifiedSubstance.modifierExtension":"Extension","MedicinalProductIngredient.specifiedSubstance.strength.concentration":"Ratio","MedicinalProductIngredient.specifiedSubstance.strength.concentrationLowLimit":"Ratio","MedicinalProductIngredient.specifiedSubstance.strength.country":"CodeableConcept","MedicinalProductIngredient.specifiedSubstance.strength.extension":"Extension","MedicinalProductIngredient.specifiedSubstance.strength.id":"System.String","MedicinalProductIngredient.specifiedSubstance.strength.measurementPoint":"string","MedicinalProductIngredient.specifiedSubstance.strength.modifierExtension":"Extension","MedicinalProductIngredient.specifiedSubstance.strength.presentation":"Ratio","MedicinalProductIngredient.specifiedSubstance.strength.presentationLowLimit":"Ratio","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.country":"CodeableConcept","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.extension":"Extension","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.id":"System.String","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.measurementPoint":"string","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.modifierExtension":"Extension","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.strength":"Ratio","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.strengthLowLimit":"Ratio","MedicinalProductIngredient.specifiedSubstance.strength.referenceStrength.substance":"CodeableConcept","MedicinalProductIngredient.substance.code":"CodeableConcept","MedicinalProductIngredient.substance.extension":"Extension","MedicinalProductIngredient.substance.id":"System.String","MedicinalProductIngredient.substance.modifierExtension":"Extension","MedicinalProductIngredient.text":"Narrative","MedicinalProductInteraction.contained":"Resource","MedicinalProductInteraction.description":"string","MedicinalProductInteraction.effect":"CodeableConcept","MedicinalProductInteraction.extension":"Extension","MedicinalProductInteraction.id":"System.String","MedicinalProductInteraction.implicitRules":"uri","MedicinalProductInteraction.incidence":"CodeableConcept","MedicinalProductInteraction.interactant.extension":"Extension","MedicinalProductInteraction.interactant.id":"System.String","MedicinalProductInteraction.interactant.itemCodeableConcept":"CodeableConcept","MedicinalProductInteraction.interactant.itemReference":"Reference","MedicinalProductInteraction.interactant.modifierExtension":"Extension","MedicinalProductInteraction.language":"code","MedicinalProductInteraction.management":"CodeableConcept","MedicinalProductInteraction.meta":"Meta","MedicinalProductInteraction.modifierExtension":"Extension","MedicinalProductInteraction.subject":"Reference","MedicinalProductInteraction.text":"Narrative","MedicinalProductInteraction.type":"CodeableConcept","MedicinalProductManufactured.contained":"Resource","MedicinalProductManufactured.extension":"Extension","MedicinalProductManufactured.id":"System.String","MedicinalProductManufactured.implicitRules":"uri","MedicinalProductManufactured.ingredient":"Reference","MedicinalProductManufactured.language":"code","MedicinalProductManufactured.manufacturedDoseForm":"CodeableConcept","MedicinalProductManufactured.manufacturer":"Reference","MedicinalProductManufactured.meta":"Meta","MedicinalProductManufactured.modifierExtension":"Extension","MedicinalProductManufactured.otherCharacteristics":"CodeableConcept","MedicinalProductManufactured.physicalCharacteristics":"ProdCharacteristic","MedicinalProductManufactured.quantity":"Quantity","MedicinalProductManufactured.text":"Narrative","MedicinalProductManufactured.unitOfPresentation":"CodeableConcept","MedicinalProductPackaged.batchIdentifier.extension":"Extension","MedicinalProductPackaged.batchIdentifier.id":"System.String","MedicinalProductPackaged.batchIdentifier.immediatePackaging":"Identifier","MedicinalProductPackaged.batchIdentifier.modifierExtension":"Extension","MedicinalProductPackaged.batchIdentifier.outerPackaging":"Identifier","MedicinalProductPackaged.contained":"Resource","MedicinalProductPackaged.description":"string","MedicinalProductPackaged.extension":"Extension","MedicinalProductPackaged.id":"System.String","MedicinalProductPackaged.identifier":"Identifier","MedicinalProductPackaged.implicitRules":"uri","MedicinalProductPackaged.language":"code","MedicinalProductPackaged.legalStatusOfSupply":"CodeableConcept","MedicinalProductPackaged.manufacturer":"Reference","MedicinalProductPackaged.marketingAuthorization":"Reference","MedicinalProductPackaged.marketingStatus":"MarketingStatus","MedicinalProductPackaged.meta":"Meta","MedicinalProductPackaged.modifierExtension":"Extension","MedicinalProductPackaged.packageItem.alternateMaterial":"CodeableConcept","MedicinalProductPackaged.packageItem.device":"Reference","MedicinalProductPackaged.packageItem.extension":"Extension","MedicinalProductPackaged.packageItem.id":"System.String","MedicinalProductPackaged.packageItem.identifier":"Identifier","MedicinalProductPackaged.packageItem.manufacturedItem":"Reference","MedicinalProductPackaged.packageItem.manufacturer":"Reference","MedicinalProductPackaged.packageItem.material":"CodeableConcept","MedicinalProductPackaged.packageItem.modifierExtension":"Extension","MedicinalProductPackaged.packageItem.otherCharacteristics":"CodeableConcept","MedicinalProductPackaged.packageItem.physicalCharacteristics":"ProdCharacteristic","MedicinalProductPackaged.packageItem.quantity":"Quantity","MedicinalProductPackaged.packageItem.shelfLifeStorage":"ProductShelfLife","MedicinalProductPackaged.packageItem.type":"CodeableConcept","MedicinalProductPackaged.subject":"Reference","MedicinalProductPackaged.text":"Narrative","MedicinalProductPharmaceutical.administrableDoseForm":"CodeableConcept","MedicinalProductPharmaceutical.characteristics.code":"CodeableConcept","MedicinalProductPharmaceutical.characteristics.extension":"Extension","MedicinalProductPharmaceutical.characteristics.id":"System.String","MedicinalProductPharmaceutical.characteristics.modifierExtension":"Extension","MedicinalProductPharmaceutical.characteristics.status":"CodeableConcept","MedicinalProductPharmaceutical.contained":"Resource","MedicinalProductPharmaceutical.device":"Reference","MedicinalProductPharmaceutical.extension":"Extension","MedicinalProductPharmaceutical.id":"System.String","MedicinalProductPharmaceutical.identifier":"Identifier","MedicinalProductPharmaceutical.implicitRules":"uri","MedicinalProductPharmaceutical.ingredient":"Reference","MedicinalProductPharmaceutical.language":"code","MedicinalProductPharmaceutical.meta":"Meta","MedicinalProductPharmaceutical.modifierExtension":"Extension","MedicinalProductPharmaceutical.routeOfAdministration.code":"CodeableConcept","MedicinalProductPharmaceutical.routeOfAdministration.extension":"Extension","MedicinalProductPharmaceutical.routeOfAdministration.firstDose":"Quantity","MedicinalProductPharmaceutical.routeOfAdministration.id":"System.String","MedicinalProductPharmaceutical.routeOfAdministration.maxDosePerDay":"Quantity","MedicinalProductPharmaceutical.routeOfAdministration.maxDosePerTreatmentPeriod":"Ratio","MedicinalProductPharmaceutical.routeOfAdministration.maxSingleDose":"Quantity","MedicinalProductPharmaceutical.routeOfAdministration.maxTreatmentPeriod":"Duration","MedicinalProductPharmaceutical.routeOfAdministration.modifierExtension":"Extension","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.code":"CodeableConcept","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.extension":"Extension","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.id":"System.String","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.modifierExtension":"Extension","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.extension":"Extension","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.id":"System.String","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.modifierExtension":"Extension","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.supportingInformation":"string","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.tissue":"CodeableConcept","MedicinalProductPharmaceutical.routeOfAdministration.targetSpecies.withdrawalPeriod.value":"Quantity","MedicinalProductPharmaceutical.text":"Narrative","MedicinalProductPharmaceutical.unitOfPresentation":"CodeableConcept","MedicinalProductUndesirableEffect.classification":"CodeableConcept","MedicinalProductUndesirableEffect.contained":"Resource","MedicinalProductUndesirableEffect.extension":"Extension","MedicinalProductUndesirableEffect.frequencyOfOccurrence":"CodeableConcept","MedicinalProductUndesirableEffect.id":"System.String","MedicinalProductUndesirableEffect.implicitRules":"uri","MedicinalProductUndesirableEffect.language":"code","MedicinalProductUndesirableEffect.meta":"Meta","MedicinalProductUndesirableEffect.modifierExtension":"Extension","MedicinalProductUndesirableEffect.population":"Population","MedicinalProductUndesirableEffect.subject":"Reference","MedicinalProductUndesirableEffect.symptomConditionEffect":"CodeableConcept","MedicinalProductUndesirableEffect.text":"Narrative","MessageDefinition.allowedResponse.extension":"Extension","MessageDefinition.allowedResponse.id":"System.String","MessageDefinition.allowedResponse.message":"canonical","MessageDefinition.allowedResponse.modifierExtension":"Extension","MessageDefinition.allowedResponse.situation":"markdown","MessageDefinition.base":"canonical","MessageDefinition.category":"code","MessageDefinition.contact":"ContactDetail","MessageDefinition.contained":"Resource","MessageDefinition.copyright":"markdown","MessageDefinition.date":"dateTime","MessageDefinition.description":"markdown","MessageDefinition.eventCoding":"Coding","MessageDefinition.eventUri":"uri","MessageDefinition.experimental":"boolean","MessageDefinition.extension":"Extension","MessageDefinition.focus.code":"code","MessageDefinition.focus.extension":"Extension","MessageDefinition.focus.id":"System.String","MessageDefinition.focus.max":"string","MessageDefinition.focus.min":"unsignedInt","MessageDefinition.focus.modifierExtension":"Extension","MessageDefinition.focus.profile":"canonical","MessageDefinition.graph":"canonical","MessageDefinition.id":"System.String","MessageDefinition.identifier":"Identifier","MessageDefinition.implicitRules":"uri","MessageDefinition.jurisdiction":"CodeableConcept","MessageDefinition.language":"code","MessageDefinition.meta":"Meta","MessageDefinition.modifierExtension":"Extension","MessageDefinition.name":"string","MessageDefinition.parent":"canonical","MessageDefinition.publisher":"string","MessageDefinition.purpose":"markdown","MessageDefinition.replaces":"canonical","MessageDefinition.responseRequired":"code","MessageDefinition.status":"code","MessageDefinition.text":"Narrative","MessageDefinition.title":"string","MessageDefinition.url":"uri","MessageDefinition.useContext":"UsageContext","MessageDefinition.version":"string","MessageHeader.author":"Reference","MessageHeader.contained":"Resource","MessageHeader.definition":"canonical","MessageHeader.destination.endpoint":"url","MessageHeader.destination.extension":"Extension","MessageHeader.destination.id":"System.String","MessageHeader.destination.modifierExtension":"Extension","MessageHeader.destination.name":"string","MessageHeader.destination.receiver":"Reference","MessageHeader.destination.target":"Reference","MessageHeader.enterer":"Reference","MessageHeader.eventCoding":"Coding","MessageHeader.eventUri":"uri","MessageHeader.extension":"Extension","MessageHeader.focus":"Reference","MessageHeader.id":"System.String","MessageHeader.implicitRules":"uri","MessageHeader.language":"code","MessageHeader.meta":"Meta","MessageHeader.modifierExtension":"Extension","MessageHeader.reason":"CodeableConcept","MessageHeader.response.code":"code","MessageHeader.response.details":"Reference","MessageHeader.response.extension":"Extension","MessageHeader.response.id":"System.String","MessageHeader.response.identifier":"id","MessageHeader.response.modifierExtension":"Extension","MessageHeader.responsible":"Reference","MessageHeader.sender":"Reference","MessageHeader.source.contact":"ContactPoint","MessageHeader.source.endpoint":"url","MessageHeader.source.extension":"Extension","MessageHeader.source.id":"System.String","MessageHeader.source.modifierExtension":"Extension","MessageHeader.source.name":"string","MessageHeader.source.software":"string","MessageHeader.source.version":"string","MessageHeader.text":"Narrative","Meta.extension":"Extension","Meta.id":"System.String","Meta.lastUpdated":"instant","Meta.profile":"canonical","Meta.security":"Coding","Meta.source":"uri","Meta.tag":"Coding","Meta.versionId":"id","MetadataResource.contact":"ContactDetail","MetadataResource.contained":"Resource","MetadataResource.date":"dateTime","MetadataResource.description":"markdown","MetadataResource.experimental":"boolean","MetadataResource.extension":"Extension","MetadataResource.id":"System.String","MetadataResource.implicitRules":"uri","MetadataResource.jurisdiction":"CodeableConcept","MetadataResource.language":"code","MetadataResource.meta":"Meta","MetadataResource.modifierExtension":"Extension","MetadataResource.name":"string","MetadataResource.publisher":"string","MetadataResource.status":"code","MetadataResource.text":"Narrative","MetadataResource.title":"string","MetadataResource.url":"uri","MetadataResource.useContext":"UsageContext","MetadataResource.version":"string","MolecularSequence.contained":"Resource","MolecularSequence.coordinateSystem":"integer","MolecularSequence.device":"Reference","MolecularSequence.extension":"Extension","MolecularSequence.id":"System.String","MolecularSequence.identifier":"Identifier","MolecularSequence.implicitRules":"uri","MolecularSequence.language":"code","MolecularSequence.meta":"Meta","MolecularSequence.modifierExtension":"Extension","MolecularSequence.observedSeq":"string","MolecularSequence.patient":"Reference","MolecularSequence.performer":"Reference","MolecularSequence.pointer":"Reference","MolecularSequence.quality.end":"integer","MolecularSequence.quality.extension":"Extension","MolecularSequence.quality.fScore":"decimal","MolecularSequence.quality.gtFP":"decimal","MolecularSequence.quality.id":"System.String","MolecularSequence.quality.method":"CodeableConcept","MolecularSequence.quality.modifierExtension":"Extension","MolecularSequence.quality.precision":"decimal","MolecularSequence.quality.queryFP":"decimal","MolecularSequence.quality.queryTP":"decimal","MolecularSequence.quality.recall":"decimal","MolecularSequence.quality.roc.extension":"Extension","MolecularSequence.quality.roc.fMeasure":"decimal","MolecularSequence.quality.roc.id":"System.String","MolecularSequence.quality.roc.modifierExtension":"Extension","MolecularSequence.quality.roc.numFN":"integer","MolecularSequence.quality.roc.numFP":"integer","MolecularSequence.quality.roc.numTP":"integer","MolecularSequence.quality.roc.precision":"decimal","MolecularSequence.quality.roc.score":"integer","MolecularSequence.quality.roc.sensitivity":"decimal","MolecularSequence.quality.score":"Quantity","MolecularSequence.quality.standardSequence":"CodeableConcept","MolecularSequence.quality.start":"integer","MolecularSequence.quality.truthFN":"decimal","MolecularSequence.quality.truthTP":"decimal","MolecularSequence.quality.type":"code","MolecularSequence.quantity":"Quantity","MolecularSequence.readCoverage":"integer","MolecularSequence.referenceSeq.chromosome":"CodeableConcept","MolecularSequence.referenceSeq.extension":"Extension","MolecularSequence.referenceSeq.genomeBuild":"string","MolecularSequence.referenceSeq.id":"System.String","MolecularSequence.referenceSeq.modifierExtension":"Extension","MolecularSequence.referenceSeq.orientation":"code","MolecularSequence.referenceSeq.referenceSeqId":"CodeableConcept","MolecularSequence.referenceSeq.referenceSeqPointer":"Reference","MolecularSequence.referenceSeq.referenceSeqString":"string","MolecularSequence.referenceSeq.strand":"code","MolecularSequence.referenceSeq.windowEnd":"integer","MolecularSequence.referenceSeq.windowStart":"integer","MolecularSequence.repository.datasetId":"string","MolecularSequence.repository.extension":"Extension","MolecularSequence.repository.id":"System.String","MolecularSequence.repository.modifierExtension":"Extension","MolecularSequence.repository.name":"string","MolecularSequence.repository.readsetId":"string","MolecularSequence.repository.type":"code","MolecularSequence.repository.url":"uri","MolecularSequence.repository.variantsetId":"string","MolecularSequence.specimen":"Reference","MolecularSequence.structureVariant.exact":"boolean","MolecularSequence.structureVariant.extension":"Extension","MolecularSequence.structureVariant.id":"System.String","MolecularSequence.structureVariant.inner.end":"integer","MolecularSequence.structureVariant.inner.extension":"Extension","MolecularSequence.structureVariant.inner.id":"System.String","MolecularSequence.structureVariant.inner.modifierExtension":"Extension","MolecularSequence.structureVariant.inner.start":"integer","MolecularSequence.structureVariant.length":"integer","MolecularSequence.structureVariant.modifierExtension":"Extension","MolecularSequence.structureVariant.outer.end":"integer","MolecularSequence.structureVariant.outer.extension":"Extension","MolecularSequence.structureVariant.outer.id":"System.String","MolecularSequence.structureVariant.outer.modifierExtension":"Extension","MolecularSequence.structureVariant.outer.start":"integer","MolecularSequence.structureVariant.variantType":"CodeableConcept","MolecularSequence.text":"Narrative","MolecularSequence.type":"code","MolecularSequence.variant.cigar":"string","MolecularSequence.variant.end":"integer","MolecularSequence.variant.extension":"Extension","MolecularSequence.variant.id":"System.String","MolecularSequence.variant.modifierExtension":"Extension","MolecularSequence.variant.observedAllele":"string","MolecularSequence.variant.referenceAllele":"string","MolecularSequence.variant.start":"integer","MolecularSequence.variant.variantPointer":"Reference","Money.currency":"code","Money.extension":"Extension","Money.id":"System.String","Money.value":"decimal","NamingSystem.contact":"ContactDetail","NamingSystem.contained":"Resource","NamingSystem.date":"dateTime","NamingSystem.description":"markdown","NamingSystem.extension":"Extension","NamingSystem.id":"System.String","NamingSystem.implicitRules":"uri","NamingSystem.jurisdiction":"CodeableConcept","NamingSystem.kind":"code","NamingSystem.language":"code","NamingSystem.meta":"Meta","NamingSystem.modifierExtension":"Extension","NamingSystem.name":"string","NamingSystem.publisher":"string","NamingSystem.responsible":"string","NamingSystem.status":"code","NamingSystem.text":"Narrative","NamingSystem.type":"CodeableConcept","NamingSystem.uniqueId.comment":"string","NamingSystem.uniqueId.extension":"Extension","NamingSystem.uniqueId.id":"System.String","NamingSystem.uniqueId.modifierExtension":"Extension","NamingSystem.uniqueId.period":"Period","NamingSystem.uniqueId.preferred":"boolean","NamingSystem.uniqueId.type":"code","NamingSystem.uniqueId.value":"string","NamingSystem.usage":"string","NamingSystem.useContext":"UsageContext","Narrative.div":"xhtml","Narrative.extension":"Extension","Narrative.id":"System.String","Narrative.status":"code","NutritionOrder.allergyIntolerance":"Reference","NutritionOrder.contained":"Resource","NutritionOrder.dateTime":"dateTime","NutritionOrder.encounter":"Reference","NutritionOrder.enteralFormula.additiveProductName":"string","NutritionOrder.enteralFormula.additiveType":"CodeableConcept","NutritionOrder.enteralFormula.administration.extension":"Extension","NutritionOrder.enteralFormula.administration.id":"System.String","NutritionOrder.enteralFormula.administration.modifierExtension":"Extension","NutritionOrder.enteralFormula.administration.quantity":"Quantity","NutritionOrder.enteralFormula.administration.rateQuantity":"Quantity","NutritionOrder.enteralFormula.administration.rateRatio":"Ratio","NutritionOrder.enteralFormula.administration.schedule":"Timing","NutritionOrder.enteralFormula.administrationInstruction":"string","NutritionOrder.enteralFormula.baseFormulaProductName":"string","NutritionOrder.enteralFormula.baseFormulaType":"CodeableConcept","NutritionOrder.enteralFormula.caloricDensity":"Quantity","NutritionOrder.enteralFormula.extension":"Extension","NutritionOrder.enteralFormula.id":"System.String","NutritionOrder.enteralFormula.maxVolumeToDeliver":"Quantity","NutritionOrder.enteralFormula.modifierExtension":"Extension","NutritionOrder.enteralFormula.routeofAdministration":"CodeableConcept","NutritionOrder.excludeFoodModifier":"CodeableConcept","NutritionOrder.extension":"Extension","NutritionOrder.foodPreferenceModifier":"CodeableConcept","NutritionOrder.id":"System.String","NutritionOrder.identifier":"Identifier","NutritionOrder.implicitRules":"uri","NutritionOrder.instantiates":"uri","NutritionOrder.instantiatesCanonical":"canonical","NutritionOrder.instantiatesUri":"uri","NutritionOrder.intent":"code","NutritionOrder.language":"code","NutritionOrder.meta":"Meta","NutritionOrder.modifierExtension":"Extension","NutritionOrder.note":"Annotation","NutritionOrder.oralDiet.extension":"Extension","NutritionOrder.oralDiet.fluidConsistencyType":"CodeableConcept","NutritionOrder.oralDiet.id":"System.String","NutritionOrder.oralDiet.instruction":"string","NutritionOrder.oralDiet.modifierExtension":"Extension","NutritionOrder.oralDiet.nutrient.amount":"Quantity","NutritionOrder.oralDiet.nutrient.extension":"Extension","NutritionOrder.oralDiet.nutrient.id":"System.String","NutritionOrder.oralDiet.nutrient.modifier":"CodeableConcept","NutritionOrder.oralDiet.nutrient.modifierExtension":"Extension","NutritionOrder.oralDiet.schedule":"Timing","NutritionOrder.oralDiet.texture.extension":"Extension","NutritionOrder.oralDiet.texture.foodType":"CodeableConcept","NutritionOrder.oralDiet.texture.id":"System.String","NutritionOrder.oralDiet.texture.modifier":"CodeableConcept","NutritionOrder.oralDiet.texture.modifierExtension":"Extension","NutritionOrder.oralDiet.type":"CodeableConcept","NutritionOrder.orderer":"Reference","NutritionOrder.patient":"Reference","NutritionOrder.status":"code","NutritionOrder.supplement.extension":"Extension","NutritionOrder.supplement.id":"System.String","NutritionOrder.supplement.instruction":"string","NutritionOrder.supplement.modifierExtension":"Extension","NutritionOrder.supplement.productName":"string","NutritionOrder.supplement.quantity":"Quantity","NutritionOrder.supplement.schedule":"Timing","NutritionOrder.supplement.type":"CodeableConcept","NutritionOrder.text":"Narrative","Observation.basedOn":"Reference","Observation.bodySite":"CodeableConcept","Observation.category":"CodeableConcept","Observation.code":"CodeableConcept","Observation.component.code":"CodeableConcept","Observation.component.dataAbsentReason":"CodeableConcept","Observation.component.extension":"Extension","Observation.component.id":"System.String","Observation.component.interpretation":"CodeableConcept","Observation.component.modifierExtension":"Extension","Observation.component.valueBoolean":"boolean","Observation.component.valueCodeableConcept":"CodeableConcept","Observation.component.valueDateTime":"dateTime","Observation.component.valueInteger":"integer","Observation.component.valuePeriod":"Period","Observation.component.valueQuantity":"Quantity","Observation.component.valueRange":"Range","Observation.component.valueRatio":"Ratio","Observation.component.valueSampledData":"SampledData","Observation.component.valueString":"string","Observation.component.valueTime":"time","Observation.contained":"Resource","Observation.dataAbsentReason":"CodeableConcept","Observation.derivedFrom":"Reference","Observation.device":"Reference","Observation.effectiveDateTime":"dateTime","Observation.effectiveInstant":"instant","Observation.effectivePeriod":"Period","Observation.effectiveTiming":"Timing","Observation.encounter":"Reference","Observation.extension":"Extension","Observation.focus":"Reference","Observation.hasMember":"Reference","Observation.id":"System.String","Observation.identifier":"Identifier","Observation.implicitRules":"uri","Observation.interpretation":"CodeableConcept","Observation.issued":"instant","Observation.language":"code","Observation.meta":"Meta","Observation.method":"CodeableConcept","Observation.modifierExtension":"Extension","Observation.note":"Annotation","Observation.partOf":"Reference","Observation.performer":"Reference","Observation.referenceRange.age":"Range","Observation.referenceRange.appliesTo":"CodeableConcept","Observation.referenceRange.extension":"Extension","Observation.referenceRange.high":"Quantity","Observation.referenceRange.id":"System.String","Observation.referenceRange.low":"Quantity","Observation.referenceRange.modifierExtension":"Extension","Observation.referenceRange.text":"string","Observation.referenceRange.type":"CodeableConcept","Observation.specimen":"Reference","Observation.status":"code","Observation.subject":"Reference","Observation.text":"Narrative","Observation.valueBoolean":"boolean","Observation.valueCodeableConcept":"CodeableConcept","Observation.valueDateTime":"dateTime","Observation.valueInteger":"integer","Observation.valuePeriod":"Period","Observation.valueQuantity":"Quantity","Observation.valueRange":"Range","Observation.valueRatio":"Ratio","Observation.valueSampledData":"SampledData","Observation.valueString":"string","Observation.valueTime":"time","ObservationDefinition.abnormalCodedValueSet":"Reference","ObservationDefinition.category":"CodeableConcept","ObservationDefinition.code":"CodeableConcept","ObservationDefinition.contained":"Resource","ObservationDefinition.criticalCodedValueSet":"Reference","ObservationDefinition.extension":"Extension","ObservationDefinition.id":"System.String","ObservationDefinition.identifier":"Identifier","ObservationDefinition.implicitRules":"uri","ObservationDefinition.language":"code","ObservationDefinition.meta":"Meta","ObservationDefinition.method":"CodeableConcept","ObservationDefinition.modifierExtension":"Extension","ObservationDefinition.multipleResultsAllowed":"boolean","ObservationDefinition.normalCodedValueSet":"Reference","ObservationDefinition.permittedDataType":"code","ObservationDefinition.preferredReportName":"string","ObservationDefinition.qualifiedInterval.age":"Range","ObservationDefinition.qualifiedInterval.appliesTo":"CodeableConcept","ObservationDefinition.qualifiedInterval.category":"code","ObservationDefinition.qualifiedInterval.condition":"string","ObservationDefinition.qualifiedInterval.context":"CodeableConcept","ObservationDefinition.qualifiedInterval.extension":"Extension","ObservationDefinition.qualifiedInterval.gender":"code","ObservationDefinition.qualifiedInterval.gestationalAge":"Range","ObservationDefinition.qualifiedInterval.id":"System.String","ObservationDefinition.qualifiedInterval.modifierExtension":"Extension","ObservationDefinition.qualifiedInterval.range":"Range","ObservationDefinition.quantitativeDetails.conversionFactor":"decimal","ObservationDefinition.quantitativeDetails.customaryUnit":"CodeableConcept","ObservationDefinition.quantitativeDetails.decimalPrecision":"integer","ObservationDefinition.quantitativeDetails.extension":"Extension","ObservationDefinition.quantitativeDetails.id":"System.String","ObservationDefinition.quantitativeDetails.modifierExtension":"Extension","ObservationDefinition.quantitativeDetails.unit":"CodeableConcept","ObservationDefinition.text":"Narrative","ObservationDefinition.validCodedValueSet":"Reference","OperationDefinition.affectsState":"boolean","OperationDefinition.base":"canonical","OperationDefinition.code":"code","OperationDefinition.comment":"markdown","OperationDefinition.contact":"ContactDetail","OperationDefinition.contained":"Resource","OperationDefinition.date":"dateTime","OperationDefinition.description":"markdown","OperationDefinition.experimental":"boolean","OperationDefinition.extension":"Extension","OperationDefinition.id":"System.String","OperationDefinition.implicitRules":"uri","OperationDefinition.inputProfile":"canonical","OperationDefinition.instance":"boolean","OperationDefinition.jurisdiction":"CodeableConcept","OperationDefinition.kind":"code","OperationDefinition.language":"code","OperationDefinition.meta":"Meta","OperationDefinition.modifierExtension":"Extension","OperationDefinition.name":"string","OperationDefinition.outputProfile":"canonical","OperationDefinition.overload.comment":"string","OperationDefinition.overload.extension":"Extension","OperationDefinition.overload.id":"System.String","OperationDefinition.overload.modifierExtension":"Extension","OperationDefinition.overload.parameterName":"string","OperationDefinition.parameter.binding.extension":"Extension","OperationDefinition.parameter.binding.id":"System.String","OperationDefinition.parameter.binding.modifierExtension":"Extension","OperationDefinition.parameter.binding.strength":"code","OperationDefinition.parameter.binding.valueSet":"canonical","OperationDefinition.parameter.documentation":"string","OperationDefinition.parameter.extension":"Extension","OperationDefinition.parameter.id":"System.String","OperationDefinition.parameter.max":"string","OperationDefinition.parameter.min":"integer","OperationDefinition.parameter.modifierExtension":"Extension","OperationDefinition.parameter.name":"code","OperationDefinition.parameter.referencedFrom.extension":"Extension","OperationDefinition.parameter.referencedFrom.id":"System.String","OperationDefinition.parameter.referencedFrom.modifierExtension":"Extension","OperationDefinition.parameter.referencedFrom.source":"string","OperationDefinition.parameter.referencedFrom.sourceId":"string","OperationDefinition.parameter.searchType":"code","OperationDefinition.parameter.targetProfile":"canonical","OperationDefinition.parameter.type":"code","OperationDefinition.parameter.use":"code","OperationDefinition.publisher":"string","OperationDefinition.purpose":"markdown","OperationDefinition.resource":"code","OperationDefinition.status":"code","OperationDefinition.system":"boolean","OperationDefinition.text":"Narrative","OperationDefinition.title":"string","OperationDefinition.type":"boolean","OperationDefinition.url":"uri","OperationDefinition.useContext":"UsageContext","OperationDefinition.version":"string","OperationOutcome.contained":"Resource","OperationOutcome.extension":"Extension","OperationOutcome.id":"System.String","OperationOutcome.implicitRules":"uri","OperationOutcome.issue.code":"code","OperationOutcome.issue.details":"CodeableConcept","OperationOutcome.issue.diagnostics":"string","OperationOutcome.issue.expression":"string","OperationOutcome.issue.extension":"Extension","OperationOutcome.issue.id":"System.String","OperationOutcome.issue.location":"string","OperationOutcome.issue.modifierExtension":"Extension","OperationOutcome.issue.severity":"code","OperationOutcome.language":"code","OperationOutcome.meta":"Meta","OperationOutcome.modifierExtension":"Extension","OperationOutcome.text":"Narrative","Organization.active":"boolean","Organization.address":"Address","Organization.alias":"string","Organization.contact.address":"Address","Organization.contact.extension":"Extension","Organization.contact.id":"System.String","Organization.contact.modifierExtension":"Extension","Organization.contact.name":"HumanName","Organization.contact.purpose":"CodeableConcept","Organization.contact.telecom":"ContactPoint","Organization.contained":"Resource","Organization.endpoint":"Reference","Organization.extension":"Extension","Organization.id":"System.String","Organization.identifier":"Identifier","Organization.implicitRules":"uri","Organization.language":"code","Organization.meta":"Meta","Organization.modifierExtension":"Extension","Organization.name":"string","Organization.partOf":"Reference","Organization.telecom":"ContactPoint","Organization.text":"Narrative","Organization.type":"CodeableConcept","OrganizationAffiliation.active":"boolean","OrganizationAffiliation.code":"CodeableConcept","OrganizationAffiliation.contained":"Resource","OrganizationAffiliation.endpoint":"Reference","OrganizationAffiliation.extension":"Extension","OrganizationAffiliation.healthcareService":"Reference","OrganizationAffiliation.id":"System.String","OrganizationAffiliation.identifier":"Identifier","OrganizationAffiliation.implicitRules":"uri","OrganizationAffiliation.language":"code","OrganizationAffiliation.location":"Reference","OrganizationAffiliation.meta":"Meta","OrganizationAffiliation.modifierExtension":"Extension","OrganizationAffiliation.network":"Reference","OrganizationAffiliation.organization":"Reference","OrganizationAffiliation.participatingOrganization":"Reference","OrganizationAffiliation.period":"Period","OrganizationAffiliation.specialty":"CodeableConcept","OrganizationAffiliation.telecom":"ContactPoint","OrganizationAffiliation.text":"Narrative","ParameterDefinition.documentation":"string","ParameterDefinition.extension":"Extension","ParameterDefinition.id":"System.String","ParameterDefinition.max":"string","ParameterDefinition.min":"integer","ParameterDefinition.name":"code","ParameterDefinition.profile":"canonical","ParameterDefinition.type":"code","ParameterDefinition.use":"code","Parameters.id":"System.String","Parameters.implicitRules":"uri","Parameters.language":"code","Parameters.meta":"Meta","Parameters.parameter.extension":"Extension","Parameters.parameter.id":"System.String","Parameters.parameter.modifierExtension":"Extension","Parameters.parameter.name":"string","Parameters.parameter.resource":"Resource","Parameters.parameter.valueAddress":"Address","Parameters.parameter.valueAge":"Age","Parameters.parameter.valueAnnotation":"Annotation","Parameters.parameter.valueAttachment":"Attachment","Parameters.parameter.valueBase64Binary":"base64Binary","Parameters.parameter.valueBoolean":"boolean","Parameters.parameter.valueCanonical":"canonical","Parameters.parameter.valueCode":"code","Parameters.parameter.valueCodeableConcept":"CodeableConcept","Parameters.parameter.valueCoding":"Coding","Parameters.parameter.valueContactDetail":"ContactDetail","Parameters.parameter.valueContactPoint":"ContactPoint","Parameters.parameter.valueContributor":"Contributor","Parameters.parameter.valueCount":"Count","Parameters.parameter.valueDataRequirement":"DataRequirement","Parameters.parameter.valueDate":"date","Parameters.parameter.valueDateTime":"dateTime","Parameters.parameter.valueDecimal":"decimal","Parameters.parameter.valueDistance":"Distance","Parameters.parameter.valueDosage":"Dosage","Parameters.parameter.valueDuration":"Duration","Parameters.parameter.valueExpression":"Expression","Parameters.parameter.valueHumanName":"HumanName","Parameters.parameter.valueId":"id","Parameters.parameter.valueIdentifier":"Identifier","Parameters.parameter.valueInstant":"instant","Parameters.parameter.valueInteger":"integer","Parameters.parameter.valueMarkdown":"markdown","Parameters.parameter.valueMeta":"Meta","Parameters.parameter.valueMoney":"Money","Parameters.parameter.valueOid":"oid","Parameters.parameter.valueParameterDefinition":"ParameterDefinition","Parameters.parameter.valuePeriod":"Period","Parameters.parameter.valuePositiveInt":"positiveInt","Parameters.parameter.valueQuantity":"Quantity","Parameters.parameter.valueRange":"Range","Parameters.parameter.valueRatio":"Ratio","Parameters.parameter.valueReference":"Reference","Parameters.parameter.valueRelatedArtifact":"RelatedArtifact","Parameters.parameter.valueSampledData":"SampledData","Parameters.parameter.valueSignature":"Signature","Parameters.parameter.valueString":"string","Parameters.parameter.valueTime":"time","Parameters.parameter.valueTiming":"Timing","Parameters.parameter.valueTriggerDefinition":"TriggerDefinition","Parameters.parameter.valueUnsignedInt":"unsignedInt","Parameters.parameter.valueUri":"uri","Parameters.parameter.valueUrl":"url","Parameters.parameter.valueUsageContext":"UsageContext","Parameters.parameter.valueUuid":"uuid","Patient.active":"boolean","Patient.address":"Address","Patient.birthDate":"date","Patient.communication.extension":"Extension","Patient.communication.id":"System.String","Patient.communication.language":"CodeableConcept","Patient.communication.modifierExtension":"Extension","Patient.communication.preferred":"boolean","Patient.contact.address":"Address","Patient.contact.extension":"Extension","Patient.contact.gender":"code","Patient.contact.id":"System.String","Patient.contact.modifierExtension":"Extension","Patient.contact.name":"HumanName","Patient.contact.organization":"Reference","Patient.contact.period":"Period","Patient.contact.relationship":"CodeableConcept","Patient.contact.telecom":"ContactPoint","Patient.contained":"Resource","Patient.deceasedBoolean":"boolean","Patient.deceasedDateTime":"dateTime","Patient.extension":"Extension","Patient.gender":"code","Patient.generalPractitioner":"Reference","Patient.id":"System.String","Patient.identifier":"Identifier","Patient.implicitRules":"uri","Patient.language":"code","Patient.link.extension":"Extension","Patient.link.id":"System.String","Patient.link.modifierExtension":"Extension","Patient.link.other":"Reference","Patient.link.type":"code","Patient.managingOrganization":"Reference","Patient.maritalStatus":"CodeableConcept","Patient.meta":"Meta","Patient.modifierExtension":"Extension","Patient.multipleBirthBoolean":"boolean","Patient.multipleBirthInteger":"integer","Patient.name":"HumanName","Patient.photo":"Attachment","Patient.telecom":"ContactPoint","Patient.text":"Narrative","PaymentNotice.amount":"Money","PaymentNotice.contained":"Resource","PaymentNotice.created":"dateTime","PaymentNotice.extension":"Extension","PaymentNotice.id":"System.String","PaymentNotice.identifier":"Identifier","PaymentNotice.implicitRules":"uri","PaymentNotice.language":"code","PaymentNotice.meta":"Meta","PaymentNotice.modifierExtension":"Extension","PaymentNotice.payee":"Reference","PaymentNotice.payment":"Reference","PaymentNotice.paymentDate":"date","PaymentNotice.paymentStatus":"CodeableConcept","PaymentNotice.provider":"Reference","PaymentNotice.recipient":"Reference","PaymentNotice.request":"Reference","PaymentNotice.response":"Reference","PaymentNotice.status":"code","PaymentNotice.text":"Narrative","PaymentReconciliation.contained":"Resource","PaymentReconciliation.created":"dateTime","PaymentReconciliation.detail.amount":"Money","PaymentReconciliation.detail.date":"date","PaymentReconciliation.detail.extension":"Extension","PaymentReconciliation.detail.id":"System.String","PaymentReconciliation.detail.identifier":"Identifier","PaymentReconciliation.detail.modifierExtension":"Extension","PaymentReconciliation.detail.payee":"Reference","PaymentReconciliation.detail.predecessor":"Identifier","PaymentReconciliation.detail.request":"Reference","PaymentReconciliation.detail.response":"Reference","PaymentReconciliation.detail.responsible":"Reference","PaymentReconciliation.detail.submitter":"Reference","PaymentReconciliation.detail.type":"CodeableConcept","PaymentReconciliation.disposition":"string","PaymentReconciliation.extension":"Extension","PaymentReconciliation.formCode":"CodeableConcept","PaymentReconciliation.id":"System.String","PaymentReconciliation.identifier":"Identifier","PaymentReconciliation.implicitRules":"uri","PaymentReconciliation.language":"code","PaymentReconciliation.meta":"Meta","PaymentReconciliation.modifierExtension":"Extension","PaymentReconciliation.outcome":"code","PaymentReconciliation.paymentAmount":"Money","PaymentReconciliation.paymentDate":"date","PaymentReconciliation.paymentIdentifier":"Identifier","PaymentReconciliation.paymentIssuer":"Reference","PaymentReconciliation.period":"Period","PaymentReconciliation.processNote.extension":"Extension","PaymentReconciliation.processNote.id":"System.String","PaymentReconciliation.processNote.modifierExtension":"Extension","PaymentReconciliation.processNote.text":"string","PaymentReconciliation.processNote.type":"code","PaymentReconciliation.request":"Reference","PaymentReconciliation.requestor":"Reference","PaymentReconciliation.status":"code","PaymentReconciliation.text":"Narrative","Period.end":"dateTime","Period.extension":"Extension","Period.id":"System.String","Period.start":"dateTime","Person.active":"boolean","Person.address":"Address","Person.birthDate":"date","Person.contained":"Resource","Person.extension":"Extension","Person.gender":"code","Person.id":"System.String","Person.identifier":"Identifier","Person.implicitRules":"uri","Person.language":"code","Person.link.assurance":"code","Person.link.extension":"Extension","Person.link.id":"System.String","Person.link.modifierExtension":"Extension","Person.link.target":"Reference","Person.managingOrganization":"Reference","Person.meta":"Meta","Person.modifierExtension":"Extension","Person.name":"HumanName","Person.photo":"Attachment","Person.telecom":"ContactPoint","Person.text":"Narrative","PlanDefinition.action.cardinalityBehavior":"code","PlanDefinition.action.code":"CodeableConcept","PlanDefinition.action.condition.expression":"Expression","PlanDefinition.action.condition.extension":"Extension","PlanDefinition.action.condition.id":"System.String","PlanDefinition.action.condition.kind":"code","PlanDefinition.action.condition.modifierExtension":"Extension","PlanDefinition.action.definitionCanonical":"canonical","PlanDefinition.action.definitionUri":"uri","PlanDefinition.action.description":"string","PlanDefinition.action.documentation":"RelatedArtifact","PlanDefinition.action.dynamicValue.expression":"Expression","PlanDefinition.action.dynamicValue.extension":"Extension","PlanDefinition.action.dynamicValue.id":"System.String","PlanDefinition.action.dynamicValue.modifierExtension":"Extension","PlanDefinition.action.dynamicValue.path":"string","PlanDefinition.action.extension":"Extension","PlanDefinition.action.goalId":"id","PlanDefinition.action.groupingBehavior":"code","PlanDefinition.action.id":"System.String","PlanDefinition.action.input":"DataRequirement","PlanDefinition.action.modifierExtension":"Extension","PlanDefinition.action.output":"DataRequirement","PlanDefinition.action.participant.extension":"Extension","PlanDefinition.action.participant.id":"System.String","PlanDefinition.action.participant.modifierExtension":"Extension","PlanDefinition.action.participant.role":"CodeableConcept","PlanDefinition.action.participant.type":"code","PlanDefinition.action.precheckBehavior":"code","PlanDefinition.action.prefix":"string","PlanDefinition.action.priority":"code","PlanDefinition.action.reason":"CodeableConcept","PlanDefinition.action.relatedAction.actionId":"id","PlanDefinition.action.relatedAction.extension":"Extension","PlanDefinition.action.relatedAction.id":"System.String","PlanDefinition.action.relatedAction.modifierExtension":"Extension","PlanDefinition.action.relatedAction.offsetDuration":"Duration","PlanDefinition.action.relatedAction.offsetRange":"Range","PlanDefinition.action.relatedAction.relationship":"code","PlanDefinition.action.requiredBehavior":"code","PlanDefinition.action.selectionBehavior":"code","PlanDefinition.action.subjectCodeableConcept":"CodeableConcept","PlanDefinition.action.subjectReference":"Reference","PlanDefinition.action.textEquivalent":"string","PlanDefinition.action.timingAge":"Age","PlanDefinition.action.timingDateTime":"dateTime","PlanDefinition.action.timingDuration":"Duration","PlanDefinition.action.timingPeriod":"Period","PlanDefinition.action.timingRange":"Range","PlanDefinition.action.timingTiming":"Timing","PlanDefinition.action.title":"string","PlanDefinition.action.transform":"canonical","PlanDefinition.action.trigger":"TriggerDefinition","PlanDefinition.action.type":"CodeableConcept","PlanDefinition.approvalDate":"date","PlanDefinition.author":"ContactDetail","PlanDefinition.contact":"ContactDetail","PlanDefinition.contained":"Resource","PlanDefinition.copyright":"markdown","PlanDefinition.date":"dateTime","PlanDefinition.description":"markdown","PlanDefinition.editor":"ContactDetail","PlanDefinition.effectivePeriod":"Period","PlanDefinition.endorser":"ContactDetail","PlanDefinition.experimental":"boolean","PlanDefinition.extension":"Extension","PlanDefinition.goal.addresses":"CodeableConcept","PlanDefinition.goal.category":"CodeableConcept","PlanDefinition.goal.description":"CodeableConcept","PlanDefinition.goal.documentation":"RelatedArtifact","PlanDefinition.goal.extension":"Extension","PlanDefinition.goal.id":"System.String","PlanDefinition.goal.modifierExtension":"Extension","PlanDefinition.goal.priority":"CodeableConcept","PlanDefinition.goal.start":"CodeableConcept","PlanDefinition.goal.target.detailCodeableConcept":"CodeableConcept","PlanDefinition.goal.target.detailQuantity":"Quantity","PlanDefinition.goal.target.detailRange":"Range","PlanDefinition.goal.target.due":"Duration","PlanDefinition.goal.target.extension":"Extension","PlanDefinition.goal.target.id":"System.String","PlanDefinition.goal.target.measure":"CodeableConcept","PlanDefinition.goal.target.modifierExtension":"Extension","PlanDefinition.id":"System.String","PlanDefinition.identifier":"Identifier","PlanDefinition.implicitRules":"uri","PlanDefinition.jurisdiction":"CodeableConcept","PlanDefinition.language":"code","PlanDefinition.lastReviewDate":"date","PlanDefinition.library":"canonical","PlanDefinition.meta":"Meta","PlanDefinition.modifierExtension":"Extension","PlanDefinition.name":"string","PlanDefinition.publisher":"string","PlanDefinition.purpose":"markdown","PlanDefinition.relatedArtifact":"RelatedArtifact","PlanDefinition.reviewer":"ContactDetail","PlanDefinition.status":"code","PlanDefinition.subjectCodeableConcept":"CodeableConcept","PlanDefinition.subjectReference":"Reference","PlanDefinition.subtitle":"string","PlanDefinition.text":"Narrative","PlanDefinition.title":"string","PlanDefinition.topic":"CodeableConcept","PlanDefinition.type":"CodeableConcept","PlanDefinition.url":"uri","PlanDefinition.usage":"string","PlanDefinition.useContext":"UsageContext","PlanDefinition.version":"string","Population.ageCodeableConcept":"CodeableConcept","Population.ageRange":"Range","Population.extension":"Extension","Population.gender":"CodeableConcept","Population.id":"System.String","Population.modifierExtension":"Extension","Population.physiologicalCondition":"CodeableConcept","Population.race":"CodeableConcept","Practitioner.active":"boolean","Practitioner.address":"Address","Practitioner.birthDate":"date","Practitioner.communication":"CodeableConcept","Practitioner.contained":"Resource","Practitioner.extension":"Extension","Practitioner.gender":"code","Practitioner.id":"System.String","Practitioner.identifier":"Identifier","Practitioner.implicitRules":"uri","Practitioner.language":"code","Practitioner.meta":"Meta","Practitioner.modifierExtension":"Extension","Practitioner.name":"HumanName","Practitioner.photo":"Attachment","Practitioner.qualification.code":"CodeableConcept","Practitioner.qualification.extension":"Extension","Practitioner.qualification.id":"System.String","Practitioner.qualification.identifier":"Identifier","Practitioner.qualification.issuer":"Reference","Practitioner.qualification.modifierExtension":"Extension","Practitioner.qualification.period":"Period","Practitioner.telecom":"ContactPoint","Practitioner.text":"Narrative","PractitionerRole.active":"boolean","PractitionerRole.availabilityExceptions":"string","PractitionerRole.availableTime.allDay":"boolean","PractitionerRole.availableTime.availableEndTime":"time","PractitionerRole.availableTime.availableStartTime":"time","PractitionerRole.availableTime.daysOfWeek":"code","PractitionerRole.availableTime.extension":"Extension","PractitionerRole.availableTime.id":"System.String","PractitionerRole.availableTime.modifierExtension":"Extension","PractitionerRole.code":"CodeableConcept","PractitionerRole.contained":"Resource","PractitionerRole.endpoint":"Reference","PractitionerRole.extension":"Extension","PractitionerRole.healthcareService":"Reference","PractitionerRole.id":"System.String","PractitionerRole.identifier":"Identifier","PractitionerRole.implicitRules":"uri","PractitionerRole.language":"code","PractitionerRole.location":"Reference","PractitionerRole.meta":"Meta","PractitionerRole.modifierExtension":"Extension","PractitionerRole.notAvailable.description":"string","PractitionerRole.notAvailable.during":"Period","PractitionerRole.notAvailable.extension":"Extension","PractitionerRole.notAvailable.id":"System.String","PractitionerRole.notAvailable.modifierExtension":"Extension","PractitionerRole.organization":"Reference","PractitionerRole.period":"Period","PractitionerRole.practitioner":"Reference","PractitionerRole.specialty":"CodeableConcept","PractitionerRole.telecom":"ContactPoint","PractitionerRole.text":"Narrative","Procedure.asserter":"Reference","Procedure.basedOn":"Reference","Procedure.bodySite":"CodeableConcept","Procedure.category":"CodeableConcept","Procedure.code":"CodeableConcept","Procedure.complication":"CodeableConcept","Procedure.complicationDetail":"Reference","Procedure.contained":"Resource","Procedure.encounter":"Reference","Procedure.extension":"Extension","Procedure.focalDevice.action":"CodeableConcept","Procedure.focalDevice.extension":"Extension","Procedure.focalDevice.id":"System.String","Procedure.focalDevice.manipulated":"Reference","Procedure.focalDevice.modifierExtension":"Extension","Procedure.followUp":"CodeableConcept","Procedure.id":"System.String","Procedure.identifier":"Identifier","Procedure.implicitRules":"uri","Procedure.instantiatesCanonical":"canonical","Procedure.instantiatesUri":"uri","Procedure.language":"code","Procedure.location":"Reference","Procedure.meta":"Meta","Procedure.modifierExtension":"Extension","Procedure.note":"Annotation","Procedure.outcome":"CodeableConcept","Procedure.partOf":"Reference","Procedure.performedAge":"Age","Procedure.performedDateTime":"dateTime","Procedure.performedPeriod":"Period","Procedure.performedRange":"Range","Procedure.performedString":"string","Procedure.performer.actor":"Reference","Procedure.performer.extension":"Extension","Procedure.performer.function":"CodeableConcept","Procedure.performer.id":"System.String","Procedure.performer.modifierExtension":"Extension","Procedure.performer.onBehalfOf":"Reference","Procedure.reasonCode":"CodeableConcept","Procedure.reasonReference":"Reference","Procedure.recorder":"Reference","Procedure.report":"Reference","Procedure.status":"code","Procedure.statusReason":"CodeableConcept","Procedure.subject":"Reference","Procedure.text":"Narrative","Procedure.usedCode":"CodeableConcept","Procedure.usedReference":"Reference","ProdCharacteristic.color":"string","ProdCharacteristic.depth":"Quantity","ProdCharacteristic.extension":"Extension","ProdCharacteristic.externalDiameter":"Quantity","ProdCharacteristic.height":"Quantity","ProdCharacteristic.id":"System.String","ProdCharacteristic.image":"Attachment","ProdCharacteristic.imprint":"string","ProdCharacteristic.modifierExtension":"Extension","ProdCharacteristic.nominalVolume":"Quantity","ProdCharacteristic.scoring":"CodeableConcept","ProdCharacteristic.shape":"string","ProdCharacteristic.weight":"Quantity","ProdCharacteristic.width":"Quantity","ProductShelfLife.extension":"Extension","ProductShelfLife.id":"System.String","ProductShelfLife.identifier":"Identifier","ProductShelfLife.modifierExtension":"Extension","ProductShelfLife.period":"Quantity","ProductShelfLife.specialPrecautionsForStorage":"CodeableConcept","ProductShelfLife.type":"CodeableConcept","Provenance.activity":"CodeableConcept","Provenance.agent.extension":"Extension","Provenance.agent.id":"System.String","Provenance.agent.modifierExtension":"Extension","Provenance.agent.onBehalfOf":"Reference","Provenance.agent.role":"CodeableConcept","Provenance.agent.type":"CodeableConcept","Provenance.agent.who":"Reference","Provenance.contained":"Resource","Provenance.entity.extension":"Extension","Provenance.entity.id":"System.String","Provenance.entity.modifierExtension":"Extension","Provenance.entity.role":"code","Provenance.entity.what":"Reference","Provenance.extension":"Extension","Provenance.id":"System.String","Provenance.implicitRules":"uri","Provenance.language":"code","Provenance.location":"Reference","Provenance.meta":"Meta","Provenance.modifierExtension":"Extension","Provenance.occurredDateTime":"dateTime","Provenance.occurredPeriod":"Period","Provenance.policy":"uri","Provenance.reason":"CodeableConcept","Provenance.recorded":"instant","Provenance.signature":"Signature","Provenance.target":"Reference","Provenance.text":"Narrative","Quantity.code":"code","Quantity.comparator":"code","Quantity.extension":"Extension","Quantity.id":"System.String","Quantity.system":"uri","Quantity.unit":"string","Quantity.value":"decimal","Questionnaire.approvalDate":"date","Questionnaire.code":"Coding","Questionnaire.contact":"ContactDetail","Questionnaire.contained":"Resource","Questionnaire.copyright":"markdown","Questionnaire.date":"dateTime","Questionnaire.derivedFrom":"canonical","Questionnaire.description":"markdown","Questionnaire.effectivePeriod":"Period","Questionnaire.experimental":"boolean","Questionnaire.extension":"Extension","Questionnaire.id":"System.String","Questionnaire.identifier":"Identifier","Questionnaire.implicitRules":"uri","Questionnaire.item.answerOption.extension":"Extension","Questionnaire.item.answerOption.id":"System.String","Questionnaire.item.answerOption.initialSelected":"boolean","Questionnaire.item.answerOption.modifierExtension":"Extension","Questionnaire.item.answerOption.valueCoding":"Coding","Questionnaire.item.answerOption.valueDate":"date","Questionnaire.item.answerOption.valueInteger":"integer","Questionnaire.item.answerOption.valueReference":"Reference","Questionnaire.item.answerOption.valueString":"string","Questionnaire.item.answerOption.valueTime":"time","Questionnaire.item.answerValueSet":"canonical","Questionnaire.item.code":"Coding","Questionnaire.item.definition":"uri","Questionnaire.item.enableBehavior":"code","Questionnaire.item.enableWhen.answerBoolean":"boolean","Questionnaire.item.enableWhen.answerCoding":"Coding","Questionnaire.item.enableWhen.answerDate":"date","Questionnaire.item.enableWhen.answerDateTime":"dateTime","Questionnaire.item.enableWhen.answerDecimal":"decimal","Questionnaire.item.enableWhen.answerInteger":"integer","Questionnaire.item.enableWhen.answerQuantity":"Quantity","Questionnaire.item.enableWhen.answerReference":"Reference","Questionnaire.item.enableWhen.answerString":"string","Questionnaire.item.enableWhen.answerTime":"time","Questionnaire.item.enableWhen.extension":"Extension","Questionnaire.item.enableWhen.id":"System.String","Questionnaire.item.enableWhen.modifierExtension":"Extension","Questionnaire.item.enableWhen.operator":"code","Questionnaire.item.enableWhen.question":"string","Questionnaire.item.extension":"Extension","Questionnaire.item.id":"System.String","Questionnaire.item.initial.extension":"Extension","Questionnaire.item.initial.id":"System.String","Questionnaire.item.initial.modifierExtension":"Extension","Questionnaire.item.initial.valueAttachment":"Attachment","Questionnaire.item.initial.valueBoolean":"boolean","Questionnaire.item.initial.valueCoding":"Coding","Questionnaire.item.initial.valueDate":"date","Questionnaire.item.initial.valueDateTime":"dateTime","Questionnaire.item.initial.valueDecimal":"decimal","Questionnaire.item.initial.valueInteger":"integer","Questionnaire.item.initial.valueQuantity":"Quantity","Questionnaire.item.initial.valueReference":"Reference","Questionnaire.item.initial.valueString":"string","Questionnaire.item.initial.valueTime":"time","Questionnaire.item.initial.valueUri":"uri","Questionnaire.item.linkId":"string","Questionnaire.item.maxLength":"integer","Questionnaire.item.modifierExtension":"Extension","Questionnaire.item.prefix":"string","Questionnaire.item.readOnly":"boolean","Questionnaire.item.repeats":"boolean","Questionnaire.item.required":"boolean","Questionnaire.item.text":"string","Questionnaire.item.type":"code","Questionnaire.jurisdiction":"CodeableConcept","Questionnaire.language":"code","Questionnaire.lastReviewDate":"date","Questionnaire.meta":"Meta","Questionnaire.modifierExtension":"Extension","Questionnaire.name":"string","Questionnaire.publisher":"string","Questionnaire.purpose":"markdown","Questionnaire.status":"code","Questionnaire.subjectType":"code","Questionnaire.text":"Narrative","Questionnaire.title":"string","Questionnaire.url":"uri","Questionnaire.useContext":"UsageContext","Questionnaire.version":"string","QuestionnaireResponse.author":"Reference","QuestionnaireResponse.authored":"dateTime","QuestionnaireResponse.basedOn":"Reference","QuestionnaireResponse.contained":"Resource","QuestionnaireResponse.encounter":"Reference","QuestionnaireResponse.extension":"Extension","QuestionnaireResponse.id":"System.String","QuestionnaireResponse.identifier":"Identifier","QuestionnaireResponse.implicitRules":"uri","QuestionnaireResponse.item.answer.extension":"Extension","QuestionnaireResponse.item.answer.id":"System.String","QuestionnaireResponse.item.answer.modifierExtension":"Extension","QuestionnaireResponse.item.answer.valueAttachment":"Attachment","QuestionnaireResponse.item.answer.valueBoolean":"boolean","QuestionnaireResponse.item.answer.valueCoding":"Coding","QuestionnaireResponse.item.answer.valueDate":"date","QuestionnaireResponse.item.answer.valueDateTime":"dateTime","QuestionnaireResponse.item.answer.valueDecimal":"decimal","QuestionnaireResponse.item.answer.valueInteger":"integer","QuestionnaireResponse.item.answer.valueQuantity":"Quantity","QuestionnaireResponse.item.answer.valueReference":"Reference","QuestionnaireResponse.item.answer.valueString":"string","QuestionnaireResponse.item.answer.valueTime":"time","QuestionnaireResponse.item.answer.valueUri":"uri","QuestionnaireResponse.item.definition":"uri","QuestionnaireResponse.item.extension":"Extension","QuestionnaireResponse.item.id":"System.String","QuestionnaireResponse.item.linkId":"string","QuestionnaireResponse.item.modifierExtension":"Extension","QuestionnaireResponse.item.text":"string","QuestionnaireResponse.language":"code","QuestionnaireResponse.meta":"Meta","QuestionnaireResponse.modifierExtension":"Extension","QuestionnaireResponse.partOf":"Reference","QuestionnaireResponse.questionnaire":"canonical","QuestionnaireResponse.source":"Reference","QuestionnaireResponse.status":"code","QuestionnaireResponse.subject":"Reference","QuestionnaireResponse.text":"Narrative","Range.extension":"Extension","Range.high":"Quantity","Range.id":"System.String","Range.low":"Quantity","Ratio.denominator":"Quantity","Ratio.extension":"Extension","Ratio.id":"System.String","Ratio.numerator":"Quantity","Reference.display":"string","Reference.extension":"Extension","Reference.id":"System.String","Reference.identifier":"Identifier","Reference.reference":"string","Reference.type":"uri","RelatedArtifact.citation":"markdown","RelatedArtifact.display":"string","RelatedArtifact.document":"Attachment","RelatedArtifact.extension":"Extension","RelatedArtifact.id":"System.String","RelatedArtifact.label":"string","RelatedArtifact.resource":"canonical","RelatedArtifact.type":"code","RelatedArtifact.url":"url","RelatedPerson.active":"boolean","RelatedPerson.address":"Address","RelatedPerson.birthDate":"date","RelatedPerson.communication.extension":"Extension","RelatedPerson.communication.id":"System.String","RelatedPerson.communication.language":"CodeableConcept","RelatedPerson.communication.modifierExtension":"Extension","RelatedPerson.communication.preferred":"boolean","RelatedPerson.contained":"Resource","RelatedPerson.extension":"Extension","RelatedPerson.gender":"code","RelatedPerson.id":"System.String","RelatedPerson.identifier":"Identifier","RelatedPerson.implicitRules":"uri","RelatedPerson.language":"code","RelatedPerson.meta":"Meta","RelatedPerson.modifierExtension":"Extension","RelatedPerson.name":"HumanName","RelatedPerson.patient":"Reference","RelatedPerson.period":"Period","RelatedPerson.photo":"Attachment","RelatedPerson.relationship":"CodeableConcept","RelatedPerson.telecom":"ContactPoint","RelatedPerson.text":"Narrative","RequestGroup.action.cardinalityBehavior":"code","RequestGroup.action.code":"CodeableConcept","RequestGroup.action.condition.expression":"Expression","RequestGroup.action.condition.extension":"Extension","RequestGroup.action.condition.id":"System.String","RequestGroup.action.condition.kind":"code","RequestGroup.action.condition.modifierExtension":"Extension","RequestGroup.action.description":"string","RequestGroup.action.documentation":"RelatedArtifact","RequestGroup.action.extension":"Extension","RequestGroup.action.groupingBehavior":"code","RequestGroup.action.id":"System.String","RequestGroup.action.modifierExtension":"Extension","RequestGroup.action.participant":"Reference","RequestGroup.action.precheckBehavior":"code","RequestGroup.action.prefix":"string","RequestGroup.action.priority":"code","RequestGroup.action.relatedAction.actionId":"id","RequestGroup.action.relatedAction.extension":"Extension","RequestGroup.action.relatedAction.id":"System.String","RequestGroup.action.relatedAction.modifierExtension":"Extension","RequestGroup.action.relatedAction.offsetDuration":"Duration","RequestGroup.action.relatedAction.offsetRange":"Range","RequestGroup.action.relatedAction.relationship":"code","RequestGroup.action.requiredBehavior":"code","RequestGroup.action.resource":"Reference","RequestGroup.action.selectionBehavior":"code","RequestGroup.action.textEquivalent":"string","RequestGroup.action.timingAge":"Age","RequestGroup.action.timingDateTime":"dateTime","RequestGroup.action.timingDuration":"Duration","RequestGroup.action.timingPeriod":"Period","RequestGroup.action.timingRange":"Range","RequestGroup.action.timingTiming":"Timing","RequestGroup.action.title":"string","RequestGroup.action.type":"CodeableConcept","RequestGroup.author":"Reference","RequestGroup.authoredOn":"dateTime","RequestGroup.basedOn":"Reference","RequestGroup.code":"CodeableConcept","RequestGroup.contained":"Resource","RequestGroup.encounter":"Reference","RequestGroup.extension":"Extension","RequestGroup.groupIdentifier":"Identifier","RequestGroup.id":"System.String","RequestGroup.identifier":"Identifier","RequestGroup.implicitRules":"uri","RequestGroup.instantiatesCanonical":"canonical","RequestGroup.instantiatesUri":"uri","RequestGroup.intent":"code","RequestGroup.language":"code","RequestGroup.meta":"Meta","RequestGroup.modifierExtension":"Extension","RequestGroup.note":"Annotation","RequestGroup.priority":"code","RequestGroup.reasonCode":"CodeableConcept","RequestGroup.reasonReference":"Reference","RequestGroup.replaces":"Reference","RequestGroup.status":"code","RequestGroup.subject":"Reference","RequestGroup.text":"Narrative","ResearchDefinition.approvalDate":"date","ResearchDefinition.author":"ContactDetail","ResearchDefinition.comment":"string","ResearchDefinition.contact":"ContactDetail","ResearchDefinition.contained":"Resource","ResearchDefinition.copyright":"markdown","ResearchDefinition.date":"dateTime","ResearchDefinition.description":"markdown","ResearchDefinition.editor":"ContactDetail","ResearchDefinition.effectivePeriod":"Period","ResearchDefinition.endorser":"ContactDetail","ResearchDefinition.experimental":"boolean","ResearchDefinition.exposure":"Reference","ResearchDefinition.exposureAlternative":"Reference","ResearchDefinition.extension":"Extension","ResearchDefinition.id":"System.String","ResearchDefinition.identifier":"Identifier","ResearchDefinition.implicitRules":"uri","ResearchDefinition.jurisdiction":"CodeableConcept","ResearchDefinition.language":"code","ResearchDefinition.lastReviewDate":"date","ResearchDefinition.library":"canonical","ResearchDefinition.meta":"Meta","ResearchDefinition.modifierExtension":"Extension","ResearchDefinition.name":"string","ResearchDefinition.outcome":"Reference","ResearchDefinition.population":"Reference","ResearchDefinition.publisher":"string","ResearchDefinition.purpose":"markdown","ResearchDefinition.relatedArtifact":"RelatedArtifact","ResearchDefinition.reviewer":"ContactDetail","ResearchDefinition.shortTitle":"string","ResearchDefinition.status":"code","ResearchDefinition.subjectCodeableConcept":"CodeableConcept","ResearchDefinition.subjectReference":"Reference","ResearchDefinition.subtitle":"string","ResearchDefinition.text":"Narrative","ResearchDefinition.title":"string","ResearchDefinition.topic":"CodeableConcept","ResearchDefinition.url":"uri","ResearchDefinition.usage":"string","ResearchDefinition.useContext":"UsageContext","ResearchDefinition.version":"string","ResearchElementDefinition.approvalDate":"date","ResearchElementDefinition.author":"ContactDetail","ResearchElementDefinition.characteristic.definitionCanonical":"canonical","ResearchElementDefinition.characteristic.definitionCodeableConcept":"CodeableConcept","ResearchElementDefinition.characteristic.definitionDataRequirement":"DataRequirement","ResearchElementDefinition.characteristic.definitionExpression":"Expression","ResearchElementDefinition.characteristic.exclude":"boolean","ResearchElementDefinition.characteristic.extension":"Extension","ResearchElementDefinition.characteristic.id":"System.String","ResearchElementDefinition.characteristic.modifierExtension":"Extension","ResearchElementDefinition.characteristic.participantEffectiveDateTime":"dateTime","ResearchElementDefinition.characteristic.participantEffectiveDescription":"string","ResearchElementDefinition.characteristic.participantEffectiveDuration":"Duration","ResearchElementDefinition.characteristic.participantEffectiveGroupMeasure":"code","ResearchElementDefinition.characteristic.participantEffectivePeriod":"Period","ResearchElementDefinition.characteristic.participantEffectiveTimeFromStart":"Duration","ResearchElementDefinition.characteristic.participantEffectiveTiming":"Timing","ResearchElementDefinition.characteristic.studyEffectiveDateTime":"dateTime","ResearchElementDefinition.characteristic.studyEffectiveDescription":"string","ResearchElementDefinition.characteristic.studyEffectiveDuration":"Duration","ResearchElementDefinition.characteristic.studyEffectiveGroupMeasure":"code","ResearchElementDefinition.characteristic.studyEffectivePeriod":"Period","ResearchElementDefinition.characteristic.studyEffectiveTimeFromStart":"Duration","ResearchElementDefinition.characteristic.studyEffectiveTiming":"Timing","ResearchElementDefinition.characteristic.unitOfMeasure":"CodeableConcept","ResearchElementDefinition.characteristic.usageContext":"UsageContext","ResearchElementDefinition.comment":"string","ResearchElementDefinition.contact":"ContactDetail","ResearchElementDefinition.contained":"Resource","ResearchElementDefinition.copyright":"markdown","ResearchElementDefinition.date":"dateTime","ResearchElementDefinition.description":"markdown","ResearchElementDefinition.editor":"ContactDetail","ResearchElementDefinition.effectivePeriod":"Period","ResearchElementDefinition.endorser":"ContactDetail","ResearchElementDefinition.experimental":"boolean","ResearchElementDefinition.extension":"Extension","ResearchElementDefinition.id":"System.String","ResearchElementDefinition.identifier":"Identifier","ResearchElementDefinition.implicitRules":"uri","ResearchElementDefinition.jurisdiction":"CodeableConcept","ResearchElementDefinition.language":"code","ResearchElementDefinition.lastReviewDate":"date","ResearchElementDefinition.library":"canonical","ResearchElementDefinition.meta":"Meta","ResearchElementDefinition.modifierExtension":"Extension","ResearchElementDefinition.name":"string","ResearchElementDefinition.publisher":"string","ResearchElementDefinition.purpose":"markdown","ResearchElementDefinition.relatedArtifact":"RelatedArtifact","ResearchElementDefinition.reviewer":"ContactDetail","ResearchElementDefinition.shortTitle":"string","ResearchElementDefinition.status":"code","ResearchElementDefinition.subjectCodeableConcept":"CodeableConcept","ResearchElementDefinition.subjectReference":"Reference","ResearchElementDefinition.subtitle":"string","ResearchElementDefinition.text":"Narrative","ResearchElementDefinition.title":"string","ResearchElementDefinition.topic":"CodeableConcept","ResearchElementDefinition.type":"code","ResearchElementDefinition.url":"uri","ResearchElementDefinition.usage":"string","ResearchElementDefinition.useContext":"UsageContext","ResearchElementDefinition.variableType":"code","ResearchElementDefinition.version":"string","ResearchStudy.arm.description":"string","ResearchStudy.arm.extension":"Extension","ResearchStudy.arm.id":"System.String","ResearchStudy.arm.modifierExtension":"Extension","ResearchStudy.arm.name":"string","ResearchStudy.arm.type":"CodeableConcept","ResearchStudy.category":"CodeableConcept","ResearchStudy.condition":"CodeableConcept","ResearchStudy.contact":"ContactDetail","ResearchStudy.contained":"Resource","ResearchStudy.description":"markdown","ResearchStudy.enrollment":"Reference","ResearchStudy.extension":"Extension","ResearchStudy.focus":"CodeableConcept","ResearchStudy.id":"System.String","ResearchStudy.identifier":"Identifier","ResearchStudy.implicitRules":"uri","ResearchStudy.keyword":"CodeableConcept","ResearchStudy.language":"code","ResearchStudy.location":"CodeableConcept","ResearchStudy.meta":"Meta","ResearchStudy.modifierExtension":"Extension","ResearchStudy.note":"Annotation","ResearchStudy.objective.extension":"Extension","ResearchStudy.objective.id":"System.String","ResearchStudy.objective.modifierExtension":"Extension","ResearchStudy.objective.name":"string","ResearchStudy.objective.type":"CodeableConcept","ResearchStudy.partOf":"Reference","ResearchStudy.period":"Period","ResearchStudy.phase":"CodeableConcept","ResearchStudy.primaryPurposeType":"CodeableConcept","ResearchStudy.principalInvestigator":"Reference","ResearchStudy.protocol":"Reference","ResearchStudy.reasonStopped":"CodeableConcept","ResearchStudy.relatedArtifact":"RelatedArtifact","ResearchStudy.site":"Reference","ResearchStudy.sponsor":"Reference","ResearchStudy.status":"code","ResearchStudy.text":"Narrative","ResearchStudy.title":"string","ResearchSubject.actualArm":"string","ResearchSubject.assignedArm":"string","ResearchSubject.consent":"Reference","ResearchSubject.contained":"Resource","ResearchSubject.extension":"Extension","ResearchSubject.id":"System.String","ResearchSubject.identifier":"Identifier","ResearchSubject.implicitRules":"uri","ResearchSubject.individual":"Reference","ResearchSubject.language":"code","ResearchSubject.meta":"Meta","ResearchSubject.modifierExtension":"Extension","ResearchSubject.period":"Period","ResearchSubject.status":"code","ResearchSubject.study":"Reference","ResearchSubject.text":"Narrative","Resource.id":"System.String","Resource.implicitRules":"uri","Resource.language":"code","Resource.meta":"Meta","RiskAssessment.basedOn":"Reference","RiskAssessment.basis":"Reference","RiskAssessment.code":"CodeableConcept","RiskAssessment.condition":"Reference","RiskAssessment.contained":"Resource","RiskAssessment.encounter":"Reference","RiskAssessment.extension":"Extension","RiskAssessment.id":"System.String","RiskAssessment.identifier":"Identifier","RiskAssessment.implicitRules":"uri","RiskAssessment.language":"code","RiskAssessment.meta":"Meta","RiskAssessment.method":"CodeableConcept","RiskAssessment.mitigation":"string","RiskAssessment.modifierExtension":"Extension","RiskAssessment.note":"Annotation","RiskAssessment.occurrenceDateTime":"dateTime","RiskAssessment.occurrencePeriod":"Period","RiskAssessment.parent":"Reference","RiskAssessment.performer":"Reference","RiskAssessment.prediction.extension":"Extension","RiskAssessment.prediction.id":"System.String","RiskAssessment.prediction.modifierExtension":"Extension","RiskAssessment.prediction.outcome":"CodeableConcept","RiskAssessment.prediction.probabilityDecimal":"decimal","RiskAssessment.prediction.probabilityRange":"Range","RiskAssessment.prediction.qualitativeRisk":"CodeableConcept","RiskAssessment.prediction.rationale":"string","RiskAssessment.prediction.relativeRisk":"decimal","RiskAssessment.prediction.whenPeriod":"Period","RiskAssessment.prediction.whenRange":"Range","RiskAssessment.reasonCode":"CodeableConcept","RiskAssessment.reasonReference":"Reference","RiskAssessment.status":"code","RiskAssessment.subject":"Reference","RiskAssessment.text":"Narrative","RiskEvidenceSynthesis.approvalDate":"date","RiskEvidenceSynthesis.author":"ContactDetail","RiskEvidenceSynthesis.certainty.certaintySubcomponent.extension":"Extension","RiskEvidenceSynthesis.certainty.certaintySubcomponent.id":"System.String","RiskEvidenceSynthesis.certainty.certaintySubcomponent.modifierExtension":"Extension","RiskEvidenceSynthesis.certainty.certaintySubcomponent.note":"Annotation","RiskEvidenceSynthesis.certainty.certaintySubcomponent.rating":"CodeableConcept","RiskEvidenceSynthesis.certainty.certaintySubcomponent.type":"CodeableConcept","RiskEvidenceSynthesis.certainty.extension":"Extension","RiskEvidenceSynthesis.certainty.id":"System.String","RiskEvidenceSynthesis.certainty.modifierExtension":"Extension","RiskEvidenceSynthesis.certainty.note":"Annotation","RiskEvidenceSynthesis.certainty.rating":"CodeableConcept","RiskEvidenceSynthesis.contact":"ContactDetail","RiskEvidenceSynthesis.contained":"Resource","RiskEvidenceSynthesis.copyright":"markdown","RiskEvidenceSynthesis.date":"dateTime","RiskEvidenceSynthesis.description":"markdown","RiskEvidenceSynthesis.editor":"ContactDetail","RiskEvidenceSynthesis.effectivePeriod":"Period","RiskEvidenceSynthesis.endorser":"ContactDetail","RiskEvidenceSynthesis.exposure":"Reference","RiskEvidenceSynthesis.extension":"Extension","RiskEvidenceSynthesis.id":"System.String","RiskEvidenceSynthesis.identifier":"Identifier","RiskEvidenceSynthesis.implicitRules":"uri","RiskEvidenceSynthesis.jurisdiction":"CodeableConcept","RiskEvidenceSynthesis.language":"code","RiskEvidenceSynthesis.lastReviewDate":"date","RiskEvidenceSynthesis.meta":"Meta","RiskEvidenceSynthesis.modifierExtension":"Extension","RiskEvidenceSynthesis.name":"string","RiskEvidenceSynthesis.note":"Annotation","RiskEvidenceSynthesis.outcome":"Reference","RiskEvidenceSynthesis.population":"Reference","RiskEvidenceSynthesis.publisher":"string","RiskEvidenceSynthesis.relatedArtifact":"RelatedArtifact","RiskEvidenceSynthesis.reviewer":"ContactDetail","RiskEvidenceSynthesis.riskEstimate.denominatorCount":"integer","RiskEvidenceSynthesis.riskEstimate.description":"string","RiskEvidenceSynthesis.riskEstimate.extension":"Extension","RiskEvidenceSynthesis.riskEstimate.id":"System.String","RiskEvidenceSynthesis.riskEstimate.modifierExtension":"Extension","RiskEvidenceSynthesis.riskEstimate.numeratorCount":"integer","RiskEvidenceSynthesis.riskEstimate.precisionEstimate.extension":"Extension","RiskEvidenceSynthesis.riskEstimate.precisionEstimate.from":"decimal","RiskEvidenceSynthesis.riskEstimate.precisionEstimate.id":"System.String","RiskEvidenceSynthesis.riskEstimate.precisionEstimate.level":"decimal","RiskEvidenceSynthesis.riskEstimate.precisionEstimate.modifierExtension":"Extension","RiskEvidenceSynthesis.riskEstimate.precisionEstimate.to":"decimal","RiskEvidenceSynthesis.riskEstimate.precisionEstimate.type":"CodeableConcept","RiskEvidenceSynthesis.riskEstimate.type":"CodeableConcept","RiskEvidenceSynthesis.riskEstimate.unitOfMeasure":"CodeableConcept","RiskEvidenceSynthesis.riskEstimate.value":"decimal","RiskEvidenceSynthesis.sampleSize.description":"string","RiskEvidenceSynthesis.sampleSize.extension":"Extension","RiskEvidenceSynthesis.sampleSize.id":"System.String","RiskEvidenceSynthesis.sampleSize.modifierExtension":"Extension","RiskEvidenceSynthesis.sampleSize.numberOfParticipants":"integer","RiskEvidenceSynthesis.sampleSize.numberOfStudies":"integer","RiskEvidenceSynthesis.status":"code","RiskEvidenceSynthesis.studyType":"CodeableConcept","RiskEvidenceSynthesis.synthesisType":"CodeableConcept","RiskEvidenceSynthesis.text":"Narrative","RiskEvidenceSynthesis.title":"string","RiskEvidenceSynthesis.topic":"CodeableConcept","RiskEvidenceSynthesis.url":"uri","RiskEvidenceSynthesis.useContext":"UsageContext","RiskEvidenceSynthesis.version":"string","SampledData.data":"string","SampledData.dimensions":"positiveInt","SampledData.extension":"Extension","SampledData.factor":"decimal","SampledData.id":"System.String","SampledData.lowerLimit":"decimal","SampledData.origin":"Quantity","SampledData.period":"decimal","SampledData.upperLimit":"decimal","Schedule.active":"boolean","Schedule.actor":"Reference","Schedule.comment":"string","Schedule.contained":"Resource","Schedule.extension":"Extension","Schedule.id":"System.String","Schedule.identifier":"Identifier","Schedule.implicitRules":"uri","Schedule.language":"code","Schedule.meta":"Meta","Schedule.modifierExtension":"Extension","Schedule.planningHorizon":"Period","Schedule.serviceCategory":"CodeableConcept","Schedule.serviceType":"CodeableConcept","Schedule.specialty":"CodeableConcept","Schedule.text":"Narrative","SearchParameter.base":"code","SearchParameter.chain":"string","SearchParameter.code":"code","SearchParameter.comparator":"code","SearchParameter.component.definition":"canonical","SearchParameter.component.expression":"string","SearchParameter.component.extension":"Extension","SearchParameter.component.id":"System.String","SearchParameter.component.modifierExtension":"Extension","SearchParameter.contact":"ContactDetail","SearchParameter.contained":"Resource","SearchParameter.date":"dateTime","SearchParameter.derivedFrom":"canonical","SearchParameter.description":"markdown","SearchParameter.experimental":"boolean","SearchParameter.expression":"string","SearchParameter.extension":"Extension","SearchParameter.id":"System.String","SearchParameter.implicitRules":"uri","SearchParameter.jurisdiction":"CodeableConcept","SearchParameter.language":"code","SearchParameter.meta":"Meta","SearchParameter.modifier":"code","SearchParameter.modifierExtension":"Extension","SearchParameter.multipleAnd":"boolean","SearchParameter.multipleOr":"boolean","SearchParameter.name":"string","SearchParameter.publisher":"string","SearchParameter.purpose":"markdown","SearchParameter.status":"code","SearchParameter.target":"code","SearchParameter.text":"Narrative","SearchParameter.type":"code","SearchParameter.url":"uri","SearchParameter.useContext":"UsageContext","SearchParameter.version":"string","SearchParameter.xpath":"string","SearchParameter.xpathUsage":"code","ServiceRequest.asNeededBoolean":"boolean","ServiceRequest.asNeededCodeableConcept":"CodeableConcept","ServiceRequest.authoredOn":"dateTime","ServiceRequest.basedOn":"Reference","ServiceRequest.bodySite":"CodeableConcept","ServiceRequest.category":"CodeableConcept","ServiceRequest.code":"CodeableConcept","ServiceRequest.contained":"Resource","ServiceRequest.doNotPerform":"boolean","ServiceRequest.encounter":"Reference","ServiceRequest.extension":"Extension","ServiceRequest.id":"System.String","ServiceRequest.identifier":"Identifier","ServiceRequest.implicitRules":"uri","ServiceRequest.instantiatesCanonical":"canonical","ServiceRequest.instantiatesUri":"uri","ServiceRequest.insurance":"Reference","ServiceRequest.intent":"code","ServiceRequest.language":"code","ServiceRequest.locationCode":"CodeableConcept","ServiceRequest.locationReference":"Reference","ServiceRequest.meta":"Meta","ServiceRequest.modifierExtension":"Extension","ServiceRequest.note":"Annotation","ServiceRequest.occurrenceDateTime":"dateTime","ServiceRequest.occurrencePeriod":"Period","ServiceRequest.occurrenceTiming":"Timing","ServiceRequest.orderDetail":"CodeableConcept","ServiceRequest.patientInstruction":"string","ServiceRequest.performer":"Reference","ServiceRequest.performerType":"CodeableConcept","ServiceRequest.priority":"code","ServiceRequest.quantityQuantity":"Quantity","ServiceRequest.quantityRange":"Range","ServiceRequest.quantityRatio":"Ratio","ServiceRequest.reasonCode":"CodeableConcept","ServiceRequest.reasonReference":"Reference","ServiceRequest.relevantHistory":"Reference","ServiceRequest.replaces":"Reference","ServiceRequest.requester":"Reference","ServiceRequest.requisition":"Identifier","ServiceRequest.specimen":"Reference","ServiceRequest.status":"code","ServiceRequest.subject":"Reference","ServiceRequest.supportingInfo":"Reference","ServiceRequest.text":"Narrative","Signature.data":"base64Binary","Signature.extension":"Extension","Signature.id":"System.String","Signature.onBehalfOf":"Reference","Signature.sigFormat":"code","Signature.targetFormat":"code","Signature.type":"Coding","Signature.when":"instant","Signature.who":"Reference","Slot.appointmentType":"CodeableConcept","Slot.comment":"string","Slot.contained":"Resource","Slot.end":"instant","Slot.extension":"Extension","Slot.id":"System.String","Slot.identifier":"Identifier","Slot.implicitRules":"uri","Slot.language":"code","Slot.meta":"Meta","Slot.modifierExtension":"Extension","Slot.overbooked":"boolean","Slot.schedule":"Reference","Slot.serviceCategory":"CodeableConcept","Slot.serviceType":"CodeableConcept","Slot.specialty":"CodeableConcept","Slot.start":"instant","Slot.status":"code","Slot.text":"Narrative","Specimen.accessionIdentifier":"Identifier","Specimen.collection.bodySite":"CodeableConcept","Specimen.collection.collectedDateTime":"dateTime","Specimen.collection.collectedPeriod":"Period","Specimen.collection.collector":"Reference","Specimen.collection.duration":"Duration","Specimen.collection.extension":"Extension","Specimen.collection.fastingStatusCodeableConcept":"CodeableConcept","Specimen.collection.fastingStatusDuration":"Duration","Specimen.collection.id":"System.String","Specimen.collection.method":"CodeableConcept","Specimen.collection.modifierExtension":"Extension","Specimen.collection.quantity":"Quantity","Specimen.condition":"CodeableConcept","Specimen.contained":"Resource","Specimen.container.additiveCodeableConcept":"CodeableConcept","Specimen.container.additiveReference":"Reference","Specimen.container.capacity":"Quantity","Specimen.container.description":"string","Specimen.container.extension":"Extension","Specimen.container.id":"System.String","Specimen.container.identifier":"Identifier","Specimen.container.modifierExtension":"Extension","Specimen.container.specimenQuantity":"Quantity","Specimen.container.type":"CodeableConcept","Specimen.extension":"Extension","Specimen.id":"System.String","Specimen.identifier":"Identifier","Specimen.implicitRules":"uri","Specimen.language":"code","Specimen.meta":"Meta","Specimen.modifierExtension":"Extension","Specimen.note":"Annotation","Specimen.parent":"Reference","Specimen.processing.additive":"Reference","Specimen.processing.description":"string","Specimen.processing.extension":"Extension","Specimen.processing.id":"System.String","Specimen.processing.modifierExtension":"Extension","Specimen.processing.procedure":"CodeableConcept","Specimen.processing.timeDateTime":"dateTime","Specimen.processing.timePeriod":"Period","Specimen.receivedTime":"dateTime","Specimen.request":"Reference","Specimen.status":"code","Specimen.subject":"Reference","Specimen.text":"Narrative","Specimen.type":"CodeableConcept","SpecimenDefinition.collection":"CodeableConcept","SpecimenDefinition.contained":"Resource","SpecimenDefinition.extension":"Extension","SpecimenDefinition.id":"System.String","SpecimenDefinition.identifier":"Identifier","SpecimenDefinition.implicitRules":"uri","SpecimenDefinition.language":"code","SpecimenDefinition.meta":"Meta","SpecimenDefinition.modifierExtension":"Extension","SpecimenDefinition.patientPreparation":"CodeableConcept","SpecimenDefinition.text":"Narrative","SpecimenDefinition.timeAspect":"string","SpecimenDefinition.typeCollected":"CodeableConcept","SpecimenDefinition.typeTested.container.additive.additiveCodeableConcept":"CodeableConcept","SpecimenDefinition.typeTested.container.additive.additiveReference":"Reference","SpecimenDefinition.typeTested.container.additive.extension":"Extension","SpecimenDefinition.typeTested.container.additive.id":"System.String","SpecimenDefinition.typeTested.container.additive.modifierExtension":"Extension","SpecimenDefinition.typeTested.container.cap":"CodeableConcept","SpecimenDefinition.typeTested.container.capacity":"Quantity","SpecimenDefinition.typeTested.container.description":"string","SpecimenDefinition.typeTested.container.extension":"Extension","SpecimenDefinition.typeTested.container.id":"System.String","SpecimenDefinition.typeTested.container.material":"CodeableConcept","SpecimenDefinition.typeTested.container.minimumVolumeQuantity":"Quantity","SpecimenDefinition.typeTested.container.minimumVolumeString":"string","SpecimenDefinition.typeTested.container.modifierExtension":"Extension","SpecimenDefinition.typeTested.container.preparation":"string","SpecimenDefinition.typeTested.container.type":"CodeableConcept","SpecimenDefinition.typeTested.extension":"Extension","SpecimenDefinition.typeTested.handling.extension":"Extension","SpecimenDefinition.typeTested.handling.id":"System.String","SpecimenDefinition.typeTested.handling.instruction":"string","SpecimenDefinition.typeTested.handling.maxDuration":"Duration","SpecimenDefinition.typeTested.handling.modifierExtension":"Extension","SpecimenDefinition.typeTested.handling.temperatureQualifier":"CodeableConcept","SpecimenDefinition.typeTested.handling.temperatureRange":"Range","SpecimenDefinition.typeTested.id":"System.String","SpecimenDefinition.typeTested.isDerived":"boolean","SpecimenDefinition.typeTested.modifierExtension":"Extension","SpecimenDefinition.typeTested.preference":"code","SpecimenDefinition.typeTested.rejectionCriterion":"CodeableConcept","SpecimenDefinition.typeTested.requirement":"string","SpecimenDefinition.typeTested.retentionTime":"Duration","SpecimenDefinition.typeTested.type":"CodeableConcept","StructureDefinition.abstract":"boolean","StructureDefinition.baseDefinition":"canonical","StructureDefinition.contact":"ContactDetail","StructureDefinition.contained":"Resource","StructureDefinition.context.expression":"string","StructureDefinition.context.extension":"Extension","StructureDefinition.context.id":"System.String","StructureDefinition.context.modifierExtension":"Extension","StructureDefinition.context.type":"code","StructureDefinition.contextInvariant":"string","StructureDefinition.copyright":"markdown","StructureDefinition.date":"dateTime","StructureDefinition.derivation":"code","StructureDefinition.description":"markdown","StructureDefinition.differential.element":"ElementDefinition","StructureDefinition.differential.extension":"Extension","StructureDefinition.differential.id":"System.String","StructureDefinition.differential.modifierExtension":"Extension","StructureDefinition.experimental":"boolean","StructureDefinition.extension":"Extension","StructureDefinition.fhirVersion":"code","StructureDefinition.id":"System.String","StructureDefinition.identifier":"Identifier","StructureDefinition.implicitRules":"uri","StructureDefinition.jurisdiction":"CodeableConcept","StructureDefinition.keyword":"Coding","StructureDefinition.kind":"code","StructureDefinition.language":"code","StructureDefinition.mapping.comment":"string","StructureDefinition.mapping.extension":"Extension","StructureDefinition.mapping.id":"System.String","StructureDefinition.mapping.identity":"id","StructureDefinition.mapping.modifierExtension":"Extension","StructureDefinition.mapping.name":"string","StructureDefinition.mapping.uri":"uri","StructureDefinition.meta":"Meta","StructureDefinition.modifierExtension":"Extension","StructureDefinition.name":"string","StructureDefinition.publisher":"string","StructureDefinition.purpose":"markdown","StructureDefinition.snapshot.element":"ElementDefinition","StructureDefinition.snapshot.extension":"Extension","StructureDefinition.snapshot.id":"System.String","StructureDefinition.snapshot.modifierExtension":"Extension","StructureDefinition.status":"code","StructureDefinition.text":"Narrative","StructureDefinition.title":"string","StructureDefinition.type":"uri","StructureDefinition.url":"uri","StructureDefinition.useContext":"UsageContext","StructureDefinition.version":"string","StructureMap.contact":"ContactDetail","StructureMap.contained":"Resource","StructureMap.copyright":"markdown","StructureMap.date":"dateTime","StructureMap.description":"markdown","StructureMap.experimental":"boolean","StructureMap.extension":"Extension","StructureMap.group.documentation":"string","StructureMap.group.extends":"id","StructureMap.group.extension":"Extension","StructureMap.group.id":"System.String","StructureMap.group.input.documentation":"string","StructureMap.group.input.extension":"Extension","StructureMap.group.input.id":"System.String","StructureMap.group.input.mode":"code","StructureMap.group.input.modifierExtension":"Extension","StructureMap.group.input.name":"id","StructureMap.group.input.type":"string","StructureMap.group.modifierExtension":"Extension","StructureMap.group.name":"id","StructureMap.group.rule.dependent.extension":"Extension","StructureMap.group.rule.dependent.id":"System.String","StructureMap.group.rule.dependent.modifierExtension":"Extension","StructureMap.group.rule.dependent.name":"id","StructureMap.group.rule.dependent.variable":"string","StructureMap.group.rule.documentation":"string","StructureMap.group.rule.extension":"Extension","StructureMap.group.rule.id":"System.String","StructureMap.group.rule.modifierExtension":"Extension","StructureMap.group.rule.name":"id","StructureMap.group.rule.source.check":"string","StructureMap.group.rule.source.condition":"string","StructureMap.group.rule.source.context":"id","StructureMap.group.rule.source.defaultValueAddress":"Address","StructureMap.group.rule.source.defaultValueAge":"Age","StructureMap.group.rule.source.defaultValueAnnotation":"Annotation","StructureMap.group.rule.source.defaultValueAttachment":"Attachment","StructureMap.group.rule.source.defaultValueBase64Binary":"base64Binary","StructureMap.group.rule.source.defaultValueBoolean":"boolean","StructureMap.group.rule.source.defaultValueCanonical":"canonical","StructureMap.group.rule.source.defaultValueCode":"code","StructureMap.group.rule.source.defaultValueCodeableConcept":"CodeableConcept","StructureMap.group.rule.source.defaultValueCoding":"Coding","StructureMap.group.rule.source.defaultValueContactDetail":"ContactDetail","StructureMap.group.rule.source.defaultValueContactPoint":"ContactPoint","StructureMap.group.rule.source.defaultValueContributor":"Contributor","StructureMap.group.rule.source.defaultValueCount":"Count","StructureMap.group.rule.source.defaultValueDataRequirement":"DataRequirement","StructureMap.group.rule.source.defaultValueDate":"date","StructureMap.group.rule.source.defaultValueDateTime":"dateTime","StructureMap.group.rule.source.defaultValueDecimal":"decimal","StructureMap.group.rule.source.defaultValueDistance":"Distance","StructureMap.group.rule.source.defaultValueDosage":"Dosage","StructureMap.group.rule.source.defaultValueDuration":"Duration","StructureMap.group.rule.source.defaultValueExpression":"Expression","StructureMap.group.rule.source.defaultValueHumanName":"HumanName","StructureMap.group.rule.source.defaultValueId":"id","StructureMap.group.rule.source.defaultValueIdentifier":"Identifier","StructureMap.group.rule.source.defaultValueInstant":"instant","StructureMap.group.rule.source.defaultValueInteger":"integer","StructureMap.group.rule.source.defaultValueMarkdown":"markdown","StructureMap.group.rule.source.defaultValueMeta":"Meta","StructureMap.group.rule.source.defaultValueMoney":"Money","StructureMap.group.rule.source.defaultValueOid":"oid","StructureMap.group.rule.source.defaultValueParameterDefinition":"ParameterDefinition","StructureMap.group.rule.source.defaultValuePeriod":"Period","StructureMap.group.rule.source.defaultValuePositiveInt":"positiveInt","StructureMap.group.rule.source.defaultValueQuantity":"Quantity","StructureMap.group.rule.source.defaultValueRange":"Range","StructureMap.group.rule.source.defaultValueRatio":"Ratio","StructureMap.group.rule.source.defaultValueReference":"Reference","StructureMap.group.rule.source.defaultValueRelatedArtifact":"RelatedArtifact","StructureMap.group.rule.source.defaultValueSampledData":"SampledData","StructureMap.group.rule.source.defaultValueSignature":"Signature","StructureMap.group.rule.source.defaultValueString":"string","StructureMap.group.rule.source.defaultValueTime":"time","StructureMap.group.rule.source.defaultValueTiming":"Timing","StructureMap.group.rule.source.defaultValueTriggerDefinition":"TriggerDefinition","StructureMap.group.rule.source.defaultValueUnsignedInt":"unsignedInt","StructureMap.group.rule.source.defaultValueUri":"uri","StructureMap.group.rule.source.defaultValueUrl":"url","StructureMap.group.rule.source.defaultValueUsageContext":"UsageContext","StructureMap.group.rule.source.defaultValueUuid":"uuid","StructureMap.group.rule.source.element":"string","StructureMap.group.rule.source.extension":"Extension","StructureMap.group.rule.source.id":"System.String","StructureMap.group.rule.source.listMode":"code","StructureMap.group.rule.source.logMessage":"string","StructureMap.group.rule.source.max":"string","StructureMap.group.rule.source.min":"integer","StructureMap.group.rule.source.modifierExtension":"Extension","StructureMap.group.rule.source.type":"string","StructureMap.group.rule.source.variable":"id","StructureMap.group.rule.target.context":"id","StructureMap.group.rule.target.contextType":"code","StructureMap.group.rule.target.element":"string","StructureMap.group.rule.target.extension":"Extension","StructureMap.group.rule.target.id":"System.String","StructureMap.group.rule.target.listMode":"code","StructureMap.group.rule.target.listRuleId":"id","StructureMap.group.rule.target.modifierExtension":"Extension","StructureMap.group.rule.target.parameter.extension":"Extension","StructureMap.group.rule.target.parameter.id":"System.String","StructureMap.group.rule.target.parameter.modifierExtension":"Extension","StructureMap.group.rule.target.parameter.valueBoolean":"boolean","StructureMap.group.rule.target.parameter.valueDecimal":"decimal","StructureMap.group.rule.target.parameter.valueId":"id","StructureMap.group.rule.target.parameter.valueInteger":"integer","StructureMap.group.rule.target.parameter.valueString":"string","StructureMap.group.rule.target.transform":"code","StructureMap.group.rule.target.variable":"id","StructureMap.group.typeMode":"code","StructureMap.id":"System.String","StructureMap.identifier":"Identifier","StructureMap.implicitRules":"uri","StructureMap.import":"canonical","StructureMap.jurisdiction":"CodeableConcept","StructureMap.language":"code","StructureMap.meta":"Meta","StructureMap.modifierExtension":"Extension","StructureMap.name":"string","StructureMap.publisher":"string","StructureMap.purpose":"markdown","StructureMap.status":"code","StructureMap.structure.alias":"string","StructureMap.structure.documentation":"string","StructureMap.structure.extension":"Extension","StructureMap.structure.id":"System.String","StructureMap.structure.mode":"code","StructureMap.structure.modifierExtension":"Extension","StructureMap.structure.url":"canonical","StructureMap.text":"Narrative","StructureMap.title":"string","StructureMap.url":"uri","StructureMap.useContext":"UsageContext","StructureMap.version":"string","Subscription.channel.endpoint":"url","Subscription.channel.extension":"Extension","Subscription.channel.header":"string","Subscription.channel.id":"System.String","Subscription.channel.modifierExtension":"Extension","Subscription.channel.payload":"code","Subscription.channel.type":"code","Subscription.contact":"ContactPoint","Subscription.contained":"Resource","Subscription.criteria":"string","Subscription.end":"instant","Subscription.error":"string","Subscription.extension":"Extension","Subscription.id":"System.String","Subscription.implicitRules":"uri","Subscription.language":"code","Subscription.meta":"Meta","Subscription.modifierExtension":"Extension","Subscription.reason":"string","Subscription.status":"code","Subscription.text":"Narrative","Substance.category":"CodeableConcept","Substance.code":"CodeableConcept","Substance.contained":"Resource","Substance.description":"string","Substance.extension":"Extension","Substance.id":"System.String","Substance.identifier":"Identifier","Substance.implicitRules":"uri","Substance.ingredient.extension":"Extension","Substance.ingredient.id":"System.String","Substance.ingredient.modifierExtension":"Extension","Substance.ingredient.quantity":"Ratio","Substance.ingredient.substanceCodeableConcept":"CodeableConcept","Substance.ingredient.substanceReference":"Reference","Substance.instance.expiry":"dateTime","Substance.instance.extension":"Extension","Substance.instance.id":"System.String","Substance.instance.identifier":"Identifier","Substance.instance.modifierExtension":"Extension","Substance.instance.quantity":"Quantity","Substance.language":"code","Substance.meta":"Meta","Substance.modifierExtension":"Extension","Substance.status":"code","Substance.text":"Narrative","SubstanceAmount.amountQuantity":"Quantity","SubstanceAmount.amountRange":"Range","SubstanceAmount.amountString":"string","SubstanceAmount.amountText":"string","SubstanceAmount.amountType":"CodeableConcept","SubstanceAmount.extension":"Extension","SubstanceAmount.id":"System.String","SubstanceAmount.modifierExtension":"Extension","SubstanceAmount.referenceRange.extension":"Extension","SubstanceAmount.referenceRange.highLimit":"Quantity","SubstanceAmount.referenceRange.id":"System.String","SubstanceAmount.referenceRange.lowLimit":"Quantity","SubstanceNucleicAcid.areaOfHybridisation":"string","SubstanceNucleicAcid.contained":"Resource","SubstanceNucleicAcid.extension":"Extension","SubstanceNucleicAcid.id":"System.String","SubstanceNucleicAcid.implicitRules":"uri","SubstanceNucleicAcid.language":"code","SubstanceNucleicAcid.meta":"Meta","SubstanceNucleicAcid.modifierExtension":"Extension","SubstanceNucleicAcid.numberOfSubunits":"integer","SubstanceNucleicAcid.oligoNucleotideType":"CodeableConcept","SubstanceNucleicAcid.sequenceType":"CodeableConcept","SubstanceNucleicAcid.subunit.extension":"Extension","SubstanceNucleicAcid.subunit.fivePrime":"CodeableConcept","SubstanceNucleicAcid.subunit.id":"System.String","SubstanceNucleicAcid.subunit.length":"integer","SubstanceNucleicAcid.subunit.linkage.connectivity":"string","SubstanceNucleicAcid.subunit.linkage.extension":"Extension","SubstanceNucleicAcid.subunit.linkage.id":"System.String","SubstanceNucleicAcid.subunit.linkage.identifier":"Identifier","SubstanceNucleicAcid.subunit.linkage.modifierExtension":"Extension","SubstanceNucleicAcid.subunit.linkage.name":"string","SubstanceNucleicAcid.subunit.linkage.residueSite":"string","SubstanceNucleicAcid.subunit.modifierExtension":"Extension","SubstanceNucleicAcid.subunit.sequence":"string","SubstanceNucleicAcid.subunit.sequenceAttachment":"Attachment","SubstanceNucleicAcid.subunit.subunit":"integer","SubstanceNucleicAcid.subunit.sugar.extension":"Extension","SubstanceNucleicAcid.subunit.sugar.id":"System.String","SubstanceNucleicAcid.subunit.sugar.identifier":"Identifier","SubstanceNucleicAcid.subunit.sugar.modifierExtension":"Extension","SubstanceNucleicAcid.subunit.sugar.name":"string","SubstanceNucleicAcid.subunit.sugar.residueSite":"string","SubstanceNucleicAcid.subunit.threePrime":"CodeableConcept","SubstanceNucleicAcid.text":"Narrative","SubstancePolymer.class":"CodeableConcept","SubstancePolymer.contained":"Resource","SubstancePolymer.copolymerConnectivity":"CodeableConcept","SubstancePolymer.extension":"Extension","SubstancePolymer.geometry":"CodeableConcept","SubstancePolymer.id":"System.String","SubstancePolymer.implicitRules":"uri","SubstancePolymer.language":"code","SubstancePolymer.meta":"Meta","SubstancePolymer.modification":"string","SubstancePolymer.modifierExtension":"Extension","SubstancePolymer.monomerSet.extension":"Extension","SubstancePolymer.monomerSet.id":"System.String","SubstancePolymer.monomerSet.modifierExtension":"Extension","SubstancePolymer.monomerSet.ratioType":"CodeableConcept","SubstancePolymer.monomerSet.startingMaterial.amount":"SubstanceAmount","SubstancePolymer.monomerSet.startingMaterial.extension":"Extension","SubstancePolymer.monomerSet.startingMaterial.id":"System.String","SubstancePolymer.monomerSet.startingMaterial.isDefining":"boolean","SubstancePolymer.monomerSet.startingMaterial.material":"CodeableConcept","SubstancePolymer.monomerSet.startingMaterial.modifierExtension":"Extension","SubstancePolymer.monomerSet.startingMaterial.type":"CodeableConcept","SubstancePolymer.repeat.averageMolecularFormula":"string","SubstancePolymer.repeat.extension":"Extension","SubstancePolymer.repeat.id":"System.String","SubstancePolymer.repeat.modifierExtension":"Extension","SubstancePolymer.repeat.numberOfUnits":"integer","SubstancePolymer.repeat.repeatUnit.amount":"SubstanceAmount","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.amount":"SubstanceAmount","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.degree":"CodeableConcept","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.extension":"Extension","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.id":"System.String","SubstancePolymer.repeat.repeatUnit.degreeOfPolymerisation.modifierExtension":"Extension","SubstancePolymer.repeat.repeatUnit.extension":"Extension","SubstancePolymer.repeat.repeatUnit.id":"System.String","SubstancePolymer.repeat.repeatUnit.modifierExtension":"Extension","SubstancePolymer.repeat.repeatUnit.orientationOfPolymerisation":"CodeableConcept","SubstancePolymer.repeat.repeatUnit.repeatUnit":"string","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.attachment":"Attachment","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.extension":"Extension","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.id":"System.String","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.modifierExtension":"Extension","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.representation":"string","SubstancePolymer.repeat.repeatUnit.structuralRepresentation.type":"CodeableConcept","SubstancePolymer.repeat.repeatUnitAmountType":"CodeableConcept","SubstancePolymer.text":"Narrative","SubstanceProtein.contained":"Resource","SubstanceProtein.disulfideLinkage":"string","SubstanceProtein.extension":"Extension","SubstanceProtein.id":"System.String","SubstanceProtein.implicitRules":"uri","SubstanceProtein.language":"code","SubstanceProtein.meta":"Meta","SubstanceProtein.modifierExtension":"Extension","SubstanceProtein.numberOfSubunits":"integer","SubstanceProtein.sequenceType":"CodeableConcept","SubstanceProtein.subunit.cTerminalModification":"string","SubstanceProtein.subunit.cTerminalModificationId":"Identifier","SubstanceProtein.subunit.extension":"Extension","SubstanceProtein.subunit.id":"System.String","SubstanceProtein.subunit.length":"integer","SubstanceProtein.subunit.modifierExtension":"Extension","SubstanceProtein.subunit.nTerminalModification":"string","SubstanceProtein.subunit.nTerminalModificationId":"Identifier","SubstanceProtein.subunit.sequence":"string","SubstanceProtein.subunit.sequenceAttachment":"Attachment","SubstanceProtein.subunit.subunit":"integer","SubstanceProtein.text":"Narrative","SubstanceReferenceInformation.classification.classification":"CodeableConcept","SubstanceReferenceInformation.classification.domain":"CodeableConcept","SubstanceReferenceInformation.classification.extension":"Extension","SubstanceReferenceInformation.classification.id":"System.String","SubstanceReferenceInformation.classification.modifierExtension":"Extension","SubstanceReferenceInformation.classification.source":"Reference","SubstanceReferenceInformation.classification.subtype":"CodeableConcept","SubstanceReferenceInformation.comment":"string","SubstanceReferenceInformation.contained":"Resource","SubstanceReferenceInformation.extension":"Extension","SubstanceReferenceInformation.gene.extension":"Extension","SubstanceReferenceInformation.gene.gene":"CodeableConcept","SubstanceReferenceInformation.gene.geneSequenceOrigin":"CodeableConcept","SubstanceReferenceInformation.gene.id":"System.String","SubstanceReferenceInformation.gene.modifierExtension":"Extension","SubstanceReferenceInformation.gene.source":"Reference","SubstanceReferenceInformation.geneElement.element":"Identifier","SubstanceReferenceInformation.geneElement.extension":"Extension","SubstanceReferenceInformation.geneElement.id":"System.String","SubstanceReferenceInformation.geneElement.modifierExtension":"Extension","SubstanceReferenceInformation.geneElement.source":"Reference","SubstanceReferenceInformation.geneElement.type":"CodeableConcept","SubstanceReferenceInformation.id":"System.String","SubstanceReferenceInformation.implicitRules":"uri","SubstanceReferenceInformation.language":"code","SubstanceReferenceInformation.meta":"Meta","SubstanceReferenceInformation.modifierExtension":"Extension","SubstanceReferenceInformation.target.amountQuantity":"Quantity","SubstanceReferenceInformation.target.amountRange":"Range","SubstanceReferenceInformation.target.amountString":"string","SubstanceReferenceInformation.target.amountType":"CodeableConcept","SubstanceReferenceInformation.target.extension":"Extension","SubstanceReferenceInformation.target.id":"System.String","SubstanceReferenceInformation.target.interaction":"CodeableConcept","SubstanceReferenceInformation.target.modifierExtension":"Extension","SubstanceReferenceInformation.target.organism":"CodeableConcept","SubstanceReferenceInformation.target.organismType":"CodeableConcept","SubstanceReferenceInformation.target.source":"Reference","SubstanceReferenceInformation.target.target":"Identifier","SubstanceReferenceInformation.target.type":"CodeableConcept","SubstanceReferenceInformation.text":"Narrative","SubstanceSourceMaterial.contained":"Resource","SubstanceSourceMaterial.countryOfOrigin":"CodeableConcept","SubstanceSourceMaterial.developmentStage":"CodeableConcept","SubstanceSourceMaterial.extension":"Extension","SubstanceSourceMaterial.fractionDescription.extension":"Extension","SubstanceSourceMaterial.fractionDescription.fraction":"string","SubstanceSourceMaterial.fractionDescription.id":"System.String","SubstanceSourceMaterial.fractionDescription.materialType":"CodeableConcept","SubstanceSourceMaterial.fractionDescription.modifierExtension":"Extension","SubstanceSourceMaterial.geographicalLocation":"string","SubstanceSourceMaterial.id":"System.String","SubstanceSourceMaterial.implicitRules":"uri","SubstanceSourceMaterial.language":"code","SubstanceSourceMaterial.meta":"Meta","SubstanceSourceMaterial.modifierExtension":"Extension","SubstanceSourceMaterial.organism.author.authorDescription":"string","SubstanceSourceMaterial.organism.author.authorType":"CodeableConcept","SubstanceSourceMaterial.organism.author.extension":"Extension","SubstanceSourceMaterial.organism.author.id":"System.String","SubstanceSourceMaterial.organism.author.modifierExtension":"Extension","SubstanceSourceMaterial.organism.extension":"Extension","SubstanceSourceMaterial.organism.family":"CodeableConcept","SubstanceSourceMaterial.organism.genus":"CodeableConcept","SubstanceSourceMaterial.organism.hybrid.extension":"Extension","SubstanceSourceMaterial.organism.hybrid.hybridType":"CodeableConcept","SubstanceSourceMaterial.organism.hybrid.id":"System.String","SubstanceSourceMaterial.organism.hybrid.maternalOrganismId":"string","SubstanceSourceMaterial.organism.hybrid.maternalOrganismName":"string","SubstanceSourceMaterial.organism.hybrid.modifierExtension":"Extension","SubstanceSourceMaterial.organism.hybrid.paternalOrganismId":"string","SubstanceSourceMaterial.organism.hybrid.paternalOrganismName":"string","SubstanceSourceMaterial.organism.id":"System.String","SubstanceSourceMaterial.organism.intraspecificDescription":"string","SubstanceSourceMaterial.organism.intraspecificType":"CodeableConcept","SubstanceSourceMaterial.organism.modifierExtension":"Extension","SubstanceSourceMaterial.organism.organismGeneral.class":"CodeableConcept","SubstanceSourceMaterial.organism.organismGeneral.extension":"Extension","SubstanceSourceMaterial.organism.organismGeneral.id":"System.String","SubstanceSourceMaterial.organism.organismGeneral.kingdom":"CodeableConcept","SubstanceSourceMaterial.organism.organismGeneral.modifierExtension":"Extension","SubstanceSourceMaterial.organism.organismGeneral.order":"CodeableConcept","SubstanceSourceMaterial.organism.organismGeneral.phylum":"CodeableConcept","SubstanceSourceMaterial.organism.species":"CodeableConcept","SubstanceSourceMaterial.organismId":"Identifier","SubstanceSourceMaterial.organismName":"string","SubstanceSourceMaterial.parentSubstanceId":"Identifier","SubstanceSourceMaterial.parentSubstanceName":"string","SubstanceSourceMaterial.partDescription.extension":"Extension","SubstanceSourceMaterial.partDescription.id":"System.String","SubstanceSourceMaterial.partDescription.modifierExtension":"Extension","SubstanceSourceMaterial.partDescription.part":"CodeableConcept","SubstanceSourceMaterial.partDescription.partLocation":"CodeableConcept","SubstanceSourceMaterial.sourceMaterialClass":"CodeableConcept","SubstanceSourceMaterial.sourceMaterialState":"CodeableConcept","SubstanceSourceMaterial.sourceMaterialType":"CodeableConcept","SubstanceSourceMaterial.text":"Narrative","SubstanceSpecification.code.code":"CodeableConcept","SubstanceSpecification.code.comment":"string","SubstanceSpecification.code.extension":"Extension","SubstanceSpecification.code.id":"System.String","SubstanceSpecification.code.modifierExtension":"Extension","SubstanceSpecification.code.source":"Reference","SubstanceSpecification.code.status":"CodeableConcept","SubstanceSpecification.code.statusDate":"dateTime","SubstanceSpecification.comment":"string","SubstanceSpecification.contained":"Resource","SubstanceSpecification.description":"string","SubstanceSpecification.domain":"CodeableConcept","SubstanceSpecification.extension":"Extension","SubstanceSpecification.id":"System.String","SubstanceSpecification.identifier":"Identifier","SubstanceSpecification.implicitRules":"uri","SubstanceSpecification.language":"code","SubstanceSpecification.meta":"Meta","SubstanceSpecification.modifierExtension":"Extension","SubstanceSpecification.moiety.amountQuantity":"Quantity","SubstanceSpecification.moiety.amountString":"string","SubstanceSpecification.moiety.extension":"Extension","SubstanceSpecification.moiety.id":"System.String","SubstanceSpecification.moiety.identifier":"Identifier","SubstanceSpecification.moiety.modifierExtension":"Extension","SubstanceSpecification.moiety.molecularFormula":"string","SubstanceSpecification.moiety.name":"string","SubstanceSpecification.moiety.opticalActivity":"CodeableConcept","SubstanceSpecification.moiety.role":"CodeableConcept","SubstanceSpecification.moiety.stereochemistry":"CodeableConcept","SubstanceSpecification.name.domain":"CodeableConcept","SubstanceSpecification.name.extension":"Extension","SubstanceSpecification.name.id":"System.String","SubstanceSpecification.name.jurisdiction":"CodeableConcept","SubstanceSpecification.name.language":"CodeableConcept","SubstanceSpecification.name.modifierExtension":"Extension","SubstanceSpecification.name.name":"string","SubstanceSpecification.name.official.authority":"CodeableConcept","SubstanceSpecification.name.official.date":"dateTime","SubstanceSpecification.name.official.extension":"Extension","SubstanceSpecification.name.official.id":"System.String","SubstanceSpecification.name.official.modifierExtension":"Extension","SubstanceSpecification.name.official.status":"CodeableConcept","SubstanceSpecification.name.preferred":"boolean","SubstanceSpecification.name.source":"Reference","SubstanceSpecification.name.status":"CodeableConcept","SubstanceSpecification.name.type":"CodeableConcept","SubstanceSpecification.nucleicAcid":"Reference","SubstanceSpecification.polymer":"Reference","SubstanceSpecification.property.amountQuantity":"Quantity","SubstanceSpecification.property.amountString":"string","SubstanceSpecification.property.category":"CodeableConcept","SubstanceSpecification.property.code":"CodeableConcept","SubstanceSpecification.property.definingSubstanceCodeableConcept":"CodeableConcept","SubstanceSpecification.property.definingSubstanceReference":"Reference","SubstanceSpecification.property.extension":"Extension","SubstanceSpecification.property.id":"System.String","SubstanceSpecification.property.modifierExtension":"Extension","SubstanceSpecification.property.parameters":"string","SubstanceSpecification.protein":"Reference","SubstanceSpecification.referenceInformation":"Reference","SubstanceSpecification.relationship.amountQuantity":"Quantity","SubstanceSpecification.relationship.amountRange":"Range","SubstanceSpecification.relationship.amountRatio":"Ratio","SubstanceSpecification.relationship.amountRatioLowLimit":"Ratio","SubstanceSpecification.relationship.amountString":"string","SubstanceSpecification.relationship.amountType":"CodeableConcept","SubstanceSpecification.relationship.extension":"Extension","SubstanceSpecification.relationship.id":"System.String","SubstanceSpecification.relationship.isDefining":"boolean","SubstanceSpecification.relationship.modifierExtension":"Extension","SubstanceSpecification.relationship.relationship":"CodeableConcept","SubstanceSpecification.relationship.source":"Reference","SubstanceSpecification.relationship.substanceCodeableConcept":"CodeableConcept","SubstanceSpecification.relationship.substanceReference":"Reference","SubstanceSpecification.source":"Reference","SubstanceSpecification.sourceMaterial":"Reference","SubstanceSpecification.status":"CodeableConcept","SubstanceSpecification.structure.extension":"Extension","SubstanceSpecification.structure.id":"System.String","SubstanceSpecification.structure.isotope.extension":"Extension","SubstanceSpecification.structure.isotope.halfLife":"Quantity","SubstanceSpecification.structure.isotope.id":"System.String","SubstanceSpecification.structure.isotope.identifier":"Identifier","SubstanceSpecification.structure.isotope.modifierExtension":"Extension","SubstanceSpecification.structure.isotope.molecularWeight.amount":"Quantity","SubstanceSpecification.structure.isotope.molecularWeight.extension":"Extension","SubstanceSpecification.structure.isotope.molecularWeight.id":"System.String","SubstanceSpecification.structure.isotope.molecularWeight.method":"CodeableConcept","SubstanceSpecification.structure.isotope.molecularWeight.modifierExtension":"Extension","SubstanceSpecification.structure.isotope.molecularWeight.type":"CodeableConcept","SubstanceSpecification.structure.isotope.name":"CodeableConcept","SubstanceSpecification.structure.isotope.substitution":"CodeableConcept","SubstanceSpecification.structure.modifierExtension":"Extension","SubstanceSpecification.structure.molecularFormula":"string","SubstanceSpecification.structure.molecularFormulaByMoiety":"string","SubstanceSpecification.structure.opticalActivity":"CodeableConcept","SubstanceSpecification.structure.representation.attachment":"Attachment","SubstanceSpecification.structure.representation.extension":"Extension","SubstanceSpecification.structure.representation.id":"System.String","SubstanceSpecification.structure.representation.modifierExtension":"Extension","SubstanceSpecification.structure.representation.representation":"string","SubstanceSpecification.structure.representation.type":"CodeableConcept","SubstanceSpecification.structure.source":"Reference","SubstanceSpecification.structure.stereochemistry":"CodeableConcept","SubstanceSpecification.text":"Narrative","SubstanceSpecification.type":"CodeableConcept","SupplyDelivery.basedOn":"Reference","SupplyDelivery.contained":"Resource","SupplyDelivery.destination":"Reference","SupplyDelivery.extension":"Extension","SupplyDelivery.id":"System.String","SupplyDelivery.identifier":"Identifier","SupplyDelivery.implicitRules":"uri","SupplyDelivery.language":"code","SupplyDelivery.meta":"Meta","SupplyDelivery.modifierExtension":"Extension","SupplyDelivery.occurrenceDateTime":"dateTime","SupplyDelivery.occurrencePeriod":"Period","SupplyDelivery.occurrenceTiming":"Timing","SupplyDelivery.partOf":"Reference","SupplyDelivery.patient":"Reference","SupplyDelivery.receiver":"Reference","SupplyDelivery.status":"code","SupplyDelivery.suppliedItem.extension":"Extension","SupplyDelivery.suppliedItem.id":"System.String","SupplyDelivery.suppliedItem.itemCodeableConcept":"CodeableConcept","SupplyDelivery.suppliedItem.itemReference":"Reference","SupplyDelivery.suppliedItem.modifierExtension":"Extension","SupplyDelivery.suppliedItem.quantity":"Quantity","SupplyDelivery.supplier":"Reference","SupplyDelivery.text":"Narrative","SupplyDelivery.type":"CodeableConcept","SupplyRequest.authoredOn":"dateTime","SupplyRequest.category":"CodeableConcept","SupplyRequest.contained":"Resource","SupplyRequest.deliverFrom":"Reference","SupplyRequest.deliverTo":"Reference","SupplyRequest.extension":"Extension","SupplyRequest.id":"System.String","SupplyRequest.identifier":"Identifier","SupplyRequest.implicitRules":"uri","SupplyRequest.itemCodeableConcept":"CodeableConcept","SupplyRequest.itemReference":"Reference","SupplyRequest.language":"code","SupplyRequest.meta":"Meta","SupplyRequest.modifierExtension":"Extension","SupplyRequest.occurrenceDateTime":"dateTime","SupplyRequest.occurrencePeriod":"Period","SupplyRequest.occurrenceTiming":"Timing","SupplyRequest.parameter.code":"CodeableConcept","SupplyRequest.parameter.extension":"Extension","SupplyRequest.parameter.id":"System.String","SupplyRequest.parameter.modifierExtension":"Extension","SupplyRequest.parameter.valueBoolean":"boolean","SupplyRequest.parameter.valueCodeableConcept":"CodeableConcept","SupplyRequest.parameter.valueQuantity":"Quantity","SupplyRequest.parameter.valueRange":"Range","SupplyRequest.priority":"code","SupplyRequest.quantity":"Quantity","SupplyRequest.reasonCode":"CodeableConcept","SupplyRequest.reasonReference":"Reference","SupplyRequest.requester":"Reference","SupplyRequest.status":"code","SupplyRequest.supplier":"Reference","SupplyRequest.text":"Narrative","Task.authoredOn":"dateTime","Task.basedOn":"Reference","Task.businessStatus":"CodeableConcept","Task.code":"CodeableConcept","Task.contained":"Resource","Task.description":"string","Task.encounter":"Reference","Task.executionPeriod":"Period","Task.extension":"Extension","Task.focus":"Reference","Task.for":"Reference","Task.groupIdentifier":"Identifier","Task.id":"System.String","Task.identifier":"Identifier","Task.implicitRules":"uri","Task.input.extension":"Extension","Task.input.id":"System.String","Task.input.modifierExtension":"Extension","Task.input.type":"CodeableConcept","Task.input.valueAddress":"Address","Task.input.valueAge":"Age","Task.input.valueAnnotation":"Annotation","Task.input.valueAttachment":"Attachment","Task.input.valueBase64Binary":"base64Binary","Task.input.valueBoolean":"boolean","Task.input.valueCanonical":"canonical","Task.input.valueCode":"code","Task.input.valueCodeableConcept":"CodeableConcept","Task.input.valueCoding":"Coding","Task.input.valueContactDetail":"ContactDetail","Task.input.valueContactPoint":"ContactPoint","Task.input.valueContributor":"Contributor","Task.input.valueCount":"Count","Task.input.valueDataRequirement":"DataRequirement","Task.input.valueDate":"date","Task.input.valueDateTime":"dateTime","Task.input.valueDecimal":"decimal","Task.input.valueDistance":"Distance","Task.input.valueDosage":"Dosage","Task.input.valueDuration":"Duration","Task.input.valueExpression":"Expression","Task.input.valueHumanName":"HumanName","Task.input.valueId":"id","Task.input.valueIdentifier":"Identifier","Task.input.valueInstant":"instant","Task.input.valueInteger":"integer","Task.input.valueMarkdown":"markdown","Task.input.valueMeta":"Meta","Task.input.valueMoney":"Money","Task.input.valueOid":"oid","Task.input.valueParameterDefinition":"ParameterDefinition","Task.input.valuePeriod":"Period","Task.input.valuePositiveInt":"positiveInt","Task.input.valueQuantity":"Quantity","Task.input.valueRange":"Range","Task.input.valueRatio":"Ratio","Task.input.valueReference":"Reference","Task.input.valueRelatedArtifact":"RelatedArtifact","Task.input.valueSampledData":"SampledData","Task.input.valueSignature":"Signature","Task.input.valueString":"string","Task.input.valueTime":"time","Task.input.valueTiming":"Timing","Task.input.valueTriggerDefinition":"TriggerDefinition","Task.input.valueUnsignedInt":"unsignedInt","Task.input.valueUri":"uri","Task.input.valueUrl":"url","Task.input.valueUsageContext":"UsageContext","Task.input.valueUuid":"uuid","Task.instantiatesCanonical":"canonical","Task.instantiatesUri":"uri","Task.insurance":"Reference","Task.intent":"code","Task.language":"code","Task.lastModified":"dateTime","Task.location":"Reference","Task.meta":"Meta","Task.modifierExtension":"Extension","Task.note":"Annotation","Task.output.extension":"Extension","Task.output.id":"System.String","Task.output.modifierExtension":"Extension","Task.output.type":"CodeableConcept","Task.output.valueAddress":"Address","Task.output.valueAge":"Age","Task.output.valueAnnotation":"Annotation","Task.output.valueAttachment":"Attachment","Task.output.valueBase64Binary":"base64Binary","Task.output.valueBoolean":"boolean","Task.output.valueCanonical":"canonical","Task.output.valueCode":"code","Task.output.valueCodeableConcept":"CodeableConcept","Task.output.valueCoding":"Coding","Task.output.valueContactDetail":"ContactDetail","Task.output.valueContactPoint":"ContactPoint","Task.output.valueContributor":"Contributor","Task.output.valueCount":"Count","Task.output.valueDataRequirement":"DataRequirement","Task.output.valueDate":"date","Task.output.valueDateTime":"dateTime","Task.output.valueDecimal":"decimal","Task.output.valueDistance":"Distance","Task.output.valueDosage":"Dosage","Task.output.valueDuration":"Duration","Task.output.valueExpression":"Expression","Task.output.valueHumanName":"HumanName","Task.output.valueId":"id","Task.output.valueIdentifier":"Identifier","Task.output.valueInstant":"instant","Task.output.valueInteger":"integer","Task.output.valueMarkdown":"markdown","Task.output.valueMeta":"Meta","Task.output.valueMoney":"Money","Task.output.valueOid":"oid","Task.output.valueParameterDefinition":"ParameterDefinition","Task.output.valuePeriod":"Period","Task.output.valuePositiveInt":"positiveInt","Task.output.valueQuantity":"Quantity","Task.output.valueRange":"Range","Task.output.valueRatio":"Ratio","Task.output.valueReference":"Reference","Task.output.valueRelatedArtifact":"RelatedArtifact","Task.output.valueSampledData":"SampledData","Task.output.valueSignature":"Signature","Task.output.valueString":"string","Task.output.valueTime":"time","Task.output.valueTiming":"Timing","Task.output.valueTriggerDefinition":"TriggerDefinition","Task.output.valueUnsignedInt":"unsignedInt","Task.output.valueUri":"uri","Task.output.valueUrl":"url","Task.output.valueUsageContext":"UsageContext","Task.output.valueUuid":"uuid","Task.owner":"Reference","Task.partOf":"Reference","Task.performerType":"CodeableConcept","Task.priority":"code","Task.reasonCode":"CodeableConcept","Task.reasonReference":"Reference","Task.relevantHistory":"Reference","Task.requester":"Reference","Task.restriction.extension":"Extension","Task.restriction.id":"System.String","Task.restriction.modifierExtension":"Extension","Task.restriction.period":"Period","Task.restriction.recipient":"Reference","Task.restriction.repetitions":"positiveInt","Task.status":"code","Task.statusReason":"CodeableConcept","Task.text":"Narrative","TerminologyCapabilities.closure.extension":"Extension","TerminologyCapabilities.closure.id":"System.String","TerminologyCapabilities.closure.modifierExtension":"Extension","TerminologyCapabilities.closure.translation":"boolean","TerminologyCapabilities.codeSearch":"code","TerminologyCapabilities.codeSystem.extension":"Extension","TerminologyCapabilities.codeSystem.id":"System.String","TerminologyCapabilities.codeSystem.modifierExtension":"Extension","TerminologyCapabilities.codeSystem.subsumption":"boolean","TerminologyCapabilities.codeSystem.uri":"canonical","TerminologyCapabilities.codeSystem.version.code":"string","TerminologyCapabilities.codeSystem.version.compositional":"boolean","TerminologyCapabilities.codeSystem.version.extension":"Extension","TerminologyCapabilities.codeSystem.version.filter.code":"code","TerminologyCapabilities.codeSystem.version.filter.extension":"Extension","TerminologyCapabilities.codeSystem.version.filter.id":"System.String","TerminologyCapabilities.codeSystem.version.filter.modifierExtension":"Extension","TerminologyCapabilities.codeSystem.version.filter.op":"code","TerminologyCapabilities.codeSystem.version.id":"System.String","TerminologyCapabilities.codeSystem.version.isDefault":"boolean","TerminologyCapabilities.codeSystem.version.language":"code","TerminologyCapabilities.codeSystem.version.modifierExtension":"Extension","TerminologyCapabilities.codeSystem.version.property":"code","TerminologyCapabilities.contact":"ContactDetail","TerminologyCapabilities.contained":"Resource","TerminologyCapabilities.copyright":"markdown","TerminologyCapabilities.date":"dateTime","TerminologyCapabilities.description":"markdown","TerminologyCapabilities.expansion.extension":"Extension","TerminologyCapabilities.expansion.hierarchical":"boolean","TerminologyCapabilities.expansion.id":"System.String","TerminologyCapabilities.expansion.incomplete":"boolean","TerminologyCapabilities.expansion.modifierExtension":"Extension","TerminologyCapabilities.expansion.paging":"boolean","TerminologyCapabilities.expansion.parameter.documentation":"string","TerminologyCapabilities.expansion.parameter.extension":"Extension","TerminologyCapabilities.expansion.parameter.id":"System.String","TerminologyCapabilities.expansion.parameter.modifierExtension":"Extension","TerminologyCapabilities.expansion.parameter.name":"code","TerminologyCapabilities.expansion.textFilter":"markdown","TerminologyCapabilities.experimental":"boolean","TerminologyCapabilities.extension":"Extension","TerminologyCapabilities.id":"System.String","TerminologyCapabilities.implementation.description":"string","TerminologyCapabilities.implementation.extension":"Extension","TerminologyCapabilities.implementation.id":"System.String","TerminologyCapabilities.implementation.modifierExtension":"Extension","TerminologyCapabilities.implementation.url":"url","TerminologyCapabilities.implicitRules":"uri","TerminologyCapabilities.jurisdiction":"CodeableConcept","TerminologyCapabilities.kind":"code","TerminologyCapabilities.language":"code","TerminologyCapabilities.lockedDate":"boolean","TerminologyCapabilities.meta":"Meta","TerminologyCapabilities.modifierExtension":"Extension","TerminologyCapabilities.name":"string","TerminologyCapabilities.publisher":"string","TerminologyCapabilities.purpose":"markdown","TerminologyCapabilities.software.extension":"Extension","TerminologyCapabilities.software.id":"System.String","TerminologyCapabilities.software.modifierExtension":"Extension","TerminologyCapabilities.software.name":"string","TerminologyCapabilities.software.version":"string","TerminologyCapabilities.status":"code","TerminologyCapabilities.text":"Narrative","TerminologyCapabilities.title":"string","TerminologyCapabilities.translation.extension":"Extension","TerminologyCapabilities.translation.id":"System.String","TerminologyCapabilities.translation.modifierExtension":"Extension","TerminologyCapabilities.translation.needsMap":"boolean","TerminologyCapabilities.url":"uri","TerminologyCapabilities.useContext":"UsageContext","TerminologyCapabilities.validateCode.extension":"Extension","TerminologyCapabilities.validateCode.id":"System.String","TerminologyCapabilities.validateCode.modifierExtension":"Extension","TerminologyCapabilities.validateCode.translations":"boolean","TerminologyCapabilities.version":"string","TestReport.contained":"Resource","TestReport.extension":"Extension","TestReport.id":"System.String","TestReport.identifier":"Identifier","TestReport.implicitRules":"uri","TestReport.issued":"dateTime","TestReport.language":"code","TestReport.meta":"Meta","TestReport.modifierExtension":"Extension","TestReport.name":"string","TestReport.participant.display":"string","TestReport.participant.extension":"Extension","TestReport.participant.id":"System.String","TestReport.participant.modifierExtension":"Extension","TestReport.participant.type":"code","TestReport.participant.uri":"uri","TestReport.result":"code","TestReport.score":"decimal","TestReport.setup.action.assert.detail":"string","TestReport.setup.action.assert.extension":"Extension","TestReport.setup.action.assert.id":"System.String","TestReport.setup.action.assert.message":"markdown","TestReport.setup.action.assert.modifierExtension":"Extension","TestReport.setup.action.assert.result":"code","TestReport.setup.action.extension":"Extension","TestReport.setup.action.id":"System.String","TestReport.setup.action.modifierExtension":"Extension","TestReport.setup.action.operation.detail":"uri","TestReport.setup.action.operation.extension":"Extension","TestReport.setup.action.operation.id":"System.String","TestReport.setup.action.operation.message":"markdown","TestReport.setup.action.operation.modifierExtension":"Extension","TestReport.setup.action.operation.result":"code","TestReport.setup.extension":"Extension","TestReport.setup.id":"System.String","TestReport.setup.modifierExtension":"Extension","TestReport.status":"code","TestReport.teardown.action.extension":"Extension","TestReport.teardown.action.id":"System.String","TestReport.teardown.action.modifierExtension":"Extension","TestReport.teardown.extension":"Extension","TestReport.teardown.id":"System.String","TestReport.teardown.modifierExtension":"Extension","TestReport.test.action.extension":"Extension","TestReport.test.action.id":"System.String","TestReport.test.action.modifierExtension":"Extension","TestReport.test.description":"string","TestReport.test.extension":"Extension","TestReport.test.id":"System.String","TestReport.test.modifierExtension":"Extension","TestReport.test.name":"string","TestReport.testScript":"Reference","TestReport.tester":"string","TestReport.text":"Narrative","TestScript.contact":"ContactDetail","TestScript.contained":"Resource","TestScript.copyright":"markdown","TestScript.date":"dateTime","TestScript.description":"markdown","TestScript.destination.extension":"Extension","TestScript.destination.id":"System.String","TestScript.destination.index":"integer","TestScript.destination.modifierExtension":"Extension","TestScript.destination.profile":"Coding","TestScript.experimental":"boolean","TestScript.extension":"Extension","TestScript.fixture.autocreate":"boolean","TestScript.fixture.autodelete":"boolean","TestScript.fixture.extension":"Extension","TestScript.fixture.id":"System.String","TestScript.fixture.modifierExtension":"Extension","TestScript.fixture.resource":"Reference","TestScript.id":"System.String","TestScript.identifier":"Identifier","TestScript.implicitRules":"uri","TestScript.jurisdiction":"CodeableConcept","TestScript.language":"code","TestScript.meta":"Meta","TestScript.metadata.capability.capabilities":"canonical","TestScript.metadata.capability.description":"string","TestScript.metadata.capability.destination":"integer","TestScript.metadata.capability.extension":"Extension","TestScript.metadata.capability.id":"System.String","TestScript.metadata.capability.link":"uri","TestScript.metadata.capability.modifierExtension":"Extension","TestScript.metadata.capability.origin":"integer","TestScript.metadata.capability.required":"boolean","TestScript.metadata.capability.validated":"boolean","TestScript.metadata.extension":"Extension","TestScript.metadata.id":"System.String","TestScript.metadata.link.description":"string","TestScript.metadata.link.extension":"Extension","TestScript.metadata.link.id":"System.String","TestScript.metadata.link.modifierExtension":"Extension","TestScript.metadata.link.url":"uri","TestScript.metadata.modifierExtension":"Extension","TestScript.modifierExtension":"Extension","TestScript.name":"string","TestScript.origin.extension":"Extension","TestScript.origin.id":"System.String","TestScript.origin.index":"integer","TestScript.origin.modifierExtension":"Extension","TestScript.origin.profile":"Coding","TestScript.profile":"Reference","TestScript.publisher":"string","TestScript.purpose":"markdown","TestScript.setup.action.assert.compareToSourceExpression":"string","TestScript.setup.action.assert.compareToSourceId":"string","TestScript.setup.action.assert.compareToSourcePath":"string","TestScript.setup.action.assert.contentType":"code","TestScript.setup.action.assert.description":"string","TestScript.setup.action.assert.direction":"code","TestScript.setup.action.assert.expression":"string","TestScript.setup.action.assert.extension":"Extension","TestScript.setup.action.assert.headerField":"string","TestScript.setup.action.assert.id":"System.String","TestScript.setup.action.assert.label":"string","TestScript.setup.action.assert.minimumId":"string","TestScript.setup.action.assert.modifierExtension":"Extension","TestScript.setup.action.assert.navigationLinks":"boolean","TestScript.setup.action.assert.operator":"code","TestScript.setup.action.assert.path":"string","TestScript.setup.action.assert.requestMethod":"code","TestScript.setup.action.assert.requestURL":"string","TestScript.setup.action.assert.resource":"code","TestScript.setup.action.assert.response":"code","TestScript.setup.action.assert.responseCode":"string","TestScript.setup.action.assert.sourceId":"id","TestScript.setup.action.assert.validateProfileId":"id","TestScript.setup.action.assert.value":"string","TestScript.setup.action.assert.warningOnly":"boolean","TestScript.setup.action.extension":"Extension","TestScript.setup.action.id":"System.String","TestScript.setup.action.modifierExtension":"Extension","TestScript.setup.action.operation.accept":"code","TestScript.setup.action.operation.contentType":"code","TestScript.setup.action.operation.description":"string","TestScript.setup.action.operation.destination":"integer","TestScript.setup.action.operation.encodeRequestUrl":"boolean","TestScript.setup.action.operation.extension":"Extension","TestScript.setup.action.operation.id":"System.String","TestScript.setup.action.operation.label":"string","TestScript.setup.action.operation.method":"code","TestScript.setup.action.operation.modifierExtension":"Extension","TestScript.setup.action.operation.origin":"integer","TestScript.setup.action.operation.params":"string","TestScript.setup.action.operation.requestHeader.extension":"Extension","TestScript.setup.action.operation.requestHeader.field":"string","TestScript.setup.action.operation.requestHeader.id":"System.String","TestScript.setup.action.operation.requestHeader.modifierExtension":"Extension","TestScript.setup.action.operation.requestHeader.value":"string","TestScript.setup.action.operation.requestId":"id","TestScript.setup.action.operation.resource":"code","TestScript.setup.action.operation.responseId":"id","TestScript.setup.action.operation.sourceId":"id","TestScript.setup.action.operation.targetId":"id","TestScript.setup.action.operation.type":"Coding","TestScript.setup.action.operation.url":"string","TestScript.setup.extension":"Extension","TestScript.setup.id":"System.String","TestScript.setup.modifierExtension":"Extension","TestScript.status":"code","TestScript.teardown.action.extension":"Extension","TestScript.teardown.action.id":"System.String","TestScript.teardown.action.modifierExtension":"Extension","TestScript.teardown.extension":"Extension","TestScript.teardown.id":"System.String","TestScript.teardown.modifierExtension":"Extension","TestScript.test.action.extension":"Extension","TestScript.test.action.id":"System.String","TestScript.test.action.modifierExtension":"Extension","TestScript.test.description":"string","TestScript.test.extension":"Extension","TestScript.test.id":"System.String","TestScript.test.modifierExtension":"Extension","TestScript.test.name":"string","TestScript.text":"Narrative","TestScript.title":"string","TestScript.url":"uri","TestScript.useContext":"UsageContext","TestScript.variable.defaultValue":"string","TestScript.variable.description":"string","TestScript.variable.expression":"string","TestScript.variable.extension":"Extension","TestScript.variable.headerField":"string","TestScript.variable.hint":"string","TestScript.variable.id":"System.String","TestScript.variable.modifierExtension":"Extension","TestScript.variable.name":"string","TestScript.variable.path":"string","TestScript.variable.sourceId":"id","TestScript.version":"string","Timing.code":"CodeableConcept","Timing.event":"dateTime","Timing.extension":"Extension","Timing.id":"System.String","Timing.modifierExtension":"Extension","Timing.repeat.boundsDuration":"Duration","Timing.repeat.boundsPeriod":"Period","Timing.repeat.boundsRange":"Range","Timing.repeat.count":"positiveInt","Timing.repeat.countMax":"positiveInt","Timing.repeat.dayOfWeek":"code","Timing.repeat.duration":"decimal","Timing.repeat.durationMax":"decimal","Timing.repeat.durationUnit":"code","Timing.repeat.extension":"Extension","Timing.repeat.frequency":"positiveInt","Timing.repeat.frequencyMax":"positiveInt","Timing.repeat.id":"System.String","Timing.repeat.offset":"unsignedInt","Timing.repeat.period":"decimal","Timing.repeat.periodMax":"decimal","Timing.repeat.periodUnit":"code","Timing.repeat.timeOfDay":"time","Timing.repeat.when":"code","TriggerDefinition.condition":"Expression","TriggerDefinition.data":"DataRequirement","TriggerDefinition.extension":"Extension","TriggerDefinition.id":"System.String","TriggerDefinition.name":"string","TriggerDefinition.timingDate":"date","TriggerDefinition.timingDateTime":"dateTime","TriggerDefinition.timingReference":"Reference","TriggerDefinition.timingTiming":"Timing","TriggerDefinition.type":"code","UsageContext.code":"Coding","UsageContext.extension":"Extension","UsageContext.id":"System.String","UsageContext.valueCodeableConcept":"CodeableConcept","UsageContext.valueQuantity":"Quantity","UsageContext.valueRange":"Range","UsageContext.valueReference":"Reference","ValueSet.compose.extension":"Extension","ValueSet.compose.id":"System.String","ValueSet.compose.inactive":"boolean","ValueSet.compose.include.concept.code":"code","ValueSet.compose.include.concept.designation.extension":"Extension","ValueSet.compose.include.concept.designation.id":"System.String","ValueSet.compose.include.concept.designation.language":"code","ValueSet.compose.include.concept.designation.modifierExtension":"Extension","ValueSet.compose.include.concept.designation.use":"Coding","ValueSet.compose.include.concept.designation.value":"string","ValueSet.compose.include.concept.display":"string","ValueSet.compose.include.concept.extension":"Extension","ValueSet.compose.include.concept.id":"System.String","ValueSet.compose.include.concept.modifierExtension":"Extension","ValueSet.compose.include.extension":"Extension","ValueSet.compose.include.filter.extension":"Extension","ValueSet.compose.include.filter.id":"System.String","ValueSet.compose.include.filter.modifierExtension":"Extension","ValueSet.compose.include.filter.op":"code","ValueSet.compose.include.filter.property":"code","ValueSet.compose.include.filter.value":"string","ValueSet.compose.include.id":"System.String","ValueSet.compose.include.modifierExtension":"Extension","ValueSet.compose.include.system":"uri","ValueSet.compose.include.valueSet":"canonical","ValueSet.compose.include.version":"string","ValueSet.compose.lockedDate":"date","ValueSet.compose.modifierExtension":"Extension","ValueSet.contact":"ContactDetail","ValueSet.contained":"Resource","ValueSet.copyright":"markdown","ValueSet.date":"dateTime","ValueSet.description":"markdown","ValueSet.expansion.contains.abstract":"boolean","ValueSet.expansion.contains.code":"code","ValueSet.expansion.contains.display":"string","ValueSet.expansion.contains.extension":"Extension","ValueSet.expansion.contains.id":"System.String","ValueSet.expansion.contains.inactive":"boolean","ValueSet.expansion.contains.modifierExtension":"Extension","ValueSet.expansion.contains.system":"uri","ValueSet.expansion.contains.version":"string","ValueSet.expansion.extension":"Extension","ValueSet.expansion.id":"System.String","ValueSet.expansion.identifier":"uri","ValueSet.expansion.modifierExtension":"Extension","ValueSet.expansion.offset":"integer","ValueSet.expansion.parameter.extension":"Extension","ValueSet.expansion.parameter.id":"System.String","ValueSet.expansion.parameter.modifierExtension":"Extension","ValueSet.expansion.parameter.name":"string","ValueSet.expansion.parameter.valueBoolean":"boolean","ValueSet.expansion.parameter.valueCode":"code","ValueSet.expansion.parameter.valueDateTime":"dateTime","ValueSet.expansion.parameter.valueDecimal":"decimal","ValueSet.expansion.parameter.valueInteger":"integer","ValueSet.expansion.parameter.valueString":"string","ValueSet.expansion.parameter.valueUri":"uri","ValueSet.expansion.timestamp":"dateTime","ValueSet.expansion.total":"integer","ValueSet.experimental":"boolean","ValueSet.extension":"Extension","ValueSet.id":"System.String","ValueSet.identifier":"Identifier","ValueSet.immutable":"boolean","ValueSet.implicitRules":"uri","ValueSet.jurisdiction":"CodeableConcept","ValueSet.language":"code","ValueSet.meta":"Meta","ValueSet.modifierExtension":"Extension","ValueSet.name":"string","ValueSet.publisher":"string","ValueSet.purpose":"markdown","ValueSet.status":"code","ValueSet.text":"Narrative","ValueSet.title":"string","ValueSet.url":"uri","ValueSet.useContext":"UsageContext","ValueSet.version":"string","VerificationResult.attestation.communicationMethod":"CodeableConcept","VerificationResult.attestation.date":"date","VerificationResult.attestation.extension":"Extension","VerificationResult.attestation.id":"System.String","VerificationResult.attestation.modifierExtension":"Extension","VerificationResult.attestation.onBehalfOf":"Reference","VerificationResult.attestation.proxyIdentityCertificate":"string","VerificationResult.attestation.proxySignature":"Signature","VerificationResult.attestation.sourceIdentityCertificate":"string","VerificationResult.attestation.sourceSignature":"Signature","VerificationResult.attestation.who":"Reference","VerificationResult.contained":"Resource","VerificationResult.extension":"Extension","VerificationResult.failureAction":"CodeableConcept","VerificationResult.frequency":"Timing","VerificationResult.id":"System.String","VerificationResult.implicitRules":"uri","VerificationResult.language":"code","VerificationResult.lastPerformed":"dateTime","VerificationResult.meta":"Meta","VerificationResult.modifierExtension":"Extension","VerificationResult.need":"CodeableConcept","VerificationResult.nextScheduled":"date","VerificationResult.primarySource.canPushUpdates":"CodeableConcept","VerificationResult.primarySource.communicationMethod":"CodeableConcept","VerificationResult.primarySource.extension":"Extension","VerificationResult.primarySource.id":"System.String","VerificationResult.primarySource.modifierExtension":"Extension","VerificationResult.primarySource.pushTypeAvailable":"CodeableConcept","VerificationResult.primarySource.type":"CodeableConcept","VerificationResult.primarySource.validationDate":"dateTime","VerificationResult.primarySource.validationStatus":"CodeableConcept","VerificationResult.primarySource.who":"Reference","VerificationResult.status":"code","VerificationResult.statusDate":"dateTime","VerificationResult.target":"Reference","VerificationResult.targetLocation":"string","VerificationResult.text":"Narrative","VerificationResult.validationProcess":"CodeableConcept","VerificationResult.validationType":"CodeableConcept","VerificationResult.validator.attestationSignature":"Signature","VerificationResult.validator.extension":"Extension","VerificationResult.validator.id":"System.String","VerificationResult.validator.identityCertificate":"string","VerificationResult.validator.modifierExtension":"Extension","VerificationResult.validator.organization":"Reference","VisionPrescription.contained":"Resource","VisionPrescription.created":"dateTime","VisionPrescription.dateWritten":"dateTime","VisionPrescription.encounter":"Reference","VisionPrescription.extension":"Extension","VisionPrescription.id":"System.String","VisionPrescription.identifier":"Identifier","VisionPrescription.implicitRules":"uri","VisionPrescription.language":"code","VisionPrescription.lensSpecification.add":"decimal","VisionPrescription.lensSpecification.axis":"integer","VisionPrescription.lensSpecification.backCurve":"decimal","VisionPrescription.lensSpecification.brand":"string","VisionPrescription.lensSpecification.color":"string","VisionPrescription.lensSpecification.cylinder":"decimal","VisionPrescription.lensSpecification.diameter":"decimal","VisionPrescription.lensSpecification.duration":"Quantity","VisionPrescription.lensSpecification.extension":"Extension","VisionPrescription.lensSpecification.eye":"code","VisionPrescription.lensSpecification.id":"System.String","VisionPrescription.lensSpecification.modifierExtension":"Extension","VisionPrescription.lensSpecification.note":"Annotation","VisionPrescription.lensSpecification.power":"decimal","VisionPrescription.lensSpecification.prism.amount":"decimal","VisionPrescription.lensSpecification.prism.base":"code","VisionPrescription.lensSpecification.prism.extension":"Extension","VisionPrescription.lensSpecification.prism.id":"System.String","VisionPrescription.lensSpecification.prism.modifierExtension":"Extension","VisionPrescription.lensSpecification.product":"CodeableConcept","VisionPrescription.lensSpecification.sphere":"decimal","VisionPrescription.meta":"Meta","VisionPrescription.modifierExtension":"Extension","VisionPrescription.patient":"Reference","VisionPrescription.prescriber":"Reference","VisionPrescription.status":"code","VisionPrescription.text":"Narrative"}');

/***/ }),
/* 92 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _import_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(93);

/**
 * A package to handle FHIR DiagnosticReport for LForms
 * https://www.hl7.org/fhir/diagnosticreport.html
 *
 * Note that this was written for DSTU2 and has not been updated.
 *
 * It provides the following functions:
 * createDiagnosticReport()
 * -- Convert existing LOINC panels/forms data in LForms format into FHIR DiagnosticReport data
 * mergeDiagnosticReportToLForms()
 * -- Merge FHIR SDC DiagnosticReport data into corresponding LForms data
 */

var dr = {
  // a prefix for references to Observation resources
  _OBX_REF_PREFIX: "Observation/",

  /**
   * Functions for creating a DiagnosticReport instance from an LFormsData object
   */

  /** Get date in a standard string format
   * @param dateObj, a date object
   * @returns {string} a formatted date string
   * @private
   */
  _getFormattedDate: function (dateObj) {
    //"2013-01-27T11:45:33+11:00",
    return dateObj ? LForms.Util.dateToDTMString(dateObj) : "";
  },

  /**
   * A recursive function that generates the DiagnosticReport content by
   * going through the LForms form data structure
   * @param item an LForms item
   * @param contained the "contained" field in a DiagnosticReport where all the Observation instances are kept.
   * @returns {{result: Array, resultObj: Array}} the content part of a Diagnostic Report instance
   * @private
   */
  _createDiagnosticReportContent: function (item, contained) {
    // return the content of "result" and "contained"
    var content = {
      result: [],
      resultObj: []
    };

    for (var i = 0, iLen = item.items.length; i < iLen; i++) {
      var subItem = item.items[i];

      if (subItem) {
        var obx = this._commonExport._createObservation(subItem, true);

        if (subItem.items && subItem.items.length > 0) {
          // single obx returned if it is a header item
          obx[0].related = [];

          var ret = this._createDiagnosticReportContent(subItem, contained);

          for (var j = 0, jLen = ret.result.length; j < jLen; j++) {
            var subObxRef = ret.result[j];
            obx[0].related.push({
              type: "has-member",
              target: {
                reference: subObxRef.reference
              }
            });
          }
        }

        for (var l = 0, lLen = obx.length; l < lLen; l++) {
          contained.push(obx[l]);
          content.result.push({
            reference: "#" + obx[l].id
          });
          content.resultObj.push(obx[l]);
        }
      }
    }

    return content;
  },

  /**
   * Convert a DiagnosticReport resource with contained Observation resources to
   * a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * @param dr a DiagnosticReport resource with contained Observation resources
   * @param bundleType the FHIR Bundle type. Only "transaction" and "collection" types are allowed.
   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   */
  _convertFromContainedToBundle: function (dr, bundleType) {
    var bundleDr = {}; // default bundleType

    if (!bundleType) {
      bundleType = "transaction";
    }

    if (dr) {
      switch (bundleType) {
        case "transaction":
          bundleDr = this._convertContainedToTransactionBundle(dr);
          break;

        case "collection":
          bundleDr = this._convertContainedToCollectionBundle(dr);
          break;

        default:
          console.log("Bundle type not supported: " + bundleType);
      }
    }

    return bundleDr;
  },

  /**
   * Convert a DiagnosticReport resource with contained Observation resources to
   * a FHIR "transaction" typed Bundle resource that includes a DiagnosticReport resource
   * and associated Observation resources
   * @param dr a DiagnosticReport resource with contained Observation resources
   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * @private
   */
  _convertContainedToTransactionBundle: function (dr) {
    var bundleDr = {
      resourceType: "Bundle",
      type: "transaction",
      entry: []
    };
    var contained = dr.contained;
    delete dr.contained; // update reference to Observation resources

    for (var i = 0, iLen = dr.result.length; i < iLen; i++) {
      var ref = dr.result[i];
      ref.reference = this._OBX_REF_PREFIX + ref.reference.slice(1);
    } // add DiagnosticReport resource into Bundle entry


    bundleDr.entry.push({
      resource: dr,
      request: {
        method: "POST",
        url: "DiagnosticReport"
      }
    }); // add Observation resources into Bundle entry

    for (var j = 0, jLen = contained.length; j < jLen; j++) {
      var res = contained[j]; // if it has related Observation resources (as it is a section in LForms)
      // update values of the references to the related Observation resources

      if (res.related) {
        for (var k = 0, kLen = res.related.length; k < kLen; k++) {
          var targetObservation = res.related[k];
          targetObservation.target.reference = this._OBX_REF_PREFIX + targetObservation.target.reference.slice(1);
        }
      } // add to the Bundle entry


      bundleDr.entry.push({
        resource: res,
        request: {
          method: "POST",
          url: "Observation"
        }
      });
    }

    return bundleDr;
  },

  /**
   * Convert a DiagnosticReport resource with contained Observation resources to
   * a FHIR "collection" typed Bundle resource that includes a DiagnosticReport resource
   * and associated Observation resources
   * @param dr a DiagnosticReport resource with contained Observation resources
   * @returns {{}} a Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * @private
   */
  _convertContainedToCollectionBundle: function (dr) {
    var bundleDr = {
      resourceType: "Bundle",
      type: "collection",
      entry: []
    };
    var contained = dr.contained;
    delete dr.contained; // add DiagnosticReport resource into Bundle entry

    bundleDr.entry.push({
      resource: dr
    }); // add Observation resources into Bundle entry

    for (var j = 0, jLen = contained.length; j < jLen; j++) {
      var res = contained[j]; // add to the Bundle entry

      bundleDr.entry.push({
        resource: res
      });
    }

    return bundleDr;
  },

  /**
   * Generate FHIR DiagnosticReport data from an LForms form data
   * @param formData an LFormsData object
   * @param subject optional, A local FHIR resource that is the subject for this
   *  DiagnoticReport.
   * @param inBundle optional, a flag that a DiagnosticReport resources and associated Observation resources
   *        should be placed into a FHIR Bundle. The default is false.
   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.
   *        Only "transaction" and "collection" types are allowed.
   * @returns {{}} a Diagnostic Report instance
   */
  createDiagnosticReport: function (formData, subject, inBundle, bundleType) {
    var dr = null,
        contained = [];

    if (formData) {
      var formAndUserData = formData.getFormData(true, true, true);

      var drContent = this._createDiagnosticReportContent(formAndUserData, contained);

      dr = {
        resourceType: "DiagnosticReport",
        id: this._commonExport._getUniqueId(formAndUserData.code),
        status: "final",
        code: {
          "coding": [{
            "system": "http://loinc.org",
            "code": formAndUserData.code,
            "display": formAndUserData.name
          }],
          "text": formAndUserData.name
        },
        result: drContent.result,
        contained: contained
      };

      this._commonExport._addVersionTag(dr);

      if (subject) dr.subject = LForms.Util.createLocalFHIRReference(subject); // issued

      dr["issued"] = this._getFormattedDate(new Date());
    }

    var ret = inBundle ? this._convertFromContainedToBundle(dr, bundleType) : dr;
    LForms.Util.pruneNulls(ret);
    return ret;
  },

  /**
   * Functions for merging a DiagnosticReport instance into an LFormsData object
   */

  /**
   * Find an observation from the "contained" list by an observation id
   * @param refId an observation instance's id
   * @param contained the "contained" field in a DiagnosticReport instance
   * @returns {{}} an observation instance
   * @private
   */
  _findObxById: function (refId, contained) {
    var obx = null;

    if (refId) {
      var id = refId[0] === "#" ? refId.slice(1) : refId;

      for (var i = 0, iLen = contained.length; i < iLen; i++) {
        if (contained[i].id === id) {
          obx = contained[i];
          break;
        }
      }
    }

    return obx;
  },

  /**
   * Merge an Observation instance into an item object
   * @param obx an observation instance
   * @param item an item in an LForms object
   * @private
   */
  _setupItemValueAndUnit: function (obx, item) {
    if (item && obx.code.coding[0].code === item.questionCode) {
      var dataType = item.dataType; // any one has a unit must be a numerical type, let use REAL for now.
      // dataType conversion should be handled when panel data are added to lforms-service.

      if ((!dataType || dataType === "ST") && item.units && item.units.length > 0) {
        dataType = "REAL";
      }

      switch (dataType) {
        case "INT":
          if (obx.valueInteger) {
            item.value = obx.valueInteger;
            break;
          }

        // else handle as Quantity

        case "REAL": // handle as Quantity

        case "QTY":
          let qty = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_0__.importFHIRQuantity)(obx.valueQuantity);
          item.value = qty.value;
          delete qty.value;
          if (qty.name || qty.code || qty.system) item.unit = qty;
          break;

        case "DT":
          item.value = LForms.Util.stringToDTDateISO(obx.valueDate);
          break;

        case "DTM":
          item.value = LForms.Util.stringToDate(obx.valueDateTime);
          break;

        case "CNE":
        case "CWE":
          // get the value from Observation resource.
          // for multiple-selected answers/values in LForms, each selected answer is exported as
          // a separated Observation resource
          var itemValue;

          if (obx.valueCodeableConcept) {
            itemValue = {
              "code": obx.valueCodeableConcept.coding[0].code,
              "text": obx.valueCodeableConcept.coding[0].display,
              "system": obx.valueCodeableConcept.coding[0].system
            };
          } else if (obx.valueString) {
            itemValue = obx.valueString;
          }

          if (item.answerCardinality && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1)) {
            if (!item.value) {
              item.value = [];
            }

            item.value.push(itemValue);
          } else {
            item.value = itemValue;
          }

          break;

        case "SECTION":
        case "TITLE":
        case "":
          // do nothing
          break;

        default:
          item.value = obx.valueString;
      }
    }
  },

  /**
   * Find the number of the repeating items that have the same code
   * in the "contained" field of a DiagnosticReport instance
   * @param refIdList a list Observation instance IDs to be checked
   * @param code an item code
   * @param contained a list of Observation instances (in the "contained")
   * @returns a structural info object for a repeating item
   * of the repeating items
   * @private
   */
  _findTotalRepeatingNum: function (refIdList, code, contained) {
    var total = 0;
    var refIds = [];

    for (var i = 0, iLen = refIdList.length; i < iLen; i++) {
      var obx = this._findObxById(refIdList[i], contained);

      if (obx.code.coding[0].code === code) {
        refIds.push(refIdList[i]);
        total += 1;
      }
    }

    return {
      total: total,
      refIds: refIds
    };
  },

  /**
   * Get structural info of a DiagnosticReport by going though each level of observations
   * @param parentObxInfo the structural info of a parent Observation
   * @param parentRefId the instance ID of a parent Observation
   * @param diagnosticReport a DiagnosticReport instance
   * @private
   */
  _checkRepeatingItems: function (parentObxInfo, parentRefId, diagnosticReport) {
    var obxInfoList = [];
    var repeatingItemInfo = {};
    var obxIdList = []; // the report level

    if (!parentRefId && diagnosticReport.result) {
      for (var i = 0, iLen = diagnosticReport.result.length; i < iLen; i++) {
        obxIdList.push(diagnosticReport.result[i].reference);
      }
    } // obx level
    else {
      var parentObx = this._findObxById(parentRefId, diagnosticReport.contained);

      if (parentObx && parentObx.related) {
        for (var i = 0, iLen = parentObx.related.length; i < iLen; i++) {
          obxIdList.push(parentObx.related[i].target.reference);
        }
      }
    } // go through each observation instance


    for (var i = 0, iLen = obxIdList.length; i < iLen; i++) {
      var refId = obxIdList[i];

      var obx = this._findObxById(refId, diagnosticReport.contained);

      var itemCode = obx.code.coding[0].code; // first obx that has the same item code, either repeating or non-repeating

      if (!repeatingItemInfo[itemCode]) {
        var repeatingInfo = this._findTotalRepeatingNum(obxIdList, itemCode, diagnosticReport.contained);

        repeatingItemInfo[itemCode] = {
          total: repeatingInfo.total,
          refIds: repeatingInfo.refIds
        };
      } // create structure info for the obx


      var repeatingRefIds = repeatingItemInfo[itemCode].refIds;

      for (var j = 0, jLen = repeatingRefIds.length; j < jLen; j++) {
        if (refId === repeatingRefIds[j]) {
          var obxInfo = {
            code: itemCode,
            refId: refId,
            index: j,
            total: repeatingItemInfo[itemCode].total
          }; // check observation instances in the sub level

          this._checkRepeatingItems(obxInfo, refId, diagnosticReport);

          obxInfoList.push(obxInfo);
        }
      }
    }

    parentObxInfo.obxInfoList = obxInfoList;
  },

  /**
   * Get structure information of a DiagnosticReport instance
   * @param diagnosticReport a DiagnosticReport instance
   * @returns {{}} a Diagnostic Report data structure object
   * @private
   */
  _getReportStructure: function (diagnosticReport) {
    var reportStructure = {
      obxInfoList: []
    };

    if (diagnosticReport) {
      this._checkRepeatingItems(reportStructure, null, diagnosticReport);
    }

    return reportStructure;
  },

  /**
   * Find a matching repeating item
   * @param parentItem a parent item
   * @param itemCode code of a repeating (or non-repeating) item
   * @param index index of the item in the sub item array of the parent item
   * @returns {{}} a matching item
   * @private
   */
  _findTheMatchingItemByCodeAndIndex: function (parentItem, itemCode, index) {
    var item = null;
    var idx = 0;

    if (parentItem.items) {
      for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
        var subItem = parentItem.items[i];

        if (itemCode === subItem.questionCode) {
          if ((subItem.dataType === "CNE" || subItem.dataType === "CWE") && subItem.answerCardinality && (subItem.answerCardinality.max === "*" || parseInt(subItem.answerCardinality.max) > 1)) {
            item = subItem;
            break;
          } else if (idx === index) {
            item = subItem;
            break;
          } else {
            idx += 1;
          }
        }
      }
    }

    return item;
  },

  /**
   * Add repeating items
   * @param parentItem a parent item
   * @param itemCode code of a repeating item
   * @param total total number of the repeating item with the same code
   * @private
   */
  _addRepeatingItems: function (parentItem, itemCode, total) {
    // find the first (and the only one) item
    var item = null;

    if (parentItem.items) {
      for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
        if (itemCode === parentItem.items[i].questionCode) {
          item = parentItem.items[i];
          break;
        }
      } // insert new items unless it is a CNE/CWE and has multiple answers.


      if (item && !((item.dataType === "CNE" || item.dataType === "CWE") && item.answerCardinality && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1))) {
        while (total > 1) {
          var newItem = LForms.Util.deepCopy(item);
          parentItem.items.splice(i, 0, newItem);
          total -= 1;
        }
      }
    }
  },

  /**
   * Merge Observation instances into items on the same level
   * @param parentObxInfo structural information of a parent item
   * @param parentItem a parent item
   * @param diagnosticReport a DiagnosticReport instance
   * @private
   */
  _processObxAndItem: function (parentObxInfo, parentItem, diagnosticReport) {
    for (var i = 0, iLen = parentObxInfo.obxInfoList.length; i < iLen; i++) {
      var obxInfo = parentObxInfo.obxInfoList[i];

      var obx = this._findObxById(obxInfo.refId, diagnosticReport.contained);

      if (obx) {
        // first repeating obx
        if (obxInfo.total > 1 && obxInfo.index === 0) {
          // add repeating items in form data
          this._addRepeatingItems(parentItem, obxInfo.code, obxInfo.total);
        }

        var item = this._findTheMatchingItemByCodeAndIndex(parentItem, obxInfo.code, obxInfo.index);

        this._setupItemValueAndUnit(obx, item); // process items on sub level


        if (obxInfo.obxInfoList && obxInfo.obxInfoList.length > 0) {
          this._processObxAndItem(obxInfo, item, diagnosticReport);
        }
      }
    }
  },

  /**
   * Convert a FHIR Bundle resource that includes a DiagnosticReport resource and associated Observation resources
   * to a DiagnosticReport resource with contained Observation resources
   * @param bundleDr a Bundle that includes a DiagnosticReport resource and associated Observation resources.
   *        Only "searchset" type is allowed.
   * @returns {{}} a DiagnosticReport resource with contained Observation resources
   */
  _convertFromBundleToContained: function (bundleDr) {
    var containedDr; // "searchset" is the only supported type at this point.

    if (bundleDr && bundleDr.type === "searchset") {
      var entry = bundleDr.entry; // find the DiagnosticReport in the bundle

      for (var i = 0, iLen = entry.length; i < iLen; i++) {
        if (entry[i].resource.resourceType === "DiagnosticReport") {
          containedDr = entry[i].resource; // change reference ids in result

          for (var j = 0, jLen = containedDr.result.length; j < jLen; j++) {
            var ref = containedDr.result[j];

            if (ref.reference && ref.reference.match(new RegExp(this._OBX_REF_PREFIX))) {
              ref.reference = ref.reference.slice(this._OBX_REF_PREFIX.length);
            }
          }

          containedDr.contained = [];
          break;
        }
      } // if DiagnosticReport is found


      if (containedDr) {
        // Move all Observation resource into "contained" field of the DiagnosticReport resource
        for (var i = 0, iLen = entry.length; i < iLen; i++) {
          if (entry[i].resource.resourceType === "Observation") {
            var obx = entry[i].resource; // change reference ids in related

            if (obx.related) {
              for (var j = 0, jLen = obx.related.length; j < jLen; j++) {
                var related = obx.related[j];

                if (related.target && related.target.reference && related.target.reference.match(new RegExp(this._OBX_REF_PREFIX))) {
                  related.target.reference = related.target.reference.slice(this._OBX_REF_PREFIX.length);
                }
              }
            }

            containedDr.contained.push(obx);
          }
        }
      }
    }

    return containedDr;
  },

  /**
   * Merge a DiagnosticReport instance into an LForms form definition or LFormsData object
   * @param formData an LForms form definition or LFormsData object.
   * @param diagnosticReport a DiagnosticReport resource with contained Observation resources,
   * or a Bundle that includes a DiagnosticReport resource and associated Observation resources
   * @param bundleType, optional, the FHIR Bundle type if inBundle is true.
   * @returns {{}} an updated LForms form definition, with answer data
   */
  mergeDiagnosticReportToLForms: function (formData, diagnosticReport) {
    if (!(formData instanceof LForms.LFormsData)) {
      // get the default settings in case they are missing in the form data
      // not to set item values by default values for saved forms with user data
      formData.hasSavedData = true;
      formData = new LForms.LFormsData(formData).getFormData();
    }

    var inBundle = diagnosticReport && diagnosticReport.resourceType === "Bundle"; // move Observation resources in Bundle to be in "contained" in DiagnosticReport resource
    // as a base data structure for converting

    var dr = inBundle ? this._convertFromBundleToContained(diagnosticReport) : diagnosticReport;

    var reportStructure = this._getReportStructure(dr);

    this._processObxAndItem(reportStructure, formData, dr);

    return formData;
  }
};
/* harmony default export */ __webpack_exports__["default"] = (dr);

/***/ }),
/* 93 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "importFHIRQuantity": function() { return /* binding */ importFHIRQuantity; }
/* harmony export */ });
/*
 *  Defines import functions that are the same across the different FHIR
 *  versions and that are used by both the SDC and DiagnosticReport imports.
 */

/**
 *  Converts a FHIR Quantity to the an an LForms equivalent-- essentially, the
 *  unit object plus 'value' field.
 * @param quantity the quantity to be converted.
 * @return the quantity data with field labels appropriate for LForms.
 */
function importFHIRQuantity(quantity) {
  const rtn = {
    _type: 'Quantity',
    value: quantity.value
  };
  const unitOrCode = quantity.unit || quantity.code;

  if (unitOrCode) {
    rtn.name = unitOrCode; // in some data 'unit' is undefined

    if (quantity.code) rtn.code = quantity.code;
    if (quantity.system) rtn.system = quantity.system;
  }

  return rtn;
}

/***/ }),
/* 94 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _export_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(95);
// R4-specific export code common to DiagnosticReport and SDC.

let self = Object.create(_export_common_js__WEBPACK_IMPORTED_MODULE_0__["default"]); // copies properties to self.prototype

Object.assign(self, {
  /**
   *  Creates a structure for use by _createObservation() in constructing an
   *  Observation value for the given integer value.
   * @param item an LForms item with the integer value to be represented in an Observation.
   *  It is assumed that the caller has already checked the data type.
   * @return an object with a "key" property that will be the property name for
   *  the value in the Observation object, and a "val" property that holds the
   *  value (formatted for the Observation).
   */
  _createObsIntValue: function (item) {
    // R4 added valueInteger to Observation, so we use that unless the item has
    // a unit, in which case we use valueQuantity.
    // valueQuantity.
    let rtn;

    if (item.unit) {
      let quantity = {
        value: item.value
      };

      this._setFHIRQuantityUnit(quantity, item.unit);

      rtn = {
        key: 'valueQuantity',
        val: quantity
      };
    } else rtn = {
      key: 'valueInteger',
      val: item.value
    };

    return rtn;
  }
});
/* harmony default export */ __webpack_exports__["default"] = (self);

/***/ }),
/* 95 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fhir_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* jshint -W097 */
// suppress jshint warning about strict

/* jshint node: true */
// suppress warning about "require"



var _versionTagStr = 'lformsVersion: ';
/**
 *  Defines export functions that are the same across the different FHIR
 *  versions and that are used by both the SDC and DiagnosticReport exports.
 */

var self = {
  /**
   *  Creates Observation resources from an LForms item object
   * @param item an LForms item object
   * @param setId (optional) a flag indicating if a unique ID should be set on the Observation resource
   * @returns {{}} an array of observation resources representing the values
   *  stored in the item.
   * @private
   */
  _createObservation: function (item, setId) {
    var values = [];
    var dataType = item.dataType; // any item has a unit must be a numerical type, let use REAL for now.

    if ((!dataType || dataType === "ST") && item.units && item.units.length > 0) {
      dataType = "REAL";
    }

    switch (dataType) {
      case "INT":
        values = [this._createObsIntValue(item)];
        break;

      case "REAL": // A "real" data type should be exported as valueQuantity, because
      // there is no valueDecimal for Observation (as of R4).

      case "QTY":
        var valValue = {
          value: item.value
        };

        this._setFHIRQuantityUnit(valValue, item.unit);

        values = [{
          key: "valueQuantity",
          val: valValue
        }];
        break;

      case "DT":
        values = [{
          key: "valueDate",
          val: item.value
        }];
        break;

      case "DTM":
        values = [{
          key: "valueDateTime",
          val: item.value
        }];
        break;

      case "CNE":
      case "CWE":
        var max = item.answerCardinality.max; // multiple values, each value creates a separate Observation resource

        var itemValues;

        if (max && (max === "*" || parseInt(max) > 1)) {
          itemValues = item.value;
        } else {
          itemValues = [item.value];
        }

        for (var j = 0, jLen = itemValues.length; j < jLen; j++) {
          var val = itemValues[j];

          if (typeof val === "object") {
            var coding = {};
            if (val.code) coding.code = val.code;
            if (val.text) coding.display = val.text;
            var codeSystem = val.system;
            if (codeSystem) coding.system = LForms.Util.getCodeSystem(codeSystem);
            values.push({
              key: "valueCodeableConcept",
              val: {
                "coding": [coding],
                "text": coding.display
              }
            });
          } else if (typeof val === "string") {
            if (val !== "") {
              values.push({
                key: "valueString",
                val: val
              });
            }
          }
        }

        break;

      case "attachment":
        values = [{
          key: "valueAttachment",
          val: item.value
        }];
        break;

      case "BL":
        values = [{
          key: "valueBoolean",
          val: item.value // undefined, null, or '' values should have been skipped before calling this function

        }];
        break;

      default:
        values = [{
          key: "valueString",
          val: item.value
        }];
    }

    var obxs = [];

    for (var i = 0, iLen = values.length; i < iLen; i++) {
      var obx = {
        "resourceType": "Observation",
        "status": "final",
        "code": {
          "coding": item.codeList,
          "text": item.question
        }
      };

      this._addVersionTag(obx);

      if (setId) {
        obx.id = this._getUniqueId(item.questionCode);
      }

      if (!item.header) {
        obx[values[i].key] = values[i].val;
      }

      obxs.push(obx);
    }

    return obxs;
  },

  /**
   * Generate an almost unique ID for a given Observation code
   * @param prefix A prefix for the ID (e.g. a code or resource name)
   * @returns {string} a unique id
   * @private
   */
  _getUniqueId: function (prefix) {
    this._idCtr || (this._idCtr = 0);
    return prefix + "-" + Date.now() + '-' + ++this._idCtr + '-' + Math.random().toString(16).substr(2);
  },

  /**
   *  Sets the unit for a Quantity.
   * @param qty the FHIR Quantity structure whose unit will be set.  This
   *  function assumes there is no unit information already set.
   * @param unit An LForms unit object.
   */
  _setFHIRQuantityUnit: function (qty, unit) {
    if (unit) {
      if (unit.name) qty.unit = unit.name;
      if (unit.code) qty.code = unit.code;
      if (unit.system) qty.system = unit.system;
    }
  },

  /**
   *  Returns and creates if necessary the tag array object on the resource.  If
   *  created, the given resource will be modified.
   * @param res the resource whose tag array is needed.
   */
  _resTags: function (res) {
    var meta = res.meta;
    if (!meta) meta = res.meta = {};
    var tag = meta.tag;
    if (!tag) tag = meta.tag = [];
    return tag;
  },

  /**
   *  Sets the LForms version tag on a FHIR resource to indicate the LForms version used to
   *  export it.  This will replace any version tag already present.
   * @param res the resource object to be tagged.
   */
  _setVersionTag: function (res) {
    var tags = this._resTags(res); // Delete any lformsVersion tag present.  There should be at most one


    for (var i = 0, len = tags.length; i < len; ++i) {
      var t = tags[i];

      if (t.code && t.code.indexOf(_versionTagStr) === 0) {
        tags.splice(i, 1);
        break;
      }
    }

    this._addVersionTag(res);
  },

  /**
   *  Adds a tag to a FHIR resource to indicate the LForms version used to
   *  export it.  Assumes the version tag does not already exist.
   * @param res the resource object to be tagged.
   */
  _addVersionTag: function (res) {
    var tag = this._resTags(res);

    tag.push({
      code: _versionTagStr + LForms.lformsVersion
    });
  }
};
/* harmony default export */ __webpack_exports__["default"] = (self);

/***/ }),
/* 96 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A package to handle FHIR Questionnaire and SDC (STU2) Questionnaire and QuestionnaireResponse for LForms
 *
 * FHIR Questionnaire:
 * https://www.hl7.org/fhir/questionnaire.html
 *
 * R4 Ballot (3.5) for comment:
 * http://hl7.org/fhir/uv/sdc/2018Sep/sdc-questionnaire.html
 * http://hl7.org/fhir/uv/sdc/2018Sep/sdc-questionnaireresponse.html
 *
 * It provides the following functions:
 * convertLFormsToQuestionnaire()
 * -- Convert existing LOINC panels/forms data in LForms format into FHIR (standard or SDC) Questionnaire data
 * convertLFormsToQuestionnaireResponse()
 * -- Generate FHIR (standard or SDC) QuestionnaireResponse data from captured data in LForms
 */
var self = {
  /**
   *  Convert LForms captured data to a bundle consisting of a FHIR SDC
   *  QuestionnaireResponse and any extractable resources. (Currently this means
   *  any Observations that can be extracted via the observationLinkPeriod
   *  extension).
   *
   * @param lfData a LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without 
   *  any extensions. The default is false.
   * @param subject A local FHIR resource that is the subject of the output resource.
   *  If provided, a reference to this resource will be added to the output FHIR
   *  resource when applicable.
   * @returns an array of QuestionnaireResponse and Observations, or null if there is 
   *  no valid QuestionnaireResponse. Observations will have derivedFrom set to a 
   *  temporary reference created for the returned QuestionnaireResponse 
   *  (the first element of the array). The caller may wish to put all of the 
   *  returned resources into a transaction Bundle for creating them on a FHIR server.
   */
  convertLFormsToQRAndExtracFHIRData: function (lfData, noExtensions, subject) {
    var qr = this.convertLFormsToQuestionnaireResponse(lfData, noExtensions, subject);

    if (!qr) {
      return null;
    }

    if (!qr.id) {
      qr.id = this._commonExport._getUniqueId(qr.identifier && qr.identifier.value || 'QR');
    }

    var qrRef = 'QuestionnaireResponse/' + qr.id;
    var rtn = [qr];

    for (var i = 0, len = lfData.itemList.length; i < len; ++i) {
      var item = lfData.itemList[i];

      if (this._getExtractValue(item) && this._hasItemValue(item)) {
        var obs = this._commonExport._createObservation(item);

        for (var j = 0, jLen = obs.length; j < jLen; j++) {
          // Following
          // http://hl7.org/fhir/uv/sdc/2019May/extraction.html#observation-based-extraction
          if (qr.basedOn) obs[j].basedOn = qr.basedOn;
          if (qr.partOf) obs[j].partOf = qr.partOf;
          if (qr.subject) obs[j].subject = qr.subject;
          if (qr.encounter) obs[j].encounter = qr.encounter;

          if (qr.authored) {
            obs[j].effectiveDateTime = qr.authored;
            obs[j].issued = qr.authored;
          }

          if (qr.author) obs[j].performer = qr.author;
          obs[j].derivedFrom = [{
            reference: qrRef
          }];
          rtn.push(obs[j]);
        }
      }
    }

    return rtn;
  },

  /**
   *  Proceses the LForms questionCardinality into FHIR.
   * @param targetItem an item in Questionnaire
   * @param item a LForms item
   */
  _processQuestionCardinality: function (targetItem, item) {
    if (item.questionCardinality) {
      if (item.questionCardinality.max === "*") {
        targetItem.repeats = true;
      } else if (parseInt(item.questionCardinality.max) > 1) {
        targetItem.repeats = true;
        targetItem.extension.push({
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs",
          "valueInteger": parseInt(item.questionCardinality.max)
        });
      }
    } else {// No default in R4
      // targetItem.repeats = false;
    }
  },

  /**
   * Handle special requirements for 'display' items
   * @param targetItem an item in Questionnaire
   * @param item a LForms item
   * @private
   */
  _handleSpecialConstraints: function (targetItem, item) {
    //Display items cannot have a "code" asserted
    //Required and repeat aren't permitted for display items
    //Read-only can't be specified for "display" items
    if (targetItem && item.dataType === "TITLE") {
      delete targetItem.code;
      delete targetItem.required;
      delete targetItem.repeats;
      delete targetItem.readOnly;
    }
  },

  /**
   * Process various restriction settings
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  _handleRestrictions: function (targetItem, item) {
    // http://hl7.org/fhir/StructureDefinition/minLength
    // http://hl7.org/fhir/StructureDefinition/regex
    // http://hl7.org/fhir/StructureDefinition/minValue
    // http://hl7.org/fhir/StructureDefinition/maxValue
    // http://hl7.org/fhir/StructureDefinition/maxDecimalPlaces, not supported yet
    // http://hl7.org/fhir/StructureDefinition/maxSize, for attachment, not supported yet
    // maxLength
    if (item.restrictions) {
      for (var key in item.restrictions) {
        var value = item.restrictions[key];
        var extValue = null;

        var dataType = this._getAssumedDataTypeForExport(item);

        var valueKey = this._getValueKeyByDataType("value", item);

        switch (key) {
          // http://hl7.org/fhir/StructureDefinition/minValue
          // { // Must be >= this value
          //   // from Element: extension
          //   "url" : "http://hl7.org/fhir/StructureDefinition/minValue", // R!
          //   // value[x]: Value of extension. One of these 6:
          //   "valueDate" : "<date>" // R! Value of extension
          //   "valueDateTime" : "<dateTime>", // R! Value of extension
          //   "valueTime" : "<time>", // R! Value of extension
          //   "valueInstant" : "<instant>", // R! Value of extension
          //   "valueDecimal" : <decimal>, // R! Value of extension
          //   "valueInteger" : <integer>, // R! Value of extension
          // }
          case "minExclusive":
          case "minInclusive": // http://hl7.org/fhir/StructureDefinition/maxValue

          case "maxExclusive":
          case "maxInclusive":
            extValue = this._exportMinMax(dataType, value, valueKey, key);
            break;
          // http://hl7.org/fhir/StructureDefinition/minLength

          case "minLength":
            if (dataType === "ST" || dataType === "TX" || dataType === "URL" || dataType === "QTY") {
              extValue = {
                "url": "http://hl7.org/fhir/StructureDefinition/minLength",
                "valueInteger": parseInt(value)
              };
            }

            break;
          // maxLength, not an extension, directly on item

          case "maxLength":
            if (dataType === "ST" || dataType === "TX" || dataType === "URL" || dataType === "QTY") {
              targetItem.maxLength = parseInt(value);
            }

            break;
          // http://hl7.org/fhir/StructureDefinition/regex

          case "pattern":
            if (dataType === "ST" || dataType === "TX") {
              extValue = {
                "url": "http://hl7.org/fhir/StructureDefinition/regex",
                "valueString": value
              };
            }

            break;
        }

        if (extValue) {
          targetItem.extension.push(extValue);
        }
      }
    }
  },

  /**
   *  Processes settings for a list field with choices.
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in the LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *        The default is false.
   */
  _handleChoiceField: function (targetItem, item, noExtensions) {
    // an extension for the search url of the auto-complete field.
    if (item.externallyDefined) {
      this._handleExternallyDefined(targetItem, item);
    } // option, for answer list
    else if (item.answers && !item.answerValueSet) {
      // Make sure the answers did not come from answerExpression.
      if (!item._fhirExt || !item._fhirExt[this.fhirExtAnswerExp]) targetItem.answerOption = this._handleAnswers(item, noExtensions);
    } else if (item.answerValueSet) targetItem.answerValueSet = item.answerValueSet;
  },

  /**
   * Process an item's answer list
   * @param item an item in the LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *        The default is false.
   * @returns {Array}
   * @private
   */
  _handleAnswers: function (item, noExtensions) {
    var optionArray = [];

    for (var i = 0, iLen = item.answers.length; i < iLen; i++) {
      var answer = item.answers[i];
      var option = {}; // when option's values are Coding

      if (item.dataType === "CNE" || item.dataType === "CWE") {
        option.valueCoding = {};
        if (answer.code) option.valueCoding.code = answer.code;
        if (answer.text) option.valueCoding.display = answer.text;

        if (answer.system) {
          option.valueCoding.system = LForms.Util.getCodeSystem(answer.system);
        } // check default answers, coding only for now


        if (item.defaultAnswer && (item.dataType === 'CWE' || item.dataType === 'CNE')) {
          var defaultAnswers = this._answerRepeats(item) && Array.isArray(item.defaultAnswer) ? item.defaultAnswer : [item.defaultAnswer]; // go through each default value and set the initialSelected on the matching answer item

          for (var j = 0, jLen = defaultAnswers.length; j < jLen; j++) {
            if (LForms.Util.areTwoAnswersSame(defaultAnswers[j], answer, item)) {
              option.initialSelected = true;
            }
          }
        }
      } // when option's values are string, integer, date or time
      else if (item.dataType === "ST" || item.dataType === "INT" || item.dataType === "DT" || item.dataType === "TM") {
        var valueKey = this._getValueKeyByDataType("value", item);

        option[valueKey] = answer.text;
      } // needs an extension for label


      if (!noExtensions) {
        var ext = [];

        if (answer.label) {
          ext.push({
            "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix",
            "valueString": answer.label
          });
        }

        if (answer.score !== null && answer.score !== undefined) {
          ext.push({
            "url": "http://hl7.org/fhir/StructureDefinition/ordinalValue",
            "valueDecimal": parseFloat(answer.score)
          });
        }

        if (ext.length > 0) {
          option.extension = ext;
        }
      }

      optionArray.push(option);
    }

    return optionArray;
  },

  /**
   * Process default values
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  _handleInitialValues: function (targetItem, item) {
    if (item.defaultAnswer === null || item.defaultAnswer === undefined || item.defaultAnswer === '') {
      return;
    }

    var dataType = this._getAssumedDataTypeForExport(item); // item.defaultAnswer could be an array of multiple default values or a single value


    var defaultAnswers = this._answerRepeats(item) && Array.isArray(item.defaultAnswer) ? item.defaultAnswer : [item.defaultAnswer];

    var valueKey = this._getValueKeyByDataType("value", item);

    var answer = null;
    let initialValues = []; // go through each default value and handle it based on the data type.

    for (var i = 0, iLen = defaultAnswers.length; i < iLen; i++) {
      let defaultAnswer = defaultAnswers[i]; // for Coding, the default answer is partially handled in _handleAnswers(), where
      // initialSelected is set on the answer items.
      // Only the not-on-list values (string or Coding) in item.defaultAnswer is processed here

      if (dataType === "CWE" || dataType === 'CNE') {
        // go through each default value and to see if it is one of answers in the answers list
        let onList = false;

        if (item.answers) {
          for (var j = 0, jLen = item.answers.length; j < jLen; j++) {
            if (LForms.Util.areTwoAnswersSame(defaultAnswer, item.answers[j], item)) {
              onList = true;
              break;
            }
          }
        }

        if (!onList) {
          // valueString, free text
          if (typeof defaultAnswer === "string") {
            initialValues.push({
              "valueString": defaultAnswer
            });
          } // valueCoding, off list coding // TODO: not fully supported yet
          else if (typeof defaultAnswer === "object") {
            let valCoding = LForms.Util.deepCopy(defaultAnswer);

            if (valCoding.text) {
              valCoding.display = valCoding.text;
              delete valCoding.text;
            }

            if (valCoding.system) {
              valCoding.system = LForms.Util.getCodeSystem(valCoding.system);
            }

            initialValues.push(valCoding);
          }
        }
      } // for Quantity,
      else if (dataType === 'QTY') {
        // for now, handling only simple quantities without the comparators.
        answer = {};
        answer[valueKey] = this._makeQuantity(defaultAnswer, item.units);
        initialValues.push(answer);
      } // answerOption is date, time, integer or string
      else if (item.answers && (dataType === 'ST' || dataType === 'INT' || dataType === 'DT' || dataType === 'TM')) {
        initialValues.push({
          [valueKey]: defaultAnswer.text
        });
      } // for boolean, decimal, integer, date, dateTime, instant, time, string, uri
      else if (dataType === "INT" || dataType === "REAL" || dataType === "BL" || dataType === "TM" || dataType === "ST" || dataType === "TX" || dataType === "URL") {
        answer = {};
        answer[valueKey] = defaultAnswer;
        initialValues.push(answer);
      } else if (dataType === "DT" || dataType === "DTM") {
        // transform to FHIR date/datetime format.
        var dateValue = LForms.Util.stringToDate(defaultAnswer);

        if (dateValue) {
          dateValue = dataType === "DTM" ? LForms.Util.dateToDTMString(dateValue) : LForms.Util.dateToDTStringISO(dateValue);
          initialValues.push({
            [valueKey]: dateValue
          });
        } else {
          // LForms.Util.stringToDate returns null on invalid string
          // TODO: should save the errors or emitting events.
          console.error(defaultAnswer + ': Invalid date/datetime string as defaultAnswer for ' + item.questionCode);
        }
      } // no support for reference

    }

    if (initialValues.length > 0) {
      targetItem.initial = initialValues;
    }
  },

  /**
   * Process units list
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */
  _handleLFormsUnits: function (targetItem, item) {
    if (item.units && item.units.length > 0) {
      var dataType = this._getAssumedDataTypeForExport(item);

      if (dataType === "REAL" || dataType === "INT") {
        targetItem.extension.push({
          "url": this.fhirExtUrlUnit,
          // Datatype with multiple units is quantity. There is only one unit here.
          "valueCoding": this._createFhirUnitCoding(item.units[0])
        });
      } else if (dataType === 'QTY') {
        var defUnit = this._getDefaultUnit(item.units); // Skip if units are already set in default answer conversion.


        if (defUnit && defUnit.default && !(targetItem.initial && targetItem.initial.length > 0)) {
          // Use initial[].valueQuantity.unit to export the default unit.
          if (!targetItem.initial) {
            targetItem.initial = [];
          }

          var qty = {};

          this._setUnitAttributesToFhirQuantity(qty, defUnit);

          targetItem.initial.push({
            valueQuantity: qty
          });
        }

        for (var i = 0, iLen = item.units.length; i < iLen; i++) {
          var unit = item.units[i];
          var fhirUnitExt = {
            "url": this.fhirExtUrlUnitOption,
            "valueCoding": this._createFhirUnitCoding(unit)
          };
          targetItem.extension.push(fhirUnitExt);
        }
      }
    }
  },

  /**
   * Process skip logic
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @param source a LForms form object
   * @private
   */
  _handleSkipLogic: function (targetItem, item, source) {
    if (item.skipLogic) {
      var enableWhen = [];
      var rangeFound = false; // ignore "ANY", "ALL" on item.skipLogic.logic
      // ignore "show" on item.skipLogic.action

      for (var i = 0, iLen = item.skipLogic.conditions.length; i < iLen; i++) {
        var condition = item.skipLogic.conditions[i];

        var sourceItem = source._getSkipLogicSourceItem(item, condition.source);

        let enableWhenRules = this._createEnableWhenRulesForSkipLogicCondition(condition, sourceItem);

        if (enableWhenRules.length > 1) {
          rangeFound = true;
        }

        enableWhen = enableWhen.concat(enableWhenRules);
      }

      if (rangeFound && item.skipLogic.conditions.length > 1) {
        // TODO: Multiple skip logic conditons included with range specification is not supported with core FHIR.
        // Use SDC extensions with fhirpath expressions, but not all fhirpath functionality is
        // available yet. Revisit after implementation of variables, %resource etc. in fhirpath.
        throw new Error('Multiple skip logic conditons included with range specification is not supported yet.');
      }

      targetItem.enableWhen = enableWhen;

      if (item.skipLogic.logic === 'ALL' || rangeFound) {
        targetItem.enableBehavior = 'all';
      } else if (enableWhen.length > 1) {
        targetItem.enableBehavior = 'any';
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["default"] = (self);

/***/ }),
/* 97 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 *  Defines SDC export functions that are the same across the different FHIR
 *  versions.  The function takes the SDC namespace object defined in the sdc export
 *  code, and adds additional functions to it.
 */
function addCommonSDCExportFns(ns) {
  "use strict";

  var self = ns;
  /**
   * Convert LForms captured data to FHIR SDC QuestionnaireResponse
   * @param lfData a LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *  The default is false.
   * @param subject A local FHIR resource that is the subject of the output resource.
   *  If provided, a reference to this resource will be added to the output FHIR
   *  resource when applicable.
   * @returns {{}} a QuestionnaireResponse, or null if there is no valid QuestionnaireResponse.
   */

  self.convertLFormsToQuestionnaireResponse = function (lfData, noExtensions, subject) {
    var target = null;

    if (lfData) {
      var source = lfData.getFormData(true, true, true);

      if (!lfData._invalidData) {
        target = {};

        this._processRepeatingItemValues(source);

        this._setResponseFormLevelFields(target, source, noExtensions);

        if (source.items && Array.isArray(source.items)) {
          var tmp = this._processResponseItem(source, true);

          if (tmp && tmp.item && tmp.item.length) {
            target.item = tmp.item;
          }
        } // FHIR doesn't allow null values, strip them out.


        LForms.Util.pruneNulls(target);
        if (subject) target["subject"] = LForms.Util.createLocalFHIRReference(subject);

        this._commonExport._setVersionTag(target);
      }
    }

    return target;
  };
  /**
   * Convert LForms form definition to standard FHIR Questionnaire or FHIR SDC Questionnaire
   * @param lfData a LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *        The default is false.
   * @returns {{}}
   */


  self.convertLFormsToQuestionnaire = function (lfData, noExtensions) {
    var target = {};

    if (lfData) {
      var source = LForms.Util.deepCopy(lfData);

      if (!(source instanceof LForms.LFormsData)) {
        source = new LForms.LFormsData(source);
      }

      this._removeRepeatingItems(source);

      this._setFormLevelFields(target, source);

      if (source.items && Array.isArray(source.items)) {
        target.item = [];

        for (var i = 0, iLen = source.items.length; i < iLen; i++) {
          var newItem = this._processItem(source.items[i], source, noExtensions);

          target.item.push(newItem);
        }
      }
    } // FHIR doesn't allow null values, strip them out.


    LForms.Util.pruneNulls(target);

    this._commonExport._setVersionTag(target);

    return target;
  };
  /**
   * Process an item of the form
   * @param item an item in LForms form object
   * @param source a LForms form object
   * @param noExtensions a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *        The default is false.
   * @returns {{}}
   * @private
   */


  self._processItem = function (item, source, noExtensions) {
    var targetItem = {}; // type

    targetItem.type = this._getFhirDataType(item); // id (empty for new record)
    // code

    if (item.codeList && item.codeList.length > 0) {
      targetItem.code = item.codeList;
    } // extension


    targetItem.extension = item.extension || []; // later we delete if empty
    // required

    if (item._answerRequired === true || item._answerRequired === false) {
      targetItem.required = item._answerRequired;
    } // http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs


    if (targetItem.required) {
      var minOccurInt = parseInt(item.questionCardinality.min);

      if (minOccurInt > 1) {
        targetItem.extension.push({
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs",
          "valueInteger": minOccurInt
        });
      }
    } // question/answer repeats
    // http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs


    this._processQuestionAndAnswerCardinality(targetItem, item); // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl


    this._handleItemControl(targetItem, item); // check restrictions


    this._handleRestrictions(targetItem, item); // http://hl7.org/fhir/StructureDefinition/entryFormat
    // looks like tooltip, TBD


    if (item.isHiddenInDef) {
      targetItem.extension.push({
        url: "http://hl7.org/fhir/StructureDefinition/questionnaire-hidden",
        valueBoolean: true
      });
    } // linkId


    targetItem.linkId = item.linkId; // Text & prefix

    targetItem.text = item.question;

    if (item.prefix) {
      targetItem.prefix = item.prefix;
    } // Copy item extensions


    for (let extField of ['_prefix', '_text']) {
      let extFieldData = item['obj' + extField];
      if (extFieldData) targetItem[extField] = extFieldData;
    } // enableWhen


    if (item.skipLogic) {
      this._handleSkipLogic(targetItem, item, source);
    } // repeats, handled above
    // readonly, (editable)


    if (item.dataType !== "SECTION" && item.dataType !== "TITLE" && item.editable === "0") {
      targetItem.readOnly = true;
    }

    this._handleChoiceField(targetItem, item, noExtensions);

    this._handleTerminologyServer(targetItem, item); // initialValue, for default values


    this._handleInitialValues(targetItem, item); // add LForms Extension to units list. Process units after handling initial values.


    if (item.units) {
      this._handleLFormsUnits(targetItem, item);
    } // data control


    this._handleDataControl(targetItem, item);

    if (item.items && Array.isArray(item.items)) {
      targetItem.item = [];

      for (var i = 0, iLen = item.items.length; i < iLen; i++) {
        var newItem = this._processItem(item.items[i], source, noExtensions);

        targetItem.item.push(newItem);
      }
    } // the coding instruction is a sub item with a "display" type, and an item-control value as "help"
    // it is added as a sub item of this item.
    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl, for instructions


    if (item.codingInstructions) {
      let helpItem = {
        "text": item.codingInstructionsPlain ? item.codingInstructionsPlain : item.codingInstructions,
        "type": "display",
        "linkId": targetItem.linkId + "-help",
        "extension": [{
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl",
          "valueCodeableConcept": {
            "text": "Help-Button",
            "coding": [{
              "code": "help",
              "display": "Help-Button",
              "system": "http://hl7.org/fhir/questionnaire-item-control"
            }]
          }
        }]
      }; // format could be 'html' or 'text'

      if (item.codingInstructionsFormat === 'html') {
        // add a "_text" field to contain the extension for the string value in the 'text' field
        // see http://hl7.org/fhir/R4/json.html#primitive
        helpItem._text = {
          "extension": [{
            "url": "http://hl7.org/fhir/StructureDefinition/rendering-xhtml",
            "valueString": item.codingInstructions
          }]
        };
      }

      if (Array.isArray(targetItem.item)) {
        targetItem.item.push(helpItem);
      } else {
        targetItem.item = [helpItem];
      }
    }

    if (item.maxAttachmentSize) {
      var exts = targetItem.extension || (targetItem.extension = []);
      exts.push({
        url: self.fhirExtMaxSize,
        valueDecimal: item.maxAttachmentSize
      });
    }

    if (item.allowedAttachmentTypes) {
      exts = targetItem.extension || (targetItem.extension = []);

      for (let type of item.allowedAttachmentTypes) {
        exts.push({
          url: self.fhirExtMimeType,
          valueCode: type
        });
      }
    } // handle special constraints for "display" item


    this._handleSpecialConstraints(targetItem, item); // if no extensions are allowed or there is no extension, remove it


    if (noExtensions || targetItem.extension.length === 0) delete targetItem.extension;
    this.copyFields(item, targetItem, this.itemLevelIgnoredFields);
    return targetItem;
  };
  /**
   * Process the LForms questionCardinality and answerCardinality into FHIR.
   * @param targetItem an item in Questionnaire
   * @param item a LForms item
   */


  self._processQuestionAndAnswerCardinality = function (targetItem, item) {
    var maxOccurs = 0;
    var qCard = item.questionCardinality,
        aCard = item.answerCardinality;
    var qCardMax = qCard && qCard.max !== undefined ? qCard.max : null;
    var aCardMax = aCard && aCard.max !== undefined ? aCard.max : null; // unlimited repeats, no need to set maxOccurs

    if (qCardMax === "*" || aCardMax === "*") {
      if (item.dataType !== "TITLE") {
        targetItem.repeats = true;
      }
    } // not unlimited repeats
    else {
      var intQCardMax = parseInt(qCardMax),
          intACardMax = parseInt(aCardMax); // has a maxOcurrs value

      if (intQCardMax > 1 || intACardMax > 1) {
        if (item.dataType !== "TITLE") {
          targetItem.repeats = true; // get the maxOccurs value

          if (!isNaN(intQCardMax) && !isNaN(intACardMax)) {
            maxOccurs = Math.max(intQCardMax, intACardMax);
          } else if (!isNaN(intQCardMax)) {
            maxOccurs = intQCardMax;
          } else if (!isNaN(intACardMax)) {
            maxOccurs = intACardMax;
          }

          if (maxOccurs > 1) {
            targetItem.extension.push({
              "url": self.fhirExtUrlCardinalityMax,
              "valueInteger": maxOccurs
            });
          }
        }
      }
    }
  };
  /**
   * Process an item's externally defined answer list
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in the LForms form object
   * @returns {*}
   * @private
   */


  self._handleExternallyDefined = function (targetItem, item) {
    if (item.externallyDefined) {
      targetItem.extension.push({
        "url": self.fhirExtUrlExternallyDefined,
        "valueUri": item.externallyDefined
      });
    }
  };
  /**
   * Process an item's data control
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in the LForms form object
   * @returns {*}
   * @private
   */


  self._handleDataControl = function (targetItem, item) {
    if (item.dataControl) {
      targetItem.extension.push({
        "url": "http://lhcforms.nlm.nih.gov/fhirExt/dataControl",
        "valueString": JSON.stringify(item.dataControl)
      });
    }
  };
  /**
   * Remove repeating items in a form data object
   * @param source a LForms form data object
   * @private
   */


  self._removeRepeatingItems = function (source) {
    if (source.items && Array.isArray(source.items)) {
      for (var i = source.items.length - 1; i >= 0; i--) {
        // if it is a repeating item, whose _id is not 1
        if (source.items[i]._id > 1) {
          source.items.splice(i, 1);
        } else {
          this._removeRepeatingItems(source.items[i]);
        }
      }
    }
  };
  /**
   * Set form level attributes
   * @param target a Questionnaire object
   * @param source a LForms form object
   * @private
   */


  self._setFormLevelFields = function (target, source) {
    this.copyFields(source, target, this.formLevelFields); // Handle title and name.  In LForms, "name" is the "title", but FHIR
    // defines both.

    target.name = source.shortName; // computer friendly

    target.title = source.name; // Handle extensions on title

    if (source.obj_title) target._title = source.obj_title;
    target.code = source.codeList; // resourceType

    target.resourceType = "Questionnaire";
    target.status = target.status ? target.status : "draft"; // handle lforms copyright

    if (source.copyrightNotice) {
      target.copyright = source.copyrightNotice;
    } // meta


    this._handleMeta(target);
  };
  /**
   * Handle Questionnaire.meta field
   */


  self._handleMeta = function (targetFhirQ) {
    targetFhirQ.meta = targetFhirQ.meta ? targetFhirQ.meta : {}; // Handle profiles

    this._handleMetaProfile(targetFhirQ.meta);
  };
  /**
   * Handle Questionnaire.meta field
   *
   * Follows these rules:
   * -------------
   * 1) For new questionnaires, we just export with the standard profile
   * 2) When we import and questionnaire which had meta.profile set, look for the highest version of
   *      FHIR listed in meta.profile.
   * 3) User will (optionally) be able to say which version of FHIR they want when uploading a file
   *      (or using the lforms API)
   * 4) When we export a questionnaire that we imported and which had meta.profile set,
   *      we will set the standard profile for that FHIR version, and remove known conflicting profile URIs.
   *  ------------
   * @param meta - The target questionnaire.meta to update.
   * @private
   */


  self._handleMetaProfile = function (meta) {
    const thisVersion = LForms.Util.detectFHIRVersionFromProfiles([this.stdQProfile]);
    const retainedProfiles = [];

    if (meta.profile?.length > 0) {
      for (let i = 0; i < meta.profile.length; i++) {
        const ver = LForms.Util.detectFHIRVersionFromProfiles([meta.profile[i]]);

        if (!ver || ver === thisVersion && meta.profile[i] !== this.stdQProfile) {
          // Keep profiles of this version and unknown. Others are conflicting, discard them.
          retainedProfiles.push(meta.profile[i]);
        }
      }
    }

    retainedProfiles.push(this.stdQProfile);
    meta.profile = retainedProfiles;
  };
  /**
   * Process itemControl based on LForms item's answerLayout and questionLayout
   * @param targetItem an item in FHIR SDC Questionnaire object
   * @param item an item in LForms form object
   * @private
   */


  self._handleItemControl = function (targetItem, item) {
    // http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl
    var itemControlType = "";
    var itemControlDisplay, answerChoiceOrientation; // Fly-over, Table, Checkbox, Combo-box, Lookup

    if (!LForms.jQuery.isEmptyObject(item.displayControl)) {
      var dataType = this._getAssumedDataTypeForExport(item); // for answers


      if (item.displayControl.answerLayout && (item.dataType === "CNE" || item.dataType === "CWE" || item.answers && (item.dataType === "ST" || item.dataType === "INT" || item.dataType === "DT" || item.dataType === "TM"))) {
        // search field
        if (item.externallyDefined || item.answerValueSet && item.isSearchAutocomplete) {
          itemControlType = "autocomplete";
          itemControlDisplay = "Auto-complete";
        } // prefetch list
        // combo-box
        else if (item.displayControl.answerLayout.type === "COMBO_BOX") {
          itemControlType = "drop-down";
          itemControlDisplay = "Drop down";
        } // radio or checkbox
        else if (item.displayControl.answerLayout.type === "RADIO_CHECKBOX") {
          if (item.answerCardinality && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1)) {
            itemControlType = "check-box";
            itemControlDisplay = "Check-box";
          } else {
            itemControlType = "radio-button";
            itemControlDisplay = "Radio Button";
          } // answer choice orientation


          if (item.displayControl.answerLayout.columns === "0") {
            answerChoiceOrientation = "horizontal";
          } else if (item.displayControl.answerLayout.columns === "1") {
            answerChoiceOrientation = "vertical";
          }
        }
      } // for section item
      else if (item.displayControl.questionLayout && dataType === "SECTION") {
        if (item.displayControl.questionLayout === "horizontal") {
          itemControlType = "gtable"; // Not in STU3, but the binding is extensible, so we can use it

          itemControlDisplay = "Group Table";
        } else if (item.displayControl.questionLayout === "matrix") {
          itemControlType = "table";
          itemControlDisplay = "Vertical Answer Table";
        } // else {
        //   itemControlType = "List";
        // }

      }

      if (itemControlType) {
        targetItem.extension.push({
          "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl",
          "valueCodeableConcept": {
            "coding": [{
              //"system" : "<uri>", // Identity of the terminology system
              //"version" : "<string>", // Version of the system - if relevant
              //"code" : "<code>", // Symbol in syntax defined by the system
              //"display" : "<string>", // Representation defined by the system
              //"userSelected" : <boolean> // If this coding was chosen directly by the user
              "system": "http://hl7.org/fhir/questionnaire-item-control",
              "code": itemControlType,
              "display": itemControlDisplay
            }],
            "text": itemControlDisplay || itemControlType
          }
        }); // answer choice orientation

        if (answerChoiceOrientation) {
          targetItem.extension.push({
            "url": "http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation",
            "valueCode": answerChoiceOrientation
          });
        }
      }
    }
  };
  /**
   * Process an item's terminology server setting.
   * @param targetItem a QuestionnaireResponse object
   * @param item an item in the LForms form object
   * @returns {*}
   * @private
   */


  self._handleTerminologyServer = function (targetItem, item) {
    if (item.terminologyServer) {
      targetItem.extension.push({
        "url": self.fhirExtTerminologyServer,
        "valueUrl": item.terminologyServer
      });
    }
  };
  /**
   * Convert LForms data type to FHIR SDC data type
   * @param item an item in the LForms form object
   * @returns {string}
   * @private
   */


  self._getFhirDataType = function (item) {
    var dataType = this._getAssumedDataTypeForExport(item);

    var type = this._lformsTypesToFHIRTypes[dataType]; // default is string

    if (!type) {
      type = 'string';
    }

    return type;
  };
  /**
   * Determine how an item's data type should be for export.
    If number type has multiple units, change it to quantity type. In such a case,
   multiple units are converted to quesionnaire-unitOption extension and the default unit
   would go into initial.valueQuantity.unit.
   For single unit numbers, use the same type, whose unit will be in questionnaire-unit extension.
    * @param item an item in the LForms form object
   * @returns {string} dataType - Data type in lforms
   * @private
   */


  self._getAssumedDataTypeForExport = function (item) {
    var dataType = item.dataType;

    if ((item.dataType === 'REAL' || item.dataType === 'INT') && item.units && item.units.length > 1) {
      dataType = 'QTY';
    }

    return dataType;
  };
  /**
   * Make a FHIR Quantity for the given value and unit info.
   * @param value optional, must be an integer or decimal
   * @param itemUnit optional, lform data item.unit (that has a name property)
   * @param unitSystem optional, overrides any system in itemUnit.
   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).
   * @private
   */


  self._makeValueQuantity = function (value, itemUnit, unitSystem) {
    let fhirQuantity = {};
    let floatValue = parseFloat(value);

    if (!isNaN(floatValue)) {
      fhirQuantity.value = floatValue;
    }

    if (itemUnit) {
      self._setUnitAttributesToFhirQuantity(fhirQuantity, itemUnit);

      if (unitSystem) {
        fhirQuantity.system = unitSystem;
      }
    }

    return Object.keys(fhirQuantity).length > 0 ? fhirQuantity : null;
  };
  /**
   * Make a FHIR Quantity for the given value and unit info.
   * @param value required, must be an integer or decimal
   * @param itemUnits optional, lform data item.units (An array of units)
   * @param unitSystem optional.
   * @return a FHIR quantity or null IFF the given value is not a number (parseFloat() returns NaN).
   * @private
   */


  self._makeQuantity = function (value, itemUnits, unitSystem) {
    var defaultUnit = this._getDefaultUnit(itemUnits);

    return this._makeValueQuantity(value, defaultUnit, unitSystem);
  };
  /**
   * Pick a default unit if found, otherwise return first one as default. Will return
   * null, if passed with empty list.
   * @param lformsUnits - Array of lforms units i.e with {name, default}
   * @returns {*} Return lforms unit if found otherwise null.
   * @private
   */


  self._getDefaultUnit = function (lformsUnits) {
    if (!lformsUnits || lformsUnits.length === 0) {
      return null;
    }

    var ret = null;

    for (var i = 0; i < lformsUnits.length; i++) {
      if (lformsUnits[i].default) {
        ret = lformsUnits[i];
        break;
      }
    }

    if (!ret) {
      ret = lformsUnits[0];
    }

    return ret;
  };
  /**
   * Create a key from data type to be used in a hash
   * @param prefix a prefix to be added to the key
   * @param item a LForms item
   * @returns {*}
   * @private
   */


  self._getValueKeyByDataType = function (prefix, item) {
    // prefix could be 'value', 'initial', 'answer'
    if (!prefix) {
      prefix = "value";
    }

    var fhirType = this._getFhirDataType(item);

    var dataType = fhirType === 'quantity' ? 'QTY' : item.dataType;
    var valueKey = this._lformsTypesToFHIRFields[dataType];
    return prefix + valueKey;
  };
  /**
   * Convert the minInclusive/minExclusive, maxInclusive/maxExclusive to FHIR. See the
   * the function _handleRestrictions() in sdc-export.js for more details on the context.
   * @param dataType Lforms data type, currently supporting DT, DTM, TM, REAL, and INT.
   * @param value the value (in the lforms system, either a number or a string).
   * @param valueKey the valueKey in FHIR minValue/maxValue extension (e.g., valueInteger)
   * @param minMaxKey must be one of minInclusive, minExclusive, maxInclusive, maxExclusive
   * @return The FHIR extension element. Specifically, undefined is returned if:
   *         - the given value is null or undefined, or
   *         - the dataType is not one of those listed above, or
   *         - the minMaxKey is not one of those listed above
   * @private
   */


  self._MIN_MAX_TYPES = ['DT', 'DTM', 'TM', 'REAL', 'INT'].reduce((map, t) => {
    map[t] = t;
    return map;
  }, {});
  self._MIN_MAX_KEYS = ['minExclusive', 'minInclusive', 'maxExclusive', 'maxInclusive'].reduce((map, t) => {
    map[t] = t;
    return map;
  }, {});

  self._exportMinMax = function (dataType, value, valueKey, minMaxKey) {
    if (value === null || value === undefined || !self._MIN_MAX_TYPES[dataType] || !self._MIN_MAX_KEYS[minMaxKey]) {
      return undefined;
    }

    var isoDateStr = dataType === "DT" || dataType === "DTM" ? new Date(value).toISOString() : dataType == "TM" ? new Date('1970-01-01T' + value + 'Z').toISOString() : null;
    var fhirValue = dataType === "DT" ? isoDateStr.substring(0, 10) : dataType === "DTM" ? isoDateStr : dataType === "TM" ? isoDateStr.substring(11, isoDateStr.length - 1) : dataType === "REAL" ? parseFloat(value) : parseInt(value);
    var fhirExtUrl = minMaxKey.indexOf('min') === 0 ? 'http://hl7.org/fhir/StructureDefinition/minValue' : 'http://hl7.org/fhir/StructureDefinition/maxValue';
    return {
      url: fhirExtUrl,
      [valueKey]: fhirValue
    };
  }; // known source data types (besides CNE/CWE) in skip logic export handling,
  // see _createEnableWhenRulesForSkipLogicCondition below


  self._skipLogicValueDataTypes = ["BL", "REAL", "INT", 'QTY', "DT", "DTM", "TM", "ST", "TX", "URL"].reduce((map, type) => {
    map[type] = type;
    return map;
  }, {});
  /**
   * @param skipLogicCondition - Lforms skip logic condition object
   * @param sourceItem - Skip logic source item in lforms.
   * @return {Array} FHIR enableWhen array
   * @private
   */

  self._createEnableWhenRulesForSkipLogicCondition = function (skipLogicCondition, sourceItem) {
    // dataTypes:
    // boolean, decimal, integer, date, dateTime, instant, time, string, uri,
    // Attachment, Coding, Quantity, Reference(Resource)
    let sourceDataType = this._getAssumedDataTypeForExport(sourceItem);

    let sourceValueKey = this._getValueKeyByDataType("answer", sourceItem);

    let enableWhenRules = []; // Per lforms spec, the trigger keys can be:
    // exists, value, minExclusive, minInclusive, maxExclusive, maxInclusive

    Object.keys(skipLogicCondition.trigger).forEach(function (key) {
      let operator = self._operatorMapping[key];
      let triggerValue = skipLogicCondition.trigger[key];

      if (!operator || triggerValue !== 0 && triggerValue !== false && !triggerValue) {
        throw new Error('Invalid lforms skip logic trigger: ' + JSON.stringify(skipLogicCondition.trigger, null, 4));
      }

      let rule = null;

      if (operator === 'exists') {
        rule = {
          answerBoolean: triggerValue
        };
      } // for Coding
      // multiple selections, item.value is an array
      // NO support of multiple selections in FHIR SDC, just pick one
      else if (sourceDataType === 'CWE' || sourceDataType === 'CNE') {
        let answerCoding = self._copyTriggerCoding(triggerValue, null, true);

        if (!answerCoding) {
          throw new Error('Invalid CNE/CWE trigger, key=' + key + '; value=' + triggerValue);
        }

        rule = {
          answerCoding: answerCoding
        };
      } else if (sourceDataType && self._skipLogicValueDataTypes[sourceDataType]) {
        let answer = triggerValue;

        if (sourceValueKey === 'answerQuantity') {
          answer = self._makeQuantity(answer, sourceItem.units);
        }

        if (answer === 0 || answer === false || answer) {
          rule = {
            [sourceValueKey]: answer
          };
        } else {
          throw new Error('Invalid value for trigger ' + key + ': ' + triggerValue);
        }
      } else {
        throw new Error('Unsupported data type for skip logic export: ' + sourceDataType);
      }

      rule.question = sourceItem.linkId;
      rule.operator = operator;
      enableWhenRules.push(rule);
    });
    return enableWhenRules;
  };
  /**
   * Set form level attribute
   * @param target a QuestionnaireResponse object
   * @param noExtensions  a flag that a standard FHIR Questionnaire is to be created without any extensions.
   *        The default is false.
   * @param source a LForms form object
    * @private
   */


  self._setResponseFormLevelFields = function (target, source, noExtensions) {
    // resourceType
    target.resourceType = "QuestionnaireResponse"; // meta

    var profile = noExtensions ? this.stdQRProfile : this.QRProfile;
    target.meta = target.meta ? target.meta : {};
    target.meta.profile = target.meta.profile ? target.meta.profile : [profile]; // "identifier": - not including identifier in QuestionnaireResponse per LF-1183
    //target.identifier = {
    //  "system": LForms.Util.getCodeSystem(source.codeSystem),
    //  "value": source.code
    //};
    // status, required
    // "in-progress", "completed", "amended"

    target.status = "completed"; // authored, required

    target.authored = LForms.Util.dateToDTMString(new Date()); // questionnaire , required
    // We do not have the ID at this point, so leave it unset for now.  Note
    // that the fomat has also changed from Reference to canonical in R4.

    /*
    target.questionnaire = {
      // questionnaireId should be an id of a related existing questionnaire resource stored in the server
      "reference": "Questionnaire/{{questionnaireId}}"
    };
    */
  };
  /**
   * Set unit attributes to a given FHIR quantity.
   *
   * @param fhirQuantity - FHIR Quantity object
   * @param lfUnit - Lforms unit, which includes name, code and system.
   * @private
   */


  self._setUnitAttributesToFhirQuantity = function (fhirQuantity, lfUnit) {
    if (fhirQuantity && lfUnit) {
      if (lfUnit.name) {
        fhirQuantity.unit = lfUnit.name;
      }

      if (lfUnit.code) {
        fhirQuantity.code = lfUnit.code;
      } // Unit system is optional. It was using a default system before,
      // Now we have an defined system field, read it from data and
      // not assume a default.


      if (lfUnit.system) {
        fhirQuantity.system = lfUnit.system;
      }
    }
  };
  /**
   * Create a FHIR coding object for a unit.
   *
   * @param lfUnit - Lforms unit, which includes name, code and system.
   * @returns FHIR coding object
   * @private
   */


  self._createFhirUnitCoding = function (lfUnit) {
    var ret = null;

    if (lfUnit) {
      ret = {};

      if (lfUnit.code) {
        ret.code = lfUnit.code;
      }

      if (lfUnit.name) {
        ret.display = lfUnit.name;
      }

      if (lfUnit.system) {
        ret.system = lfUnit.system;
      }
    }

    return ret;
  };
  /**
   * Converting the given item's value to FHIR QuestionaireResponse.answer (an array).
   * This is almost straightly refactored out of the original function self._handleAnswerValues.
   * This function only looks at the item value itself and not its sub-items, if any.
   * Here are the details for a single value's conversion (to an element in the returned answer array)
   * - For item data type quantity (QTY), a valueQuantity answer element will be created IF
   *   either (or both) item value or item unit is available.
   * - For item data types boolean, decimal, integer, date, dateTime, instant, time, string, attachment, and url,
   *   it will be converted to a FHIR value{TYPE} entry if the value is not null, not undefined, and not
   *   an empty string.
   * - For CNE and CWE, a valueCoding entry is created IF at least one of the item value's code, text, or system
   *   is available
   * - No answer entry will be created in all other cases, e.g., for types reference, title, section, etc.
   * @param item the item whose value is to be converted
   * @return the converted FHIR QuestionnaireResponse answer (an array), or null if the value is not converted -
   *         see the function description above for more details.
   * @private
   */


  self._lfItemValueToFhirAnswer = function (item) {
    // item could have an empty value if its sub-item has a value
    if (item.value === undefined || item.value === null || item.value === '') return null;

    var dataType = this._getAssumedDataTypeForExport(item);

    var values = this._answerRepeats(item) ? item.value : [item.value];
    var answers = [];

    for (var i = 0; i < values.length; ++i) {
      var itemValue = values[i];

      if (itemValue !== undefined && itemValue !== null && itemValue !== '') {
        var answer = null; // for Coding

        if (dataType === 'CWE' || dataType === 'CNE') {
          // for CWE, the value could be string if it is a user typed, not-on-list value
          if (dataType === 'CWE' && typeof itemValue === 'string') {
            answer = {
              "valueString": itemValue
            };
          } else if (!LForms.jQuery.isEmptyObject(itemValue)) {
            var answerCoding = this._setIfHasValue(null, 'system', LForms.Util.getCodeSystem(itemValue.system));

            answerCoding = this._setIfHasValue(answerCoding, 'code', itemValue.code);
            answerCoding = this._setIfHasValue(answerCoding, 'display', itemValue.text);
            answer = this._setIfHasValue(null, 'valueCoding', answerCoding);
          }
        } else if (item.answers && (dataType === 'INT' || dataType === 'ST' || dataType === 'DT' || dataType === 'TM')) {
          var valueKey = this._getValueKeyByDataType("value", item);

          answer = {
            [valueKey]: itemValue.text
          };
        } // for Quantity
        else if (dataType === "QTY") {
          // For now, handling only simple quantities without the comparators.
          // [{
          //   // from Element: extension
          //   "value" : <decimal>, // Numerical value (with implicit precision)
          //   "comparator" : "<code>", // < | <= | >= | > - how to understand the value
          //   "unit" : "<string>", // Unit representation
          //   "system" : "<uri>", // Code System that defines coded unit form
          //   "code" : "<code>" // Coded form of the unit
          // }]
          answer = this._setIfHasValue(null, 'valueQuantity', this._makeValueQuantity(itemValue, item.unit));
        } // for boolean, decimal, integer, date, dateTime, instant, time, string, uri, attachment
        else if (this._lformsTypesToFHIRFields[dataType]) {
          var valueKey = this._getValueKeyByDataType("value", item);

          answer = {
            [valueKey]: itemValue
          };
        }
      }

      if (answer !== null) {
        answers.push(answer);
      }
    }

    return answers.length === 0 ? null : answers;
  };
  /**
   * Check if an lform item has sub-items, that is, having an "items" field whose value is an array with non-zero length.
   * @param item the item to be checked for the presense of sub-items.
   * @return {*|boolean} true if the item has sub-items, false otherwise.
   * @private
   */


  self._lfHasSubItems = function (item) {
    return item && item.items && Array.isArray(item.items) && item.items.length > 0;
  };
  /**
   * Process an item of the form or the form itself - if it's the form itself, the form-level
   * properties will not be set here and will need to be managed outside of this function.
   * If the lforms item is repeatable, this function handles one particular occurrence of the item.
   * @param lfItem an item in LForms form object, or the form object itself
   * @param isForm optional, default false. If true, the given item is the form object itself.
   * @returns {{}} the converted FHIR item
   * @private
   */


  self._processResponseItem = function (lfItem, isForm) {
    if (isForm && typeof isForm !== 'boolean') {
      // just in case some are invoking it the old way.
      throw new Error('_processResponseItem function signature has been changed, please check/fix.');
    }

    var targetItem = isForm || lfItem.dataType === 'TITLE' ? {} : {
      linkId: lfItem.linkId,
      text: lfItem.question
    }; // just handle/convert the current item's value, no-recursion to sub-items at this step.

    if (!isForm && lfItem.dataType !== 'TITLE' && lfItem.dataType !== 'SECTION') {
      this._setIfHasValue(targetItem, 'answer', this._lfItemValueToFhirAnswer(lfItem));
    }

    if (this._lfHasSubItems(lfItem)) {
      var fhirItems = [];

      for (var i = 0; i < lfItem.items.length; ++i) {
        var lfSubItem = lfItem.items[i];

        if (!lfSubItem._isProcessed) {
          var linkId = lfSubItem.linkId;
          var repeats = lfItem._repeatingItems && lfItem._repeatingItems[linkId];

          if (repeats) {
            // Can only be questions here per _processRepeatingItemValues
            let fhirItem = {
              // one FHIR item for all repeats with the same linkId
              linkId: linkId,
              text: lfSubItem.question,
              answer: []
            };

            for (var rpt = 0; rpt < repeats.length; ++rpt) {
              var rptItem = repeats[rpt];

              var tmpFhirItem = this._processResponseItem(rptItem);

              if (tmpFhirItem.answer) {
                // TODO: not sure how to handle cases when both (lforms) question and answer repeat.
                // For now, just put all the answers from question and answer repeats into the answer (array).
                Array.prototype.push.apply(fhirItem.answer, tmpFhirItem.answer);
              }

              rptItem._isProcessed = true;
            }

            fhirItems.push(fhirItem);
            delete lfItem._repeatingItems[linkId]; // cleanup, no longer needed
          } else {
            let fhirItem = this._processResponseItem(lfSubItem);

            fhirItems.push(fhirItem);
          }
        }

        if (lfSubItem._isProcessed) {
          delete lfSubItem._isProcessed; // cleanup, no longer needed
        }
      }

      if (fhirItems.length > 0) {
        if (!isForm && lfItem.dataType !== 'SECTION') {
          // Question repeat is handled at the "parent level"; TODO: not sure how to handle answer repeat here,
          // assuming it isn't possible for an item to have answer repeat and sub-items at the same time.
          targetItem.answer = targetItem.answer || [];
          targetItem.answer[0] = targetItem.answer[0] || {};
          targetItem.answer[0].item = fhirItems;
        } else {
          targetItem.item = fhirItems;
        }
      }
    }

    return targetItem;
  };
  /**
   * Group values of the questions that have the same linkId
   * @param item an item in the LForms form object or a form item object
   * @private
   *
   */


  self._processRepeatingItemValues = function (item) {
    if (item.items) {
      for (var i = 0, iLen = item.items.length; i < iLen; i++) {
        var subItem = item.items[i]; // if it is a question and it repeats

        if (subItem.dataType !== 'TITLE' && subItem.dataType !== 'SECTION' && this._questionRepeats(subItem)) {
          var linkId = subItem.linkId;
          item._repeatingItems = item._repeatingItems || {};
          item._repeatingItems[linkId] = item._repeatingItems[linkId] || [];

          item._repeatingItems[linkId].push(subItem);
        } // if it's a section or a question that has children items


        if (this._lfHasSubItems(subItem)) {
          this._processRepeatingItemValues(subItem);
        }
      }
    }
  };
  /**
   * Get the extract value for the item or the closest parent
   * @param item an item in Questionnaire
   */


  self._getExtractValue = function (item) {
    let currentItem = item;

    while (true) {
      if (currentItem._fhirExt && currentItem._fhirExt[this.fhirExtObsExtract]) {
        return currentItem._fhirExt[this.fhirExtObsExtract][0].valueBoolean;
      } else if (!currentItem._parentItem) {
        return false;
      }

      currentItem = currentItem._parentItem;
    }
  };
  /**
   * Check if the item has a value
   * @param {*} item  an item in lforms with attritues set by lforms
   * @returns {boolean}
   */


  self._hasItemValue = function (item) {
    // not a group item, or a display item
    // not hidden by skip logic
    // has values
    return item.dataType !== "SECTION" && item.dataType !== "TITLE" && item._skipLogicStatus !== "target-disabled" && !LForms.Util.isItemValueEmpty(item.value) ? true : false;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (addCommonSDCExportFns);

/***/ }),
/* 98 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * A package to handle conversion from FHIR SDC Questionnaire to LForms
 *
 * It provides the following functions:
 * convertQuestionnaireToLForms()
 * -- Convert FHIR SDC QuestionnaireResponse data into corresponding LForms data
 * mergeQuestionnaireResponseToLForms()  (defined in sdc-import-common.js)
 * -- Merge FHIR SDC QuestionnaireResponse data into corresponding LForms data
 */
function addSDCImportFns(ns) {
  "use strict";

  var self = ns; // FHIR extension urls

  self.fhirExtUrlOptionScore = "http://hl7.org/fhir/StructureDefinition/ordinalValue";
  self.fhirExtUrlValueSetScore = self.fhirExtUrlOptionScore;
  /**
   * Extract contained VS (if any) from the given questionnaire resource object.
   * @param questionnaire the FHIR questionnaire resource object
   * @return when there are contained value sets, returns a hash from the ValueSet url to the answers
   *         options object, which, in turn, is a hash with 4 entries:
   *         - "answers" is the list of LF answers converted from the value set.
   *         - "systems" is the list of code systems for each answer item; and
   *         returns undefined if no contained value set is present.
   * @private
   */

  self._extractContainedVS = function (questionnaire) {
    var answersVS;

    if (questionnaire.contained && questionnaire.contained.length > 0) {
      answersVS = {};
      questionnaire.contained.forEach(function (vs) {
        if (vs.resourceType === 'ValueSet') {
          var answers = self.answersFromVS(vs);
          if (!answers) answers = []; // continuing with previous default; not sure if needed
          // Support both id and url based lookup - we are only supporting our non-standard url approach
          // for backward-compatibility with previous LForms versions. For more details on FHIR contained
          // resource references, please see "http://hl7.org/fhir/references.html#canonical-fragments"

          var lfVS = {
            answers: answers
          };

          if (vs.id) {
            answersVS['#' + vs.id] = lfVS;
          }

          if (vs.url) {
            answersVS[vs.url] = lfVS;
          }
        }
      });
    }

    return answersVS;
  };
  /**
   * Parse questionnaire object for skip logic information
   *
   * @param lfItem {object} - LForms item object to assign the skip logic
   * @param qItem {object} - Questionnaire item object
   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.
   * @private
   */


  self._processSkipLogic = function (lfItem, qItem, linkIdItemMap) {
    if (qItem.enableWhen) {
      lfItem.skipLogic = {
        conditions: [],
        action: 'show'
      };

      for (var i = 0; i < qItem.enableWhen.length; i++) {
        var dataType = self._getDataType(linkIdItemMap[qItem.enableWhen[i].question]);

        var condition = {
          source: qItem.enableWhen[i].question,
          trigger: {}
        };

        var answer = self._getFHIRValueWithPrefixKey(qItem.enableWhen[i], /^answer/);

        var opMapping = self._operatorMapping[qItem.enableWhen[i].operator];

        if (!opMapping) {
          throw new Error('Unable to map FHIR enableWhen operator: ' + qItem.enableWhen[i].operator);
        }

        if (opMapping === 'exists') {
          condition.trigger.exists = answer; // boolean value here regardless of data type
        } else if (dataType === 'CWE' || dataType === 'CNE') {
          condition.trigger[opMapping] = self._copyTriggerCoding(answer, null, false);
        } else if (dataType === 'QTY') {
          condition.trigger[opMapping] = answer.value;
        } else {
          condition.trigger[opMapping] = answer;
        }

        lfItem.skipLogic.conditions.push(condition);
      }

      if (qItem.enableBehavior) {
        lfItem.skipLogic.logic = qItem.enableBehavior.toUpperCase();
      }
    }
  };
  /**
   * Parse questionnaire item for answers list
   *
   * @param lfItem {object} - LForms item object to assign answer list
   * @param qItem {object} - Questionnaire item object
   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details
   * @private
   */


  self._processAnswers = function (lfItem, qItem, containedVS) {
    if (qItem.answerOption) {
      lfItem.answers = [];

      for (var i = 0; i < qItem.answerOption.length; i++) {
        var answer = {};
        var option = qItem.answerOption[i];
        var optionKey = Object.keys(option).filter(function (key) {
          return key.indexOf('value') === 0;
        });

        if (optionKey && optionKey.length > 0) {
          // For a given answerOption, only one value[x] is expectedOnly one kind of value[x] is expected
          if (optionKey[0] === 'valueCoding') {
            if (option[optionKey[0]].code !== undefined) answer.code = option[optionKey[0]].code;
            if (option[optionKey[0]].display !== undefined) answer.text = option[optionKey[0]].display; // TBD- Lforms has answer code system at item level, expects all options to have one code system!

            if (option[optionKey[0]].system !== undefined) {
              answer.system = option[optionKey[0]].system;
            }
          } else if (optionKey[0] === 'valueString' || optionKey[0] === 'valueDate' || optionKey[0] === 'valueTime') {
            answer.text = option[optionKey[0]];
          } else if (optionKey[0] === 'valueInteger') {
            answer.text = parseInt(option[optionKey[0]]);
          } else {
            throw new Error('Unable to handle data type in answerOption: ' + optionKey[0]);
          }

          var label = LForms.Util.findObjectInArray(option.extension, 'url', self.fhirExtUrlOptionPrefix);

          if (label) {
            answer.label = label.valueString;
          }

          var score = LForms.Util.findObjectInArray(option.extension, 'url', self.fhirExtUrlOptionScore); // Look for argonaut extension.

          score = !score ? LForms.Util.findObjectInArray(option.extension, 'url', self.argonautExtUrlExtensionScore) : score;

          if (score) {
            answer.score = score.valueDecimal.toString();
          }
        }

        lfItem.answers.push(answer);
      }
    } else if (qItem.answerValueSet) {
      if (containedVS) var vs = containedVS[qItem.answerValueSet];

      if (vs) {
        // contained
        lfItem.answers = vs.answers;
      } else lfItem.answerValueSet = qItem.answerValueSet; // a URI for a ValueSet

    }
  };
  /**
   * Parse questionnaire item for question cardinality and answer cardinality
   *
   * @param lfItem {object} - LForms item object to assign question cardinality
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processFHIRQuestionAndAnswerCardinality = function (lfItem, qItem) {
    var min = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMin);
    var max = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlCardinalityMax);
    var repeats = qItem.repeats;
    var required = qItem.required;
    var answerCardinality, questionCardinality; // CNE/CWE, repeats handled by autocompleter with multiple answers in one question

    if (lfItem.dataType === 'CNE' || lfItem.dataType === 'CWE' || qItem.answerOption && (lfItem.dataType === 'ST' || lfItem.dataType === 'INT' || lfItem.dataType === 'DT' || lfItem.dataType === 'TM')) {
      if (repeats) {
        answerCardinality = max ? {
          max: max.valueInteger.toString()
        } : {
          max: "*"
        };
      } else {
        answerCardinality = {
          max: "1"
        };
      }

      if (required) {
        answerCardinality.min = min ? min.valueInteger.toString() : "1";
      } else {
        answerCardinality.min = "0";
      }
    } // no answerOptiopn, question repeats
    else {
      // repeats
      if (repeats) {
        questionCardinality = max ? {
          max: max.valueInteger.toString()
        } : {
          max: "*"
        };
      } else {
        questionCardinality = {
          max: "1"
        };
      } // required


      if (required) {
        questionCardinality.min = min ? min.valueInteger.toString() : "1";
        answerCardinality = {
          min: "1"
        };
      } else {
        questionCardinality.min = "1";
      }
    }

    if (questionCardinality) lfItem.questionCardinality = questionCardinality;
    if (answerCardinality) lfItem.answerCardinality = answerCardinality;
  };
  /**
   * Parse questionnaire item for editable
   *
   * @param lfItem {object} - LForms item object to assign editable
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processEditable = function (lfItem, qItem) {
    if (qItem.readOnly) {
      lfItem.editable = '0';
    }
  };
  /**
   * Process answer value
   * @param {*} answer an entry in item.answerOption or in item.initial
   * @param {*} vals an array that contains all default answers
   */


  self._processDefaultAnswerValue = function (answer, vals) {
    answer = LForms.Util.deepCopy(answer); // Use a clone to avoid changing the original

    var val = answer.valueCoding;
    if (val) val._type = 'Coding';else val = self._getFHIRValueWithPrefixKey(answer, /^value/);
    if (val !== undefined && val !== null) vals.push(val);
  };
  /**
   * Parse questionnaire item for default answer
   *
   * @param lfItem {object} - LForms item object to assign default answer
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processDefaultAnswer = function (lfItem, qItem) {
    var vals = []; // check item.answerOption.initialSelected

    if (qItem.answerOption) {
      qItem.answerOption.forEach(function (elem) {
        if (elem.initialSelected) {
          self._processDefaultAnswerValue(elem, vals);
        }
      });
    } // check item.initial


    if (qItem.initial) {
      qItem.initial.forEach(function (elem) {
        self._processDefaultAnswerValue(elem, vals);
      });
    } // set default values


    if (vals.length > 0) this._processFHIRValues(lfItem, vals, true);
  };
  /**
   *  Returns the first initial quanitity for the given Questionnaire item, or
   *  null if there isn't one.
   */


  self.getFirstInitialQuantity = function (qItem) {
    return qItem.initial && qItem.initial.length > 0 && qItem.initial[0].valueQuantity || null;
  };
  /**
   * Parse 'linkId' for the LForms questionCode of a 'display' item, which does not have a 'code'
   *
   * @param lfItem {object} - LForms item object to assign questionCode
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processDisplayItemCode = function (lfItem, qItem) {
    if (qItem.type === "display" && qItem.linkId) {
      var codes = qItem.linkId.split("/");

      if (codes && codes[codes.length - 1]) {
        lfItem.questionCode = codes[codes.length - 1];
      }
    }
  };
  /**
   * Parse questionnaire item for data type
   *
   * @param lfItem {object} - LForms item object to assign data type
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processDataType = function (lfItem, qItem) {
    var type = self._getDataType(qItem);

    if (type === 'SECTION') {
      lfItem.header = true;
    }

    lfItem.dataType = type;
  }; // Quesitonnaire Response Import


  self._mergeQR = {
    /**
     * Get structure information of a QuestionnaireResponse instance
     * @param qr a QuestionnaireResponse instance
     * @returns {{}} a QuestionnaireResponse data structure object
     * @private
     */
    _getQRStructure: function (qr) {
      var qrInfo = {
        qrItemsInfo: []
      };

      if (qr) {
        this._checkQRItems(qrInfo, qr);
      }

      return qrInfo;
    },

    /**
     * Get structural info of a QuestionnaireResponse by going though each level of items
     * @param parentQRItemInfo the structural info of a parent item
     * @param parentItem a parent item in a QuestionnaireResponse object
     * @private
     */
    _checkQRItems: function (parentQRItemInfo, parentQRItem) {
      var qrItemsInfo = [];
      var repeatingItemProcessed = {};

      if (parentQRItem && parentQRItem.item) {
        for (var i = 0, iLen = parentQRItem.item.length; i < iLen; i++) {
          var item = parentQRItem.item[i];
          var linkId = item.linkId; //code is not necessary included in linkId
          // first item that has the same code, either repeating or non-repeating

          if (!repeatingItemProcessed[linkId]) {
            var repeatingInfo = this._findTotalRepeatingNum(linkId, parentQRItem); // create structure info for the item


            var repeatingItems = repeatingInfo.repeatingItems;

            for (var j = 0, jLen = repeatingItems.length; j < jLen; j++) {
              var qrItemInfo = {
                linkId: linkId,
                item: repeatingItems[j],
                index: j,
                total: repeatingInfo.total
              }; // check observation instances in the sub level

              this._checkQRItems(qrItemInfo, repeatingItems[j]);

              self._checkQRItemAnswerItems(qrItemInfo, repeatingItems[j]);

              qrItemsInfo.push(qrItemInfo);
            }

            repeatingItemProcessed[linkId] = true;
          }
        }

        parentQRItemInfo.qrItemsInfo = qrItemsInfo;
      }
    },

    /**
     * Find the number of the repeating items that have the same code
     * @param linkId an item's linkId
     * @param parentQRItem a parent item in a QuestionnaireResponse object
     * @returns a structural info object for a repeating item
     * @private
     */
    _findTotalRepeatingNum: function (linkId, parentQRItem) {
      var total = 0;
      var repeatingItems = [];

      for (var i = 0, iLen = parentQRItem.item.length; i < iLen; i++) {
        var item = parentQRItem.item[i];

        if (linkId === item.linkId) {
          repeatingItems.push(item);

          if (Array.isArray(item.answer)) {
            total += item.answer.length; // answers for repeating questions and repeating answers
          } else {
            total += 1;
          }
        }
      }

      return {
        total: total,
        repeatingItems: repeatingItems
      };
    },

    /**
     * Add repeating items into LForms definition data object
     * @param parentItem a parent item
     * @param linkId linkId of a repeating item
     * @param total total number of the repeating item with the same code
     * @private
     */
    _addRepeatingItems: function (parentItem, linkId, total) {
      // find the first (and the only one) item
      var item = null;

      if (parentItem.items) {
        for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
          if (linkId === parentItem.items[i].linkId) {
            item = parentItem.items[i];
            break;
          }
        } // insert new items


        if (item) {
          while (total > 1) {
            var newItem = LForms.Util.deepCopy(item);
            parentItem.items.splice(i, 0, newItem);
            total -= 1;
          }
        }
      }
    },

    /**
     * Find a matching repeating item by item code and the index in the items array
     * @param parentItem a parent item
     * @param linkId linkId of a repeating (or non-repeating) item
     * @param index index of the item in the sub item array of the parent item
     * @returns {{}} a matching item
     * @private
     */
    _findTheMatchingItemByLinkIdAndIndex: function (parentItem, linkId, index) {
      var item = null;
      var idx = 0;

      if (parentItem.items) {
        for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
          if (linkId === parentItem.items[i].linkId) {
            if (idx === index) {
              item = parentItem.items[i];
              break;
            } else {
              idx += 1;
            }
          }
        }
      }

      return item;
    },

    /**
     * Find a matching repeating item by item code alone
     * When used on the LForms definition data object, there is no repeating items yet.
     * @param parentItem a parent item
     * @param linkId linkId of an item
     * @returns {{}} a matching item
     * @private
     */
    _findTheMatchingItemByLinkId: function (parentItem, linkId) {
      var item = null;

      if (parentItem.items) {
        for (var i = 0, iLen = parentItem.items.length; i < iLen; i++) {
          if (linkId === parentItem.items[i].linkId) {
            item = parentItem.items[i];
            break;
          }
        }
      }

      return item;
    }
  };
}

/* harmony default export */ __webpack_exports__["default"] = (addSDCImportFns);

/***/ }),
/* 99 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _obs_prepop_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(100);

/**
 *  Defines SDC functions (used by both import and export, or for other
 *  SDC-related purposes) that are the same across the different FHIR versions.
 *  The function takes SDC namespace object defined in the sdc export code,
 *  and adds additional functions to it.
 */

function addCommonSDCFns(ns) {
  "use strict";

  var self = ns;
  self.requestLinkedObs = _obs_prepop_mjs__WEBPACK_IMPORTED_MODULE_0__.requestLinkedObs; // A mapping of data types of items from LHC-Forms to FHIR Questionnaire

  self._lformsTypesToFHIRTypes = {
    "SECTION": 'group',
    "TITLE": 'display',
    "ST": 'string',
    "BL": 'boolean',
    "REAL": 'decimal',
    "INT": 'integer',
    "DT": 'date',
    "DTM": 'dateTime',
    "TM": 'time',
    "TX": 'text',
    "URL": 'url',
    "CNE": 'choice',
    "CWE": 'open-choice',
    "QTY": 'quantity',
    "attachment": 'attachment'
  }; // A mapping from LHC-Forms data types to the partial field names of the value fields
  // and initial value fields in FHIR Questionnaire

  self._lformsTypesToFHIRFields = {
    "attachment": "Attachment",
    "INT": 'Integer',
    "REAL": 'Decimal',
    "DT": 'Date',
    "DTM": 'DateTime',
    "TM": 'Time',
    "ST": 'String',
    "TX": 'String',
    "BL": 'Boolean',
    "URL": 'Url',
    "CNE": 'Coding',
    "CWE": 'Coding',
    "QTY": 'Quantity'
  };
  self._operatorMapping = {
    'minExclusive': '>',
    'maxExclusive': '<',
    'minInclusive': '>=',
    'maxInclusive': '<=',
    'value': '=',
    'notEqual': '!=',
    '>': 'minExclusive',
    '<': 'maxExclusive',
    '>=': 'minInclusive',
    '<=': 'maxInclusive',
    '=': 'value',
    '!=': 'notEqual',
    'exists': 'exists'
  };
  /**
   * Check if a LForms item has repeating questions
   * @param item a LForms item
   * @returns {*|boolean}
   * @private
   */

  self._questionRepeats = function (item) {
    return item._questionRepeatable !== undefined ? item._questionRepeatable : item.questionCardinality && item.questionCardinality.max && (item.questionCardinality.max === "*" || parseInt(item.questionCardinality.max) > 1);
  };
  /**
   * Check if a LForms item has repeating answers
   * @param item a LForms item
   * @returns {*|boolean}
   * @private
   */


  self._answerRepeats = function (item) {
    return item._multipleAnswers !== undefined ? item._multipleAnswers : item.answerCardinality && item.answerCardinality.max && (item.answerCardinality.max === "*" || parseInt(item.answerCardinality.max) > 1);
  };
  /**
   * Do a shallow copy of specified fields from source to target.
   *
   * @param source - Source object
   * @param target - Target object
   * @param fieldList - Array of fields to copy from the source. If the field is
   * not found in the source, it is ignored.
   */


  self.copyFields = function (source, target, fieldList) {
    if (source && target && fieldList && fieldList.length > 0) {
      fieldList.forEach(function (field) {
        if (source.hasOwnProperty(field)) {
          target[field] = source[field];
        }
      });
    }
  }; // Store the UCUM code system URI


  self.UCUM_URI = 'http://unitsofmeasure.org';
  /**
   * Set the given key/value to the object if the value is not undefined, not null, and not an empty string.
   * @param obj the object to set the key/value on. It can be null/undefined, and if so, a new object will
   *        be created and returned (only if the value is valid).
   * @param key the key for the given value to be set to the given object, required.
   * @param value the value to be set to the given object using the given key.
   * @return if the input object is not null/undefined, it will be returned;
   *         if the input object is null/undefined:
   *         - return the given object as is if the value is invalid, or
   *         - a newly created object with the given key/value set.
   * @private
   */

  self._setIfHasValue = function (obj, key, value) {
    if (value !== undefined && value !== null && value !== '') {
      if (!obj) {
        obj = {};
      }

      obj[key] = value;
    }

    return obj;
  };
  /**
   * Copy between lforms trigger value coding and FHIR enableWhen valueCoding. It only copies 3 fields:
   * code, system, and display/text (called "text" in lforms, "display" in FHIR)
   * @param srcCoding the coding object to copy from
   * @param dstCoding the coding object to copy to, may be null/undefined, and if null/undefined, a new object
   *        will be created but only if the srcCoding has at least one of code, system, display/text
   * @param lforms2Fhir The direction of copying, can be true or false. The direction matters because in lforms,
   *        the text/display field is called "text", while in FHIR, it's called "display"
   * @return the resulting dstCoding object.
   * @private
   */


  self._copyTriggerCoding = function (srcCoding, dstCoding, lforms2Fhir) {
    let srcTextField = lforms2Fhir ? 'text' : 'display';
    let dstTextField = lforms2Fhir ? 'display' : 'text';
    dstCoding = self._setIfHasValue(dstCoding, 'code', srcCoding.code);
    dstCoding = self._setIfHasValue(dstCoding, 'system', srcCoding.system);
    dstCoding = self._setIfHasValue(dstCoding, dstTextField, srcCoding[srcTextField]);
    return dstCoding;
  };
  /**
   *  Returns true if the given item (or LFormsData) has an expression
   *  which needs to be re-evaluated when the user changes their response.
   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed
   *  that the relevant extensions will be in an _fhirExt hash where
   *  the key is the URI of the extension and the values are arrays of the FHIR
   *  extension structure.
   */


  self.hasResponsiveExpression = function (itemOrLFData) {
    var ext = itemOrLFData._fhirExt;
    return ext ? !!(ext[self.fhirExtCalculatedExp] || ext[self.fhirExtAnswerExp] || ext[self.fhirExtEnableWhenExp]) : false;
  };
  /**
   *  Returns true if the given item has an expression
   *  which sets the list.
   * @param item the item to be checked.  It is assumed
   *  that the relevant extensions will be in an _fhirExt hash where
   *  the key is the URI of the extension and the values are arrays of the FHIR
   *  extension structure.
   */


  self.hasListExpression = function (item) {
    var ext = item._fhirExt; // This should one day include a check for cqf-expression, when we add
    // support for it

    return ext ? !!ext[self.fhirExtAnswerExp] : false;
  };
  /**
   *  Returns true if the given item (or LFormsData) has an expression
   *  which needs to be evaluated only once, when form is first rendered.
   * @param itemOrLFData the item or LFormsData to be checked.  It is assumed
   *  that the relevant extensions will be in an _fhirExt hash where
   *  the key is the URI of the extension and the values are arrays of the FHIR
   *  extension structure.
   */


  self.hasInitialExpression = function (itemOrLFData) {
    return !!(itemOrLFData._fhirExt && itemOrLFData._fhirExt[self.fhirExtInitialExp]);
  };
  /**
   *  Builds a map from extension URIs to arrays of the FHIR extension
   *  structures, and stores it on the item.  Also builds an array of all
   *  Expression extensions.
   *
   * @param itemOrLFData a form item or an LFormsData which possibly contain
   *  FHIR extensions (in an "extension" property).
   */


  self.buildExtensionMap = function (itemOrLFData) {
    // Initialize a map for testing whether an extension is an Expression extension.
    // The keys are the URIs, and the values are see to true.
    if (!self.isExpressionExtension) {
      self.isExpressionExtension = [self.fhirExtCalculatedExp, self.fhirExtInitialExp, self.fhirExtAnswerExp, self.fhirExtVariable, self.fhirExtEnableWhenExp].reduce((x, k) => {
        x[k] = true;
        return x;
      }, {});
    }

    if (itemOrLFData.extension) {
      var m = {};
      var exprExtensions = [];

      for (let ext of itemOrLFData.extension) {
        var extArray = m[ext.url];
        if (!extArray) extArray = m[ext.url] = [];
        extArray.push(ext);
        if (self.isExpressionExtension[ext.url]) exprExtensions.push(ext);
      }

      itemOrLFData._fhirExt = m;
      if (exprExtensions.length) itemOrLFData._exprExtensions = exprExtensions;
    }
  };
  /**
   *  Requests launchContext resources.  Assumes LForms.Util.setFHIRContext() has
   *  been called.
   * @param lfData a LFormsData object for the form.
   * @return an array of Promises which resolve when the attempt to load the
   *  resources has completed (succesful or not, they resolve without being
   *  rejected).
   */


  self.loadLaunchContext = function (lfData) {
    // launchContext
    var contextItems = LForms.Util.findObjectInArray(lfData.extension, 'url', self.fhirExtLaunchContext, 0, true); // Define a list of known, supported context variables, which we can get from the FHIR server,
    // and they resources they are allowed to take.

    const contextsFromServer = {
      patient: {
        Patient: 1
      },
      encounter: {
        Encounter: 1
      },
      user: {
        Patient: 1,
        Practitioner: 1,
        PractitionerRole: 1,
        RelatedPerson: 1
      }
    };
    const pendingPromises = [];
    /**
     *  Checks to make sure that the type of the resource is what it should be
     *  per FHIR's requirements, and if it is okay, assigns the resource to
     *  the Questionnaires' variables map.
     * @param name the name of the variable
     * @param typeList the list of types for the name as specified in the
     *  launchContext extension.
     * @param resource the resource that was obtained as the value of the variable.
     */

    function addIfValid(name, typeList, resource) {
      let resType = resource.resourceType; // Validate the "type"

      let permittedTypes = contextsFromServer[name];

      if (permittedTypes && !permittedTypes[resType]) {
        console.warn("a launch context resource of type " + restype + " was found for name " + name + ", but the supported types for name " + name + " are: " + Object.keys(permittedTypes).join(", "));
      } else if (typeList.indexOf(resType) == -1) {
        console.warn("Could not retrieve a resource of the requested" + " types for launch context name " + name);
      } else {
        lfData._fhirVariables[name] = resource;
      }
    }

    for (var i = 0, len = contextItems.length; i < len; ++i) {
      let contextItemExt = contextItems[i].extension;
      let name = null,
          typeList = [];

      for (var j = 0, jLen = contextItemExt.length; j < jLen; ++j) {
        var fieldExt = contextItemExt[j];

        if (!name && fieldExt.url === 'name') {
          if (fieldExt.valueId) {
            // Handle a change in the specification
            console.log("Warning:  The type of the launchContext 'name' field should be 'Coding', not 'id'.");
            name = fieldExt.valueId;
          } else name = fieldExt.valueCoding?.code;

          lfData._checkFHIRVarName(name); // might throw if the name is not valid as a variable name

        } else if (fieldExt.url === 'type') {
          // there can be more than one
          typeList.push(fieldExt.valueCode);
        }
      }

      if (name && typeList.length) {
        pendingPromises.push(new Promise(function (resolve, reject) {
          let fromMap = LForms.fhirContext.vars?.[name];
          let contextResource = LForms.fhirContext.client?.[name];

          if (!fromMap && !contextResource.id) {
            console.warn('A launch context resource of name ' + name + ' was requested by the form, but none was available'); // The loading of this resource should not be critical for the
            // Questionnaire, because it is just for prepopulation.  Don't
            // reject the promise.

            resolve();
          } else {
            if (fromMap) {
              addIfValid(name, typeList, fromMap);
              resolve();
            } else {
              contextResource.read().then(function (resource) {
                if (resource) {
                  addIfValid(name, typeList, resource);
                }

                resolve();
              }, function fail(reason) {
                console.warn('A launch context of name ' + name + ' was requested, ' + 'but could not be read.');
                console.error(reason);
                resolve(); // per above, we are not rejecting the promise
              });
            }
          }
        }));
      }
    }

    return pendingPromises;
  };
}

/* harmony default export */ __webpack_exports__["default"] = (addCommonSDCFns);

/***/ }),
/* 100 */
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "requestLinkedObs": function() { return /* binding */ requestLinkedObs; }
/* harmony export */ });
// A module for Observation-based pre-population.

/**
 *  Starts the (likely asynchronous) requests to retrieve linked Observation
 *  resources for pre-population.  When the resources have been retrieved,
 *  prepoluation will be performed.
 * @param lfData the LFormsData object for the form being prepopulated.
 * @return a promise resolving after the resources have been retrieved and
 *  any prepopulation has been performed.
 */
function requestLinkedObs(lfData) {
  if (LForms.fhirContext?.client && lfData._fhir) {
    // We will need to know what version of FHIR the server is using.  Make
    // sure that is available before continuing.
    if (!LForms._serverFHIRReleaseID) {
      // Go fetch the server's FHIR version first before continuing
      return new Promise(function (resolve, reject) {
        LForms.Util.getServerFHIRReleaseID(function (relID) {
          if (!relID) reject("Unable to obtain the server's FHIR version");else resolve(requestLinkedObs(lfData));
        });
      });
    } else {
      var pendingPromises = [];
      LForms.Util.validateFHIRVersion(LForms._serverFHIRReleaseID);
      var serverFHIR = LForms.FHIR[LForms._serverFHIRReleaseID];
      let obsLinkURI = lfData._fhir.SDC.fhirExtObsLinkPeriod;

      for (var i = 0, len = lfData.itemList.length; i < len; ++i) {
        let item = lfData.itemList[i];
        const obsExt = item._fhirExt && item._fhirExt[obsLinkURI];

        if (obsExt) {
          // an array of at least 1 if present
          var duration = obsExt[0].valueDuration; // optional

          var fhirClient = LForms.fhirContext.client; // Get a comma separated list of codes

          const codeQuery = item.codeList.map(code => {
            const codeSystem = code.system === 'LOINC' ? serverFHIR.LOINC_URI : code.system;
            return [codeSystem, code.code].join('|');
          }).join(',');
          const queryParams = {
            code: codeQuery,
            _sort: '-date',
            status: 'final,amended,corrected',
            _count: 5 // only need one, but we need to filter out focus=true below

          }; // Temporarily disabling the addition of the focus search
          // parameter, because of support issues.  Instead, for now, we
          // will check the focus parameter when the Observation is
          // returned.  Later, we might query the server to find out whether
          // :missing is supported.
          //if (LForms._serverFHIRReleaseID != 'STU3') // STU3 does not know about "focus"
          //  queryParams.focus = {$missing: true}; // TBD -- sometimes :missing is not supported
          // Constrain the date range

          if (duration && duration.value && duration.code) {
            // Convert value to milliseconds
            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(duration.code, duration.value, 'ms');

            if (result.status === 'succeeded') {
              var date = new Date(new Date() - result.toVal);
              queryParams.date = 'gt' + date.toISOString();
            }
          }

          pendingPromises.push(fhirClient.patient.request(lfData._buildURL(['Observation'], queryParams)).then(function (successData) {
            var bundle = successData;

            if (bundle.entry) {
              var foundObs;

              for (var j = 0, jLen = bundle.entry.length; j < jLen && !foundObs; ++j) {
                var obs = bundle.entry[j].resource;

                if (!obs.focus) {
                  // in case we couldn't use focus:missing above
                  serverFHIR.SDC.importObsValue(item, obs);

                  if (item.value) {
                    // obs.value[x] could be missing
                    foundObs = true;
                    if (item.unit) lfData._setUnitDisplay(item.unit);
                  }
                }
              }
            }

            return item.questionCode; // code is not needed, but useful for debugging
          }));
        }
      }

      return Promise.all(pendingPromises);
    }
  }
}
;

/***/ }),
/* 101 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(102);
/* harmony import */ var _import_common_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93);

 // TBD import this path function from fhirpath.js.  When that is done, also
// remove the regex test for /Quantity$/ below and replace it with a simple
// equality check for a path of 'Quantity'.

/**
 *  For a given result of a fhirpath.js evaluation, returns the path from the
 *  nearest FHIR type to the result which might be a fragement of that type.
 *  (Example:  Questionnaire.item, given a result consisting of items.)
 */

function path(fhirpathRes) {
  return fhirpathRes.__path__;
}
/**
 *  Defines SDC import functions that are the same across the different FHIR
 *  versions.  The function takes SDC namespace object defined in the sdc export
 *  code, and adds additional functions to it.
 */


function addCommonSDCImportFns(ns) {
  "use strict";

  var self = ns;
  var errorMessages = LForms.Util._internalUtil.errorMessages; // FHIR extension urls

  self.fhirExtUrlCardinalityMin = "http://hl7.org/fhir/StructureDefinition/questionnaire-minOccurs";
  self.fhirExtUrlCardinalityMax = "http://hl7.org/fhir/StructureDefinition/questionnaire-maxOccurs";
  self.fhirExtUrlItemControl = "http://hl7.org/fhir/StructureDefinition/questionnaire-itemControl";
  self.fhirExtUrlUnit = "http://hl7.org/fhir/StructureDefinition/questionnaire-unit";
  self.fhirExtUrlUnitOption = "http://hl7.org/fhir/StructureDefinition/questionnaire-unitOption";
  self.fhirExtUrlOptionPrefix = "http://hl7.org/fhir/StructureDefinition/questionnaire-optionPrefix";
  self.fhirExtVariable = "http://hl7.org/fhir/StructureDefinition/variable";
  self.fhirExtUrlMinValue = "http://hl7.org/fhir/StructureDefinition/minValue";
  self.fhirExtUrlMaxValue = "http://hl7.org/fhir/StructureDefinition/maxValue";
  self.fhirExtUrlMinLength = "http://hl7.org/fhir/StructureDefinition/minLength";
  self.fhirExtUrlRegex = "http://hl7.org/fhir/StructureDefinition/regex";
  self.fhirExtUrlAnswerRepeats = "http://hl7.org/fhir/StructureDefinition/questionnaire-answerRepeats";
  self.fhirExtUrlExternallyDefined = "http://lhcforms.nlm.nih.gov/fhir/StructureDefinition/questionnaire-externallydefined";
  self.argonautExtUrlExtensionScore = "http://fhir.org/guides/argonaut-questionnaire/StructureDefinition/extension-score";
  self.fhirExtUrlHidden = "http://hl7.org/fhir/StructureDefinition/questionnaire-hidden";
  self.fhirExtTerminologyServer = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-preferredTerminologyServer";
  self.fhirExtUrlDataControl = "http://lhcforms.nlm.nih.gov/fhirExt/dataControl";
  self.fhirExtCalculatedExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-calculatedExpression";
  self.fhirExtInitialExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-initialExpression";
  self.fhirExtObsLinkPeriod = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationLinkPeriod";
  self.fhirExtObsExtract = 'http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-observationExtract';
  self.fhirExtAnswerExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-answerExpression";
  self.fhirExtEnableWhenExp = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-enableWhenExpression";
  self.fhirExtChoiceOrientation = "http://hl7.org/fhir/StructureDefinition/questionnaire-choiceOrientation";
  self.fhirExtLaunchContext = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-launchContext";
  self.fhirExtMaxSize = "http://hl7.org/fhir/StructureDefinition/maxSize";
  self.fhirExtMimeType = "http://hl7.org/fhir/StructureDefinition/mimeType";
  self.fhirExtUnitOpen = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-unitOpen";
  self.fhirExtUnitSuppSystem = "http://hl7.org/fhir/uv/sdc/StructureDefinition/sdc-questionnaire-unitSupplementalSystem";
  self.fhirExtEntryFormat = "http://hl7.org/fhir/StructureDefinition/entryFormat";
  self.fhirExtUrlRestrictionArray = [self.fhirExtUrlMinValue, self.fhirExtUrlMaxValue, self.fhirExtUrlMinLength, self.fhirExtUrlRegex]; // One way or the other, the following extensions are converted to lforms internal fields.
  // Any extensions not listed here (there are many) are recognized as lforms extensions as they are.

  self.handledExtensionSet = new Set([self.fhirExtUrlCardinalityMin, self.fhirExtUrlCardinalityMax, self.fhirExtUrlItemControl, self.fhirExtUrlUnit, self.fhirExtUrlUnitOption, self.fhirExtUrlOptionPrefix, self.fhirExtUrlMinValue, self.fhirExtUrlMaxValue, self.fhirExtUrlMinLength, self.fhirExtUrlRegex, self.fhirExtUrlAnswerRepeats, self.fhirExtUrlExternallyDefined, self.argonautExtUrlExtensionScore, self.fhirExtUrlHidden, self.fhirExtTerminologyServer, self.fhirExtUrlDataControl, self.fhirExtChoiceOrientation]); // Simple functions for mapping extensions to properties in the internal structure.
  // Parameters:
  //   extension: the FHIR extension object
  //   item:  The LForms item to be updated
  // Returns:  true if the extension should still be added to the LForms item
  //   extension array, and false/undefined otherwise.
  //

  self.extensionHandlers = {};

  self.extensionHandlers[self.fhirExtMaxSize] = function (extension, item) {
    item.maxAttachmentSize = extension.valueDecimal || extension.valueInteger; // not sure why it is decimal
  };

  self.extensionHandlers[self.fhirExtMimeType] = function (extension, item) {
    item.allowedAttachmentTypes || (item.allowedAttachmentTypes = []);
    item.allowedAttachmentTypes.push(extension.valueCode);
  };

  self.extensionHandlers["http://hl7.org/fhir/StructureDefinition/questionnaire-initialExpression"] = function (extension, item) {
    // Update the URI to the current one.
    extension.url = self.fhirExtInitialExp;
    return true; // add extension to LForms item
  };

  self.extensionHandlers["http://hl7.org/fhir/StructureDefinition/terminology-server"] = function (extension, item) {
    // Note: The above URI will be the new one, and it is pending the
    // application of an approved change request (see jira.hl7.org), but for now
    // we need to use the old one because that is what is published.
    extension.url = self.fhirExtTerminologyServer;
  };

  self.extensionHandlers[self.fhirExtUnitOpen] = function (extension, item) {
    item._unitOpen = extension.valueCode;
  };

  self.extensionHandlers[self.fhirExtUnitSuppSystem] = function (extension, item) {
    item._unitSuppSystem = extension.valueCanonical;
  };

  self.extensionHandlers[self.fhirExtUrlExternallyDefined] = // (also handle old URL below)
  self.extensionHandlers["http://hl7.org/fhir/StructureDefinition/questionnaire-externallydefined"] = function (extension, item) {
    if (extension.valueUri) {
      item.externallyDefined = extension.valueUri;
    }
  };

  self.extensionHandlers[self.fhirExtEntryFormat] = function (extension, item) {
    if (extension.valueString) {
      item._entryFormat = extension.valueString;
      return true; // add extension to LForms item
    }
  };

  self.formLevelFields = [// Resource
  'id', 'meta', 'implicitRules', 'language', // Domain Resource
  'text', 'contained', 'extension', 'modifiedExtension', // Questionnaire
  'date', 'version', 'identifier', 'code', // code in FHIR clashes with previous definition in lforms. It needs special handling.
  'subjectType', 'derivedFrom', // New in R4
  'status', 'experimental', 'publisher', 'contact', 'description', 'useContext', 'jurisdiction', 'purpose', 'approvalDate', 'reviewDate', 'effectivePeriod', 'url'];
  self.itemLevelIgnoredFields = ['definition'];
  /**
   * Convert FHIR SQC Questionnaire to LForms definition
   *
   * @param fhirData - FHIR Questionnaire object
   * @returns {{}} - LForms json object
   */

  self.convertQuestionnaireToLForms = function (fhirData) {
    var target = null;

    if (fhirData) {
      target = LForms.Util.baseFormDef();

      self._processFormLevelFields(target, fhirData);

      var containedVS = self._extractContainedVS(fhirData);

      if (fhirData.item && fhirData.item.length > 0) {
        var linkIdItemMap = self._createLinkIdItemMap(fhirData);

        target.items = [];

        for (var i = 0; i < fhirData.item.length; i++) {
          var item = self._processQuestionnaireItem(fhirData.item[i], containedVS, linkIdItemMap); // no instructions on the questionnaire level


          target.items.push(item);
        }
      }

      target.fhirVersion = self.fhirVersion;
    }

    return target;
  };
  /**
   * Parse form level fields from FHIR questionnaire and assign to LForms object.
   *
   * @param lfData - LForms object to assign the extracted fields
   * @param questionnaire - FHIR questionnaire resource object to parse for the fields.
   * @private
   */


  self._processFormLevelFields = function (lfData, questionnaire) {
    self.copyFields(questionnaire, lfData, self.formLevelFields);

    self._processTerminologyServer(lfData, questionnaire); // Handle title and name.  In LForms, "name" is the "title", but FHIR
    // defines both.


    lfData.shortName = questionnaire.name; // computer friendly

    lfData.name = questionnaire.title; // Handle extensions on title

    if (questionnaire._title) lfData.obj_title = questionnaire._title; // For backward compatibility, we keep lforms.code as it is, and use lforms.codeList
    // for storing questionnaire.code. While exporting, merge lforms.code and lforms.codeList
    // into questionnaire.code. While importing, convert first of questionnaire.code
    // as lforms.code, and copy questionnaire.code to lforms.codeList.

    if (questionnaire.code && questionnaire.code.length > 0) {
      // Rename questionnaire code to codeList
      lfData.codeList = questionnaire.code;
    } // copy over the copyright


    if (questionnaire.copyright) {
      lfData.copyrightNotice = questionnaire.copyright;
    }

    var codeAndSystemObj = self._getCode(questionnaire);

    if (codeAndSystemObj) {
      lfData.code = codeAndSystemObj.code;
      lfData.codeSystem = codeAndSystemObj.system;
    }
  };
  /**
   * Process questionnaire item recursively
   *
   * @param qItem - item object as defined in FHIR Questionnaire.
   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details
   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.
   * @returns {{}} - Converted 'item' field object as defined by LForms definition.
   * @private
   */


  self._processQuestionnaireItem = function (qItem, containedVS, linkIdItemMap) {
    var targetItem = {}; //A lot of parsing depends on data type. Extract it first.

    self._processExtensions(targetItem, qItem);

    self._processDataType(targetItem, qItem);

    self._processTextAndPrefix(targetItem, qItem);

    self._processCodeAndLinkId(targetItem, qItem);

    self._processDisplayItemCode(targetItem, qItem);

    self._processEditable(targetItem, qItem);

    self._processFHIRQuestionAndAnswerCardinality(targetItem, qItem);

    self._processDisplayControl(targetItem, qItem);

    self._processDataControl(targetItem, qItem);

    self._processRestrictions(targetItem, qItem);

    self._processHiddenItem(targetItem, qItem);

    self._processUnitList(targetItem, qItem);

    self._processAnswers(targetItem, qItem, containedVS);

    self._processDefaultAnswer(targetItem, qItem);

    self._processTerminologyServer(targetItem, qItem);

    self._processSkipLogic(targetItem, qItem, linkIdItemMap);

    self.copyFields(qItem, targetItem, self.itemLevelIgnoredFields);

    self._processChildItems(targetItem, qItem, containedVS, linkIdItemMap);

    return targetItem;
  };
  /**
   *  Returns the number of sinificant digits in the number after, ignoring
   *  trailing zeros.  (I am including this on "self" so we can have tests for it.)
   */


  self._significantDigits = function (x) {
    // Based on https://stackoverflow.com/a/9539746/360782
    // Make sure it is a number and use the builtin number -> string.
    var s = "" + +x; // The following RegExp include the exponent, which we don't need
    //var match = /(\d+)(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/.exec(s);

    var match = /(\d+)(?:\.(\d+))?/.exec(s); // NaN or Infinity or integer.
    // We arbitrarily decide that Infinity is integral.

    if (!match) {
      return 0;
    }

    var wholeNum = match[1];
    var fraction = match[2]; //var exponent = match[3];

    return wholeNum === '0' ? 0 : wholeNum.length + (fraction ? fraction.length : 0);
  };
  /**
   *  Imports an observation's values into the given LForms item.
   * @param lfItem the LForms item to which a value will be assigned.
   * @param obs the observation whose value will be assigned to lfItem.  It
   *  assumed that obs has an appropriate data type for its value.
   */


  self.importObsValue = function (lfItem, obs) {
    // Get the value from obs, based on lfItem's data type.  (The alternative
    // seems to be looping through the keys on obs looking for something that
    // starts with "value".
    var val = null;
    var lfDataType = lfItem.dataType;
    var fhirValType = this._lformsTypesToFHIRFields[lfDataType]; // fhirValType is now the FHIR data type for a Questionnaire.  However,
    // where Questionnaire uses Coding, Observation uses CodeableConcept.

    if (fhirValType === 'Coding') fhirValType = 'CodeableConcept';
    if (fhirValType) val = obs['value' + fhirValType];

    if (!val && (lfDataType === 'REAL' || lfDataType === 'INT')) {
      // Accept initial value of type Quantity for these types.
      val = obs.valueQuantity;
      if (val) val._type = 'Quantity';
    }

    if (val) {
      if (!val._type && typeof val === 'object') val._type = fhirValType; // Before importing, confirm val contains a valid unit from the
      // item's unit list.

      var unitOkay = true;

      if (val._type === 'Quantity') {
        if (lfItem.units) {
          var matchingUnit;
          var valSystem = val.system; // On SMART sandbox, val.system might have a trailing slash (which is wrong, at least
          // for UCUM).  For now, just remove it.

          if (valSystem && valSystem[valSystem.length - 1] === '/') valSystem = valSystem.slice(0, -1);
          var isUCUMUnit = valSystem === self.UCUM_URI;
          var ucumUnit;

          for (var i = 0, len = lfItem.units.length; i < len && !matchingUnit; ++i) {
            var lfUnit = lfItem.units[i];

            if (lfUnit.system && lfUnit.system === valSystem && lfUnit.code === val.code || !lfUnit.system && lfUnit.name === val.unit) {
              matchingUnit = lfUnit;
            }

            if (isUCUMUnit && !matchingUnit && !ucumUnit && lfUnit.system === self.UCUM_URI) ucumUnit = lfUnit;
          }

          if (!matchingUnit && ucumUnit) {
            // See if we can convert to the ucumUnit we found
            var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(val.code, val.value, ucumUnit.code);

            if (result.status === 'succeeded') {
              matchingUnit = ucumUnit; // Round the result to the same number of significant digits as the
              // input value.

              var originalSD = this._significantDigits(val.value);

              if (originalSD > 0) val.value = parseFloat(result.toVal.toPrecision(originalSD));else val.value = result.toVal;
              val.code = ucumUnit.code;
              val.unit = ucumUnit.name || ucumUnit.code; // name can be undefined
            }
          }

          if (!matchingUnit) unitOkay = false;else lfItem.unit = matchingUnit;
        }
      }

      if (unitOkay) {
        this._processFHIRValues(lfItem, [val]);
      }
    }
  };
  /**
   *   Converts FHIR values to an LForms item values, but does not assign the
   *   values to the item.  (For a function that assigns values, call _processFHIRValues).
   *  @param lfItem the LForms item to for which these are new values
   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).
   *   Complex types like Quantity should have _type set to the type, if
   *   possible, or an attempt will be made to guess the FHIR type from the
   *   lfItem's data type.
   *  @param forDefault if true, the intented target of the values is the item's
   *   default value instead of the item value.
   *  @return an array of the processed/converted values, and an array of any error/warning/info
   *   messages for each of those messages.  For each item in the messages
   *   array, if there is a message there will be an object with keys "errors",
   *   "warnings", and "info" (if those exist), the values of which will will be
   *   an object with message ID keys (from error-messages.js) and message text
   *   values in the currently selected language.  Regarding the answers, note
   *   that Quantities will be returned as is, because those go into more than
   *   one field on the item, but some error checking will be done for them.
   */


  self._convertFHIRValues = function (lfItem, fhirVals, forDefault) {
    // Note that this is used by the import process, and so lfItem is an item
    // from the lforms definition object in that case, not an item from LFormsData.
    // On the other hand, it is also used by the ExpressionProcessor, an in that
    // case lfItem is an item from LFormsData.
    var lfDataType = lfItem.dataType;
    var answers = [];
    const messages = [];
    const fhirValPath = path(fhirVals); // TBD - should be on each value, as they might vary

    for (let i = 0, len = fhirVals.length; i < len; ++i) {
      let fhirVal = fhirVals[i];
      if (typeof fhirVal == 'object') fhirVal.__path__ = fhirValPath; // TBD - work around for getting path on individual nodes

      var answer = undefined; // reset back to undefined each iteration

      let errors = {};
      let hasMessages = false;

      if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(lfItem)) {
        if (lfDataType === 'CWE' || lfDataType === 'CNE') {
          var codings = null;

          if (fhirVal._type === 'CodeableConcept') {
            codings = fhirVal.coding;
          } else if (fhirVal._type === 'Coding' || typeof fhirVal === 'object') {
            codings = [fhirVal];
          }

          if (!codings) {
            // the value or the default value could be a string for 'open-choice'/CWE
            if (lfDataType === 'CWE') {
              answer = fhirVal;
            }
          } else {
            // Pick a Coding that is appropriate for this list item.
            // Note:  It could be an off list Coding.
            if (lfItem.answers) {
              var itemAnswers = lfItem.answers;

              for (var k = 0, kLen = codings.length; k < kLen && !answer; ++k) {
                var coding = codings[k];

                for (var j = 0, jLen = itemAnswers.length; j < jLen && !answer; ++j) {
                  var listAnswer = itemAnswers[j];
                  var listAnswerSystem = listAnswer.system ? LForms.Util.getCodeSystem(listAnswer.system) : null;

                  if ((!coding.system && !listAnswerSystem || coding.system === listAnswerSystem) && (coding.hasOwnProperty('code') && listAnswer.hasOwnProperty('code') && coding.code === listAnswer.code || coding.hasOwnProperty('display') && listAnswer.hasOwnProperty('text') && coding.display === listAnswer.text)) {
                    answer = itemAnswers[j]; // include label in answer text
                  }
                }
              }
            }

            if (!answer && lfDataType === 'CWE') {
              // no match in the list.
              answer = self._processCWECNEValueInQR({
                valueCoding: fhirVal
              }, lfItem, true);
            }
          }
        } // answerOption is string, integer, data or time
        else if (lfItem.answers) {
          var itemAnswers = lfItem.answers;

          for (var j = 0, jLen = itemAnswers.length; j < jLen && !answer; ++j) {
            if (fhirVal === itemAnswers[j].text) {
              answer = itemAnswers[j];
            }
          }
        }
      } else {
        if ((lfDataType === 'QTY' || lfDataType === 'REAL' || lfDataType === 'INT') && (fhirVal._type === 'Quantity' || /Quantity$/.test(path(fhirVal)))) {
          delete fhirVal.__path__;
          fhirVal._type = 'Quantity';
          [answer, errors] = this._convertFHIRQuantity(lfItem, fhirVal);
          hasMessages = !!errors;
        } // For date types, convert them to date objects, but only for values.
        // If we're setting defaultAnswer, leave them as strings.
        else if (!forDefault && lfItem.dataType === 'DTM' && typeof fhirVal === 'string') answer = new Date(fhirVal);else if (!forDefault && lfItem.dataType === 'DT' && typeof fhirVal === 'string') answer = LForms.Util.stringToDTDateISO(fhirVal);else {
          answer = fhirVal;
        }
      }

      answers.push(answer);
      messages.push(hasMessages ? {
        errors
      } : null);
    }

    return [answers, messages];
  };
  /**
   *  Checks a FHIR Quantity for suitability for the given lfItem, converts
   *  its units as necessary, and sets error messages.
   * @param lfItem the LForms item to for which these are new values
   * @param quantity the FHIR Quantity value for the item
   * @return an array of two elements:  the processed/converted value (possibly
   *  null if there were an error), and an error/warning/info messages object
   *  (see _convertFHIRValues for the format) if there were messages.  In the
   *  case of an error, the converted value will be undefined.  Otherwise, the
   *  converted value will have fields for item.unit plus a 'value' field for
   *  the value.
   */


  self._convertFHIRQuantity = function (lfItem, quantity, forDefault) {
    let answer, errors;

    if (quantity.comparator !== undefined) {
      errors = {};
      errorMessages.addMsg(errors, 'comparatorInQuantity');
    } else {
      // The unit must match one of the provided units list, or be convertible
      // to such, unless the extensions unitOpen and unitSupplementalSystem are
      // specified. (These are R5 features, but we are including support for any
      // version.)
      if (!lfItem.units) {
        // In this case the quantity should not have a unit.
        if (quantity.unit) {
          errorMessages.addMsg(errors, 'nonMatchingQuantityUnit');
        } else answer = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_1__.importFHIRQuantity)(quantity);
      } else {
        // Try to find a matching unit
        var matchingUnit;
        var valSystem = quantity.system; // On SMART sandbox, quantity.system might have a trailing slash (which is wrong, at least
        // for UCUM).  For now, just remove it.

        if (valSystem && valSystem[valSystem.length - 1] === '/') valSystem = valSystem.slice(0, -1);
        var isUCUMUnit = valSystem === self.UCUM_URI;
        var ucumUnit;

        for (var i = 0, len = lfItem.units.length; i < len && !matchingUnit; ++i) {
          var lfUnit = lfItem.units[i];

          if (lfUnit.system && lfUnit.system === valSystem && lfUnit.code === quantity.code || !lfUnit.system && lfUnit.name === quantity.unit) {
            matchingUnit = lfUnit;
          }

          if (isUCUMUnit && !matchingUnit && !ucumUnit && lfUnit.system === self.UCUM_URI) ucumUnit = lfUnit;
        }

        quantity = LForms.Util.deepCopy(quantity); // so we don't change the input argument

        if (!matchingUnit && ucumUnit) {
          // See if we can convert to the ucumUnit we found
          var result = LForms.ucumPkg.UcumLhcUtils.getInstance().convertUnitTo(quantity.code, quantity.value, ucumUnit.code);

          if (result.status === 'succeeded') {
            matchingUnit = ucumUnit; // Round the result to the same number of significant digits as the
            // input value.

            var originalSD = this._significantDigits(quantity.value);

            if (originalSD > 0) quantity.value = parseFloat(result.toVal.toPrecision(originalSD));else quantity.value = result.toVal;
            quantity.code = ucumUnit.code;
            quantity.unit = ucumUnit.name || ucumUnit.code; // name can be undefined
          }
        }

        if (!matchingUnit) {
          if (lfItem._unitOpen == 'optionsOrString') {
            // Then accept the nonmatching unit, but only as a string
            delete quantity.code;
            delete quantity.system;
          } else if (!(lfItem._unitSuppSystem && lfItem._unitOpen == 'optionsOrType' && lfItem._unitSuppSystem == quantity.system)) {
            errors = {};
            errorMessages.addMsg(errors, 'nonMatchingQuantityUnit');
          }
        }
      }

      if (!errors) {
        answer = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_1__.importFHIRQuantity)(quantity);
      }
    }

    return [answer, errors];
  };
  /**
   *   Assigns FHIR values to an LForms item.
   *  @param lfItem the LForms item to receive the values from fhirVals
   *  @param fhirVals an array of FHIR values (e.g.  Quantity, Coding, string, etc.).
   *   Complex types like Quantity should have _type set to the type, if
   *   possible, or an attempt will be made to guess the FHIR type from the
   *   lfItem's data type.
   *  @param setDefault if true, the default value in lfItem will be set instead
   *   of the value.
   */


  self._processFHIRValues = function (lfItem, fhirVals, setDefault) {
    // Currently this is called for:
    //   - importing an Observation value (prepop) (a single value, but could
    //     have components referred to by child items)
    //   - processing default answers during an import.  For default answers, we
    //     do not assign the value here, but just put it in defaultAnswer.
    // Note that when importing, we are creating a LForms form definition, but
    // not and LFormsData object.
    let [answers, messages] = this._convertFHIRValues(lfItem, fhirVals, setDefault);

    let val = LForms.Util._hasMultipleAnswers(lfItem) ? answers : answers[0];

    if (setDefault) {
      lfItem.defaultAnswer = val;

      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, 'default answers');
    } else {
      LForms.Util._internalUtil.assignValueToItem(lfItem, val);

      LForms.Util._internalUtil.setItemMessagesArray(lfItem, messages, '_processFHIRValues');
    }
  };
  /**
   * Get a FHIR value from an object given a partial string of hash key.
   * Use it where at most only one key matches.
   *
   * @param obj {object} - Object to search
   * @param keyRegex {regex} - Regular expression to match a key.  This should
   *  be the beginning part of the key up to the type (e.g., /^value/, to match
   *  "valueQuantity").
   * @returns {*} - Corresponding value of matching key.  For complex types,
   *  such as Quantity, the type of the returned object will be present under
   *  a _type attribute.
   * @private
   */


  self._getFHIRValueWithPrefixKey = function (obj, keyRegex) {
    var ret = null;

    if (typeof obj === 'object') {
      for (var key in obj) {
        var matchData = key.match(keyRegex);

        if (matchData) {
          ret = obj[key];

          if (ret && typeof ret === 'object') {
            ret = LForms.Util.deepCopy(ret); // Work with clone

            ret._type = key.substring(matchData[0].length);
          }

          break;
        }
      }
    }

    return ret;
  };
  /**
   *  Process the text and prefix data.
   * @param lfItem {object} - LForms item object to receive the data
   * @param qItem {object} - Questionnaire item object (as the source)
   */


  self._processTextAndPrefix = function (lfItem, qItem) {
    // prefix
    if (qItem.prefix) lfItem.prefix = qItem.prefix; // text

    lfItem.question = qItem.text; // Copy item extensions

    for (let extField of ['_prefix', '_text']) {
      let extFieldData = qItem[extField];
      if (extFieldData) lfItem['obj' + extField] = extFieldData;
    }
  };
  /**
   * Parse questionnaire item for code and code system
   * @param lfItem {object} - LForms item object to assign question code
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processCodeAndLinkId = function (lfItem, qItem) {
    if (qItem.code) {
      lfItem.codeList = qItem.code;
    }

    var code = self._getCode(qItem);

    if (code) {
      lfItem.questionCode = code.code;
      lfItem.questionCodeSystem = code.system;
    } // use linkId as questionCode, which should not be exported as code
    else {
      lfItem.questionCode = qItem.linkId;
      lfItem.questionCodeSystem = "LinkId";
    }

    lfItem.linkId = qItem.linkId;
  };
  /**
   * Parse questionnaire item for units list
   *
   * @param lfItem {object} - LForms item object to assign units
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processUnitList = function (lfItem, qItem) {
    var lformsUnits = [];
    var lformsDefaultUnit = null; // The questionnaire-unitOption extension is only for item.type = quantity

    var unitOption = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnitOption, 0, true);

    if (unitOption && unitOption.length > 0) {
      if (qItem.type !== 'quantity') {
        throw new Error('The extension ' + self.fhirExtUrlUnitOption + ' can only be used with type quantity.  Question "' + qItem.text + '" is of type ' + qItem.type);
      }

      for (var i = 0; i < unitOption.length; i++) {
        var coding = unitOption[i].valueCoding;
        var lUnit = {
          name: coding.display,
          code: coding.code,
          system: coding.system
        };
        lformsUnits.push(lUnit);
      }
    } // The questionnaire-unit extension is only for item.type = integer or decimal


    var unit = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlUnit);

    if (unit) {
      if (qItem.type !== 'integer' && qItem.type !== 'decimal') {
        throw new Error('The extension ' + self.fhirExtUrlUnit + ' can only be used with types integer or decimal.  Question "' + qItem.text + '" is of type ' + qItem.type);
      }

      lformsDefaultUnit = {
        name: unit.valueCoding.display,
        code: unit.valueCoding.code,
        system: unit.valueCoding.system,
        default: true
      };
      lformsUnits.push(lformsDefaultUnit);
    }

    if (qItem.type === 'quantity') {
      let initialQ = this.getFirstInitialQuantity(qItem);

      if (initialQ && initialQ.unit) {
        lformsDefaultUnit = LForms.Util.findItem(lformsUnits, 'name', initialQ.unit);

        if (lformsDefaultUnit) {
          lformsDefaultUnit.default = true;
        } else {
          lformsDefaultUnit = {
            name: initialQ.unit,
            code: initialQ.code,
            system: initialQ.system,
            default: true
          };
          lformsUnits.push(lformsDefaultUnit);
        }
      }
    }

    if (lformsUnits.length > 0) {
      if (!lformsDefaultUnit) {
        lformsUnits[0].default = true;
      }

      lfItem.units = lformsUnits;
    }
  };
  /**
   * Parse questionnaire item for display control
   *
   * @param lfItem {object} - LForms item object to assign display control
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processDisplayControl = function (lfItem, qItem) {
    var itemControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);

    if (itemControlType) {
      var displayControl = {};

      switch (itemControlType.valueCodeableConcept.coding[0].code) {
        case 'Lookup': // backward-compatibility with old export

        case 'Combo-box': // backward-compatibility with old export

        case 'autocomplete':
          lfItem.isSearchAutocomplete = true;
        // continue to drop-down case

        case 'drop-down':
          displayControl.answerLayout = {
            type: 'COMBO_BOX'
          };
          break;

        case 'Checkbox': // backward-compatibility with old export

        case 'check-box':
        case 'Radio': // backward-compatibility with old export

        case 'radio-button':
          displayControl.answerLayout = {
            type: 'RADIO_CHECKBOX'
          };
          var answerChoiceOrientation = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtChoiceOrientation);

          if (answerChoiceOrientation) {
            if (answerChoiceOrientation.valueCode === "vertical") {
              displayControl.answerLayout.columns = "1";
            } else if (answerChoiceOrientation.valueCode === "horizontal") {
              displayControl.answerLayout.columns = "0";
            }
          }

          break;

        case 'Table': // backward-compatibility with old export

        case 'gtable':
          // Not in STU3, but we'll accept it
          if (lfItem.dataType === 'SECTION') {
            displayControl.questionLayout = "horizontal";
          }

          break;

        case 'Matrix': // backward-compatibility with old export

        case 'table':
          if (lfItem.dataType === 'SECTION') {
            displayControl.questionLayout = "matrix";
          }

          break;

        default:
          displayControl = null;
      }

      if (displayControl && !LForms.jQuery.isEmptyObject(displayControl)) {
        lfItem.displayControl = displayControl;
      }
    }
  };
  /**
   * Parse questionnaire item for data control
   *
   * @param lfItem {object} - LForms item object to assign data control
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processDataControl = function (lfItem, qItem) {
    var dataControlType = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlDataControl);

    if (dataControlType && dataControlType.valueString) {
      try {
        var dataControl = JSON.parse(dataControlType.valueString);

        if (dataControl) {
          lfItem.dataControl = dataControl;
        }
      } catch (e) {
        console.log("Invalid dataControl data!");
      }
    }
  };
  /**
   * Parse questionnaire item for "hidden" extension
   *
   * @param lfItem {object} - LForms item object to be assigned the isHiddenInDef flag if the item is to be hidden.
   * @param qItem {object} - Questionnaire item object
   * @private
   * @return true if the item is hidden or if its ancestor is hidden, false otherwise
   */


  self._processHiddenItem = function (lfItem, qItem) {
    var ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlHidden);

    if (ci) {
      lfItem.isHiddenInDef = typeof ci.valueBoolean === 'boolean' ? ci.valueBoolean : ci.valueBoolean === 'true';
    }

    return lfItem.isHiddenInDef;
  }; // ---------------- QuestionnaireResponse Import ---------------


  var qrImport = self._mergeQR;
  /**
   * Merge a QuestionnaireResponse instance into an LForms form object
   * @param formData an LForms form definition or LFormsData object.
   * @param qr a QuestionnaireResponse instance
   * @returns {{}} an updated LForms form definition, with answer data
   */

  qrImport.mergeQuestionnaireResponseToLForms = function (formData, qr) {
    if (!(formData instanceof LForms.LFormsData)) {
      // get the default settings in case they are missing in the form data
      // not to set item values by default values for saved forms with user data
      formData.hasSavedData = true;
      formData = new LForms.LFormsData(formData).getFormData();
    } // The reference to _mergeQR below is here because this function gets copied to
    // the containing object to be a part of the public API.


    var qrInfo = qrImport._getQRStructure(qr);

    qrImport._processQRItemAndLFormsItem(qrInfo, formData);

    return formData;
  };
  /**
   * Merge data into items on the same level
   * @param parentQRItemInfo structural information of a parent item
   * @param parentLFormsItem a parent item, could be a LForms form object or a form item object.
   * @private
   */


  qrImport._processQRItemAndLFormsItem = function (parentQRItemInfo, parentLFormsItem) {
    // note: parentQRItemInfo.qrItemInfo.length will increase when new data is inserted into the array
    for (var i = 0; i < parentQRItemInfo.qrItemsInfo.length; i++) {
      var qrItemInfo = parentQRItemInfo.qrItemsInfo[i];
      var qrItem = qrItemInfo.item;

      if (qrItem) {
        // first repeating qrItem
        if (qrItemInfo.total > 1 && qrItemInfo.index === 0) {
          var defItem = this._findTheMatchingItemByLinkId(parentLFormsItem, qrItemInfo.linkId); // add repeating items in form data
          // if it is a case of repeating questions, not repeating answers


          if (ns._questionRepeats(defItem)) {
            this._addRepeatingItems(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.total); // add missing qrItemInfo nodes for the newly added repeating LForms items (questions, not sections)


            if (defItem.dataType !== 'SECTION' && defItem.dataType !== 'TITLE') {
              for (var j = 1; j < qrItemInfo.total; j++) {
                var newQRItemInfo = LForms.Util.deepCopy(qrItemInfo);
                newQRItemInfo.index = j;
                newQRItemInfo.item.answer = [newQRItemInfo.item.answer[j]];

                if (qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[j]) {
                  newQRItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[j]];
                }

                parentQRItemInfo.qrItemsInfo.splice(i + j, 0, newQRItemInfo);
              } // change the first qr item's answer too


              qrItemInfo.item.answer = [qrItemInfo.item.answer[0]];

              if (qrItemInfo.qrAnswersItemsInfo && qrItemInfo.qrAnswersItemsInfo[0]) {
                qrItemInfo.qrAnswersItemsInfo = [qrItemInfo.qrAnswersItemsInfo[0]];
              } else {
                delete qrItemInfo.qrAnswersItemsInfo;
              }
            }
          } // reset the total number of questions when it is the answers that repeats
          else if (ns._answerRepeats(defItem)) {
            qrItemInfo.total = 1;
          }
        } // find the matching LForms item


        var item = this._findTheMatchingItemByLinkIdAndIndex(parentLFormsItem, qrItemInfo.linkId, qrItemInfo.index); // set up value and units if it is a question


        if (item.dataType !== 'SECTION' && item.dataType !== 'TITLE') {
          var qrAnswer = qrItem.answer;

          if (qrAnswer && qrAnswer.length > 0) {
            this._setupItemValueAndUnit(qrItem.linkId, qrAnswer, item); // process item.answer.item, if applicable


            if (qrItemInfo.qrAnswersItemsInfo) {
              // _setupItemValueAndUnit seems to assume single-answer except for multiple choices on CNE/CWE
              // moreover, each answer has already got its own item above if question repeats
              if (qrItemInfo.qrAnswersItemsInfo.length > 1) {
                throw new Error('item.answer.item with item.answer.length > 1 is not yet supported');
              }

              this._processQRItemAndLFormsItem(qrItemInfo.qrAnswersItemsInfo[0], item);
            }
          }
        } // process items on the sub-level


        if (qrItemInfo.qrItemsInfo && qrItemInfo.qrItemsInfo.length > 0) {
          this._processQRItemAndLFormsItem(qrItemInfo, item);
        }
      }
    }
  };
  /**
   * Set value and units on a LForms item
   * @param linkId a QuestionnaireResponse item's linkId
   * @param answer value for the item in QuestionnaireResponse
   * @param item a LForms item
   * @private
   */


  qrImport._setupItemValueAndUnit = function (linkId, answer, item) {
    if (item && linkId === item.linkId && item.dataType !== 'SECTION' && item.dataType !== 'TITLE') {
      var dataType = item.dataType; // any one has a unit must be a numerical type, let use REAL for now.
      // dataType conversion should be handled when panel data are added to lforms-service.

      if ((!dataType || dataType === "ST") && item.units && item.units.length > 0) {
        item.dataType = dataType = "REAL";
      }

      var qrValue = answer[0];

      switch (dataType) {
        case "BL":
          if (qrValue.valueBoolean === true || qrValue.valueBoolean === false) {
            item.value = qrValue.valueBoolean;
          }

          break;

        case "INT":
          if (qrValue.hasOwnProperty('valueQuantity')) {
            item.value = qrValue.valueQuantity.value;

            if (qrValue.valueQuantity.code) {
              item.unit = {
                name: qrValue.valueQuantity.code
              };
            }
          } else if (qrValue.hasOwnProperty('valueInteger')) {
            // has an answer list
            if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
              // answer repeats (autocomplete or checkboxes)
              ns._processOtherAnswerOptionValueInQR(answer, item);
            } // normal item
            else {
              item.value = qrValue.valueInteger;
            }
          }

          break;

        case "REAL":
        case "QTY":
          if (qrValue.hasOwnProperty('valueQuantity')) {
            var quantity = qrValue.valueQuantity;
            var lformsQuantity = (0,_import_common_js__WEBPACK_IMPORTED_MODULE_1__.importFHIRQuantity)(quantity);

            LForms.Util._internalUtil.assignValueToItem(item, lformsQuantity, 'Quantity');
          } else if (qrValue.hasOwnProperty('valueDecimal')) {
            item.value = qrValue.valueDecimal;
          }

          break;

        case "DT":
          // has an answer list
          if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
            // answer repeats (autocomplete or checkboxes)
            ns._processOtherAnswerOptionValueInQR(answer, item);
          } // normal item
          else {
            item.value = qrValue.valueDate;
          }

          break;

        case "TM":
          // has an answer list
          if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
            // answer repeats (autocomplete or checkboxes)
            ns._processOtherAnswerOptionValueInQR(answer, item);
          } // normal item
          else {
            item.value = qrValue.valueTime;
          }

          break;

        case "DTM":
          item.value = qrValue.valueDateTime;
          break;

        case "CNE":
        case "CWE":
          if (ns._answerRepeats(item)) {
            var value = [];

            for (var j = 0, jLen = answer.length; j < jLen; j++) {
              var val = ns._processCWECNEValueInQR(answer[j], item);

              if (val) {
                value.push(val);
              }
            }

            item.value = value;
          } else {
            var val = ns._processCWECNEValueInQR(qrValue, item);

            if (val) {
              item.value = val;
            }
          }

          break;

        case "ST":
          // has an answer list
          if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
            // answer repeats (autocomplete or checkboxes)
            ns._processOtherAnswerOptionValueInQR(answer, item);
          } // normal item
          else {
            item.value = qrValue.valueString;
          }

          break;

        case "TX":
          item.value = qrValue.valueString;
          break;

        case "attachment":
          item.value = qrValue.valueAttachment;
          break;

        case "SECTION":
        case "TITLE":
        case "":
          // do nothing
          break;

        default:
          item.value = qrValue.valueString;
      }
    }
  };
  /**
   * Get LForms data type from questionnaire item
   *
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._getDataType = function (qItem) {
    var type = 'string';

    switch (qItem.type) {
      case 'string':
        type = 'ST';
        break;

      case 'group':
        type = 'SECTION';
        break;

      case "choice":
        type = 'CNE';
        break;

      case "open-choice":
        type = 'CWE';
        break;

      case 'integer':
        type = 'INT';
        break;

      case 'decimal':
        type = 'REAL';
        break;

      case 'text':
        type = 'TX';
        break;

      case "boolean":
        type = 'BL';
        break;

      case "date":
        //dataType = 'date';
        type = 'DT';
        break;

      case "dateTime":
        type = 'DTM';
        break;

      case "time":
        type = 'TM';
        break;

      case "display":
        type = 'TITLE';
        break;

      case "url":
        type = 'URL';
        break;

      case "quantity":
        type = 'QTY';
        break;

      case "attachment":
        type = 'attachment';
        break;
    }

    return type;
  };
  /**
   * Build a map of items to linkid from a questionnaire resource.
   * @param qResource - FHIR Questionnaire resource
   * @returns {*} - Hash object with link id keys pointing to their respective items.
   * @private
   */


  self._createLinkIdItemMap = function (qResource) {
    var traverse = function (itemArray, collection) {
      itemArray.forEach(function (item) {
        collection[item.linkId] = item;

        if (item.item) {
          traverse(item.item, collection);
        }
      });
      return collection;
    };

    var ret = {};

    if (qResource.item) {
      ret = traverse(qResource.item, ret);
    }

    return ret;
  };
  /**
   * Get an object with code and code system
   *
   * @param questionnaireItemOrResource {object} - question
   * @private
   */


  self._getCode = function (questionnaireItemOrResource) {
    var code = null;

    if (questionnaireItemOrResource && Array.isArray(questionnaireItemOrResource.code) && questionnaireItemOrResource.code.length) {
      code = {
        code: questionnaireItemOrResource.code[0].code,
        system: self._toLfCodeSystem(questionnaireItemOrResource.code[0].system)
      };
    } // If code is missing look for identifier.
    else if (questionnaireItemOrResource && Array.isArray(questionnaireItemOrResource.identifier) && questionnaireItemOrResource.identifier.length) {
      code = {
        code: questionnaireItemOrResource.identifier[0].value,
        system: self._toLfCodeSystem(questionnaireItemOrResource.identifier[0].system)
      };
    }

    return code;
  };
  /**
   *  Converts the given ValueSet into an array of answers that can be used with a prefetch autocompleter.
   * @return the array of answers, or null if the extraction cannot be done.
   */


  self.answersFromVS = function (valueSet) {
    var vs = valueSet;
    var rtn = [];

    if (vs.expansion && vs.expansion.contains && vs.expansion.contains.length > 0) {
      vs.expansion.contains.forEach(function (vsItem) {
        var answer = {
          code: vsItem.code,
          text: vsItem.display,
          system: vsItem.system
        };
        var ordExt = LForms.Util.findObjectInArray(vsItem.extension, 'url', self.fhirExtUrlValueSetScore);

        if (ordExt) {
          answer.score = ordExt.valueDecimal;
        }

        rtn.push(answer);
      });
    }

    return rtn.length > 0 ? rtn : null;
  };
  /**
   * Convert the given code system to LForms internal code system. Currently
   * only converts 'http://loinc.org' to 'LOINC' and returns all other input as is.
   * @param codeSystem
   * @private
   */


  self._toLfCodeSystem = function (codeSystem) {
    var ret = codeSystem;

    switch (codeSystem) {
      case 'http://loinc.org':
        ret = 'LOINC';
        break;
    }

    return ret;
  }; // Copy the main merge function to preserve the same API usage.


  self.mergeQuestionnaireResponseToLForms = qrImport.mergeQuestionnaireResponseToLForms;
  /**
   *  Processes the terminology server setting, if any.
   *
   * @param lfItem - LForms form or item object to receive the terminology
   *  server setting.
   * @param qItem - Questionnaire or Questionnaire item object
   * @private
   */

  self._processTerminologyServer = function (lfItem, qItem) {
    var tServer = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtTerminologyServer);

    if (tServer && tServer.valueUrl) {
      lfItem.terminologyServer = tServer.valueUrl;
    }
  };
  /**
   * Parse Questionnaire item for externallyDefined url
   *
   * @param lfItem - LForms item object to assign externallyDefined
   * @param qItem - Questionnaire item object
   * @private
   */


  self._processExternallyDefined = function (lfItem, qItem) {
    var externallyDefined = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlExternallyDefined);

    if (externallyDefined && externallyDefined.valueUri) {
      lfItem.externallyDefined = externallyDefined.valueUri;
    }
  };
  /**
   *  Finds the terminology server URL (if any) for the given item.
   * @param item a question, title, or group in the form (in the LFormsData
   *  structure, not the Questionnaire).
   * @return the base terminology server URL, or undefined if there isn't one
   *  for this item.
   */


  self._getTerminologyServer = function (item) {
    var terminologyServer = item.terminologyServer;
    var parent = item._parentItem;

    while (!terminologyServer && parent) {
      terminologyServer = parent.terminologyServer;
      parent = parent._parentItem;
    }

    return terminologyServer;
  };
  /**
   *  Returns the URL for performing a ValueSet expansion for the given item,
   *  if the given item has a terminology server and answerValueSet
   *  configured; otherwise it returns undefined.
   * @param item a question, title, or group in the form
   */


  self._getExpansionURL = function (item) {
    var rtn;

    if (item.answerValueSet) {
      var terminologyServer = this._getTerminologyServer(item);

      if (terminologyServer) rtn = terminologyServer + '/ValueSet/$expand?url=' + item.answerValueSet;
    }

    return rtn;
  };
  /**
   *  Loads answerValueSets for prefetched lists.
   * @param lfData the LFormsData for the form
   * @return an array of promise objects which resolve when the answer valuesets
   * have been loaded and imported.
   */


  self.loadAnswerValueSets = function (lfData) {
    var pendingPromises = [];
    var items = lfData.itemList;

    for (var i = 0, len = items.length; i < len; ++i) {
      let item = items[i];

      if (item.answerValueSet && !item.isSearchAutocomplete) {
        let expURL = this._getExpansionURL(item);

        let vsKey = expURL ? expURL : item.answerValueSet;
        item._answerValueSetKey = vsKey;
        if (!LForms._valueSetAnswerCache) LForms._valueSetAnswerCache = {};
        let answers = LForms._valueSetAnswerCache[vsKey];

        if (answers) {
          item.answers = answers;

          lfData._updateAutocompOptions(item);

          lfData._resetItemValueWithAnswers(item);
        } else {
          // if not already loaded
          if (expURL) {
            pendingPromises.push(fetch(expURL).then(function (response) {
              return response.json();
            }).then(function (parsedJSON) {
              if (parsedJSON.resourceType === "OperationOutcome") {
                var errorOrFatal = parsedJSON.issue.find(item => item.severity === "error" || item.severity === "fatal");

                if (errorOrFatal) {
                  throw new Error(errorOrFatal.diagnostics);
                }
              } else {
                answers = self.answersFromVS(parsedJSON);

                if (answers) {
                  LForms._valueSetAnswerCache[expURL] = answers;
                  item.answers = answers;

                  lfData._updateAutocompOptions(item);

                  lfData._resetItemValueWithAnswers(item);
                }
              }
            }).catch(function (error) {
              throw new Error("Unable to load ValueSet from " + expURL);
            }));
          } else {
            // use FHIR context
            var fhirClient = LForms.fhirContext.client;
            pendingPromises.push(fhirClient.request(lfData._buildURL(['ValueSet', '$expand'], {
              url: item.answerValueSet
            })).then(function (response) {
              var valueSet = response;
              var answers = self.answersFromVS(valueSet);

              if (answers) {
                LForms._valueSetAnswerCache[vsKey] = answers;
                item.answers = answers;

                lfData._updateAutocompOptions(item);

                lfData._resetItemValueWithAnswers(item);
              }
            }).catch(function (error) {
              throw new Error("Unable to load ValueSet " + item.answerValueSet + " from FHIR server");
            }));
          }
        }
      }
    }

    return pendingPromises;
  };
  /**
   * Handle the item.value in QuestionnaireResponse for CWE/CNE typed items
   * @param qrItemValue a value of item in QuestionnaireResponse
   * @param lfItem an item in lforms
   * @param notOnList a flag indicates if the item's value is known to be not any of the answers
   * in the answer list. If false or undefined, a check of the answers will be made.
   * @returns {{code: *, text: *}}
   * @private
   */


  self._processCWECNEValueInQR = function (qrItemValue, lfItem, notOnList) {
    var retValue; // a valueCoding, which is one of the answers

    if (qrItemValue.valueCoding) {
      var c = qrItemValue.valueCoding;
      retValue = {};
      if (c.code) retValue.code = c.code;
      if (c.display) retValue.text = c.display;
      if (c.system) retValue.system = c.system;

      if (notOnList) {
        retValue._notOnList = true;
      } // compare retValue to the item.answers
      // if not same, add "_notOnList: true" to retValue
      else if (lfItem.dataType === 'CWE' && lfItem.answers) {
        var found = false;

        for (var i = 0, len = lfItem.answers.length; i < len; i++) {
          if (LForms.Util.areTwoAnswersSame(retValue, lfItem.answers[i], lfItem)) {
            found = true;
            break;
          }
        }

        if (!found) {
          retValue._notOnList = true;
        }
      }
    } // a valueString, which is a user supplied value that is not in the answers
    else if (qrItemValue.valueString) {
      retValue = qrItemValue.valueString;
    }

    return retValue;
  };
  /**
   * Handle the item.value in QuestionnaireResponse for ST/INT/DT/TM typed items
   * that have an answer list.
   * @param {*} answer an answer of an item in QuestionnaireResponse
   * @param {*} lfItem an item in lforms
   * @returns
   */


  self._processOtherAnswerOptionValueInQR = function (answer, item) {
    // has an answer list
    if (_lib_lforms_internal_utils_js__WEBPACK_IMPORTED_MODULE_0__.InternalUtil.hasAnswerList(item)) {
      // answer repeats (autocomplete or checkboxes)
      if (ns._answerRepeats(item)) {
        var value = [];

        for (var j = 0, jLen = answer.length; j < jLen; j++) {
          var val = ns._convertOtherAnswerOptionValueInQR(answer[j], item);

          if (val) {
            value.push(val);
          }
        }

        item.value = value;
      } // answer not repeats, (autocomplete or radiobuttons)
      else {
        item.value = ns._convertOtherAnswerOptionValueInQR(answer[0], item);
      }
    }
  };
  /**
   * Convert FHIR values in QuestionnaireResponse for ST/INT/DT/TM typed items
   * that have an answer list, to lforms values
   * @param {*} qrItemValue a value of item in QuestionnaireResponse
   * @param {*} lfItem an item in lforms
   * @returns
   */


  self._convertOtherAnswerOptionValueInQR = function (qrItemValue, lfItem) {
    let retValue;
    let dataType = lfItem.dataType;

    if (lfItem.answers && (dataType === "ST" || dataType === "INT" || dataType === "DT" || dataType === "TM")) {
      let answerText;

      switch (dataType) {
        case "ST":
          answerText = qrItemValue.valueString;
          break;

        case "INT":
          answerText = qrItemValue.valueInteger;
          break;

        case "DT":
          answerText = qrItemValue.valueDate;
          break;

        case "TM":
          answerText = qrItemValue.valueTime;
          break;
      }

      if (answerText) retValue = {
        text: answerText
      };
    } // compare retValue to the item.answers


    for (var i = 0, len = lfItem.answers.length; i < len; i++) {
      if (LForms.Util.areTwoAnswersSame(retValue, lfItem.answers[i], lfItem)) {
        retValue = lfItem.answers[i];
        break;
      }
    }

    return retValue; // retValue might not be in the answers? R5 allows that.
  };
  /**
   * Parse questionnaire item for coding instructions
   *
   * @param qItem {object} - Questionnaire item object
   * @return {{}} an object contains the coding instructions info.
   * @private
   */


  self._processCodingInstructions = function (qItem) {
    // if the qItem is a "display" typed item with a item-control extension, then it meant to be a help message,
    // which in LForms is an attribute of the parent item, not a separate item.
    let ret = null;
    let ci = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlItemControl);
    let xhtmlFormat;

    if (qItem.type === "display" && ci) {
      // only "redering-xhtml" is supported. others are default to text
      if (qItem._text) {
        xhtmlFormat = LForms.Util.findObjectInArray(qItem._text.extension, 'url', "http://hl7.org/fhir/StructureDefinition/rendering-xhtml");
      } // there is a xhtml extension


      if (xhtmlFormat) {
        ret = {
          codingInstructionsFormat: "html",
          codingInstructions: xhtmlFormat.valueString,
          codingInstructionsPlain: qItem.text // this always contains the coding instructions in plain text

        };
      } // no xhtml extension, default to 'text'
      else {
        ret = {
          codingInstructionsFormat: "text",
          codingInstructions: qItem.text,
          codingInstructionsPlain: qItem.text // this always contains the coding instructions in plain text

        };
      }
    }

    return ret;
  };
  /**
   *  Processes the child items of the item.
   * @param targetItem the LForms node being populated with data
   * @param qItem the Questionnaire (item) node being imported
   * @param linkIdItemMap - Map of items from link ID to item from the imported resource.
   * @param containedVS - contained ValueSet info, see _extractContainedVS() for data format details
   */


  self._processChildItems = function (targetItem, qItem, containedVS, linkIdItemMap) {
    if (Array.isArray(qItem.item)) {
      targetItem.items = [];

      for (var i = 0; i < qItem.item.length; i++) {
        var help = self._processCodingInstructions(qItem.item[i]); // pick one coding instruction if there are multiple ones in Questionnaire


        if (help !== null) {
          targetItem.codingInstructions = help.codingInstructions;
          targetItem.codingInstructionsFormat = help.codingInstructionsFormat;
          targetItem.codingInstructionsPlain = help.codingInstructionsPlain;
        } else {
          var item = self._processQuestionnaireItem(qItem.item[i], containedVS, linkIdItemMap);

          targetItem.items.push(item);
        }
      }
    }
  };
  /**
   *  Copy extensions that haven't been handled before.
   *
   * @param lfItem the LForms node being populated with data
   * @param qItem the Questionnaire (item) node being imported
   */


  self._processExtensions = function (lfItem, qItem) {
    var extensions = [];

    if (Array.isArray(qItem.extension)) {
      for (var i = 0; i < qItem.extension.length; i++) {
        var ext = qItem.extension[i];
        var extHandler = self.extensionHandlers[ext.url];

        if (extHandler && extHandler(ext, lfItem) || !self.handledExtensionSet.has(qItem.extension[i].url)) {
          extensions.push(qItem.extension[i]);
        }
      }
    }

    if (extensions.length > 0) {
      lfItem.extension = extensions;
    }
  };
  /**
   * If the given entity is an array, it will return the array length, return -1 otherwise.
   * @param entity the given entity (can be anything) that needs to be tested to see if it's an array
   * @return {number} the array length or -1 if the given entity is not an array.
   * @private
   */


  self._arrayLen = function (entity) {
    return entity && Array.isArray(entity) ? entity.length : -1;
  };
  /**
   * Get structural info of a QuestionnaireResponse item.answer.item in a way similar to that of item.item.
   * If any answer entry in item.answer has items, the qrItemInfo.qrAnswersItemsInfo will be assigned, which
   * will be an array where each element corresponds to one answer element in item.answer. When an answer entry
   * does not have any items, null will be used to fill the position.
   * @param qrItemInfo the structural info of the given item
   * @param item the item in a QuestionnaireResponse object whose answer.item structure is to be created.
   * @private
   */


  self._checkQRItemAnswerItems = function (qrItemInfo, item) {
    var answerLen = self._arrayLen(item.answer);

    if (answerLen < 1) {
      return;
    }

    var numAnswersWithItems = 0;
    var answersItemsInfo = []; // one entry for each answer; each entry is an qrItemsInfo array for the answer.item

    for (var i = 0; i < answerLen; i++) {
      if (this._arrayLen(item.answer[i].item) > 0) {
        answersItemsInfo.push({});

        self._mergeQR._checkQRItems(answersItemsInfo[i], item.answer[i]);

        ++numAnswersWithItems;
      } else {
        answersItemsInfo.push(null);
      }
    }

    if (numAnswersWithItems > 0) {
      qrItemInfo.numAnswersWithItems = numAnswersWithItems;
      qrItemInfo.qrAnswersItemsInfo = answersItemsInfo;
    }
  };
  /**
   * Parse questionnaire item for restrictions
   *
   * @param lfItem {object} - LForms item object to assign restrictions
   * @param qItem {object} - Questionnaire item object
   * @private
   */


  self._processRestrictions = function (lfItem, qItem) {
    var restrictions = {};

    if (typeof qItem.maxLength !== 'undefined') {
      restrictions['maxLength'] = qItem.maxLength.toString();
    }

    for (var i = 0; i < self.fhirExtUrlRestrictionArray.length; i++) {
      var restriction = LForms.Util.findObjectInArray(qItem.extension, 'url', self.fhirExtUrlRestrictionArray[i]);

      var val = self._getFHIRValueWithPrefixKey(restriction, /^value/);

      if (val !== undefined && val !== null) {
        if (restriction.url.match(/minValue$/)) {
          // TODO -
          // There is no distinction between inclusive and exclusive.
          // Lforms looses this information when converting back and forth.
          restrictions['minInclusive'] = val;
        } else if (restriction.url.match(/maxValue$/)) {
          restrictions['maxInclusive'] = val;
        } else if (restriction.url.match(/minLength$/)) {
          restrictions['minLength'] = val;
        } else if (restriction.url.match(/regex$/)) {
          restrictions['pattern'] = val;
        }
      }
    }

    if (!LForms.jQuery.isEmptyObject(restrictions)) {
      lfItem.restrictions = restrictions;
    }
  };
}

/* harmony default export */ __webpack_exports__["default"] = (addCommonSDCImportFns);

/***/ }),
/* 102 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InternalUtil": function() { return /* binding */ InternalUtil; }
/* harmony export */ });
/* harmony import */ var _error_messages_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(103);
/* harmony import */ var _lforms_lhc_common_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(104);
// Utility functions for files in the lforms project, not intended to be called
// by application code.


/**
 *  A default message source identifier (for when the messageSource parameter
 *  below is optional and not provided.
 */

const defaultMsgSource = 'Other message source';
const InternalUtil = {
  /**
   *  Sets the value of the item, which is the case of a quantity, involves more
   *  than one field (at present -- that might change.)
   * @param item the item receiving the value.
   * @param val the new value, which if it its origin was FHIR, should have
   *  already been processed and converted.  A quantity value is expected to be an Object with
   *  a _type key set to Quantity but with the LForms fields for units ('name',
   *  'code', and 'system'), plus a "value" field.
   * @param type (optional) the type of the value, e.g. 'Quantity'.  If this is
   *  set, then val._type will not be checked.
   * @return {boolean} whether the item.value or item.unit has changed.
   */
  assignValueToItem: function (item, val, type) {
    var changed = false;
    type = type || val && val._type;

    if (val && type === 'Quantity') {
      if (item.value !== val.value) {
        item.value = val.value;
        changed = true;
      }

      var newUnit = {
        name: val.name
      };

      if (val.code) {
        newUnit.code = val.code;
        if (val.system) newUnit.system = val.system;
      }

      if (!_lforms_lhc_common_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].deepEqual(item.unit, newUnit)) {
        item.unit = newUnit;
        changed = true;
      }
    } else if (!_lforms_lhc_common_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].deepEqual(item.value, val)) {
      item.value = val;
      changed = true;
    }

    return changed;
  },

  /**
   *  Constructs a model object for an off-list unit.
   * @param unitText the text the user typed for the off-list unit
   * @return an object suitable for item.unit.
   */
  modelForOffListUnit: function (text) {
    return text ? {
      "name": text,
      "_displayUnit": text
    } : undefined;
  },

  /**
   *  Sets the "messages" attribute of the given item.  If the given array of
   *  messages object only consists of nulls (no messages), then the messages
   *  attribute will be removed from the item.
   * @param item an item from and lforms form definition
   * @param messages an array of message objects (see _convertFHIRValues for
   * details)
   * @param messageSource a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.
   */
  setItemMessagesArray: function (item, messages, messageSource) {
    // Consolidate the array of message objects into one object for this item.
    // The code below is optimized for the usual case where there are no messages.
    let itemMsg, msgTypes;

    for (let m of messages) {
      if (m) {
        if (!itemMsg) {
          itemMsg = {
            errors: {},
            warnings: {},
            info: {}
          };
          msgTypes = Object.keys(itemMsg);
        }

        for (let t of msgTypes) {
          if (m[t]) {
            Object.assign(itemMsg[t], m[t]);
          }
        }
      }
    }

    this.setItemMessages(item, itemMsg, messageSource);
  },

  /**
   *  Updates the "messages" attribute of the given item.  Any extisting
   *  messages are preserved, and new messages are added.  Note that these
   *  messages are statements about things that happened, not validation.
   * @param item an item from and lforms form definition
   * @param messages a message object (see _convertFHIRValues for
   *  details).  May be null or undefined to remove the messages for
   *  messageSource.
   * @param messageSource a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.
   */
  setItemMessages: function (item, messages, messageSource) {
    if (messages) {
      if (!item.messages) item.messages = {};
      item.messages[messageSource] = messages;
    } else if (item.messages) {
      delete item.messages[messageSource];
      if (!Object.keys(item.messages).length) delete item.messages;
    }
  },

  /**
   *  Adds a warning message to the given item.
   * @param item the item which should get the warning.
   * @param messageID the ID of the warning message
   * @param messageSource (optional) a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.  If not provided a
   *  default source identifier will be used
   */
  addItemWarning: function (item, messageID, messageSource) {
    if (!messageSource) messageSource = 'Other message source';
    let msgObj = item.messages;
    if (!msgObj) msgObj = item.messages = {};
    let msgsFromSource = msgObj[messageSource];
    if (!msgsFromSource) msgsFromSource = msgObj[messageSource] = {};
    let warnings = msgsFromSource.warnings;
    if (!warnings) warnings = msgsFromSource.warnings = {};
    warnings[messageID] = _error_messages_js__WEBPACK_IMPORTED_MODULE_0__.ErrorMessages.getMsg(messageID);
    console.log(JSON.stringify(item.messages));
  },

  /**
   *  Removes a warning message from the given item.
   * @param item the item which has the warning.
   * @param messageID the ID of the warning message
   * @param messageSource (optional) a string indentifier for the source of these messages,
   *  to distinguish them from messages from other sources.  If not provided a
   *  default source identifier will be used
   */
  removeItemWarning: function (item, messageID, messageSource) {
    if (!messageSource) messageSource = 'Other message source';
    let msgs, msgsFromSource, warnings;

    if ((msgs = item.messages) && (msgsFromSource = msgs[messageSource]) && (warnings = msgsFromSource.warnings)) {
      delete warnings[messageID];
    }
  },

  /**
   *  Check if the lforms item has an answer list
   * @param {*} item 
   * @returns 
   */
  hasAnswerList: function (item) {
    return item.dataType === "CNE" || item.dataType === "CWE" || item.answers && (item.dataType === "ST" || item.dataType === "INT" || item.dataType === "DT" || item.dataType === "TM");
  }
};
InternalUtil.errorMessages = _error_messages_js__WEBPACK_IMPORTED_MODULE_0__.ErrorMessages; // Set the default language for error messages.  Apps can call this with a
// different language code, if error-messages.js has messages in that language.

InternalUtil.errorMessages.setLanguage('en');

/***/ }),
/* 103 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorMessages": function() { return /* binding */ ErrorMessages; }
/* harmony export */ });
/**
 *  A class for retrieving error messages (or warnings or info messages).
 *  These messages are intended to be about things that happened, not about
 *  validation, because there is no good way to remove the old messages when
 *  they don't apply without adversely impacting peformance.
 */
const ErrorMessages = {
  messages: {
    'comparatorInQuantity': {
      'en': 'This item cannot accept a quantity with a comparator'
    },
    'nonMatchingQuantityUnit': {
      'en': 'An attempt was made to assign a quantity with a non-matching unit.'
    },
    'MultipleValuesForNonRepeat': {
      'en': 'An attempt was made to assign multiple values to a non-repeating item.'
    }
  },

  /**
   *  Returns the text for a message.
   * @param messageID the id of the message
   * @return the text corresponding to messageID.
   */
  getMsg: function (messageID) {
    const messageData = this.messages[messageID];
    if (!messageData) throw new Error('Unknown message ID "' + messageID + '"');
    const message = messageData[this.language];
    if (!message) throw new Error('Unknown language code "' + this.language + '" for message ID "' + messageID + '"');
    return message;
  },

  /**
   *  Adds the message with the given ID to the given message object.
   * @param msgObj an object to which the message will be added, with the given
   * messageID as the key and the text as the value.
   * @param messageID the id of the message
   */
  addMsg: function (msgObj, messageID) {
    msgObj[messageID] = this.getMsg(messageID);
  },

  /**
   *  Sets the language code used by getMsg.
   * @param language the language code for the message.  This must be one of the
   *  languages of the messages above.
   */
  setLanguage: function (language) {
    this.language = language;
  }
};

/***/ }),
/* 104 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(105);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fast_copy__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(242);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(deep_equal__WEBPACK_IMPORTED_MODULE_2__);
/**
 * Common utility functions
 */



const CommonUtils = {
  // Acceptable date formats
  // Strict parsing -
  parseDateFormats: ['M/D/YYYY', 'M/D/YY', 'M/D', 'M-D-YYYY', 'M-D-YY', 'M-D', 'YYYY', 'YYYY-M-D', 'YYYY/M/D', (moment__WEBPACK_IMPORTED_MODULE_0___default().ISO_8601), 'M/D/YYYY HH:mm', 'M/D/YY HH:mm', 'M/D HH:mm', 'M-D-YYYY HH:mm', 'M-D-YY HH:mm', 'M-D HH:mm'],
  intRegex: /^\s*(\+|-)?\d+\s*$/,
  decRegex: /^\s*[\+-]?([\+-]?\d+\.?\d*([eE]?[\+|-]?\d+)?|[\+-]?\d*\.?\d+[eE]?([\+|-]?\d+)?)\s*$/,

  /**
   * Check if two answers can be treated as same
   * @param answer an answer item that could have part of the attributes set. 
   * It should be an object, or this function will return false.
   * @param completeAnswer an answer in the answer list that usually has more attributes set
   * @param item the lforms item that has the completeAnswer in the answer list
   * @return {boolean} whether two answers are considered same.
   */
  areTwoAnswersSame: function (answer, completeAnswer, item) {
    let standardAnswerAttr = ['label', 'code', 'text', 'score', 'other']; //let standardAnswerAttr = ['label', 'code', '_displayText', 'score', 'other'];

    if (typeof answer !== "object") {
      return false;
    } // answer in LForms might not have a codeSystem, check item.answerCodeSystem and form's codeSystem


    let completeAnswerCodeSystem = completeAnswer.system ? completeAnswer.system : item.answerCodeSystem; // check answers' attributes if they have the same code system

    let same = false; // if no code system or same code system

    if (!answer.system && !completeAnswer.system || answer.system === completeAnswerCodeSystem) {
      // check all fields in answer
      same = true;
      let fields = Object.keys(answer);

      for (var i = 0, iLen = fields.length; i < iLen; i++) {
        // not to check extra attributes not specified in specs.
        if (standardAnswerAttr.indexOf(fields[i]) >= 0 && answer[fields[i]] !== completeAnswer[fields[i]]) {
          same = false;
          break;
        }
      }
    }

    return same;
  },

  /**
    * This function and stringToDTDateISO are meant to work as a pair on DT (or FHIR date) data type.
    * The idea is that DT/date type does not have timezone info, as a result, the string value could be
    * off by a day during either way of conversion depending on the time zone the code is executed.
    * The solution here is to keep the literal values of the year, month, and date components remain
    * unchanged regardless of the time zones.
    * Convert the given date object into a DT type date string, in "yyyy-mm-dd" format, where the
    * year, month, and date are based on the "local time zone" as the users can see on the display.
    * @param dateObj the date object to be converted.
    * @return date string in yyyy-mm-dd format with year, month, and date values corresponding to that
    * at the local timezone.
    */
  dateToDTStringISO: function (dateObj) {
    return !dateObj || !(dateObj instanceof Date) || isNaN(dateObj.getTime()) ? undefined : [(10000 + dateObj.getFullYear()).toString().substr(1), (101 + dateObj.getMonth()).toString().substr(1), (100 + dateObj.getDate()).toString().substr(1)].join('-');
  },

  /**
   * Parse the given iso date string, that is, a string of format "yyyy[-mm[-dd]]", into a Date object,
   * and then, adjust the year, month, and day so that when displayed (as local date) the literal values of
   * the year, month, and date components remain unchanged.
   * See the comments/docs for function dateToDTStringISO().
   * @param isoDateString
   */
  stringToDTDateISO: function (isoDateString) {
    var d = new Date(isoDateString);
    return isNaN(d.getTime()) ? undefined : new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
  },

  /**
   * Get a formatted date string from a date object
   * for example: "2016-10-31T14:42:12Z"
   * @param objDate a date object, or a valid string representation of date.
   * @returns a formatted date string
   */
  dateToDTMString: function (objDate) {
    if (typeof objDate === 'string') {
      objDate = this.stringToDate(objDate, true);
    }

    return objDate.toISOString();
  },
  // TODO: move to lhc-form-utils.js

  /**
   * Parse a formatted date string and create a date object
   * @param strDate a formatted date string
   * @param looseParsing {boolean} - Do default parsing. Intended to parse output
   * from native date object, typically from programmatic output from widgets. Default is false.
   * @returns a date object
   */
  stringToDate: function (strDate, looseParsing) {
    if (!strDate || typeof strDate != 'string') {
      // maybe already a date object.
      return strDate;
    }

    if (strDate.trim() === 't') {
      return new Date();
    }

    let m = moment__WEBPACK_IMPORTED_MODULE_0___default()(strDate, this.parseDateFormats, true);

    if (looseParsing && !m.isValid()) {
      // Make another attempt for loose parsing.
      m = moment__WEBPACK_IMPORTED_MODULE_0___default()(strDate);
    }

    return m.isValid() ? m.toDate() : null;
  },

  /**
   * Validate date object or date string. If string, check to see if it is in acceptable formats.
   * See stringToDate() for acceptable formats.
   * @param date {Date | string} - Potential date object or date string
   * @returns boolean
   */
  isValidDate: function (date) {
    return !!this.stringToDate(date);
  },

  /**
   * Format a date object with given format. Refer to momentjs documentation for
   * format specification.
   *
   * @param date - Date object
   * @param format - Format string
   * @returns {string}
   */
  formatDate: function (date, format) {
    return moment__WEBPACK_IMPORTED_MODULE_0___default()(date).format(format);
  },

  /**
   * Get the letter (or letters) indicator for the next repeating instance
   * The letters returned are in the pattern of:
   * 'a','b',...,'z','aa','ab',...,'az','ba','bb',...
   * for index that is:
   *  1,  2, ..., 26, 27,  28, ..., 52,  53,  54, ...
   * @param index the index for the current repeating instance, starting with 1
   */
  getNextLetter: function (index) {
    var letters = "abcdefghijklmnopqrstuvqxyz";
    var positions = [];
    var wkIndex = index;

    while (wkIndex > 0) {
      var letterIndex = wkIndex % 26;
      letterIndex = letterIndex === 0 ? 25 : letterIndex - 1;
      positions.push(letterIndex);
      wkIndex = Math.floor((wkIndex - 1) / 26);
    }

    var nextLetter = "";

    for (var i = positions.length - 1; i >= 0; i--) {
      nextLetter += letters.charAt(positions[i]);
    }

    return nextLetter;
  },
  // TODO: move to lhc-form-utils.js

  /**
   * Finds an object from an array using key/value pair with an optional start index.
   * The matching value should be a primitive type. If start index is not specified,
   * it is assumed to be 0.
   *
   * Only returns the first matched object in the array.
   *
   * @param targetObjects - Array of objects to search using key and value
   * @param key - Key of the target object to match the value.
   * @param matchingValue - Matching value of the specified key.
   * @param starting_index - Optional start index to lookup. Negative number indicates index from end.
   *   The absolute value should be less than the length of items in the array. If not
   *   the starting index is assumed to be 0.
   * @param all - If true, then an array will be returned containing all
   *  matches.
   *
   * @returns {*} - If "all" is false (default), then this returns the first matched
   *  object, or null if none matched.  If "all" is true, then this will return
   *  an array containing any matched objects.
   */
  findObjectInArray: function (targetObjects, key, matchingValue, starting_index, all) {
    var ret = all ? [] : null;

    if (Array.isArray(targetObjects)) {
      var start = 0; // Figure out start index.

      if (starting_index && Math.abs(starting_index) < targetObjects.length) {
        if (starting_index < 0) {
          start = targetObjects.length + starting_index;
        } else {
          start = starting_index;
        }
      }

      var len = targetObjects.length;

      for (var i = start; i < len; i++) {
        if (targetObjects[i][key] === matchingValue) {
          var match = targetObjects[i];
          if (all) ret.push(match);else {
            ret = match;
            break;
          }
        }
      }
    }

    return ret;
  },

  /**
   * Remove key/values from an object based on a regular expression of key.
   *
   * @param obj {object} - Object to prune
   * @param keyRegex {regex} - A regular expression to match the keys for deletion
   * @param recursiveKey {optional|string} - Key of the recursive field. The value
   *                                of this should be an object or an Array of objects.
   * @private
   */
  _pruneObject: function (keyRegex, obj, recursiveKey) {
    if (typeof obj === 'object') {
      for (var k in obj) {
        if (k.match(keyRegex)) {
          delete obj[k];
        } else if (recursiveKey && k === recursiveKey) {
          var val = obj[k];

          if (Array.isArray(val)) {
            var len = val.length;

            for (var i = 0; i < len; i++) {
              this._pruneObject(keyRegex, val[i], recursiveKey);
            }
          } else {
            this._pruneObject(keyRegex, val, recursiveKey);
          }
        }
      }
    }
  },
  // TODO: move to lhc-form-utils.js

  /**
   * Utility to walkthrough recurively through each element in a collection
   *
   * @param collectionObj
   */
  pruneNulls: function (collectionObj) {
    if (Array.isArray(collectionObj)) {
      for (var i = collectionObj.length - 1; i >= 0; i--) {
        if (collectionObj[i] === null || collectionObj[i] === undefined) {
          collectionObj.splice(i, 1);
        } else if (typeof collectionObj[i] === 'object') {
          this.pruneNulls(collectionObj[i]);
        }
      }
    } else if (collectionObj && typeof collectionObj === 'object') {
      var keys = Object.keys(collectionObj);
      keys.forEach(function (key) {
        if (collectionObj[key] === null || collectionObj[key] === undefined) {
          delete collectionObj[key];
        } else if (typeof collectionObj[key] === 'object') {
          this.pruneNulls(collectionObj[key]);
        }
      }, this);
    }
  },

  /**
   * deep copy of an object
   * @param {*} sourceObj an object
   * @returns an copied new object
   */
  deepCopy: function (sourceObj) {
    return fast_copy__WEBPACK_IMPORTED_MODULE_1___default()(sourceObj);
  },

  /**
   * deep comparison of two objects
   * @param {*} obj1 an object
   * @param {*} obj2 an object
   * @returns 
   */
  deepEqual: function (obj1, obj2) {
    return deep_equal__WEBPACK_IMPORTED_MODULE_2___default()(obj1, obj2);
  },

  /**
   * Shallowly compares two JavaScript objects to see if their keys and values are equal.
   * @param obj1
   * @param obj2
   * @returns {boolean}
   * @private
   */
  shallowEqual: function (obj1, obj2) {
    var ret = true; // different type

    if (typeof obj1 !== typeof obj2) {
      ret = false;
    } // not object
    else if (typeof obj1 !== "object") {
      if (obj1 !== obj2) {
        ret = false;
      }
    } // object
    else {
      var keys1 = Object.keys(obj1);
      var keys2 = Object.keys(obj2);

      if (keys1.length !== keys2.length) {
        ret = false;
      } else {
        // comparison from obj1 to obj2
        for (var i = 0, iLen = keys1.length; i < iLen; i++) {
          if (obj1[keys1[i]] !== obj2[keys1[i]]) {
            ret = false;
            break;
          }
        } // comparison from obj2 to obj1
        // is not necessary once the lengths have been checked.

      }
    }

    return ret;
  },

  /**
   *  Shows a warning message, typically about some problem with the form
   *  definition.
   * @param msg the message to show
   * @param item (optional) the item in the form to which the message applies.
   */
  showWarning: function (msg, item) {
    if (item) msg = 'The question "' + item.text + '" produced the following warning:  ' + msg;
    console.log(msg); // TBD: add a warning visible on the page.
  },

  /**
   * Check if a value is an integer or if it can be correctly converted to a valid float number
   * @param {*} Value a string or numeric value to be tested
   * @returns {boolean} 
   */
  isInteger(value) {
    return Number.isInteger(value) ? true : typeof value === "number" ? false : this.intRegex.test(value);
  },

  /**
   * Check if a value is a number or if it can be correctly converted to a valid float number
   * @param {*} value a string or numeric value to be tested
   * @returns {boolean} 
   */
  isDecimal(value) {
    return typeof value === "number" ? true : this.decRegex.test(value);
  }

};
/* harmony default export */ __webpack_exports__["default"] = (CommonUtils);

/***/ }),
/* 105 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
//! moment.js
//! version : 2.29.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com
;

(function (global, factory) {
   true ? module.exports = factory() : 0;
})(this, function () {
  'use strict';

  var hookCallback;

  function hooks() {
    return hookCallback.apply(null, arguments);
  } // This is done to register the method called with moment()
  // without creating circular dependencies.


  function setHookCallback(callback) {
    hookCallback = callback;
  }

  function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
  }

  function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
  }

  function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  }

  function isObjectEmpty(obj) {
    if (Object.getOwnPropertyNames) {
      return Object.getOwnPropertyNames(obj).length === 0;
    } else {
      var k;

      for (k in obj) {
        if (hasOwnProp(obj, k)) {
          return false;
        }
      }

      return true;
    }
  }

  function isUndefined(input) {
    return input === void 0;
  }

  function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
  }

  function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
  }

  function map(arr, fn) {
    var res = [],
        i,
        arrLen = arr.length;

    for (i = 0; i < arrLen; ++i) {
      res.push(fn(arr[i], i));
    }

    return res;
  }

  function extend(a, b) {
    for (var i in b) {
      if (hasOwnProp(b, i)) {
        a[i] = b[i];
      }
    }

    if (hasOwnProp(b, 'toString')) {
      a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
      a.valueOf = b.valueOf;
    }

    return a;
  }

  function createUTC(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
  }

  function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
      empty: false,
      unusedTokens: [],
      unusedInput: [],
      overflow: -2,
      charsLeftOver: 0,
      nullInput: false,
      invalidEra: null,
      invalidMonth: null,
      invalidFormat: false,
      userInvalidated: false,
      iso: false,
      parsedDateParts: [],
      era: null,
      meridiem: null,
      rfc2822: false,
      weekdayMismatch: false
    };
  }

  function getParsingFlags(m) {
    if (m._pf == null) {
      m._pf = defaultParsingFlags();
    }

    return m._pf;
  }

  var some;

  if (Array.prototype.some) {
    some = Array.prototype.some;
  } else {
    some = function (fun) {
      var t = Object(this),
          len = t.length >>> 0,
          i;

      for (i = 0; i < len; i++) {
        if (i in t && fun.call(this, t[i], i, t)) {
          return true;
        }
      }

      return false;
    };
  }

  function isValid(m) {
    if (m._isValid == null) {
      var flags = getParsingFlags(m),
          parsedParts = some.call(flags.parsedDateParts, function (i) {
        return i != null;
      }),
          isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);

      if (m._strict) {
        isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
      }

      if (Object.isFrozen == null || !Object.isFrozen(m)) {
        m._isValid = isNowValid;
      } else {
        return isNowValid;
      }
    }

    return m._isValid;
  }

  function createInvalid(flags) {
    var m = createUTC(NaN);

    if (flags != null) {
      extend(getParsingFlags(m), flags);
    } else {
      getParsingFlags(m).userInvalidated = true;
    }

    return m;
  } // Plugins that add properties should also add the key here (null value),
  // so we can properly clone ourselves.


  var momentProperties = hooks.momentProperties = [],
      updateInProgress = false;

  function copyConfig(to, from) {
    var i,
        prop,
        val,
        momentPropertiesLen = momentProperties.length;

    if (!isUndefined(from._isAMomentObject)) {
      to._isAMomentObject = from._isAMomentObject;
    }

    if (!isUndefined(from._i)) {
      to._i = from._i;
    }

    if (!isUndefined(from._f)) {
      to._f = from._f;
    }

    if (!isUndefined(from._l)) {
      to._l = from._l;
    }

    if (!isUndefined(from._strict)) {
      to._strict = from._strict;
    }

    if (!isUndefined(from._tzm)) {
      to._tzm = from._tzm;
    }

    if (!isUndefined(from._isUTC)) {
      to._isUTC = from._isUTC;
    }

    if (!isUndefined(from._offset)) {
      to._offset = from._offset;
    }

    if (!isUndefined(from._pf)) {
      to._pf = getParsingFlags(from);
    }

    if (!isUndefined(from._locale)) {
      to._locale = from._locale;
    }

    if (momentPropertiesLen > 0) {
      for (i = 0; i < momentPropertiesLen; i++) {
        prop = momentProperties[i];
        val = from[prop];

        if (!isUndefined(val)) {
          to[prop] = val;
        }
      }
    }

    return to;
  } // Moment prototype object


  function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);

    if (!this.isValid()) {
      this._d = new Date(NaN);
    } // Prevent infinite loop in case updateOffset creates new moment
    // objects.


    if (updateInProgress === false) {
      updateInProgress = true;
      hooks.updateOffset(this);
      updateInProgress = false;
    }
  }

  function isMoment(obj) {
    return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
  }

  function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
      console.warn('Deprecation warning: ' + msg);
    }
  }

  function deprecate(msg, fn) {
    var firstTime = true;
    return extend(function () {
      if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(null, msg);
      }

      if (firstTime) {
        var args = [],
            arg,
            i,
            key,
            argLen = arguments.length;

        for (i = 0; i < argLen; i++) {
          arg = '';

          if (typeof arguments[i] === 'object') {
            arg += '\n[' + i + '] ';

            for (key in arguments[0]) {
              if (hasOwnProp(arguments[0], key)) {
                arg += key + ': ' + arguments[0][key] + ', ';
              }
            }

            arg = arg.slice(0, -2); // Remove trailing comma and space
          } else {
            arg = arguments[i];
          }

          args.push(arg);
        }

        warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + new Error().stack);
        firstTime = false;
      }

      return fn.apply(this, arguments);
    }, fn);
  }

  var deprecations = {};

  function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(name, msg);
    }

    if (!deprecations[name]) {
      warn(msg);
      deprecations[name] = true;
    }
  }

  hooks.suppressDeprecationWarnings = false;
  hooks.deprecationHandler = null;

  function isFunction(input) {
    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }

  function set(config) {
    var prop, i;

    for (i in config) {
      if (hasOwnProp(config, i)) {
        prop = config[i];

        if (isFunction(prop)) {
          this[i] = prop;
        } else {
          this['_' + i] = prop;
        }
      }
    }

    this._config = config; // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.

    this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + /\d{1,2}/.source);
  }

  function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig),
        prop;

    for (prop in childConfig) {
      if (hasOwnProp(childConfig, prop)) {
        if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
          res[prop] = {};
          extend(res[prop], parentConfig[prop]);
          extend(res[prop], childConfig[prop]);
        } else if (childConfig[prop] != null) {
          res[prop] = childConfig[prop];
        } else {
          delete res[prop];
        }
      }
    }

    for (prop in parentConfig) {
      if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
        // make sure changes to properties don't modify parent config
        res[prop] = extend({}, res[prop]);
      }
    }

    return res;
  }

  function Locale(config) {
    if (config != null) {
      this.set(config);
    }
  }

  var keys;

  if (Object.keys) {
    keys = Object.keys;
  } else {
    keys = function (obj) {
      var i,
          res = [];

      for (i in obj) {
        if (hasOwnProp(obj, i)) {
          res.push(i);
        }
      }

      return res;
    };
  }

  var defaultCalendar = {
    sameDay: '[Today at] LT',
    nextDay: '[Tomorrow at] LT',
    nextWeek: 'dddd [at] LT',
    lastDay: '[Yesterday at] LT',
    lastWeek: '[Last] dddd [at] LT',
    sameElse: 'L'
  };

  function calendar(key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
  }

  function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? forceSign ? '+' : '' : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
  }

  var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
      localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
      formatFunctions = {},
      formatTokenFunctions = {}; // token:    'M'
  // padded:   ['MM', 2]
  // ordinal:  'Mo'
  // callback: function () { this.month() + 1 }

  function addFormatToken(token, padded, ordinal, callback) {
    var func = callback;

    if (typeof callback === 'string') {
      func = function () {
        return this[callback]();
      };
    }

    if (token) {
      formatTokenFunctions[token] = func;
    }

    if (padded) {
      formatTokenFunctions[padded[0]] = function () {
        return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
      };
    }

    if (ordinal) {
      formatTokenFunctions[ordinal] = function () {
        return this.localeData().ordinal(func.apply(this, arguments), token);
      };
    }
  }

  function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
      return input.replace(/^\[|\]$/g, '');
    }

    return input.replace(/\\/g, '');
  }

  function makeFormatFunction(format) {
    var array = format.match(formattingTokens),
        i,
        length;

    for (i = 0, length = array.length; i < length; i++) {
      if (formatTokenFunctions[array[i]]) {
        array[i] = formatTokenFunctions[array[i]];
      } else {
        array[i] = removeFormattingTokens(array[i]);
      }
    }

    return function (mom) {
      var output = '',
          i;

      for (i = 0; i < length; i++) {
        output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
      }

      return output;
    };
  } // format date using native date object


  function formatMoment(m, format) {
    if (!m.isValid()) {
      return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
    return formatFunctions[format](m);
  }

  function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
      return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;

    while (i >= 0 && localFormattingTokens.test(format)) {
      format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
      localFormattingTokens.lastIndex = 0;
      i -= 1;
    }

    return format;
  }

  var defaultLongDateFormat = {
    LTS: 'h:mm:ss A',
    LT: 'h:mm A',
    L: 'MM/DD/YYYY',
    LL: 'MMMM D, YYYY',
    LLL: 'MMMM D, YYYY h:mm A',
    LLLL: 'dddd, MMMM D, YYYY h:mm A'
  };

  function longDateFormat(key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
      return format;
    }

    this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function (tok) {
      if (tok === 'MMMM' || tok === 'MM' || tok === 'DD' || tok === 'dddd') {
        return tok.slice(1);
      }

      return tok;
    }).join('');
    return this._longDateFormat[key];
  }

  var defaultInvalidDate = 'Invalid date';

  function invalidDate() {
    return this._invalidDate;
  }

  var defaultOrdinal = '%d',
      defaultDayOfMonthOrdinalParse = /\d{1,2}/;

  function ordinal(number) {
    return this._ordinal.replace('%d', number);
  }

  var defaultRelativeTime = {
    future: 'in %s',
    past: '%s ago',
    s: 'a few seconds',
    ss: '%d seconds',
    m: 'a minute',
    mm: '%d minutes',
    h: 'an hour',
    hh: '%d hours',
    d: 'a day',
    dd: '%d days',
    w: 'a week',
    ww: '%d weeks',
    M: 'a month',
    MM: '%d months',
    y: 'a year',
    yy: '%d years'
  };

  function relativeTime(number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
  }

  function pastFuture(diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
  }

  var aliases = {};

  function addUnitAlias(unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
  }

  function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
  }

  function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
      if (hasOwnProp(inputObject, prop)) {
        normalizedProp = normalizeUnits(prop);

        if (normalizedProp) {
          normalizedInput[normalizedProp] = inputObject[prop];
        }
      }
    }

    return normalizedInput;
  }

  var priorities = {};

  function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
  }

  function getPrioritizedUnits(unitsObj) {
    var units = [],
        u;

    for (u in unitsObj) {
      if (hasOwnProp(unitsObj, u)) {
        units.push({
          unit: u,
          priority: priorities[u]
        });
      }
    }

    units.sort(function (a, b) {
      return a.priority - b.priority;
    });
    return units;
  }

  function isLeapYear(year) {
    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
  }

  function absFloor(number) {
    if (number < 0) {
      // -0 -> 0
      return Math.ceil(number) || 0;
    } else {
      return Math.floor(number);
    }
  }

  function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
      value = absFloor(coercedNumber);
    }

    return value;
  }

  function makeGetSet(unit, keepTime) {
    return function (value) {
      if (value != null) {
        set$1(this, unit, value);
        hooks.updateOffset(this, keepTime);
        return this;
      } else {
        return get(this, unit);
      }
    };
  }

  function get(mom, unit) {
    return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
  }

  function set$1(mom, unit, value) {
    if (mom.isValid() && !isNaN(value)) {
      if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
        value = toInt(value);

        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
      } else {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
      }
    }
  } // MOMENTS


  function stringGet(units) {
    units = normalizeUnits(units);

    if (isFunction(this[units])) {
      return this[units]();
    }

    return this;
  }

  function stringSet(units, value) {
    if (typeof units === 'object') {
      units = normalizeObjectUnits(units);
      var prioritized = getPrioritizedUnits(units),
          i,
          prioritizedLen = prioritized.length;

      for (i = 0; i < prioritizedLen; i++) {
        this[prioritized[i].unit](units[prioritized[i].unit]);
      }
    } else {
      units = normalizeUnits(units);

      if (isFunction(this[units])) {
        return this[units](value);
      }
    }

    return this;
  }

  var match1 = /\d/,
      //       0 - 9
  match2 = /\d\d/,
      //      00 - 99
  match3 = /\d{3}/,
      //     000 - 999
  match4 = /\d{4}/,
      //    0000 - 9999
  match6 = /[+-]?\d{6}/,
      // -999999 - 999999
  match1to2 = /\d\d?/,
      //       0 - 99
  match3to4 = /\d\d\d\d?/,
      //     999 - 9999
  match5to6 = /\d\d\d\d\d\d?/,
      //   99999 - 999999
  match1to3 = /\d{1,3}/,
      //       0 - 999
  match1to4 = /\d{1,4}/,
      //       0 - 9999
  match1to6 = /[+-]?\d{1,6}/,
      // -999999 - 999999
  matchUnsigned = /\d+/,
      //       0 - inf
  matchSigned = /[+-]?\d+/,
      //    -inf - inf
  matchOffset = /Z|[+-]\d\d:?\d\d/gi,
      // +00:00 -00:00 +0000 -0000 or Z
  matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
      // +00 -00 +00:00 -00:00 +0000 -0000 or Z
  matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
      // 123456789 123456789.123
  // any word (or two) characters or numbers including two/three word month in arabic.
  // includes scottish gaelic two word and hyphenated months
  matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
      regexes;
  regexes = {};

  function addRegexToken(token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
      return isStrict && strictRegex ? strictRegex : regex;
    };
  }

  function getParseRegexForToken(token, config) {
    if (!hasOwnProp(regexes, token)) {
      return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
  } // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript


  function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
      return p1 || p2 || p3 || p4;
    }));
  }

  function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  }

  var tokens = {};

  function addParseToken(token, callback) {
    var i,
        func = callback,
        tokenLen;

    if (typeof token === 'string') {
      token = [token];
    }

    if (isNumber(callback)) {
      func = function (input, array) {
        array[callback] = toInt(input);
      };
    }

    tokenLen = token.length;

    for (i = 0; i < tokenLen; i++) {
      tokens[token[i]] = func;
    }
  }

  function addWeekParseToken(token, callback) {
    addParseToken(token, function (input, array, config, token) {
      config._w = config._w || {};
      callback(input, config._w, config, token);
    });
  }

  function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
      tokens[token](input, config._a, config, token);
    }
  }

  var YEAR = 0,
      MONTH = 1,
      DATE = 2,
      HOUR = 3,
      MINUTE = 4,
      SECOND = 5,
      MILLISECOND = 6,
      WEEK = 7,
      WEEKDAY = 8;

  function mod(n, x) {
    return (n % x + x) % x;
  }

  var indexOf;

  if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
  } else {
    indexOf = function (o) {
      // I know
      var i;

      for (i = 0; i < this.length; ++i) {
        if (this[i] === o) {
          return i;
        }
      }

      return -1;
    };
  }

  function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
      return NaN;
    }

    var modMonth = mod(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
  } // FORMATTING


  addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
  });
  addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
  });
  addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
  }); // ALIASES

  addUnitAlias('month', 'M'); // PRIORITY

  addUnitPriority('month', 8); // PARSING

  addRegexToken('M', match1to2);
  addRegexToken('MM', match1to2, match2);
  addRegexToken('MMM', function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
  });
  addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
  });
  addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
  });
  addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict); // if we didn't find a month name, mark the date as invalid.


    if (month != null) {
      array[MONTH] = month;
    } else {
      getParsingFlags(config).invalidMonth = input;
    }
  }); // LOCALES

  var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
      defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
      MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
      defaultMonthsShortRegex = matchWord,
      defaultMonthsRegex = matchWord;

  function localeMonths(m, format) {
    if (!m) {
      return isArray(this._months) ? this._months : this._months['standalone'];
    }

    return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
  }

  function localeMonthsShort(m, format) {
    if (!m) {
      return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
    }

    return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
  }

  function handleStrictParse(monthName, format, strict) {
    var i,
        ii,
        mom,
        llc = monthName.toLocaleLowerCase();

    if (!this._monthsParse) {
      // this is not used
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];

      for (i = 0; i < 12; ++i) {
        mom = createUTC([2000, i]);
        this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
        this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'MMM') {
        ii = indexOf.call(this._shortMonthsParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._longMonthsParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._longMonthsParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortMonthsParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
      return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
      this._monthsParse = [];
      this._longMonthsParse = [];
      this._shortMonthsParse = [];
    } // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse


    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);

      if (strict && !this._longMonthsParse[i]) {
        this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
        this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
      }

      if (!strict && !this._monthsParse[i]) {
        regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
        this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
      } // test the regex


      if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
        return i;
      } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
        return i;
      } else if (!strict && this._monthsParse[i].test(monthName)) {
        return i;
      }
    }
  } // MOMENTS


  function setMonth(mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
      // No op
      return mom;
    }

    if (typeof value === 'string') {
      if (/^\d+$/.test(value)) {
        value = toInt(value);
      } else {
        value = mom.localeData().monthsParse(value); // TODO: Another silent failure?

        if (!isNumber(value)) {
          return mom;
        }
      }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));

    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);

    return mom;
  }

  function getSetMonth(value) {
    if (value != null) {
      setMonth(this, value);
      hooks.updateOffset(this, true);
      return this;
    } else {
      return get(this, 'Month');
    }
  }

  function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
  }

  function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }

      if (isStrict) {
        return this._monthsShortStrictRegex;
      } else {
        return this._monthsShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsShortRegex')) {
        this._monthsShortRegex = defaultMonthsShortRegex;
      }

      return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
    }
  }

  function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
      if (!hasOwnProp(this, '_monthsRegex')) {
        computeMonthsParse.call(this);
      }

      if (isStrict) {
        return this._monthsStrictRegex;
      } else {
        return this._monthsRegex;
      }
    } else {
      if (!hasOwnProp(this, '_monthsRegex')) {
        this._monthsRegex = defaultMonthsRegex;
      }

      return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
    }
  }

  function computeMonthsParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom;

    for (i = 0; i < 12; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, i]);
      shortPieces.push(this.monthsShort(mom, ''));
      longPieces.push(this.months(mom, ''));
      mixedPieces.push(this.months(mom, ''));
      mixedPieces.push(this.monthsShort(mom, ''));
    } // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.


    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);

    for (i = 0; i < 12; i++) {
      shortPieces[i] = regexEscape(shortPieces[i]);
      longPieces[i] = regexEscape(longPieces[i]);
    }

    for (i = 0; i < 24; i++) {
      mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
  } // FORMATTING


  addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? zeroFill(y, 4) : '+' + y;
  });
  addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
  });
  addFormatToken(0, ['YYYY', 4], 0, 'year');
  addFormatToken(0, ['YYYYY', 5], 0, 'year');
  addFormatToken(0, ['YYYYYY', 6, true], 0, 'year'); // ALIASES

  addUnitAlias('year', 'y'); // PRIORITIES

  addUnitPriority('year', 1); // PARSING

  addRegexToken('Y', matchSigned);
  addRegexToken('YY', match1to2, match2);
  addRegexToken('YYYY', match1to4, match4);
  addRegexToken('YYYYY', match1to6, match6);
  addRegexToken('YYYYYY', match1to6, match6);
  addParseToken(['YYYYY', 'YYYYYY'], YEAR);
  addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
  });
  addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
  });
  addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
  }); // HELPERS

  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  } // HOOKS


  hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
  }; // MOMENTS


  var getSetYear = makeGetSet('FullYear', true);

  function getIsLeapYear() {
    return isLeapYear(this.year());
  }

  function createDate(y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date; // the date constructor remaps years 0-99 to 1900-1999

    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      date = new Date(y + 400, m, d, h, M, s, ms);

      if (isFinite(date.getFullYear())) {
        date.setFullYear(y);
      }
    } else {
      date = new Date(y, m, d, h, M, s, ms);
    }

    return date;
  }

  function createUTCDate(y) {
    var date, args; // the Date.UTC function remaps years 0-99 to 1900-1999

    if (y < 100 && y >= 0) {
      args = Array.prototype.slice.call(arguments); // preserve leap years using a full 400 year cycle, then reset

      args[0] = y + 400;
      date = new Date(Date.UTC.apply(null, args));

      if (isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
      }
    } else {
      date = new Date(Date.UTC.apply(null, arguments));
    }

    return date;
  } // start-of-first-week - start-of-year


  function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
    fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
    fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
    return -fwdlw + fwd - 1;
  } // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday


  function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear,
        resDayOfYear;

    if (dayOfYear <= 0) {
      resYear = year - 1;
      resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
      resYear = year + 1;
      resDayOfYear = dayOfYear - daysInYear(year);
    } else {
      resYear = year;
      resDayOfYear = dayOfYear;
    }

    return {
      year: resYear,
      dayOfYear: resDayOfYear
    };
  }

  function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek,
        resYear;

    if (week < 1) {
      resYear = mom.year() - 1;
      resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
      resWeek = week - weeksInYear(mom.year(), dow, doy);
      resYear = mom.year() + 1;
    } else {
      resYear = mom.year();
      resWeek = week;
    }

    return {
      week: resWeek,
      year: resYear
    };
  }

  function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
  } // FORMATTING


  addFormatToken('w', ['ww', 2], 'wo', 'week');
  addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek'); // ALIASES

  addUnitAlias('week', 'w');
  addUnitAlias('isoWeek', 'W'); // PRIORITIES

  addUnitPriority('week', 5);
  addUnitPriority('isoWeek', 5); // PARSING

  addRegexToken('w', match1to2);
  addRegexToken('ww', match1to2, match2);
  addRegexToken('W', match1to2);
  addRegexToken('WW', match1to2, match2);
  addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
  }); // HELPERS
  // LOCALES

  function localeWeek(mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
  }

  var defaultLocaleWeek = {
    dow: 0,
    // Sunday is the first day of the week.
    doy: 6 // The week that contains Jan 6th is the first week of the year.

  };

  function localeFirstDayOfWeek() {
    return this._week.dow;
  }

  function localeFirstDayOfYear() {
    return this._week.doy;
  } // MOMENTS


  function getSetWeek(input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
  }

  function getSetISOWeek(input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
  } // FORMATTING


  addFormatToken('d', 0, 'do', 'day');
  addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
  });
  addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
  });
  addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
  });
  addFormatToken('e', 0, 0, 'weekday');
  addFormatToken('E', 0, 0, 'isoWeekday'); // ALIASES

  addUnitAlias('day', 'd');
  addUnitAlias('weekday', 'e');
  addUnitAlias('isoWeekday', 'E'); // PRIORITY

  addUnitPriority('day', 11);
  addUnitPriority('weekday', 11);
  addUnitPriority('isoWeekday', 11); // PARSING

  addRegexToken('d', match1to2);
  addRegexToken('e', match1to2);
  addRegexToken('E', match1to2);
  addRegexToken('dd', function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
  });
  addRegexToken('ddd', function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
  });
  addRegexToken('dddd', function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
  });
  addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict); // if we didn't get a weekday name, mark the date as invalid


    if (weekday != null) {
      week.d = weekday;
    } else {
      getParsingFlags(config).invalidWeekday = input;
    }
  });
  addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
  }); // HELPERS

  function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
      return input;
    }

    if (!isNaN(input)) {
      return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);

    if (typeof input === 'number') {
      return input;
    }

    return null;
  }

  function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
      return locale.weekdaysParse(input) % 7 || 7;
    }

    return isNaN(input) ? null : input;
  } // LOCALES


  function shiftWeekdays(ws, n) {
    return ws.slice(n, 7).concat(ws.slice(0, n));
  }

  var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
      defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
      defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
      defaultWeekdaysRegex = matchWord,
      defaultWeekdaysShortRegex = matchWord,
      defaultWeekdaysMinRegex = matchWord;

  function localeWeekdays(m, format) {
    var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && m !== true && this._weekdays.isFormat.test(format) ? 'format' : 'standalone'];
    return m === true ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays;
  }

  function localeWeekdaysShort(m) {
    return m === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
  }

  function localeWeekdaysMin(m) {
    return m === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
  }

  function handleStrictParse$1(weekdayName, format, strict) {
    var i,
        ii,
        mom,
        llc = weekdayName.toLocaleLowerCase();

    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._minWeekdaysParse = [];

      for (i = 0; i < 7; ++i) {
        mom = createUTC([2000, 1]).day(i);
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
        this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
        this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
      }
    }

    if (strict) {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    } else {
      if (format === 'dddd') {
        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else if (format === 'ddd') {
        ii = indexOf.call(this._shortWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._minWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      } else {
        ii = indexOf.call(this._minWeekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._weekdaysParse, llc);

        if (ii !== -1) {
          return ii;
        }

        ii = indexOf.call(this._shortWeekdaysParse, llc);
        return ii !== -1 ? ii : null;
      }
    }
  }

  function localeWeekdaysParse(weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
      return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
      this._weekdaysParse = [];
      this._minWeekdaysParse = [];
      this._shortWeekdaysParse = [];
      this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);

      if (strict && !this._fullWeekdaysParse[i]) {
        this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
        this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
        this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
      }

      if (!this._weekdaysParse[i]) {
        regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
        this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
      } // test the regex


      if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
        return i;
      } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
        return i;
      }
    }
  } // MOMENTS


  function getSetDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();

    if (input != null) {
      input = parseWeekday(input, this.localeData());
      return this.add(input - day, 'd');
    } else {
      return day;
    }
  }

  function getSetLocaleDayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
  }

  function getSetISODayOfWeek(input) {
    if (!this.isValid()) {
      return input != null ? this : NaN;
    } // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.


    if (input != null) {
      var weekday = parseIsoWeekday(input, this.localeData());
      return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
      return this.day() || 7;
    }
  }

  function weekdaysRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysStrictRegex;
      } else {
        return this._weekdaysRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        this._weekdaysRegex = defaultWeekdaysRegex;
      }

      return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
    }
  }

  function weekdaysShortRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysShortStrictRegex;
      } else {
        return this._weekdaysShortRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysShortRegex')) {
        this._weekdaysShortRegex = defaultWeekdaysShortRegex;
      }

      return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
  }

  function weekdaysMinRegex(isStrict) {
    if (this._weekdaysParseExact) {
      if (!hasOwnProp(this, '_weekdaysRegex')) {
        computeWeekdaysParse.call(this);
      }

      if (isStrict) {
        return this._weekdaysMinStrictRegex;
      } else {
        return this._weekdaysMinRegex;
      }
    } else {
      if (!hasOwnProp(this, '_weekdaysMinRegex')) {
        this._weekdaysMinRegex = defaultWeekdaysMinRegex;
      }

      return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
  }

  function computeWeekdaysParse() {
    function cmpLenRev(a, b) {
      return b.length - a.length;
    }

    var minPieces = [],
        shortPieces = [],
        longPieces = [],
        mixedPieces = [],
        i,
        mom,
        minp,
        shortp,
        longp;

    for (i = 0; i < 7; i++) {
      // make the regex if we don't have it already
      mom = createUTC([2000, 1]).day(i);
      minp = regexEscape(this.weekdaysMin(mom, ''));
      shortp = regexEscape(this.weekdaysShort(mom, ''));
      longp = regexEscape(this.weekdays(mom, ''));
      minPieces.push(minp);
      shortPieces.push(shortp);
      longPieces.push(longp);
      mixedPieces.push(minp);
      mixedPieces.push(shortp);
      mixedPieces.push(longp);
    } // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.


    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;
    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
  } // FORMATTING


  function hFormat() {
    return this.hours() % 12 || 12;
  }

  function kFormat() {
    return this.hours() || 24;
  }

  addFormatToken('H', ['HH', 2], 0, 'hour');
  addFormatToken('h', ['hh', 2], 0, hFormat);
  addFormatToken('k', ['kk', 2], 0, kFormat);
  addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
  });
  addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });
  addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
  });
  addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
  });

  function meridiem(token, lowercase) {
    addFormatToken(token, 0, 0, function () {
      return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
  }

  meridiem('a', true);
  meridiem('A', false); // ALIASES

  addUnitAlias('hour', 'h'); // PRIORITY

  addUnitPriority('hour', 13); // PARSING

  function matchMeridiem(isStrict, locale) {
    return locale._meridiemParse;
  }

  addRegexToken('a', matchMeridiem);
  addRegexToken('A', matchMeridiem);
  addRegexToken('H', match1to2);
  addRegexToken('h', match1to2);
  addRegexToken('k', match1to2);
  addRegexToken('HH', match1to2, match2);
  addRegexToken('hh', match1to2, match2);
  addRegexToken('kk', match1to2, match2);
  addRegexToken('hmm', match3to4);
  addRegexToken('hmmss', match5to6);
  addRegexToken('Hmm', match3to4);
  addRegexToken('Hmmss', match5to6);
  addParseToken(['H', 'HH'], HOUR);
  addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
  });
  addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
  });
  addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4,
        pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
  });
  addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
  });
  addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4,
        pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
  }); // LOCALES

  function localeIsPM(input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return (input + '').toLowerCase().charAt(0) === 'p';
  }

  var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
      // Setting the hour should keep the time, because the user explicitly
  // specified which hour they want. So trying to maintain the same hour (in
  // a new timezone) makes sense. Adding/subtracting hours does not follow
  // this rule.
  getSetHour = makeGetSet('Hours', true);

  function localeMeridiem(hours, minutes, isLower) {
    if (hours > 11) {
      return isLower ? 'pm' : 'PM';
    } else {
      return isLower ? 'am' : 'AM';
    }
  }

  var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,
    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,
    week: defaultLocaleWeek,
    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,
    meridiemParse: defaultLocaleMeridiemParse
  }; // internal storage for locale config files

  var locales = {},
      localeFamilies = {},
      globalLocale;

  function commonPrefix(arr1, arr2) {
    var i,
        minl = Math.min(arr1.length, arr2.length);

    for (i = 0; i < minl; i += 1) {
      if (arr1[i] !== arr2[i]) {
        return i;
      }
    }

    return minl;
  }

  function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
  } // pick the locale from the array
  // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
  // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root


  function chooseLocale(names) {
    var i = 0,
        j,
        next,
        locale,
        split;

    while (i < names.length) {
      split = normalizeLocale(names[i]).split('-');
      j = split.length;
      next = normalizeLocale(names[i + 1]);
      next = next ? next.split('-') : null;

      while (j > 0) {
        locale = loadLocale(split.slice(0, j).join('-'));

        if (locale) {
          return locale;
        }

        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) {
          //the next array item is better than a shallower substring of this one
          break;
        }

        j--;
      }

      i++;
    }

    return globalLocale;
  }

  function isLocaleNameSane(name) {
    // Prevent names that look like filesystem paths, i.e contain '/' or '\'
    return name.match('^[^/\\\\]*$') != null;
  }

  function loadLocale(name) {
    var oldLocale = null,
        aliasedRequire; // TODO: Find a better way to register and load all the locales in Node

    if (locales[name] === undefined && "object" !== 'undefined' && module && module.exports && isLocaleNameSane(name)) {
      try {
        oldLocale = globalLocale._abbr;
        aliasedRequire = undefined;
        __webpack_require__(106)("./" + name);
        getSetGlobalLocale(oldLocale);
      } catch (e) {
        // mark as not found to avoid repeating expensive file require call causing high CPU
        // when trying to find en-US, en_US, en-us for every format call
        locales[name] = null; // null means not found
      }
    }

    return locales[name];
  } // This function will load locale and then set the global locale.  If
  // no arguments are passed in, it will simply return the current global
  // locale key.


  function getSetGlobalLocale(key, values) {
    var data;

    if (key) {
      if (isUndefined(values)) {
        data = getLocale(key);
      } else {
        data = defineLocale(key, values);
      }

      if (data) {
        // moment.duration._locale = moment._locale = data;
        globalLocale = data;
      } else {
        if (typeof console !== 'undefined' && console.warn) {
          //warn user if arguments are passed but the locale could not be set
          console.warn('Locale ' + key + ' not found. Did you forget to load it?');
        }
      }
    }

    return globalLocale._abbr;
  }

  function defineLocale(name, config) {
    if (config !== null) {
      var locale,
          parentConfig = baseConfig;
      config.abbr = name;

      if (locales[name] != null) {
        deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
        parentConfig = locales[name]._config;
      } else if (config.parentLocale != null) {
        if (locales[config.parentLocale] != null) {
          parentConfig = locales[config.parentLocale]._config;
        } else {
          locale = loadLocale(config.parentLocale);

          if (locale != null) {
            parentConfig = locale._config;
          } else {
            if (!localeFamilies[config.parentLocale]) {
              localeFamilies[config.parentLocale] = [];
            }

            localeFamilies[config.parentLocale].push({
              name: name,
              config: config
            });
            return null;
          }
        }
      }

      locales[name] = new Locale(mergeConfigs(parentConfig, config));

      if (localeFamilies[name]) {
        localeFamilies[name].forEach(function (x) {
          defineLocale(x.name, x.config);
        });
      } // backwards compat for now: also set the locale
      // make sure we set the locale AFTER all child locales have been
      // created, so we won't end up with the child locale set.


      getSetGlobalLocale(name);
      return locales[name];
    } else {
      // useful for testing
      delete locales[name];
      return null;
    }
  }

  function updateLocale(name, config) {
    if (config != null) {
      var locale,
          tmpLocale,
          parentConfig = baseConfig;

      if (locales[name] != null && locales[name].parentLocale != null) {
        // Update existing child locale in-place to avoid memory-leaks
        locales[name].set(mergeConfigs(locales[name]._config, config));
      } else {
        // MERGE
        tmpLocale = loadLocale(name);

        if (tmpLocale != null) {
          parentConfig = tmpLocale._config;
        }

        config = mergeConfigs(parentConfig, config);

        if (tmpLocale == null) {
          // updateLocale is called for creating a new locale
          // Set abbr so it will have a name (getters return
          // undefined otherwise).
          config.abbr = name;
        }

        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;
      } // backwards compat for now: also set the locale


      getSetGlobalLocale(name);
    } else {
      // pass null for config to unupdate, useful for tests
      if (locales[name] != null) {
        if (locales[name].parentLocale != null) {
          locales[name] = locales[name].parentLocale;

          if (name === getSetGlobalLocale()) {
            getSetGlobalLocale(name);
          }
        } else if (locales[name] != null) {
          delete locales[name];
        }
      }
    }

    return locales[name];
  } // returns locale data


  function getLocale(key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
      key = key._locale._abbr;
    }

    if (!key) {
      return globalLocale;
    }

    if (!isArray(key)) {
      //short-circuit everything else
      locale = loadLocale(key);

      if (locale) {
        return locale;
      }

      key = [key];
    }

    return chooseLocale(key);
  }

  function listLocales() {
    return keys(locales);
  }

  function checkOverflow(m) {
    var overflow,
        a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
      overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

      if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
        overflow = DATE;
      }

      if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
        overflow = WEEK;
      }

      if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
        overflow = WEEKDAY;
      }

      getParsingFlags(m).overflow = overflow;
    }

    return m;
  } // iso 8601 regex
  // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)


  var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
      tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
      isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/], ['YYYYMM', /\d{6}/, false], ['YYYY', /\d{4}/, false]],
      // iso time formats and regexes
  isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]],
      aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
      // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
  rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
      obsOffsets = {
    UT: 0,
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  }; // date from iso format

  function configFromISO(config) {
    var i,
        l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime,
        dateFormat,
        timeFormat,
        tzFormat,
        isoDatesLen = isoDates.length,
        isoTimesLen = isoTimes.length;

    if (match) {
      getParsingFlags(config).iso = true;

      for (i = 0, l = isoDatesLen; i < l; i++) {
        if (isoDates[i][1].exec(match[1])) {
          dateFormat = isoDates[i][0];
          allowTime = isoDates[i][2] !== false;
          break;
        }
      }

      if (dateFormat == null) {
        config._isValid = false;
        return;
      }

      if (match[3]) {
        for (i = 0, l = isoTimesLen; i < l; i++) {
          if (isoTimes[i][1].exec(match[3])) {
            // match[2] should be 'T' or space
            timeFormat = (match[2] || ' ') + isoTimes[i][0];
            break;
          }
        }

        if (timeFormat == null) {
          config._isValid = false;
          return;
        }
      }

      if (!allowTime && timeFormat != null) {
        config._isValid = false;
        return;
      }

      if (match[4]) {
        if (tzRegex.exec(match[4])) {
          tzFormat = 'Z';
        } else {
          config._isValid = false;
          return;
        }
      }

      config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
      configFromStringAndFormat(config);
    } else {
      config._isValid = false;
    }
  }

  function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

    if (secondStr) {
      result.push(parseInt(secondStr, 10));
    }

    return result;
  }

  function untruncateYear(yearStr) {
    var year = parseInt(yearStr, 10);

    if (year <= 49) {
      return 2000 + year;
    } else if (year <= 999) {
      return 1900 + year;
    }

    return year;
  }

  function preprocessRFC2822(s) {
    // Remove comments and folding whitespace and replace multiple-spaces with a single space
    return s.replace(/\([^()]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  }

  function checkWeekday(weekdayStr, parsedInput, config) {
    if (weekdayStr) {
      // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
      var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
          weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();

      if (weekdayProvided !== weekdayActual) {
        getParsingFlags(config).weekdayMismatch = true;
        config._isValid = false;
        return false;
      }
    }

    return true;
  }

  function calculateOffset(obsOffset, militaryOffset, numOffset) {
    if (obsOffset) {
      return obsOffsets[obsOffset];
    } else if (militaryOffset) {
      // the only allowed military tz is Z
      return 0;
    } else {
      var hm = parseInt(numOffset, 10),
          m = hm % 100,
          h = (hm - m) / 100;
      return h * 60 + m;
    }
  } // date and time from ref 2822 format


  function configFromRFC2822(config) {
    var match = rfc2822.exec(preprocessRFC2822(config._i)),
        parsedArray;

    if (match) {
      parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);

      if (!checkWeekday(match[1], parsedArray, config)) {
        return;
      }

      config._a = parsedArray;
      config._tzm = calculateOffset(match[8], match[9], match[10]);
      config._d = createUTCDate.apply(null, config._a);

      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

      getParsingFlags(config).rfc2822 = true;
    } else {
      config._isValid = false;
    }
  } // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict


  function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
      config._d = new Date(+matched[1]);
      return;
    }

    configFromISO(config);

    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    configFromRFC2822(config);

    if (config._isValid === false) {
      delete config._isValid;
    } else {
      return;
    }

    if (config._strict) {
      config._isValid = false;
    } else {
      // Final attempt, use Input Fallback
      hooks.createFromInputFallback(config);
    }
  }

  hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.', function (config) {
    config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
  }); // Pick the first defined of two or three arguments.

  function defaults(a, b, c) {
    if (a != null) {
      return a;
    }

    if (b != null) {
      return b;
    }

    return c;
  }

  function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());

    if (config._useUTC) {
      return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }

    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
  } // convert an array to a date.
  // the array should mirror the parameters below
  // note: all values past the year are optional and will default to the lowest possible value.
  // [year, month, day , hour, minute, second, millisecond]


  function configFromArray(config) {
    var i,
        date,
        input = [],
        currentDate,
        expectedWeekday,
        yearToUse;

    if (config._d) {
      return;
    }

    currentDate = currentDateArray(config); //compute day of the year from weeks and weekdays

    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
      dayOfYearFromWeekInfo(config);
    } //if the day of the year is set, figure out what it is


    if (config._dayOfYear != null) {
      yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

      if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
        getParsingFlags(config)._overflowDayOfYear = true;
      }

      date = createUTCDate(yearToUse, 0, config._dayOfYear);
      config._a[MONTH] = date.getUTCMonth();
      config._a[DATE] = date.getUTCDate();
    } // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything


    for (i = 0; i < 3 && config._a[i] == null; ++i) {
      config._a[i] = input[i] = currentDate[i];
    } // Zero out whatever was not defaulted, including time


    for (; i < 7; i++) {
      config._a[i] = input[i] = config._a[i] == null ? i === 2 ? 1 : 0 : config._a[i];
    } // Check for 24:00:00.000


    if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
      config._nextDay = true;
      config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(); // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.

    if (config._tzm != null) {
      config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
      config._a[HOUR] = 24;
    } // check for mismatching day of week


    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
      getParsingFlags(config).weekdayMismatch = true;
    }
  }

  function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
    w = config._w;

    if (w.GG != null || w.W != null || w.E != null) {
      dow = 1;
      doy = 4; // TODO: We need to take the current isoWeekYear, but that depends on
      // how we interpret now (local, utc, fixed offset). So create
      // a now version of current config (take local/utc/offset flags, and
      // create now).

      weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
      week = defaults(w.W, 1);
      weekday = defaults(w.E, 1);

      if (weekday < 1 || weekday > 7) {
        weekdayOverflow = true;
      }
    } else {
      dow = config._locale._week.dow;
      doy = config._locale._week.doy;
      curWeek = weekOfYear(createLocal(), dow, doy);
      weekYear = defaults(w.gg, config._a[YEAR], curWeek.year); // Default to current week.

      week = defaults(w.w, curWeek.week);

      if (w.d != null) {
        // weekday -- low day numbers are considered next week
        weekday = w.d;

        if (weekday < 0 || weekday > 6) {
          weekdayOverflow = true;
        }
      } else if (w.e != null) {
        // local weekday -- counting starts from beginning of week
        weekday = w.e + dow;

        if (w.e < 0 || w.e > 6) {
          weekdayOverflow = true;
        }
      } else {
        // default to beginning of week
        weekday = dow;
      }
    }

    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
      getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
      getParsingFlags(config)._overflowWeekday = true;
    } else {
      temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
      config._a[YEAR] = temp.year;
      config._dayOfYear = temp.dayOfYear;
    }
  } // constant that refers to the ISO standard


  hooks.ISO_8601 = function () {}; // constant that refers to the RFC 2822 form


  hooks.RFC_2822 = function () {}; // date from string and format string


  function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
      configFromISO(config);
      return;
    }

    if (config._f === hooks.RFC_2822) {
      configFromRFC2822(config);
      return;
    }

    config._a = [];
    getParsingFlags(config).empty = true; // This array is used to make a Date, either with `new Date` or `Date.UTC`

    var string = '' + config._i,
        i,
        parsedInput,
        tokens,
        token,
        skipped,
        stringLength = string.length,
        totalParsedInputLength = 0,
        era,
        tokenLen;
    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
    tokenLen = tokens.length;

    for (i = 0; i < tokenLen; i++) {
      token = tokens[i];
      parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];

      if (parsedInput) {
        skipped = string.substr(0, string.indexOf(parsedInput));

        if (skipped.length > 0) {
          getParsingFlags(config).unusedInput.push(skipped);
        }

        string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
        totalParsedInputLength += parsedInput.length;
      } // don't parse if it's not a known token


      if (formatTokenFunctions[token]) {
        if (parsedInput) {
          getParsingFlags(config).empty = false;
        } else {
          getParsingFlags(config).unusedTokens.push(token);
        }

        addTimeToArrayFromToken(token, parsedInput, config);
      } else if (config._strict && !parsedInput) {
        getParsingFlags(config).unusedTokens.push(token);
      }
    } // add remaining unparsed input length to the string


    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;

    if (string.length > 0) {
      getParsingFlags(config).unusedInput.push(string);
    } // clear _12h flag if hour is <= 12


    if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
      getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem; // handle meridiem

    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem); // handle era

    era = getParsingFlags(config).era;

    if (era !== null) {
      config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
    }

    configFromArray(config);
    checkOverflow(config);
  }

  function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
      // nothing to do
      return hour;
    }

    if (locale.meridiemHour != null) {
      return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
      // Fallback
      isPm = locale.isPM(meridiem);

      if (isPm && hour < 12) {
        hour += 12;
      }

      if (!isPm && hour === 12) {
        hour = 0;
      }

      return hour;
    } else {
      // this is not supposed to happen
      return hour;
    }
  } // date from string and array of format strings


  function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,
        scoreToBeat,
        i,
        currentScore,
        validFormatFound,
        bestFormatIsValid = false,
        configfLen = config._f.length;

    if (configfLen === 0) {
      getParsingFlags(config).invalidFormat = true;
      config._d = new Date(NaN);
      return;
    }

    for (i = 0; i < configfLen; i++) {
      currentScore = 0;
      validFormatFound = false;
      tempConfig = copyConfig({}, config);

      if (config._useUTC != null) {
        tempConfig._useUTC = config._useUTC;
      }

      tempConfig._f = config._f[i];
      configFromStringAndFormat(tempConfig);

      if (isValid(tempConfig)) {
        validFormatFound = true;
      } // if there is any input that was not parsed add a penalty for that format


      currentScore += getParsingFlags(tempConfig).charsLeftOver; //or tokens

      currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
      getParsingFlags(tempConfig).score = currentScore;

      if (!bestFormatIsValid) {
        if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;

          if (validFormatFound) {
            bestFormatIsValid = true;
          }
        }
      } else {
        if (currentScore < scoreToBeat) {
          scoreToBeat = currentScore;
          bestMoment = tempConfig;
        }
      }
    }

    extend(config, bestMoment || tempConfig);
  }

  function configFromObject(config) {
    if (config._d) {
      return;
    }

    var i = normalizeObjectUnits(config._i),
        dayOrDate = i.day === undefined ? i.date : i.day;
    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], function (obj) {
      return obj && parseInt(obj, 10);
    });
    configFromArray(config);
  }

  function createFromConfig(config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));

    if (res._nextDay) {
      // Adding is smart enough around DST
      res.add(1, 'd');
      res._nextDay = undefined;
    }

    return res;
  }

  function prepareConfig(config) {
    var input = config._i,
        format = config._f;
    config._locale = config._locale || getLocale(config._l);

    if (input === null || format === undefined && input === '') {
      return createInvalid({
        nullInput: true
      });
    }

    if (typeof input === 'string') {
      config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
      return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
      config._d = input;
    } else if (isArray(format)) {
      configFromStringAndArray(config);
    } else if (format) {
      configFromStringAndFormat(config);
    } else {
      configFromInput(config);
    }

    if (!isValid(config)) {
      config._d = null;
    }

    return config;
  }

  function configFromInput(config) {
    var input = config._i;

    if (isUndefined(input)) {
      config._d = new Date(hooks.now());
    } else if (isDate(input)) {
      config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
      configFromString(config);
    } else if (isArray(input)) {
      config._a = map(input.slice(0), function (obj) {
        return parseInt(obj, 10);
      });
      configFromArray(config);
    } else if (isObject(input)) {
      configFromObject(config);
    } else if (isNumber(input)) {
      // from milliseconds
      config._d = new Date(input);
    } else {
      hooks.createFromInputFallback(config);
    }
  }

  function createLocalOrUTC(input, format, locale, strict, isUTC) {
    var c = {};

    if (format === true || format === false) {
      strict = format;
      format = undefined;
    }

    if (locale === true || locale === false) {
      strict = locale;
      locale = undefined;
    }

    if (isObject(input) && isObjectEmpty(input) || isArray(input) && input.length === 0) {
      input = undefined;
    } // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423


    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;
    return createFromConfig(c);
  }

  function createLocal(input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
  }

  var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }),
      prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = createLocal.apply(null, arguments);

    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }); // Pick a moment m from moments so that m[fn](other) is true for all
  // other. This relies on the function fn to be transitive.
  //
  // moments should either be an array of moment objects or an array, whose
  // first element is an array of moment objects.

  function pickBy(fn, moments) {
    var res, i;

    if (moments.length === 1 && isArray(moments[0])) {
      moments = moments[0];
    }

    if (!moments.length) {
      return createLocal();
    }

    res = moments[0];

    for (i = 1; i < moments.length; ++i) {
      if (!moments[i].isValid() || moments[i][fn](res)) {
        res = moments[i];
      }
    }

    return res;
  } // TODO: Use [].sort instead?


  function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
  }

  function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
  }

  var now = function () {
    return Date.now ? Date.now() : +new Date();
  };

  var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

  function isDurationValid(m) {
    var key,
        unitHasDecimal = false,
        i,
        orderLen = ordering.length;

    for (key in m) {
      if (hasOwnProp(m, key) && !(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
        return false;
      }
    }

    for (i = 0; i < orderLen; ++i) {
      if (m[ordering[i]]) {
        if (unitHasDecimal) {
          return false; // only allow non-integers for smallest unit
        }

        if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
          unitHasDecimal = true;
        }
      }
    }

    return true;
  }

  function isValid$1() {
    return this._isValid;
  }

  function createInvalid$1() {
    return createDuration(NaN);
  }

  function Duration(duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;
    this._isValid = isDurationValid(normalizedInput); // representation for dateAddRemove

    this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
    minutes * 6e4 + // 1000 * 60
    hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately

    this._days = +days + weeks * 7; // It is impossible to translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.

    this._months = +months + quarters * 3 + years * 12;
    this._data = {};
    this._locale = getLocale();

    this._bubble();
  }

  function isDuration(obj) {
    return obj instanceof Duration;
  }

  function absRound(number) {
    if (number < 0) {
      return Math.round(-1 * number) * -1;
    } else {
      return Math.round(number);
    }
  } // compare two arrays, return the number of differences


  function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;

    for (i = 0; i < len; i++) {
      if (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) {
        diffs++;
      }
    }

    return diffs + lengthDiff;
  } // FORMATTING


  function offset(token, separator) {
    addFormatToken(token, 0, 0, function () {
      var offset = this.utcOffset(),
          sign = '+';

      if (offset < 0) {
        offset = -offset;
        sign = '-';
      }

      return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
    });
  }

  offset('Z', ':');
  offset('ZZ', ''); // PARSING

  addRegexToken('Z', matchShortOffset);
  addRegexToken('ZZ', matchShortOffset);
  addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
  }); // HELPERS
  // timezone chunker
  // '+10:00' > ['10',  '00']
  // '-1530'  > ['-15', '30']

  var chunkOffset = /([\+\-]|\d\d)/gi;

  function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher),
        chunk,
        parts,
        minutes;

    if (matches === null) {
      return null;
    }

    chunk = matches[matches.length - 1] || [];
    parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    minutes = +(parts[1] * 60) + toInt(parts[2]);
    return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
  } // Return a moment from input, that is local/utc/zone equivalent to model.


  function cloneWithOffset(input, model) {
    var res, diff;

    if (model._isUTC) {
      res = model.clone();
      diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

      res._d.setTime(res._d.valueOf() + diff);

      hooks.updateOffset(res, false);
      return res;
    } else {
      return createLocal(input).local();
    }
  }

  function getDateOffset(m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset());
  } // HOOKS
  // This function will be called whenever a moment is mutated.
  // It is intended to keep the offset in sync with the timezone.


  hooks.updateOffset = function () {}; // MOMENTS
  // keepLocalTime = true means only change the timezone, without
  // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
  // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
  // +0200, so we adjust the time as needed, to be valid.
  //
  // Keeping the time actually adds/subtracts (one hour)
  // from the actual represented time. That is why we call updateOffset
  // a second time. In case it wants us to change the offset again
  // _changeInProgress == true case, then we have to adjust, because
  // there is no such time in the given timezone.


  function getSetOffset(input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;

    if (!this.isValid()) {
      return input != null ? this : NaN;
    }

    if (input != null) {
      if (typeof input === 'string') {
        input = offsetFromString(matchShortOffset, input);

        if (input === null) {
          return this;
        }
      } else if (Math.abs(input) < 16 && !keepMinutes) {
        input = input * 60;
      }

      if (!this._isUTC && keepLocalTime) {
        localAdjust = getDateOffset(this);
      }

      this._offset = input;
      this._isUTC = true;

      if (localAdjust != null) {
        this.add(localAdjust, 'm');
      }

      if (offset !== input) {
        if (!keepLocalTime || this._changeInProgress) {
          addSubtract(this, createDuration(input - offset, 'm'), 1, false);
        } else if (!this._changeInProgress) {
          this._changeInProgress = true;
          hooks.updateOffset(this, true);
          this._changeInProgress = null;
        }
      }

      return this;
    } else {
      return this._isUTC ? offset : getDateOffset(this);
    }
  }

  function getSetZone(input, keepLocalTime) {
    if (input != null) {
      if (typeof input !== 'string') {
        input = -input;
      }

      this.utcOffset(input, keepLocalTime);
      return this;
    } else {
      return -this.utcOffset();
    }
  }

  function setOffsetToUTC(keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
  }

  function setOffsetToLocal(keepLocalTime) {
    if (this._isUTC) {
      this.utcOffset(0, keepLocalTime);
      this._isUTC = false;

      if (keepLocalTime) {
        this.subtract(getDateOffset(this), 'm');
      }
    }

    return this;
  }

  function setOffsetToParsedOffset() {
    if (this._tzm != null) {
      this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
      var tZone = offsetFromString(matchOffset, this._i);

      if (tZone != null) {
        this.utcOffset(tZone);
      } else {
        this.utcOffset(0, true);
      }
    }

    return this;
  }

  function hasAlignedHourOffset(input) {
    if (!this.isValid()) {
      return false;
    }

    input = input ? createLocal(input).utcOffset() : 0;
    return (this.utcOffset() - input) % 60 === 0;
  }

  function isDaylightSavingTime() {
    return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
  }

  function isDaylightSavingTimeShifted() {
    if (!isUndefined(this._isDSTShifted)) {
      return this._isDSTShifted;
    }

    var c = {},
        other;
    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
      other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
      this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
    } else {
      this._isDSTShifted = false;
    }

    return this._isDSTShifted;
  }

  function isLocal() {
    return this.isValid() ? !this._isUTC : false;
  }

  function isUtcOffset() {
    return this.isValid() ? this._isUTC : false;
  }

  function isUtc() {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
  } // ASP.NET json date format regex


  var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
      // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
  // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
  // and further modified to allow for strings containing both week and day
  isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

  function createDuration(input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
    match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
      duration = {
        ms: input._milliseconds,
        d: input._days,
        M: input._months
      };
    } else if (isNumber(input) || !isNaN(+input)) {
      duration = {};

      if (key) {
        duration[key] = +input;
      } else {
        duration.milliseconds = +input;
      }
    } else if (match = aspNetRegex.exec(input)) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: 0,
        d: toInt(match[DATE]) * sign,
        h: toInt(match[HOUR]) * sign,
        m: toInt(match[MINUTE]) * sign,
        s: toInt(match[SECOND]) * sign,
        ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match

      };
    } else if (match = isoRegex.exec(input)) {
      sign = match[1] === '-' ? -1 : 1;
      duration = {
        y: parseIso(match[2], sign),
        M: parseIso(match[3], sign),
        w: parseIso(match[4], sign),
        d: parseIso(match[5], sign),
        h: parseIso(match[6], sign),
        m: parseIso(match[7], sign),
        s: parseIso(match[8], sign)
      };
    } else if (duration == null) {
      // checks for null or undefined
      duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
      diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));
      duration = {};
      duration.ms = diffRes.milliseconds;
      duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
      ret._locale = input._locale;
    }

    if (isDuration(input) && hasOwnProp(input, '_isValid')) {
      ret._isValid = input._isValid;
    }

    return ret;
  }

  createDuration.fn = Duration.prototype;
  createDuration.invalid = createInvalid$1;

  function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.')); // apply sign while we're at it

    return (isNaN(res) ? 0 : res) * sign;
  }

  function positiveMomentsDifference(base, other) {
    var res = {};
    res.months = other.month() - base.month() + (other.year() - base.year()) * 12;

    if (base.clone().add(res.months, 'M').isAfter(other)) {
      --res.months;
    }

    res.milliseconds = +other - +base.clone().add(res.months, 'M');
    return res;
  }

  function momentsDifference(base, other) {
    var res;

    if (!(base.isValid() && other.isValid())) {
      return {
        milliseconds: 0,
        months: 0
      };
    }

    other = cloneWithOffset(other, base);

    if (base.isBefore(other)) {
      res = positiveMomentsDifference(base, other);
    } else {
      res = positiveMomentsDifference(other, base);
      res.milliseconds = -res.milliseconds;
      res.months = -res.months;
    }

    return res;
  } // TODO: remove 'name' arg after deprecation is removed


  function createAdder(direction, name) {
    return function (val, period) {
      var dur, tmp; //invert the arguments, but complain about it

      if (period !== null && !isNaN(+period)) {
        deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
        tmp = val;
        val = period;
        period = tmp;
      }

      dur = createDuration(val, period);
      addSubtract(this, dur, direction);
      return this;
    };
  }

  function addSubtract(mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
      // No op
      return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (months) {
      setMonth(mom, get(mom, 'Month') + months * isAdding);
    }

    if (days) {
      set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }

    if (milliseconds) {
      mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }

    if (updateOffset) {
      hooks.updateOffset(mom, days || months);
    }
  }

  var add = createAdder(1, 'add'),
      subtract = createAdder(-1, 'subtract');

  function isString(input) {
    return typeof input === 'string' || input instanceof String;
  } // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined


  function isMomentInput(input) {
    return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === undefined;
  }

  function isMomentInputObject(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input),
        propertyTest = false,
        properties = ['years', 'year', 'y', 'months', 'month', 'M', 'days', 'day', 'd', 'dates', 'date', 'D', 'hours', 'hour', 'h', 'minutes', 'minute', 'm', 'seconds', 'second', 's', 'milliseconds', 'millisecond', 'ms'],
        i,
        property,
        propertyLen = properties.length;

    for (i = 0; i < propertyLen; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }

    return objectTest && propertyTest;
  }

  function isNumberOrStringArray(input) {
    var arrayTest = isArray(input),
        dataTypeTest = false;

    if (arrayTest) {
      dataTypeTest = input.filter(function (item) {
        return !isNumber(item) && isString(input);
      }).length === 0;
    }

    return arrayTest && dataTypeTest;
  }

  function isCalendarSpec(input) {
    var objectTest = isObject(input) && !isObjectEmpty(input),
        propertyTest = false,
        properties = ['sameDay', 'nextDay', 'lastDay', 'nextWeek', 'lastWeek', 'sameElse'],
        i,
        property;

    for (i = 0; i < properties.length; i += 1) {
      property = properties[i];
      propertyTest = propertyTest || hasOwnProp(input, property);
    }

    return objectTest && propertyTest;
  }

  function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
  }

  function calendar$1(time, formats) {
    // Support for single parameter, formats only overload to the calendar function
    if (arguments.length === 1) {
      if (!arguments[0]) {
        time = undefined;
        formats = undefined;
      } else if (isMomentInput(arguments[0])) {
        time = arguments[0];
        formats = undefined;
      } else if (isCalendarSpec(arguments[0])) {
        formats = arguments[0];
        time = undefined;
      }
    } // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.


    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse',
        output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
  }

  function clone() {
    return new Moment(this);
  }

  function isAfter(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() > localInput.valueOf();
    } else {
      return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
  }

  function isBefore(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() < localInput.valueOf();
    } else {
      return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
  }

  function isBetween(from, to, units, inclusivity) {
    var localFrom = isMoment(from) ? from : createLocal(from),
        localTo = isMoment(to) ? to : createLocal(to);

    if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
      return false;
    }

    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
  }

  function isSame(input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;

    if (!(this.isValid() && localInput.isValid())) {
      return false;
    }

    units = normalizeUnits(units) || 'millisecond';

    if (units === 'millisecond') {
      return this.valueOf() === localInput.valueOf();
    } else {
      inputMs = localInput.valueOf();
      return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
  }

  function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
  }

  function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
  }

  function diff(input, units, asFloat) {
    var that, zoneDelta, output;

    if (!this.isValid()) {
      return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
      return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
    units = normalizeUnits(units);

    switch (units) {
      case 'year':
        output = monthDiff(this, that) / 12;
        break;

      case 'month':
        output = monthDiff(this, that);
        break;

      case 'quarter':
        output = monthDiff(this, that) / 3;
        break;

      case 'second':
        output = (this - that) / 1e3;
        break;
      // 1000

      case 'minute':
        output = (this - that) / 6e4;
        break;
      // 1000 * 60

      case 'hour':
        output = (this - that) / 36e5;
        break;
      // 1000 * 60 * 60

      case 'day':
        output = (this - that - zoneDelta) / 864e5;
        break;
      // 1000 * 60 * 60 * 24, negate dst

      case 'week':
        output = (this - that - zoneDelta) / 6048e5;
        break;
      // 1000 * 60 * 60 * 24 * 7, negate dst

      default:
        output = this - that;
    }

    return asFloat ? output : absFloor(output);
  }

  function monthDiff(a, b) {
    if (a.date() < b.date()) {
      // end-of-month calculations work correct when the start month has more
      // days than the end month.
      return -monthDiff(b, a);
    } // difference in months


    var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
    anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2,
        adjust;

    if (b - anchor < 0) {
      anchor2 = a.clone().add(wholeMonthDiff - 1, 'months'); // linear across the month

      adjust = (b - anchor) / (anchor - anchor2);
    } else {
      anchor2 = a.clone().add(wholeMonthDiff + 1, 'months'); // linear across the month

      adjust = (b - anchor) / (anchor2 - anchor);
    } //check for negative zero, return zero if negative zero


    return -(wholeMonthDiff + adjust) || 0;
  }

  hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
  hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

  function toString() {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
  }

  function toISOString(keepOffset) {
    if (!this.isValid()) {
      return null;
    }

    var utc = keepOffset !== true,
        m = utc ? this.clone().utc() : this;

    if (m.year() < 0 || m.year() > 9999) {
      return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    if (isFunction(Date.prototype.toISOString)) {
      // native implementation is ~50x faster, use it when we can
      if (utc) {
        return this.toDate().toISOString();
      } else {
        return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
      }
    }

    return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
  }
  /**
   * Return a human readable representation of a moment that can
   * also be evaluated to get a new moment which is the same
   *
   * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
   */


  function inspect() {
    if (!this.isValid()) {
      return 'moment.invalid(/* ' + this._i + ' */)';
    }

    var func = 'moment',
        zone = '',
        prefix,
        year,
        datetime,
        suffix;

    if (!this.isLocal()) {
      func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
      zone = 'Z';
    }

    prefix = '[' + func + '("]';
    year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
    datetime = '-MM-DD[T]HH:mm:ss.SSS';
    suffix = zone + '[")]';
    return this.format(prefix + year + datetime + suffix);
  }

  function format(inputString) {
    if (!inputString) {
      inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }

    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
  }

  function from(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        to: this,
        from: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function fromNow(withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
  }

  function to(time, withoutSuffix) {
    if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
      return createDuration({
        from: this,
        to: time
      }).locale(this.locale()).humanize(!withoutSuffix);
    } else {
      return this.localeData().invalidDate();
    }
  }

  function toNow(withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
  } // If passed a locale key, it will set the locale for this
  // instance.  Otherwise, it will return the locale configuration
  // variables for this instance.


  function locale(key) {
    var newLocaleData;

    if (key === undefined) {
      return this._locale._abbr;
    } else {
      newLocaleData = getLocale(key);

      if (newLocaleData != null) {
        this._locale = newLocaleData;
      }

      return this;
    }
  }

  var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function (key) {
    if (key === undefined) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  });

  function localeData() {
    return this._locale;
  }

  var MS_PER_SECOND = 1000,
      MS_PER_MINUTE = 60 * MS_PER_SECOND,
      MS_PER_HOUR = 60 * MS_PER_MINUTE,
      MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR; // actual modulo - handles negative numbers (for dates before 1970):

  function mod$1(dividend, divisor) {
    return (dividend % divisor + divisor) % divisor;
  }

  function localStartOfDate(y, m, d) {
    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return new Date(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return new Date(y, m, d).valueOf();
    }
  }

  function utcStartOfDate(y, m, d) {
    // Date.UTC remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0) {
      // preserve leap years using a full 400 year cycle, then reset
      return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
    } else {
      return Date.UTC(y, m, d);
    }
  }

  function startOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);

    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }

    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

    switch (units) {
      case 'year':
        time = startOfDate(this.year(), 0, 1);
        break;

      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
        break;

      case 'month':
        time = startOfDate(this.year(), this.month(), 1);
        break;

      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
        break;

      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
        break;

      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date());
        break;

      case 'hour':
        time = this._d.valueOf();
        time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
        break;

      case 'minute':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_MINUTE);
        break;

      case 'second':
        time = this._d.valueOf();
        time -= mod$1(time, MS_PER_SECOND);
        break;
    }

    this._d.setTime(time);

    hooks.updateOffset(this, true);
    return this;
  }

  function endOf(units) {
    var time, startOfDate;
    units = normalizeUnits(units);

    if (units === undefined || units === 'millisecond' || !this.isValid()) {
      return this;
    }

    startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

    switch (units) {
      case 'year':
        time = startOfDate(this.year() + 1, 0, 1) - 1;
        break;

      case 'quarter':
        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
        break;

      case 'month':
        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
        break;

      case 'week':
        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
        break;

      case 'isoWeek':
        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
        break;

      case 'day':
      case 'date':
        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
        break;

      case 'hour':
        time = this._d.valueOf();
        time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
        break;

      case 'minute':
        time = this._d.valueOf();
        time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
        break;

      case 'second':
        time = this._d.valueOf();
        time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
        break;
    }

    this._d.setTime(time);

    hooks.updateOffset(this, true);
    return this;
  }

  function valueOf() {
    return this._d.valueOf() - (this._offset || 0) * 60000;
  }

  function unix() {
    return Math.floor(this.valueOf() / 1000);
  }

  function toDate() {
    return new Date(this.valueOf());
  }

  function toArray() {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
  }

  function toObject() {
    var m = this;
    return {
      years: m.year(),
      months: m.month(),
      date: m.date(),
      hours: m.hours(),
      minutes: m.minutes(),
      seconds: m.seconds(),
      milliseconds: m.milliseconds()
    };
  }

  function toJSON() {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
  }

  function isValid$2() {
    return isValid(this);
  }

  function parsingFlags() {
    return extend({}, getParsingFlags(this));
  }

  function invalidAt() {
    return getParsingFlags(this).overflow;
  }

  function creationData() {
    return {
      input: this._i,
      format: this._f,
      locale: this._locale,
      isUTC: this._isUTC,
      strict: this._strict
    };
  }

  addFormatToken('N', 0, 0, 'eraAbbr');
  addFormatToken('NN', 0, 0, 'eraAbbr');
  addFormatToken('NNN', 0, 0, 'eraAbbr');
  addFormatToken('NNNN', 0, 0, 'eraName');
  addFormatToken('NNNNN', 0, 0, 'eraNarrow');
  addFormatToken('y', ['y', 1], 'yo', 'eraYear');
  addFormatToken('y', ['yy', 2], 0, 'eraYear');
  addFormatToken('y', ['yyy', 3], 0, 'eraYear');
  addFormatToken('y', ['yyyy', 4], 0, 'eraYear');
  addRegexToken('N', matchEraAbbr);
  addRegexToken('NN', matchEraAbbr);
  addRegexToken('NNN', matchEraAbbr);
  addRegexToken('NNNN', matchEraName);
  addRegexToken('NNNNN', matchEraNarrow);
  addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (input, array, config, token) {
    var era = config._locale.erasParse(input, token, config._strict);

    if (era) {
      getParsingFlags(config).era = era;
    } else {
      getParsingFlags(config).invalidEra = input;
    }
  });
  addRegexToken('y', matchUnsigned);
  addRegexToken('yy', matchUnsigned);
  addRegexToken('yyy', matchUnsigned);
  addRegexToken('yyyy', matchUnsigned);
  addRegexToken('yo', matchEraYearOrdinal);
  addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
  addParseToken(['yo'], function (input, array, config, token) {
    var match;

    if (config._locale._eraYearOrdinalRegex) {
      match = input.match(config._locale._eraYearOrdinalRegex);
    }

    if (config._locale.eraYearOrdinalParse) {
      array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
    } else {
      array[YEAR] = parseInt(input, 10);
    }
  });

  function localeEras(m, format) {
    var i,
        l,
        date,
        eras = this._eras || getLocale('en')._eras;

    for (i = 0, l = eras.length; i < l; ++i) {
      switch (typeof eras[i].since) {
        case 'string':
          // truncate time
          date = hooks(eras[i].since).startOf('day');
          eras[i].since = date.valueOf();
          break;
      }

      switch (typeof eras[i].until) {
        case 'undefined':
          eras[i].until = +Infinity;
          break;

        case 'string':
          // truncate time
          date = hooks(eras[i].until).startOf('day').valueOf();
          eras[i].until = date.valueOf();
          break;
      }
    }

    return eras;
  }

  function localeErasParse(eraName, format, strict) {
    var i,
        l,
        eras = this.eras(),
        name,
        abbr,
        narrow;
    eraName = eraName.toUpperCase();

    for (i = 0, l = eras.length; i < l; ++i) {
      name = eras[i].name.toUpperCase();
      abbr = eras[i].abbr.toUpperCase();
      narrow = eras[i].narrow.toUpperCase();

      if (strict) {
        switch (format) {
          case 'N':
          case 'NN':
          case 'NNN':
            if (abbr === eraName) {
              return eras[i];
            }

            break;

          case 'NNNN':
            if (name === eraName) {
              return eras[i];
            }

            break;

          case 'NNNNN':
            if (narrow === eraName) {
              return eras[i];
            }

            break;
        }
      } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
        return eras[i];
      }
    }
  }

  function localeErasConvertYear(era, year) {
    var dir = era.since <= era.until ? +1 : -1;

    if (year === undefined) {
      return hooks(era.since).year();
    } else {
      return hooks(era.since).year() + (year - era.offset) * dir;
    }
  }

  function getEraName() {
    var i,
        l,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].name;
      }

      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].name;
      }
    }

    return '';
  }

  function getEraNarrow() {
    var i,
        l,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].narrow;
      }

      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].narrow;
      }
    }

    return '';
  }

  function getEraAbbr() {
    var i,
        l,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      // truncate time
      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until) {
        return eras[i].abbr;
      }

      if (eras[i].until <= val && val <= eras[i].since) {
        return eras[i].abbr;
      }
    }

    return '';
  }

  function getEraYear() {
    var i,
        l,
        dir,
        val,
        eras = this.localeData().eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      dir = eras[i].since <= eras[i].until ? +1 : -1; // truncate time

      val = this.clone().startOf('day').valueOf();

      if (eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) {
        return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
      }
    }

    return this.year();
  }

  function erasNameRegex(isStrict) {
    if (!hasOwnProp(this, '_erasNameRegex')) {
      computeErasParse.call(this);
    }

    return isStrict ? this._erasNameRegex : this._erasRegex;
  }

  function erasAbbrRegex(isStrict) {
    if (!hasOwnProp(this, '_erasAbbrRegex')) {
      computeErasParse.call(this);
    }

    return isStrict ? this._erasAbbrRegex : this._erasRegex;
  }

  function erasNarrowRegex(isStrict) {
    if (!hasOwnProp(this, '_erasNarrowRegex')) {
      computeErasParse.call(this);
    }

    return isStrict ? this._erasNarrowRegex : this._erasRegex;
  }

  function matchEraAbbr(isStrict, locale) {
    return locale.erasAbbrRegex(isStrict);
  }

  function matchEraName(isStrict, locale) {
    return locale.erasNameRegex(isStrict);
  }

  function matchEraNarrow(isStrict, locale) {
    return locale.erasNarrowRegex(isStrict);
  }

  function matchEraYearOrdinal(isStrict, locale) {
    return locale._eraYearOrdinalRegex || matchUnsigned;
  }

  function computeErasParse() {
    var abbrPieces = [],
        namePieces = [],
        narrowPieces = [],
        mixedPieces = [],
        i,
        l,
        eras = this.eras();

    for (i = 0, l = eras.length; i < l; ++i) {
      namePieces.push(regexEscape(eras[i].name));
      abbrPieces.push(regexEscape(eras[i].abbr));
      narrowPieces.push(regexEscape(eras[i].narrow));
      mixedPieces.push(regexEscape(eras[i].name));
      mixedPieces.push(regexEscape(eras[i].abbr));
      mixedPieces.push(regexEscape(eras[i].narrow));
    }

    this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
    this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
    this._erasNarrowRegex = new RegExp('^(' + narrowPieces.join('|') + ')', 'i');
  } // FORMATTING


  addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
  });
  addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
  });

  function addWeekYearFormatToken(token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
  }

  addWeekYearFormatToken('gggg', 'weekYear');
  addWeekYearFormatToken('ggggg', 'weekYear');
  addWeekYearFormatToken('GGGG', 'isoWeekYear');
  addWeekYearFormatToken('GGGGG', 'isoWeekYear'); // ALIASES

  addUnitAlias('weekYear', 'gg');
  addUnitAlias('isoWeekYear', 'GG'); // PRIORITY

  addUnitPriority('weekYear', 1);
  addUnitPriority('isoWeekYear', 1); // PARSING

  addRegexToken('G', matchSigned);
  addRegexToken('g', matchSigned);
  addRegexToken('GG', match1to2, match2);
  addRegexToken('gg', match1to2, match2);
  addRegexToken('GGGG', match1to4, match4);
  addRegexToken('gggg', match1to4, match4);
  addRegexToken('GGGGG', match1to6, match6);
  addRegexToken('ggggg', match1to6, match6);
  addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
  });
  addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
  }); // MOMENTS

  function getSetWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
  }

  function getSetISOWeekYear(input) {
    return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
  }

  function getISOWeeksInYear() {
    return weeksInYear(this.year(), 1, 4);
  }

  function getISOWeeksInISOWeekYear() {
    return weeksInYear(this.isoWeekYear(), 1, 4);
  }

  function getWeeksInYear() {
    var weekInfo = this.localeData()._week;

    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
  }

  function getWeeksInWeekYear() {
    var weekInfo = this.localeData()._week;

    return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
  }

  function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;

    if (input == null) {
      return weekOfYear(this, dow, doy).year;
    } else {
      weeksTarget = weeksInYear(input, dow, doy);

      if (week > weeksTarget) {
        week = weeksTarget;
      }

      return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
  }

  function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
  } // FORMATTING


  addFormatToken('Q', 0, 'Qo', 'quarter'); // ALIASES

  addUnitAlias('quarter', 'Q'); // PRIORITY

  addUnitPriority('quarter', 7); // PARSING

  addRegexToken('Q', match1);
  addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
  }); // MOMENTS

  function getSetQuarter(input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
  } // FORMATTING


  addFormatToken('D', ['DD', 2], 'Do', 'date'); // ALIASES

  addUnitAlias('date', 'D'); // PRIORITY

  addUnitPriority('date', 9); // PARSING

  addRegexToken('D', match1to2);
  addRegexToken('DD', match1to2, match2);
  addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient;
  });
  addParseToken(['D', 'DD'], DATE);
  addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0]);
  }); // MOMENTS

  var getSetDayOfMonth = makeGetSet('Date', true); // FORMATTING

  addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear'); // ALIASES

  addUnitAlias('dayOfYear', 'DDD'); // PRIORITY

  addUnitPriority('dayOfYear', 4); // PARSING

  addRegexToken('DDD', match1to3);
  addRegexToken('DDDD', match3);
  addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
  }); // HELPERS
  // MOMENTS

  function getSetDayOfYear(input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
  } // FORMATTING


  addFormatToken('m', ['mm', 2], 0, 'minute'); // ALIASES

  addUnitAlias('minute', 'm'); // PRIORITY

  addUnitPriority('minute', 14); // PARSING

  addRegexToken('m', match1to2);
  addRegexToken('mm', match1to2, match2);
  addParseToken(['m', 'mm'], MINUTE); // MOMENTS

  var getSetMinute = makeGetSet('Minutes', false); // FORMATTING

  addFormatToken('s', ['ss', 2], 0, 'second'); // ALIASES

  addUnitAlias('second', 's'); // PRIORITY

  addUnitPriority('second', 15); // PARSING

  addRegexToken('s', match1to2);
  addRegexToken('ss', match1to2, match2);
  addParseToken(['s', 'ss'], SECOND); // MOMENTS

  var getSetSecond = makeGetSet('Seconds', false); // FORMATTING

  addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
  });
  addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
  });
  addFormatToken(0, ['SSS', 3], 0, 'millisecond');
  addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
  });
  addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
  });
  addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
  });
  addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
  });
  addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
  });
  addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
  }); // ALIASES

  addUnitAlias('millisecond', 'ms'); // PRIORITY

  addUnitPriority('millisecond', 16); // PARSING

  addRegexToken('S', match1to3, match1);
  addRegexToken('SS', match1to3, match2);
  addRegexToken('SSS', match1to3, match3);
  var token, getSetMillisecond;

  for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
  }

  function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
  }

  for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
  }

  getSetMillisecond = makeGetSet('Milliseconds', false); // FORMATTING

  addFormatToken('z', 0, 0, 'zoneAbbr');
  addFormatToken('zz', 0, 0, 'zoneName'); // MOMENTS

  function getZoneAbbr() {
    return this._isUTC ? 'UTC' : '';
  }

  function getZoneName() {
    return this._isUTC ? 'Coordinated Universal Time' : '';
  }

  var proto = Moment.prototype;
  proto.add = add;
  proto.calendar = calendar$1;
  proto.clone = clone;
  proto.diff = diff;
  proto.endOf = endOf;
  proto.format = format;
  proto.from = from;
  proto.fromNow = fromNow;
  proto.to = to;
  proto.toNow = toNow;
  proto.get = stringGet;
  proto.invalidAt = invalidAt;
  proto.isAfter = isAfter;
  proto.isBefore = isBefore;
  proto.isBetween = isBetween;
  proto.isSame = isSame;
  proto.isSameOrAfter = isSameOrAfter;
  proto.isSameOrBefore = isSameOrBefore;
  proto.isValid = isValid$2;
  proto.lang = lang;
  proto.locale = locale;
  proto.localeData = localeData;
  proto.max = prototypeMax;
  proto.min = prototypeMin;
  proto.parsingFlags = parsingFlags;
  proto.set = stringSet;
  proto.startOf = startOf;
  proto.subtract = subtract;
  proto.toArray = toArray;
  proto.toObject = toObject;
  proto.toDate = toDate;
  proto.toISOString = toISOString;
  proto.inspect = inspect;

  if (typeof Symbol !== 'undefined' && Symbol.for != null) {
    proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
      return 'Moment<' + this.format() + '>';
    };
  }

  proto.toJSON = toJSON;
  proto.toString = toString;
  proto.unix = unix;
  proto.valueOf = valueOf;
  proto.creationData = creationData;
  proto.eraName = getEraName;
  proto.eraNarrow = getEraNarrow;
  proto.eraAbbr = getEraAbbr;
  proto.eraYear = getEraYear;
  proto.year = getSetYear;
  proto.isLeapYear = getIsLeapYear;
  proto.weekYear = getSetWeekYear;
  proto.isoWeekYear = getSetISOWeekYear;
  proto.quarter = proto.quarters = getSetQuarter;
  proto.month = getSetMonth;
  proto.daysInMonth = getDaysInMonth;
  proto.week = proto.weeks = getSetWeek;
  proto.isoWeek = proto.isoWeeks = getSetISOWeek;
  proto.weeksInYear = getWeeksInYear;
  proto.weeksInWeekYear = getWeeksInWeekYear;
  proto.isoWeeksInYear = getISOWeeksInYear;
  proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
  proto.date = getSetDayOfMonth;
  proto.day = proto.days = getSetDayOfWeek;
  proto.weekday = getSetLocaleDayOfWeek;
  proto.isoWeekday = getSetISODayOfWeek;
  proto.dayOfYear = getSetDayOfYear;
  proto.hour = proto.hours = getSetHour;
  proto.minute = proto.minutes = getSetMinute;
  proto.second = proto.seconds = getSetSecond;
  proto.millisecond = proto.milliseconds = getSetMillisecond;
  proto.utcOffset = getSetOffset;
  proto.utc = setOffsetToUTC;
  proto.local = setOffsetToLocal;
  proto.parseZone = setOffsetToParsedOffset;
  proto.hasAlignedHourOffset = hasAlignedHourOffset;
  proto.isDST = isDaylightSavingTime;
  proto.isLocal = isLocal;
  proto.isUtcOffset = isUtcOffset;
  proto.isUtc = isUtc;
  proto.isUTC = isUtc;
  proto.zoneAbbr = getZoneAbbr;
  proto.zoneName = getZoneName;
  proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
  proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
  proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
  proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
  proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

  function createUnix(input) {
    return createLocal(input * 1000);
  }

  function createInZone() {
    return createLocal.apply(null, arguments).parseZone();
  }

  function preParsePostFormat(string) {
    return string;
  }

  var proto$1 = Locale.prototype;
  proto$1.calendar = calendar;
  proto$1.longDateFormat = longDateFormat;
  proto$1.invalidDate = invalidDate;
  proto$1.ordinal = ordinal;
  proto$1.preparse = preParsePostFormat;
  proto$1.postformat = preParsePostFormat;
  proto$1.relativeTime = relativeTime;
  proto$1.pastFuture = pastFuture;
  proto$1.set = set;
  proto$1.eras = localeEras;
  proto$1.erasParse = localeErasParse;
  proto$1.erasConvertYear = localeErasConvertYear;
  proto$1.erasAbbrRegex = erasAbbrRegex;
  proto$1.erasNameRegex = erasNameRegex;
  proto$1.erasNarrowRegex = erasNarrowRegex;
  proto$1.months = localeMonths;
  proto$1.monthsShort = localeMonthsShort;
  proto$1.monthsParse = localeMonthsParse;
  proto$1.monthsRegex = monthsRegex;
  proto$1.monthsShortRegex = monthsShortRegex;
  proto$1.week = localeWeek;
  proto$1.firstDayOfYear = localeFirstDayOfYear;
  proto$1.firstDayOfWeek = localeFirstDayOfWeek;
  proto$1.weekdays = localeWeekdays;
  proto$1.weekdaysMin = localeWeekdaysMin;
  proto$1.weekdaysShort = localeWeekdaysShort;
  proto$1.weekdaysParse = localeWeekdaysParse;
  proto$1.weekdaysRegex = weekdaysRegex;
  proto$1.weekdaysShortRegex = weekdaysShortRegex;
  proto$1.weekdaysMinRegex = weekdaysMinRegex;
  proto$1.isPM = localeIsPM;
  proto$1.meridiem = localeMeridiem;

  function get$1(format, index, field, setter) {
    var locale = getLocale(),
        utc = createUTC().set(setter, index);
    return locale[field](utc, format);
  }

  function listMonthsImpl(format, index, field) {
    if (isNumber(format)) {
      index = format;
      format = undefined;
    }

    format = format || '';

    if (index != null) {
      return get$1(format, index, field, 'month');
    }

    var i,
        out = [];

    for (i = 0; i < 12; i++) {
      out[i] = get$1(format, i, field, 'month');
    }

    return out;
  } // ()
  // (5)
  // (fmt, 5)
  // (fmt)
  // (true)
  // (true, 5)
  // (true, fmt, 5)
  // (true, fmt)


  function listWeekdaysImpl(localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';
    } else {
      format = localeSorted;
      index = format;
      localeSorted = false;

      if (isNumber(format)) {
        index = format;
        format = undefined;
      }

      format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0,
        i,
        out = [];

    if (index != null) {
      return get$1(format, (index + shift) % 7, field, 'day');
    }

    for (i = 0; i < 7; i++) {
      out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }

    return out;
  }

  function listMonths(format, index) {
    return listMonthsImpl(format, index, 'months');
  }

  function listMonthsShort(format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
  }

  function listWeekdays(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
  }

  function listWeekdaysShort(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
  }

  function listWeekdaysMin(localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
  }

  getSetGlobalLocale('en', {
    eras: [{
      since: '0001-01-01',
      until: +Infinity,
      offset: 1,
      name: 'Anno Domini',
      narrow: 'AD',
      abbr: 'AD'
    }, {
      since: '0000-12-31',
      until: -Infinity,
      offset: 1,
      name: 'Before Christ',
      narrow: 'BC',
      abbr: 'BC'
    }],
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
          output = toInt(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  }); // Side effect imports

  hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
  hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);
  var mathAbs = Math.abs;

  function abs() {
    var data = this._data;
    this._milliseconds = mathAbs(this._milliseconds);
    this._days = mathAbs(this._days);
    this._months = mathAbs(this._months);
    data.milliseconds = mathAbs(data.milliseconds);
    data.seconds = mathAbs(data.seconds);
    data.minutes = mathAbs(data.minutes);
    data.hours = mathAbs(data.hours);
    data.months = mathAbs(data.months);
    data.years = mathAbs(data.years);
    return this;
  }

  function addSubtract$1(duration, input, value, direction) {
    var other = createDuration(input, value);
    duration._milliseconds += direction * other._milliseconds;
    duration._days += direction * other._days;
    duration._months += direction * other._months;
    return duration._bubble();
  } // supports only 2.0-style add(1, 's') or add(duration)


  function add$1(input, value) {
    return addSubtract$1(this, input, value, 1);
  } // supports only 2.0-style subtract(1, 's') or subtract(duration)


  function subtract$1(input, value) {
    return addSubtract$1(this, input, value, -1);
  }

  function absCeil(number) {
    if (number < 0) {
      return Math.floor(number);
    } else {
      return Math.ceil(number);
    }
  }

  function bubble() {
    var milliseconds = this._milliseconds,
        days = this._days,
        months = this._months,
        data = this._data,
        seconds,
        minutes,
        hours,
        years,
        monthsFromDays; // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166

    if (!(milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0)) {
      milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
      days = 0;
      months = 0;
    } // The following code bubbles up values, see the tests for
    // examples of what that means.


    data.milliseconds = milliseconds % 1000;
    seconds = absFloor(milliseconds / 1000);
    data.seconds = seconds % 60;
    minutes = absFloor(seconds / 60);
    data.minutes = minutes % 60;
    hours = absFloor(minutes / 60);
    data.hours = hours % 24;
    days += absFloor(hours / 24); // convert days to months

    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays)); // 12 months -> 1 year

    years = absFloor(months / 12);
    months %= 12;
    data.days = days;
    data.months = months;
    data.years = years;
    return this;
  }

  function daysToMonths(days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
  }

  function monthsToDays(months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
  }

  function as(units) {
    if (!this.isValid()) {
      return NaN;
    }

    var days,
        months,
        milliseconds = this._milliseconds;
    units = normalizeUnits(units);

    if (units === 'month' || units === 'quarter' || units === 'year') {
      days = this._days + milliseconds / 864e5;
      months = this._months + daysToMonths(days);

      switch (units) {
        case 'month':
          return months;

        case 'quarter':
          return months / 3;

        case 'year':
          return months / 12;
      }
    } else {
      // handle milliseconds separately because of floating point math errors (issue #1867)
      days = this._days + Math.round(monthsToDays(this._months));

      switch (units) {
        case 'week':
          return days / 7 + milliseconds / 6048e5;

        case 'day':
          return days + milliseconds / 864e5;

        case 'hour':
          return days * 24 + milliseconds / 36e5;

        case 'minute':
          return days * 1440 + milliseconds / 6e4;

        case 'second':
          return days * 86400 + milliseconds / 1000;
        // Math.floor prevents floating point math errors here

        case 'millisecond':
          return Math.floor(days * 864e5) + milliseconds;

        default:
          throw new Error('Unknown unit ' + units);
      }
    }
  } // TODO: Use this.as('ms')?


  function valueOf$1() {
    if (!this.isValid()) {
      return NaN;
    }

    return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
  }

  function makeAs(alias) {
    return function () {
      return this.as(alias);
    };
  }

  var asMilliseconds = makeAs('ms'),
      asSeconds = makeAs('s'),
      asMinutes = makeAs('m'),
      asHours = makeAs('h'),
      asDays = makeAs('d'),
      asWeeks = makeAs('w'),
      asMonths = makeAs('M'),
      asQuarters = makeAs('Q'),
      asYears = makeAs('y');

  function clone$1() {
    return createDuration(this);
  }

  function get$2(units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
  }

  function makeGetter(name) {
    return function () {
      return this.isValid() ? this._data[name] : NaN;
    };
  }

  var milliseconds = makeGetter('milliseconds'),
      seconds = makeGetter('seconds'),
      minutes = makeGetter('minutes'),
      hours = makeGetter('hours'),
      days = makeGetter('days'),
      months = makeGetter('months'),
      years = makeGetter('years');

  function weeks() {
    return absFloor(this.days() / 7);
  }

  var round = Math.round,
      thresholds = {
    ss: 44,
    // a few seconds to seconds
    s: 45,
    // seconds to minute
    m: 45,
    // minutes to hour
    h: 22,
    // hours to day
    d: 26,
    // days to month/week
    w: null,
    // weeks to month
    M: 11 // months to year

  }; // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize

  function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
  }

  function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
    var duration = createDuration(posNegDuration).abs(),
        seconds = round(duration.as('s')),
        minutes = round(duration.as('m')),
        hours = round(duration.as('h')),
        days = round(duration.as('d')),
        months = round(duration.as('M')),
        weeks = round(duration.as('w')),
        years = round(duration.as('y')),
        a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days];

    if (thresholds.w != null) {
      a = a || weeks <= 1 && ['w'] || weeks < thresholds.w && ['ww', weeks];
    }

    a = a || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
  } // This function allows you to set the rounding function for relative time strings


  function getSetRelativeTimeRounding(roundingFunction) {
    if (roundingFunction === undefined) {
      return round;
    }

    if (typeof roundingFunction === 'function') {
      round = roundingFunction;
      return true;
    }

    return false;
  } // This function allows you to set a threshold for relative time strings


  function getSetRelativeTimeThreshold(threshold, limit) {
    if (thresholds[threshold] === undefined) {
      return false;
    }

    if (limit === undefined) {
      return thresholds[threshold];
    }

    thresholds[threshold] = limit;

    if (threshold === 's') {
      thresholds.ss = limit - 1;
    }

    return true;
  }

  function humanize(argWithSuffix, argThresholds) {
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var withSuffix = false,
        th = thresholds,
        locale,
        output;

    if (typeof argWithSuffix === 'object') {
      argThresholds = argWithSuffix;
      argWithSuffix = false;
    }

    if (typeof argWithSuffix === 'boolean') {
      withSuffix = argWithSuffix;
    }

    if (typeof argThresholds === 'object') {
      th = Object.assign({}, thresholds, argThresholds);

      if (argThresholds.s != null && argThresholds.ss == null) {
        th.ss = argThresholds.s - 1;
      }
    }

    locale = this.localeData();
    output = relativeTime$1(this, !withSuffix, th, locale);

    if (withSuffix) {
      output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
  }

  var abs$1 = Math.abs;

  function sign(x) {
    return (x > 0) - (x < 0) || +x;
  }

  function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
      return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000,
        days = abs$1(this._days),
        months = abs$1(this._months),
        minutes,
        hours,
        years,
        s,
        total = this.asSeconds(),
        totalSign,
        ymSign,
        daysSign,
        hmsSign;

    if (!total) {
      // this is the same as C#'s (Noda) and python (isodate)...
      // but not other JS (goog.date)
      return 'P0D';
    } // 3600 seconds -> 60 minutes -> 1 hour


    minutes = absFloor(seconds / 60);
    hours = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60; // 12 months -> 1 year

    years = absFloor(months / 12);
    months %= 12; // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js

    s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
    totalSign = total < 0 ? '-' : '';
    ymSign = sign(this._months) !== sign(total) ? '-' : '';
    daysSign = sign(this._days) !== sign(total) ? '-' : '';
    hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';
    return totalSign + 'P' + (years ? ymSign + years + 'Y' : '') + (months ? ymSign + months + 'M' : '') + (days ? daysSign + days + 'D' : '') + (hours || minutes || seconds ? 'T' : '') + (hours ? hmsSign + hours + 'H' : '') + (minutes ? hmsSign + minutes + 'M' : '') + (seconds ? hmsSign + s + 'S' : '');
  }

  var proto$2 = Duration.prototype;
  proto$2.isValid = isValid$1;
  proto$2.abs = abs;
  proto$2.add = add$1;
  proto$2.subtract = subtract$1;
  proto$2.as = as;
  proto$2.asMilliseconds = asMilliseconds;
  proto$2.asSeconds = asSeconds;
  proto$2.asMinutes = asMinutes;
  proto$2.asHours = asHours;
  proto$2.asDays = asDays;
  proto$2.asWeeks = asWeeks;
  proto$2.asMonths = asMonths;
  proto$2.asQuarters = asQuarters;
  proto$2.asYears = asYears;
  proto$2.valueOf = valueOf$1;
  proto$2._bubble = bubble;
  proto$2.clone = clone$1;
  proto$2.get = get$2;
  proto$2.milliseconds = milliseconds;
  proto$2.seconds = seconds;
  proto$2.minutes = minutes;
  proto$2.hours = hours;
  proto$2.days = days;
  proto$2.weeks = weeks;
  proto$2.months = months;
  proto$2.years = years;
  proto$2.humanize = humanize;
  proto$2.toISOString = toISOString$1;
  proto$2.toString = toISOString$1;
  proto$2.toJSON = toISOString$1;
  proto$2.locale = locale;
  proto$2.localeData = localeData;
  proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
  proto$2.lang = lang; // FORMATTING

  addFormatToken('X', 0, 0, 'unix');
  addFormatToken('x', 0, 0, 'valueOf'); // PARSING

  addRegexToken('x', matchSigned);
  addRegexToken('X', matchTimestamp);
  addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input) * 1000);
  });
  addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
  }); //! moment.js

  hooks.version = '2.29.4';
  setHookCallback(createLocal);
  hooks.fn = proto;
  hooks.min = min;
  hooks.max = max;
  hooks.now = now;
  hooks.utc = createUTC;
  hooks.unix = createUnix;
  hooks.months = listMonths;
  hooks.isDate = isDate;
  hooks.locale = getSetGlobalLocale;
  hooks.invalid = createInvalid;
  hooks.duration = createDuration;
  hooks.isMoment = isMoment;
  hooks.weekdays = listWeekdays;
  hooks.parseZone = createInZone;
  hooks.localeData = getLocale;
  hooks.isDuration = isDuration;
  hooks.monthsShort = listMonthsShort;
  hooks.weekdaysMin = listWeekdaysMin;
  hooks.defineLocale = defineLocale;
  hooks.updateLocale = updateLocale;
  hooks.locales = listLocales;
  hooks.weekdaysShort = listWeekdaysShort;
  hooks.normalizeUnits = normalizeUnits;
  hooks.relativeTimeRounding = getSetRelativeTimeRounding;
  hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
  hooks.calendarFormat = getCalendarFormat;
  hooks.prototype = proto; // currently HTML5 input type only supports 24-hour formats

  hooks.HTML5_FMT = {
    DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
    // <input type="datetime-local" />
    DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
    // <input type="datetime-local" step="1" />
    DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
    // <input type="datetime-local" step="0.001" />
    DATE: 'YYYY-MM-DD',
    // <input type="date" />
    TIME: 'HH:mm',
    // <input type="time" />
    TIME_SECONDS: 'HH:mm:ss',
    // <input type="time" step="1" />
    TIME_MS: 'HH:mm:ss.SSS',
    // <input type="time" step="0.001" />
    WEEK: 'GGGG-[W]WW',
    // <input type="week" />
    MONTH: 'YYYY-MM' // <input type="month" />

  };
  return hooks;
});

/***/ }),
/* 106 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./af": 107,
	"./af.js": 107,
	"./ar": 108,
	"./ar-dz": 109,
	"./ar-dz.js": 109,
	"./ar-kw": 110,
	"./ar-kw.js": 110,
	"./ar-ly": 111,
	"./ar-ly.js": 111,
	"./ar-ma": 112,
	"./ar-ma.js": 112,
	"./ar-sa": 113,
	"./ar-sa.js": 113,
	"./ar-tn": 114,
	"./ar-tn.js": 114,
	"./ar.js": 108,
	"./az": 115,
	"./az.js": 115,
	"./be": 116,
	"./be.js": 116,
	"./bg": 117,
	"./bg.js": 117,
	"./bm": 118,
	"./bm.js": 118,
	"./bn": 119,
	"./bn-bd": 120,
	"./bn-bd.js": 120,
	"./bn.js": 119,
	"./bo": 121,
	"./bo.js": 121,
	"./br": 122,
	"./br.js": 122,
	"./bs": 123,
	"./bs.js": 123,
	"./ca": 124,
	"./ca.js": 124,
	"./cs": 125,
	"./cs.js": 125,
	"./cv": 126,
	"./cv.js": 126,
	"./cy": 127,
	"./cy.js": 127,
	"./da": 128,
	"./da.js": 128,
	"./de": 129,
	"./de-at": 130,
	"./de-at.js": 130,
	"./de-ch": 131,
	"./de-ch.js": 131,
	"./de.js": 129,
	"./dv": 132,
	"./dv.js": 132,
	"./el": 133,
	"./el.js": 133,
	"./en-au": 134,
	"./en-au.js": 134,
	"./en-ca": 135,
	"./en-ca.js": 135,
	"./en-gb": 136,
	"./en-gb.js": 136,
	"./en-ie": 137,
	"./en-ie.js": 137,
	"./en-il": 138,
	"./en-il.js": 138,
	"./en-in": 139,
	"./en-in.js": 139,
	"./en-nz": 140,
	"./en-nz.js": 140,
	"./en-sg": 141,
	"./en-sg.js": 141,
	"./eo": 142,
	"./eo.js": 142,
	"./es": 143,
	"./es-do": 144,
	"./es-do.js": 144,
	"./es-mx": 145,
	"./es-mx.js": 145,
	"./es-us": 146,
	"./es-us.js": 146,
	"./es.js": 143,
	"./et": 147,
	"./et.js": 147,
	"./eu": 148,
	"./eu.js": 148,
	"./fa": 149,
	"./fa.js": 149,
	"./fi": 150,
	"./fi.js": 150,
	"./fil": 151,
	"./fil.js": 151,
	"./fo": 152,
	"./fo.js": 152,
	"./fr": 153,
	"./fr-ca": 154,
	"./fr-ca.js": 154,
	"./fr-ch": 155,
	"./fr-ch.js": 155,
	"./fr.js": 153,
	"./fy": 156,
	"./fy.js": 156,
	"./ga": 157,
	"./ga.js": 157,
	"./gd": 158,
	"./gd.js": 158,
	"./gl": 159,
	"./gl.js": 159,
	"./gom-deva": 160,
	"./gom-deva.js": 160,
	"./gom-latn": 161,
	"./gom-latn.js": 161,
	"./gu": 162,
	"./gu.js": 162,
	"./he": 163,
	"./he.js": 163,
	"./hi": 164,
	"./hi.js": 164,
	"./hr": 165,
	"./hr.js": 165,
	"./hu": 166,
	"./hu.js": 166,
	"./hy-am": 167,
	"./hy-am.js": 167,
	"./id": 168,
	"./id.js": 168,
	"./is": 169,
	"./is.js": 169,
	"./it": 170,
	"./it-ch": 171,
	"./it-ch.js": 171,
	"./it.js": 170,
	"./ja": 172,
	"./ja.js": 172,
	"./jv": 173,
	"./jv.js": 173,
	"./ka": 174,
	"./ka.js": 174,
	"./kk": 175,
	"./kk.js": 175,
	"./km": 176,
	"./km.js": 176,
	"./kn": 177,
	"./kn.js": 177,
	"./ko": 178,
	"./ko.js": 178,
	"./ku": 179,
	"./ku.js": 179,
	"./ky": 180,
	"./ky.js": 180,
	"./lb": 181,
	"./lb.js": 181,
	"./lo": 182,
	"./lo.js": 182,
	"./lt": 183,
	"./lt.js": 183,
	"./lv": 184,
	"./lv.js": 184,
	"./me": 185,
	"./me.js": 185,
	"./mi": 186,
	"./mi.js": 186,
	"./mk": 187,
	"./mk.js": 187,
	"./ml": 188,
	"./ml.js": 188,
	"./mn": 189,
	"./mn.js": 189,
	"./mr": 190,
	"./mr.js": 190,
	"./ms": 191,
	"./ms-my": 192,
	"./ms-my.js": 192,
	"./ms.js": 191,
	"./mt": 193,
	"./mt.js": 193,
	"./my": 194,
	"./my.js": 194,
	"./nb": 195,
	"./nb.js": 195,
	"./ne": 196,
	"./ne.js": 196,
	"./nl": 197,
	"./nl-be": 198,
	"./nl-be.js": 198,
	"./nl.js": 197,
	"./nn": 199,
	"./nn.js": 199,
	"./oc-lnc": 200,
	"./oc-lnc.js": 200,
	"./pa-in": 201,
	"./pa-in.js": 201,
	"./pl": 202,
	"./pl.js": 202,
	"./pt": 203,
	"./pt-br": 204,
	"./pt-br.js": 204,
	"./pt.js": 203,
	"./ro": 205,
	"./ro.js": 205,
	"./ru": 206,
	"./ru.js": 206,
	"./sd": 207,
	"./sd.js": 207,
	"./se": 208,
	"./se.js": 208,
	"./si": 209,
	"./si.js": 209,
	"./sk": 210,
	"./sk.js": 210,
	"./sl": 211,
	"./sl.js": 211,
	"./sq": 212,
	"./sq.js": 212,
	"./sr": 213,
	"./sr-cyrl": 214,
	"./sr-cyrl.js": 214,
	"./sr.js": 213,
	"./ss": 215,
	"./ss.js": 215,
	"./sv": 216,
	"./sv.js": 216,
	"./sw": 217,
	"./sw.js": 217,
	"./ta": 218,
	"./ta.js": 218,
	"./te": 219,
	"./te.js": 219,
	"./tet": 220,
	"./tet.js": 220,
	"./tg": 221,
	"./tg.js": 221,
	"./th": 222,
	"./th.js": 222,
	"./tk": 223,
	"./tk.js": 223,
	"./tl-ph": 224,
	"./tl-ph.js": 224,
	"./tlh": 225,
	"./tlh.js": 225,
	"./tr": 226,
	"./tr.js": 226,
	"./tzl": 227,
	"./tzl.js": 227,
	"./tzm": 228,
	"./tzm-latn": 229,
	"./tzm-latn.js": 229,
	"./tzm.js": 228,
	"./ug-cn": 230,
	"./ug-cn.js": 230,
	"./uk": 231,
	"./uk.js": 231,
	"./ur": 232,
	"./ur.js": 232,
	"./uz": 233,
	"./uz-latn": 234,
	"./uz-latn.js": 234,
	"./uz.js": 233,
	"./vi": 235,
	"./vi.js": 235,
	"./x-pseudo": 236,
	"./x-pseudo.js": 236,
	"./yo": 237,
	"./yo.js": 237,
	"./zh-cn": 238,
	"./zh-cn.js": 238,
	"./zh-hk": 239,
	"./zh-hk.js": 239,
	"./zh-mo": 240,
	"./zh-mo.js": 240,
	"./zh-tw": 241,
	"./zh-tw.js": 241
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 106;

/***/ }),
/* 107 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Afrikaans [af]
//! author : Werner Mollentze : https://github.com/wernerm
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var af = moment.defineLocale('af', {
    months: 'Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag'.split('_'),
    weekdaysShort: 'Son_Maa_Din_Woe_Don_Vry_Sat'.split('_'),
    weekdaysMin: 'So_Ma_Di_Wo_Do_Vr_Sa'.split('_'),
    meridiemParse: /vm|nm/i,
    isPM: function (input) {
      return /^nm$/i.test(input);
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'vm' : 'VM';
      } else {
        return isLower ? 'nm' : 'NM';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Vandag om] LT',
      nextDay: '[Mre om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[Gister om] LT',
      lastWeek: '[Laas] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oor %s',
      past: '%s gelede',
      s: "'n paar sekondes",
      ss: '%d sekondes',
      m: "'n minuut",
      mm: '%d minute',
      h: "'n uur",
      hh: '%d ure',
      d: "'n dag",
      dd: '%d dae',
      M: "'n maand",
      MM: '%d maande',
      y: "'n jaar",
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de'); // Thanks to Joris Rling : https://github.com/jjupiter
    },
    week: {
      dow: 1,
      // Maandag is die eerste dag van die week.
      doy: 4 // Die week wat die 4de Januarie bevat is die eerste week van die jaar.

    }
  });
  return af;
});

/***/ }),
/* 108 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic [ar]
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  },
      pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
  },
      pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['', '', '', '', '', '', '', '', '', '', '', ''];

  var ar = moment.defineLocale('ar', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return ar;
});

/***/ }),
/* 109 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Algeria) [ar-dz]
//! author : Amine Roukh: https://github.com/Amine27
//! author : Abdel Said: https://github.com/abdelsaid
//! author : Ahmed Elkhatib
//! author : forabi https://github.com/forabi
//! author : Noureddine LOUAHEDJ : https://github.com/noureddinem
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
  },
      pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['', '', '', '', '', '', '', '', '', '', '', ''];

  var arDz = moment.defineLocale('ar-dz', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arDz;
});

/***/ }),
/* 110 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Kuwait) [ar-kw]
//! author : Nusret Parlak: https://github.com/nusretparlak
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var arKw = moment.defineLocale('ar-kw', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return arKw;
});

/***/ }),
/* 111 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Libya) [ar-ly]
//! author : Ali Hmer: https://github.com/kikoanis
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '1',
    2: '2',
    3: '3',
    4: '4',
    5: '5',
    6: '6',
    7: '7',
    8: '8',
    9: '9',
    0: '0'
  },
      pluralForm = function (n) {
    return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;
  },
      plurals = {
    s: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    m: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    h: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    d: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    M: ['  ', ' ', ['', ''], '%d ', '%d ', '%d '],
    y: ['  ', ' ', ['', ''], '%d ', '%d ', '%d ']
  },
      pluralize = function (u) {
    return function (number, withoutSuffix, string, isFuture) {
      var f = pluralForm(number),
          str = plurals[u][pluralForm(number)];

      if (f === 2) {
        str = str[withoutSuffix ? 0 : 1];
      }

      return str.replace(/%d/i, number);
    };
  },
      months = ['', '', '', '', '', '', '', '', '', '', '', ''];

  var arLy = moment.defineLocale('ar-ly', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/\u200FM/\u200FYYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: pluralize('s'),
      ss: pluralize('s'),
      m: pluralize('m'),
      mm: pluralize('m'),
      h: pluralize('h'),
      hh: pluralize('h'),
      d: pluralize('d'),
      dd: pluralize('d'),
      M: pluralize('M'),
      MM: pluralize('M'),
      y: pluralize('y'),
      yy: pluralize('y')
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return arLy;
});

/***/ }),
/* 112 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Morocco) [ar-ma]
//! author : ElFadili Yassine : https://github.com/ElFadiliY
//! author : Abdel Said : https://github.com/abdelsaid
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var arMa = moment.defineLocale('ar-ma', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arMa;
});

/***/ }),
/* 113 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Arabic (Saudi Arabia) [ar-sa]
//! author : Suhail Alkowaileet : https://github.com/xsoh
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var arSa = moment.defineLocale('ar-sa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return arSa;
});

/***/ }),
/* 114 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale  :  Arabic (Tunisia) [ar-tn]
//! author : Nader Toukabri : https://github.com/naderio
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var arTn = moment.defineLocale('ar-tn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[  ] LT',
      nextDay: '[  ] LT',
      nextWeek: 'dddd [ ] LT',
      lastDay: '[  ] LT',
      lastWeek: 'dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return arTn;
});

/***/ }),
/* 115 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Azerbaijani [az]
//! author : topchiyev : https://github.com/topchiyev
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    1: '-inci',
    5: '-inci',
    8: '-inci',
    70: '-inci',
    80: '-inci',
    2: '-nci',
    7: '-nci',
    20: '-nci',
    50: '-nci',
    3: '-nc',
    4: '-nc',
    100: '-nc',
    6: '-nc',
    9: '-uncu',
    10: '-uncu',
    30: '-uncu',
    60: '-nc',
    90: '-nc'
  };
  var az = moment.defineLocale('az', {
    months: 'yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr'.split('_'),
    monthsShort: 'yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek'.split('_'),
    weekdays: 'Bazar_Bazar ertsi_rnb axam_rnb_Cm axam_Cm_nb'.split('_'),
    weekdaysShort: 'Baz_BzE_Ax_r_CAx_Cm_n'.split('_'),
    weekdaysMin: 'Bz_BE_A__CA_C_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[sabah saat] LT',
      nextWeek: '[gln hft] dddd [saat] LT',
      lastDay: '[dnn] LT',
      lastWeek: '[ken hft] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s vvl',
      s: 'bir ne saniy',
      ss: '%d saniy',
      m: 'bir dqiq',
      mm: '%d dqiq',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir il',
      yy: '%d il'
    },
    meridiemParse: /gec|shr|gndz|axam/,
    isPM: function (input) {
      return /^(gndz|axam)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'gec';
      } else if (hour < 12) {
        return 'shr';
      } else if (hour < 17) {
        return 'gndz';
      } else {
        return 'axam';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(nc|inci|nci|nc|nc|uncu)/,
    ordinal: function (number) {
      if (number === 0) {
        // special case for zero
        return number + '-nc';
      }

      var a = number % 10,
          b = number % 100 - a,
          c = number >= 100 ? 100 : null;
      return number + (suffixes[a] || suffixes[b] || suffixes[c]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return az;
});

/***/ }),
/* 116 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Belarusian [be]
//! author : Dmitry Demidov : https://github.com/demidov91
//! author: Praleska: http://praleska.pro/
//! Author : Menelion Elensle : https://github.com/Oire
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: withoutSuffix ? '__' : '__',
      dd: '__',
      MM: '__',
      yy: '__'
    };

    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  var be = moment.defineLocale('be', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: {
      format: '______'.split('_'),
      standalone: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:|)? ?\] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: function () {
        return '[] dddd [] LT';
      },
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return '[ ] dddd [] LT';

          case 1:
          case 2:
          case 4:
            return '[ ] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithPlural,
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return (number % 10 === 2 || number % 10 === 3) && number % 100 !== 12 && number % 100 !== 13 ? number + '-' : number + '-';

        case 'D':
          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return be;
});

/***/ }),
/* 117 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bulgarian [bg]
//! author : Krasen Borisov : https://github.com/kraz
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var bg = moment.defineLocale('bg', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[] dddd [] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      w: '',
      ww: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function (number) {
      var lastDigit = number % 10,
          last2Digits = number % 100;

      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return bg;
});

/***/ }),
/* 118 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bambara [bm]
//! author : Estelle Comment : https://github.com/estellecomment
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var bm = moment.defineLocale('bm', {
    months: 'Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mkalo_Zuwnkalo_Zuluyekalo_Utikalo_Stanburukalo_kutburukalo_Nowanburukalo_Desanburukalo'.split('_'),
    monthsShort: 'Zan_Few_Mar_Awi_M_Zuw_Zul_Uti_St_ku_Now_Des'.split('_'),
    weekdays: 'Kari_Ntnn_Tarata_Araba_Alamisa_Juma_Sibiri'.split('_'),
    weekdaysShort: 'Kar_Nt_Tar_Ara_Ala_Jum_Sib'.split('_'),
    weekdaysMin: 'Ka_Nt_Ta_Ar_Al_Ju_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'MMMM [tile] D [san] YYYY',
      LLL: 'MMMM [tile] D [san] YYYY [lr] HH:mm',
      LLLL: 'dddd MMMM [tile] D [san] YYYY [lr] HH:mm'
    },
    calendar: {
      sameDay: '[Bi lr] LT',
      nextDay: '[Sini lr] LT',
      nextWeek: 'dddd [don lr] LT',
      lastDay: '[Kunu lr] LT',
      lastWeek: 'dddd [tmnen lr] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s kn',
      past: 'a b %s b',
      s: 'sanga dama dama',
      ss: 'sekondi %d',
      m: 'miniti kelen',
      mm: 'miniti %d',
      h: 'lr kelen',
      hh: 'lr %d',
      d: 'tile kelen',
      dd: 'tile %d',
      M: 'kalo kelen',
      MM: 'kalo %d',
      y: 'san kelen',
      yy: 'san %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return bm;
});

/***/ }),
/* 119 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali [bn]
//! author : Kaushik Gandhi : https://github.com/kaushikgandhi
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var bn = moment.defineLocale('bn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bn;
});

/***/ }),
/* 120 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bengali (Bangladesh) [bn-bd]
//! author : Asraf Hossain Patoary : https://github.com/ashwoolford
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var bnBd = moment.defineLocale('bn-bd', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 3 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 6) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 15) {
        return '';
      } else if (hour < 18) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bnBd;
});

/***/ }),
/* 121 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tibetan [bo]
//! author : Thupten N. Chakrishar : https://github.com/vajradog
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var bo = moment.defineLocale('bo', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShortRegex: /^(\d{1,2})/,
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[], LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' && hour >= 4 || meridiem === '' && hour < 5 || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return bo;
});

/***/ }),
/* 122 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Breton [br]
//! author : Jean-Baptiste Le Duigou : https://github.com/jbleduigou
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function relativeTimeWithMutation(number, withoutSuffix, key) {
    var format = {
      mm: 'munutenn',
      MM: 'miz',
      dd: 'devezh'
    };
    return number + ' ' + mutation(format[key], number);
  }

  function specialMutationForYears(number) {
    switch (lastNumber(number)) {
      case 1:
      case 3:
      case 4:
      case 5:
      case 9:
        return number + ' bloaz';

      default:
        return number + ' vloaz';
    }
  }

  function lastNumber(number) {
    if (number > 9) {
      return lastNumber(number % 10);
    }

    return number;
  }

  function mutation(text, number) {
    if (number === 2) {
      return softMutation(text);
    }

    return text;
  }

  function softMutation(text) {
    var mutationTable = {
      m: 'v',
      b: 'v',
      d: 'z'
    };

    if (mutationTable[text.charAt(0)] === undefined) {
      return text;
    }

    return mutationTable[text.charAt(0)] + text.substring(1);
  }

  var monthsParse = [/^gen/i, /^c[\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i],
      monthsRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
      monthsStrictRegex = /^(genver|c[\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
      monthsShortStrictRegex = /^(gen|c[\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
      fullWeekdaysParse = [/^sul/i, /^lun/i, /^meurzh/i, /^merc[\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i],
      shortWeekdaysParse = [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i],
      minWeekdaysParse = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
  var br = moment.defineLocale('br', {
    months: 'Genver_Chwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu'.split('_'),
    monthsShort: 'Gen_Chwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker'.split('_'),
    weekdays: 'Sul_Lun_Meurzh_Mercher_Yaou_Gwener_Sadorn'.split('_'),
    weekdaysShort: 'Sul_Lun_Meu_Mer_Yao_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Lu_Me_Mer_Ya_Gw_Sa'.split('_'),
    weekdaysParse: minWeekdaysParse,
    fullWeekdaysParse: fullWeekdaysParse,
    shortWeekdaysParse: shortWeekdaysParse,
    minWeekdaysParse: minWeekdaysParse,
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: monthsStrictRegex,
    monthsShortStrictRegex: monthsShortStrictRegex,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [a viz] MMMM YYYY',
      LLL: 'D [a viz] MMMM YYYY HH:mm',
      LLLL: 'dddd, D [a viz] MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hiziv da] LT',
      nextDay: '[Warchoazh da] LT',
      nextWeek: 'dddd [da] LT',
      lastDay: '[Dech da] LT',
      lastWeek: 'dddd [paset da] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'a-benn %s',
      past: '%s zo',
      s: 'un nebeud segondenno',
      ss: '%d eilenn',
      m: 'ur vunutenn',
      mm: relativeTimeWithMutation,
      h: 'un eur',
      hh: '%d eur',
      d: 'un devezh',
      dd: relativeTimeWithMutation,
      M: 'ur miz',
      MM: relativeTimeWithMutation,
      y: 'ur bloaz',
      yy: specialMutationForYears
    },
    dayOfMonthOrdinalParse: /\d{1,2}(a|vet)/,
    ordinal: function (number) {
      var output = number === 1 ? 'a' : 'vet';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    },
    meridiemParse: /a.m.|g.m./,
    // goude merenn | a-raok merenn
    isPM: function (token) {
      return token === 'g.m.';
    },
    meridiem: function (hour, minute, isLower) {
      return hour < 12 ? 'a.m.' : 'g.m.';
    }
  });
  return br;
});

/***/ }),
/* 123 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Bosnian [bs]
//! author : Nedim Cholich : https://github.com/frontyard
//! based on (hr) translation by Bojan Markovi
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';

      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';

      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }

        return result;

      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }

        return result;

      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }

        return result;

      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }

        return result;
    }
  }

  var bs = moment.defineLocale('bs', {
    months: 'januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
            return '[prolu] dddd [u] LT';

          case 6:
            return '[prole] [subote] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return bs;
});

/***/ }),
/* 124 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Catalan [ca]
//! author : Juan G. Hurtado : https://github.com/juanghurtado
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ca = moment.defineLocale('ca', {
    months: {
      standalone: 'gener_febrer_mar_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre'.split('_'),
      format: "de gener_de febrer_de mar_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._mar_abr._maig_juny_jul._ag._set._oct._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dt._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dt_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a les] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a les] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[avui a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextDay: function () {
        return '[dem a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastDay: function () {
        return '[ahir a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [passat a ' + (this.hours() !== 1 ? 'les' : 'la') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: "d'aqu %s",
      past: 'fa %s',
      s: 'uns segons',
      ss: '%d segons',
      m: 'un minut',
      mm: '%d minuts',
      h: 'una hora',
      hh: '%d hores',
      d: 'un dia',
      dd: '%d dies',
      M: 'un mes',
      MM: '%d mesos',
      y: 'un any',
      yy: '%d anys'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal: function (number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';

      if (period === 'w' || period === 'W') {
        output = 'a';
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ca;
});

/***/ }),
/* 125 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Czech [cs]
//! author : petrbela : https://github.com/petrbela
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = {
    format: 'leden_nor_bezen_duben_kvten_erven_ervenec_srpen_z_jen_listopad_prosinec'.split('_'),
    standalone: 'ledna_nora_bezna_dubna_kvtna_ervna_ervence_srpna_z_jna_listopadu_prosince'.split('_')
  },
      monthsShort = 'led_no_be_dub_kv_vn_vc_srp_z_j_lis_pro'.split('_'),
      monthsParse = [/^led/i, /^no/i, /^be/i, /^dub/i, /^kv/i, /^(vn|erven$|ervna)/i, /^(vc|ervenec|ervence)/i, /^srp/i, /^z/i, /^j/i, /^lis/i, /^pro/i],
      // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
  // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
  monthsRegex = /^(leden|nor|bezen|duben|kvten|ervenec|ervence|erven|ervna|srpen|z|jen|listopad|prosinec|led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i;

  function plural(n) {
    return n > 1 && n < 5 && ~~(n / 10) !== 1;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr sekund' : 'pr sekundami';

      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'sekund');
        } else {
          return result + 'sekundami';
        }

      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minuta' : isFuture ? 'minutu' : 'minutou';

      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minuty' : 'minut');
        } else {
          return result + 'minutami';
        }

      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodin');
        } else {
          return result + 'hodinami';
        }

      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'den' : 'dnem';

      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dny' : 'dn');
        } else {
          return result + 'dny';
        }

      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'msc' : 'mscem';

      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'msce' : 'msc');
        } else {
          return result + 'msci';
        }

      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokem';

      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'let');
        } else {
          return result + 'lety';
        }

    }
  }

  var cs = moment.defineLocale('cs', {
    months: months,
    monthsShort: monthsShort,
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    // NOTE: 'erven' is substring of 'ervenec'; therefore 'ervenec' must precede 'erven' in the regex to be fully matched.
    // Otherwise parser matches '1. ervenec' as '1. erven' + 'ec'.
    monthsStrictRegex: /^(leden|ledna|nora|nor|bezen|bezna|duben|dubna|kvten|kvtna|ervenec|ervence|erven|ervna|srpen|srpna|z|jen|jna|listopadu|listopad|prosinec|prosince)/i,
    monthsShortStrictRegex: /^(led|no|be|dub|kv|vn|vc|srp|z|j|lis|pro)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'nedle_pondl_ter_steda_tvrtek_ptek_sobota'.split('_'),
    weekdaysShort: 'ne_po_t_st_t_p_so'.split('_'),
    weekdaysMin: 'ne_po_t_st_t_p_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm',
      l: 'D. M. YYYY'
    },
    calendar: {
      sameDay: '[dnes v] LT',
      nextDay: '[ztra v] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v nedli v] LT';

          case 1:
          case 2:
            return '[v] dddd [v] LT';

          case 3:
            return '[ve stedu v] LT';

          case 4:
            return '[ve tvrtek v] LT';

          case 5:
            return '[v ptek v] LT';

          case 6:
            return '[v sobotu v] LT';
        }
      },
      lastDay: '[vera v] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[minulou nedli v] LT';

          case 1:
          case 2:
            return '[minul] dddd [v] LT';

          case 3:
            return '[minulou stedu v] LT';

          case 4:
          case 5:
            return '[minul] dddd [v] LT';

          case 6:
            return '[minulou sobotu v] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'ped %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return cs;
});

/***/ }),
/* 126 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chuvash [cv]
//! author : Anatoly Mironov : https://github.com/mirontoli
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var cv = moment.defineLocale('cv', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'YYYY [] MMMM [] D[-]',
      LLL: 'YYYY [] MMMM [] D[-], HH:mm',
      LLLL: 'dddd, YYYY [] MMMM [] D[-], HH:mm'
    },
    calendar: {
      sameDay: '[] LT []',
      nextDay: '[] LT []',
      lastDay: '[] LT []',
      nextWeek: '[] dddd LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: function (output) {
        var affix = /$/i.exec(output) ? '' : /$/i.exec(output) ? '' : '';
        return output + affix;
      },
      past: '%s ',
      s: '- ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-/,
    ordinal: '%d-',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return cv;
});

/***/ }),
/* 127 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Welsh [cy]
//! author : Robert Allen : https://github.com/robgallen
//! author : https://github.com/ryangreaves
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var cy = moment.defineLocale('cy', {
    months: 'Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr'.split('_'),
    monthsShort: 'Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag'.split('_'),
    weekdays: 'Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn'.split('_'),
    weekdaysShort: 'Sul_Llun_Maw_Mer_Iau_Gwe_Sad'.split('_'),
    weekdaysMin: 'Su_Ll_Ma_Me_Ia_Gw_Sa'.split('_'),
    weekdaysParseExact: true,
    // time formats are the same as en-gb
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Heddiw am] LT',
      nextDay: '[Yfory am] LT',
      nextWeek: 'dddd [am] LT',
      lastDay: '[Ddoe am] LT',
      lastWeek: 'dddd [diwethaf am] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'mewn %s',
      past: '%s yn l',
      s: 'ychydig eiliadau',
      ss: '%d eiliad',
      m: 'munud',
      mm: '%d munud',
      h: 'awr',
      hh: '%d awr',
      d: 'diwrnod',
      dd: '%d diwrnod',
      M: 'mis',
      MM: '%d mis',
      y: 'blwyddyn',
      yy: '%d flynedd'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
    // traditional ordinal numbers above 31 are not commonly used in colloquial Welsh
    ordinal: function (number) {
      var b = number,
          output = '',
          lookup = ['', 'af', 'il', 'ydd', 'ydd', 'ed', 'ed', 'ed', 'fed', 'fed', 'fed', // 1af to 10fed
      'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'eg', 'fed', 'eg', 'fed' // 11eg to 20fed
      ];

      if (b > 20) {
        if (b === 40 || b === 50 || b === 60 || b === 80 || b === 100) {
          output = 'fed'; // not 30ain, 70ain or 90ain
        } else {
          output = 'ain';
        }
      } else if (b > 0) {
        output = lookup[b];
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return cy;
});

/***/ }),
/* 128 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Danish [da]
//! author : Ulrik Nielsen : https://github.com/mrbase
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var da = moment.defineLocale('da', {
    months: 'januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_man_tir_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd [d.] D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'p dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[i] dddd[s kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'f sekunder',
      ss: '%d sekunder',
      m: 'et minut',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dage',
      M: 'en mned',
      MM: '%d mneder',
      y: 'et r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return da;
});

/***/ }),
/* 129 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German [de]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Mikolaj Dadela : https://github.com/mik01aj
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var de = moment.defineLocale('de', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return de;
});

/***/ }),
/* 130 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Austria) [de-at]
//! author : lluchs : https://github.com/lluchs
//! author: Menelion Elensle: https://github.com/Oire
//! author : Martin Groller : https://github.com/MadMG
//! author : Mikolaj Dadela : https://github.com/mik01aj
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var deAt = moment.defineLocale('de-at', {
    months: 'Jnner_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jn._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So._Mo._Di._Mi._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return deAt;
});

/***/ }),
/* 131 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : German (Switzerland) [de-ch]
//! author : sschueller : https://github.com/sschueller
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eine Minute', 'einer Minute'],
      h: ['eine Stunde', 'einer Stunde'],
      d: ['ein Tag', 'einem Tag'],
      dd: [number + ' Tage', number + ' Tagen'],
      w: ['eine Woche', 'einer Woche'],
      M: ['ein Monat', 'einem Monat'],
      MM: [number + ' Monate', number + ' Monaten'],
      y: ['ein Jahr', 'einem Jahr'],
      yy: [number + ' Jahre', number + ' Jahren']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  var deCh = moment.defineLocale('de-ch', {
    months: 'Januar_Februar_Mrz_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Feb._Mrz_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag'.split('_'),
    weekdaysShort: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysMin: 'So_Mo_Di_Mi_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY HH:mm',
      LLLL: 'dddd, D. MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[heute um] LT [Uhr]',
      sameElse: 'L',
      nextDay: '[morgen um] LT [Uhr]',
      nextWeek: 'dddd [um] LT [Uhr]',
      lastDay: '[gestern um] LT [Uhr]',
      lastWeek: '[letzten] dddd [um] LT [Uhr]'
    },
    relativeTime: {
      future: 'in %s',
      past: 'vor %s',
      s: 'ein paar Sekunden',
      ss: '%d Sekunden',
      m: processRelativeTime,
      mm: '%d Minuten',
      h: processRelativeTime,
      hh: '%d Stunden',
      d: processRelativeTime,
      dd: processRelativeTime,
      w: processRelativeTime,
      ww: '%d Wochen',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return deCh;
});

/***/ }),
/* 132 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maldivian [dv]
//! author : Jawish Hameed : https://github.com/jawish
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
      weekdays = ['', '', '', '', '', '', ''];
  var dv = moment.defineLocale('dv', {
    months: months,
    monthsShort: months,
    weekdays: weekdays,
    weekdaysShort: weekdays,
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'D/M/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: '',
      ss: 'd% ',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 7,
      // Sunday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return dv;
});

/***/ }),
/* 133 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Greek [el]
//! author : Aggelos Karalias : https://github.com/mehiel
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function isFunction(input) {
    return typeof Function !== 'undefined' && input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
  }

  var el = moment.defineLocale('el', {
    monthsNominativeEl: '___________'.split('_'),
    monthsGenitiveEl: '___________'.split('_'),
    months: function (momentToFormat, format) {
      if (!momentToFormat) {
        return this._monthsNominativeEl;
      } else if (typeof format === 'string' && /D/.test(format.substring(0, format.indexOf('MMMM')))) {
        // if there is a day number before 'MMMM'
        return this._monthsGenitiveEl[momentToFormat.month()];
      } else {
        return this._monthsNominativeEl[momentToFormat.month()];
      }
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '' : '';
      } else {
        return isLower ? '' : '';
      }
    },
    isPM: function (input) {
      return (input + '').toLowerCase()[0] === '';
    },
    meridiemParse: /[]\.??\.?/i,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendarEl: {
      sameDay: '[ {}] LT',
      nextDay: '[ {}] LT',
      nextWeek: 'dddd [{}] LT',
      lastDay: '[ {}] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 6:
            return '[ ] dddd [{}] LT';

          default:
            return '[ ] dddd [{}] LT';
        }
      },
      sameElse: 'L'
    },
    calendar: function (key, mom) {
      var output = this._calendarEl[key],
          hours = mom && mom.hours();

      if (isFunction(output)) {
        output = output.apply(mom);
      }

      return output.replace('{}', hours % 12 === 1 ? '' : '');
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4st is the first week of the year.

    }
  });
  return el;
});

/***/ }),
/* 134 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Australia) [en-au]
//! author : Jared Morse : https://github.com/jarcoal
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enAu = moment.defineLocale('en-au', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enAu;
});

/***/ }),
/* 135 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Canada) [en-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enCa = moment.defineLocale('en-ca', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'YYYY-MM-DD',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY h:mm A',
      LLLL: 'dddd, MMMM D, YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enCa;
});

/***/ }),
/* 136 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (United Kingdom) [en-gb]
//! author : Chris Gedrim : https://github.com/chrisgedrim
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enGb = moment.defineLocale('en-gb', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enGb;
});

/***/ }),
/* 137 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Ireland) [en-ie]
//! author : Chris Cartlidge : https://github.com/chriscartlidge
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enIe = moment.defineLocale('en-ie', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enIe;
});

/***/ }),
/* 138 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Israel) [en-il]
//! author : Chris Gedrim : https://github.com/chrisgedrim
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enIl = moment.defineLocale('en-il', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    }
  });
  return enIl;
});

/***/ }),
/* 139 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (India) [en-in]
//! author : Jatin Agrawal : https://github.com/jatinag22
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enIn = moment.defineLocale('en-in', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 1st is the first week of the year.

    }
  });
  return enIn;
});

/***/ }),
/* 140 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (New Zealand) [en-nz]
//! author : Luke McGregor : https://github.com/lukemcgregor
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enNz = moment.defineLocale('en-nz', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enNz;
});

/***/ }),
/* 141 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : English (Singapore) [en-sg]
//! author : Matthew Castrillon-Madrigal : https://github.com/techdimension
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var enSg = moment.defineLocale('en-sg', {
    months: 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
    weekdays: 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
    weekdaysShort: 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
    weekdaysMin: 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Today at] LT',
      nextDay: '[Tomorrow at] LT',
      nextWeek: 'dddd [at] LT',
      lastDay: '[Yesterday at] LT',
      lastWeek: '[Last] dddd [at] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'in %s',
      past: '%s ago',
      s: 'a few seconds',
      ss: '%d seconds',
      m: 'a minute',
      mm: '%d minutes',
      h: 'an hour',
      hh: '%d hours',
      d: 'a day',
      dd: '%d days',
      M: 'a month',
      MM: '%d months',
      y: 'a year',
      yy: '%d years'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return enSg;
});

/***/ }),
/* 142 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Esperanto [eo]
//! author : Colin Dean : https://github.com/colindean
//! author : Mia Nordentoft Imperatori : https://github.com/miestasmia
//! comment : miestasmia corrected the translation by colindean
//! comment : Vivakvo corrected the translation by colindean and miestasmia
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var eo = moment.defineLocale('eo', {
    months: 'januaro_februaro_marto_aprilo_majo_junio_julio_agusto_septembro_oktobro_novembro_decembro'.split('_'),
    monthsShort: 'jan_feb_mart_apr_maj_jun_jul_ag_sept_okt_nov_dec'.split('_'),
    weekdays: 'dimano_lundo_mardo_merkredo_ado_vendredo_sabato'.split('_'),
    weekdaysShort: 'dim_lun_mard_merk_a_ven_sab'.split('_'),
    weekdaysMin: 'di_lu_ma_me_a_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: '[la] D[-an de] MMMM, YYYY',
      LLL: '[la] D[-an de] MMMM, YYYY HH:mm',
      LLLL: 'dddd[n], [la] D[-an de] MMMM, YYYY HH:mm',
      llll: 'ddd, [la] D[-an de] MMM, YYYY HH:mm'
    },
    meridiemParse: /[ap]\.t\.m/i,
    isPM: function (input) {
      return input.charAt(0).toLowerCase() === 'p';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? 'p.t.m.' : 'P.T.M.';
      } else {
        return isLower ? 'a.t.m.' : 'A.T.M.';
      }
    },
    calendar: {
      sameDay: '[Hodia je] LT',
      nextDay: '[Morga je] LT',
      nextWeek: 'dddd[n je] LT',
      lastDay: '[Hiera je] LT',
      lastWeek: '[pasintan] dddd[n je] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'post %s',
      past: 'anta %s',
      s: 'kelkaj sekundoj',
      ss: '%d sekundoj',
      m: 'unu minuto',
      mm: '%d minutoj',
      h: 'unu horo',
      hh: '%d horoj',
      d: 'unu tago',
      //ne 'diurno', ar estas uzita por proksimumo
      dd: '%d tagoj',
      M: 'unu monato',
      MM: '%d monatoj',
      y: 'unu jaro',
      yy: '%d jaroj'
    },
    dayOfMonthOrdinalParse: /\d{1,2}a/,
    ordinal: '%da',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return eo;
});

/***/ }),
/* 143 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish [es]
//! author : Julio Napur : https://github.com/julionc
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var es = moment.defineLocale('es', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    },
    invalidDate: 'Fecha invlida'
  });
  return es;
});

/***/ }),
/* 144 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Dominican Republic) [es-do]
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esDo = moment.defineLocale('es-do', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return esDo;
});

/***/ }),
/* 145 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (Mexico) [es-mx]
//! author : JC Franco : https://github.com/jcfranco
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esMx = moment.defineLocale('es-mx', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    },
    invalidDate: 'Fecha invlida'
  });
  return esMx;
});

/***/ }),
/* 146 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Spanish (United States) [es-us]
//! author : bustta : https://github.com/bustta
//! author : chrisrodz : https://github.com/chrisrodz
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortDot = 'ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.'.split('_'),
      monthsShort = 'ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic'.split('_'),
      monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
      monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
  var esUs = moment.defineLocale('es-us', {
    months: 'enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortDot;
      } else if (/-MMM-/.test(format)) {
        return monthsShort[m.month()];
      } else {
        return monthsShortDot[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
    monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'domingo_lunes_martes_mircoles_jueves_viernes_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mi._jue._vie._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_mi_ju_vi_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'MM/DD/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY h:mm A',
      LLLL: 'dddd, D [de] MMMM [de] YYYY h:mm A'
    },
    calendar: {
      sameDay: function () {
        return '[hoy a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[maana a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastDay: function () {
        return '[ayer a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      lastWeek: function () {
        return '[el] dddd [pasado a la' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'en %s',
      past: 'hace %s',
      s: 'unos segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'una hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      w: 'una semana',
      ww: '%d semanas',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ao',
      yy: '%d aos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return esUs;
});

/***/ }),
/* 147 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Estonian [et]
//! author : Henry Kehlmann : https://github.com/madhenry
//! improvements : Illimar Tambek : https://github.com/ragulka
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['mne sekundi', 'mni sekund', 'paar sekundit'],
      ss: [number + 'sekundi', number + 'sekundit'],
      m: ['he minuti', 'ks minut'],
      mm: [number + ' minuti', number + ' minutit'],
      h: ['he tunni', 'tund aega', 'ks tund'],
      hh: [number + ' tunni', number + ' tundi'],
      d: ['he peva', 'ks pev'],
      M: ['kuu aja', 'kuu aega', 'ks kuu'],
      MM: [number + ' kuu', number + ' kuud'],
      y: ['he aasta', 'aasta', 'ks aasta'],
      yy: [number + ' aasta', number + ' aastat']
    };

    if (withoutSuffix) {
      return format[key][2] ? format[key][2] : format[key][1];
    }

    return isFuture ? format[key][0] : format[key][1];
  }

  var et = moment.defineLocale('et', {
    months: 'jaanuar_veebruar_mrts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember'.split('_'),
    monthsShort: 'jaan_veebr_mrts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets'.split('_'),
    weekdays: 'phapev_esmaspev_teisipev_kolmapev_neljapev_reede_laupev'.split('_'),
    weekdaysShort: 'P_E_T_K_N_R_L'.split('_'),
    weekdaysMin: 'P_E_T_K_N_R_L'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[Tna,] LT',
      nextDay: '[Homme,] LT',
      nextWeek: '[Jrgmine] dddd LT',
      lastDay: '[Eile,] LT',
      lastWeek: '[Eelmine] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s prast',
      past: '%s tagasi',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: '%d peva',
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return et;
});

/***/ }),
/* 148 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Basque [eu]
//! author : Eneko Illarramendi : https://github.com/eillarra
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var eu = moment.defineLocale('eu', {
    months: 'urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua'.split('_'),
    monthsShort: 'urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.'.split('_'),
    monthsParseExact: true,
    weekdays: 'igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata'.split('_'),
    weekdaysShort: 'ig._al._ar._az._og._ol._lr.'.split('_'),
    weekdaysMin: 'ig_al_ar_az_og_ol_lr'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY[ko] MMMM[ren] D[a]',
      LLL: 'YYYY[ko] MMMM[ren] D[a] HH:mm',
      LLLL: 'dddd, YYYY[ko] MMMM[ren] D[a] HH:mm',
      l: 'YYYY-M-D',
      ll: 'YYYY[ko] MMM D[a]',
      lll: 'YYYY[ko] MMM D[a] HH:mm',
      llll: 'ddd, YYYY[ko] MMM D[a] HH:mm'
    },
    calendar: {
      sameDay: '[gaur] LT[etan]',
      nextDay: '[bihar] LT[etan]',
      nextWeek: 'dddd LT[etan]',
      lastDay: '[atzo] LT[etan]',
      lastWeek: '[aurreko] dddd LT[etan]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s barru',
      past: 'duela %s',
      s: 'segundo batzuk',
      ss: '%d segundo',
      m: 'minutu bat',
      mm: '%d minutu',
      h: 'ordu bat',
      hh: '%d ordu',
      d: 'egun bat',
      dd: '%d egun',
      M: 'hilabete bat',
      MM: '%d hilabete',
      y: 'urte bat',
      yy: '%d urte'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return eu;
});

/***/ }),
/* 149 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Persian [fa]
//! author : Ebrahim Byagowi : https://github.com/ebraminio
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var fa = moment.defineLocale('fa', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysShort: '\u200c__\u200c__\u200c__'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /  |  /,
    isPM: function (input) {
      return /  /.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '  ';
      } else {
        return '  ';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[-]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return fa;
});

/***/ }),
/* 150 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Finnish [fi]
//! author : Tarmo Aidantausta : https://github.com/bleadof
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var numbersPast = 'nolla yksi kaksi kolme nelj viisi kuusi seitsemn kahdeksan yhdeksn'.split(' '),
      numbersFuture = ['nolla', 'yhden', 'kahden', 'kolmen', 'neljn', 'viiden', 'kuuden', numbersPast[7], numbersPast[8], numbersPast[9]];

  function translate(number, withoutSuffix, key, isFuture) {
    var result = '';

    switch (key) {
      case 's':
        return isFuture ? 'muutaman sekunnin' : 'muutama sekunti';

      case 'ss':
        result = isFuture ? 'sekunnin' : 'sekuntia';
        break;

      case 'm':
        return isFuture ? 'minuutin' : 'minuutti';

      case 'mm':
        result = isFuture ? 'minuutin' : 'minuuttia';
        break;

      case 'h':
        return isFuture ? 'tunnin' : 'tunti';

      case 'hh':
        result = isFuture ? 'tunnin' : 'tuntia';
        break;

      case 'd':
        return isFuture ? 'pivn' : 'piv';

      case 'dd':
        result = isFuture ? 'pivn' : 'piv';
        break;

      case 'M':
        return isFuture ? 'kuukauden' : 'kuukausi';

      case 'MM':
        result = isFuture ? 'kuukauden' : 'kuukautta';
        break;

      case 'y':
        return isFuture ? 'vuoden' : 'vuosi';

      case 'yy':
        result = isFuture ? 'vuoden' : 'vuotta';
        break;
    }

    result = verbalNumber(number, isFuture) + ' ' + result;
    return result;
  }

  function verbalNumber(number, isFuture) {
    return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number;
  }

  var fi = moment.defineLocale('fi', {
    months: 'tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_keskuu_heinkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu'.split('_'),
    monthsShort: 'tammi_helmi_maalis_huhti_touko_kes_hein_elo_syys_loka_marras_joulu'.split('_'),
    weekdays: 'sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai'.split('_'),
    weekdaysShort: 'su_ma_ti_ke_to_pe_la'.split('_'),
    weekdaysMin: 'su_ma_ti_ke_to_pe_la'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM[ta] YYYY',
      LLL: 'Do MMMM[ta] YYYY, [klo] HH.mm',
      LLLL: 'dddd, Do MMMM[ta] YYYY, [klo] HH.mm',
      l: 'D.M.YYYY',
      ll: 'Do MMM YYYY',
      lll: 'Do MMM YYYY, [klo] HH.mm',
      llll: 'ddd, Do MMM YYYY, [klo] HH.mm'
    },
    calendar: {
      sameDay: '[tnn] [klo] LT',
      nextDay: '[huomenna] [klo] LT',
      nextWeek: 'dddd [klo] LT',
      lastDay: '[eilen] [klo] LT',
      lastWeek: '[viime] dddd[na] [klo] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s pst',
      past: '%s sitten',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fi;
});

/***/ }),
/* 151 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Filipino [fil]
//! author : Dan Hagman : https://github.com/hagmandan
//! author : Matthew Co : https://github.com/matthewdeeco
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var fil = moment.defineLocale('fil', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fil;
});

/***/ }),
/* 152 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Faroese [fo]
//! author : Ragnar Johannesen : https://github.com/ragnar123
//! author : Kristian Sakarisson : https://github.com/sakarisson
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var fo = moment.defineLocale('fo', {
    months: 'januar_februar_mars_aprl_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_'),
    weekdays: 'sunnudagur_mnadagur_tsdagur_mikudagur_hsdagur_frggjadagur_leygardagur'.split('_'),
    weekdaysShort: 'sun_mn_ts_mik_hs_fr_ley'.split('_'),
    weekdaysMin: 'su_m_t_mi_h_fr_le'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D. MMMM, YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgin kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gjr kl.] LT',
      lastWeek: '[sstu] dddd [kl] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'um %s',
      past: '%s sani',
      s: 'f sekund',
      ss: '%d sekundir',
      m: 'ein minuttur',
      mm: '%d minuttir',
      h: 'ein tmi',
      hh: '%d tmar',
      d: 'ein dagur',
      dd: '%d dagar',
      M: 'ein mnaur',
      MM: '%d mnair',
      y: 'eitt r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fo;
});

/***/ }),
/* 153 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French [fr]
//! author : John Fischer : https://github.com/jfroffice
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsStrictRegex = /^(janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
      monthsShortStrictRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?)/i,
      monthsRegex = /(janv\.?|fvr\.?|mars|avr\.?|mai|juin|juil\.?|aot|sept\.?|oct\.?|nov\.?|dc\.?|janvier|fvrier|mars|avril|mai|juin|juillet|aot|septembre|octobre|novembre|dcembre)/i,
      monthsParse = [/^janv/i, /^fvr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^aot/i, /^sept/i, /^oct/i, /^nov/i, /^dc/i];
  var fr = moment.defineLocale('fr', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: monthsStrictRegex,
    monthsShortStrictRegex: monthsShortStrictRegex,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      w: 'une semaine',
      ww: '%d semaines',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
    ordinal: function (number, period) {
      switch (period) {
        // TODO: Return 'e' when day of month > 1. Move this case inside
        // block for masculine words below.
        // See https://github.com/moment/moment/issues/3375
        case 'D':
          return number + (number === 1 ? 'er' : '');
        // Words with masculine grammatical gender: mois, trimestre, jour

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fr;
});

/***/ }),
/* 154 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Canada) [fr-ca]
//! author : Jonathan Abourbih : https://github.com/jonbca
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var frCa = moment.defineLocale('fr-ca', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function (number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    }
  });
  return frCa;
});

/***/ }),
/* 155 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : French (Switzerland) [fr-ch]
//! author : Gaspard Bucher : https://github.com/gaspard
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var frCh = moment.defineLocale('fr-ch', {
    months: 'janvier_fvrier_mars_avril_mai_juin_juillet_aot_septembre_octobre_novembre_dcembre'.split('_'),
    monthsShort: 'janv._fvr._mars_avr._mai_juin_juil._aot_sept._oct._nov._dc.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi'.split('_'),
    weekdaysShort: 'dim._lun._mar._mer._jeu._ven._sam.'.split('_'),
    weekdaysMin: 'di_lu_ma_me_je_ve_sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Aujourdhui ] LT',
      nextDay: '[Demain ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[Hier ] LT',
      lastWeek: 'dddd [dernier ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dans %s',
      past: 'il y a %s',
      s: 'quelques secondes',
      ss: '%d secondes',
      m: 'une minute',
      mm: '%d minutes',
      h: 'une heure',
      hh: '%d heures',
      d: 'un jour',
      dd: '%d jours',
      M: 'un mois',
      MM: '%d mois',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
    ordinal: function (number, period) {
      switch (period) {
        // Words with masculine grammatical gender: mois, trimestre, jour
        default:
        case 'M':
        case 'Q':
        case 'D':
        case 'DDD':
        case 'd':
          return number + (number === 1 ? 'er' : 'e');
        // Words with feminine grammatical gender: semaine

        case 'w':
        case 'W':
          return number + (number === 1 ? 're' : 'e');
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return frCh;
});

/***/ }),
/* 156 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Frisian [fy]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortWithDots = 'jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des'.split('_');
  var fy = moment.defineLocale('fy', {
    months: 'jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsParseExact: true,
    weekdays: 'snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon'.split('_'),
    weekdaysShort: 'si._mo._ti._wo._to._fr._so.'.split('_'),
    weekdaysMin: 'Si_Mo_Ti_Wo_To_Fr_So'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[hjoed om] LT',
      nextDay: '[moarn om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[juster om] LT',
      lastWeek: '[frne] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'oer %s',
      past: '%s lyn',
      s: 'in pear sekonden',
      ss: '%d sekonden',
      m: 'ien mint',
      mm: '%d minuten',
      h: 'ien oere',
      hh: '%d oeren',
      d: 'ien dei',
      dd: '%d dagen',
      M: 'ien moanne',
      MM: '%d moannen',
      y: 'ien jier',
      yy: '%d jierren'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return fy;
});

/***/ }),
/* 157 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Irish or Irish Gaelic [ga]
//! author : Andr Silva : https://github.com/askpt
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['Eanir', 'Feabhra', 'Mrta', 'Aibren', 'Bealtaine', 'Meitheamh', 'Iil', 'Lnasa', 'Men Fmhair', 'Deireadh Fmhair', 'Samhain', 'Nollaig'],
      monthsShort = ['Ean', 'Feabh', 'Mrt', 'Aib', 'Beal', 'Meith', 'Iil', 'Ln', 'M.F.', 'D.F.', 'Samh', 'Noll'],
      weekdays = ['D Domhnaigh', 'D Luain', 'D Mirt', 'D Cadaoin', 'Dardaoin', 'D hAoine', 'D Sathairn'],
      weekdaysShort = ['Domh', 'Luan', 'Mirt', 'Cad', 'Dar', 'Aoine', 'Sath'],
      weekdaysMin = ['Do', 'Lu', 'M', 'C', 'D', 'A', 'Sa'];
  var ga = moment.defineLocale('ga', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Inniu ag] LT',
      nextDay: '[Amrach ag] LT',
      nextWeek: 'dddd [ag] LT',
      lastDay: '[Inn ag] LT',
      lastWeek: 'dddd [seo caite] [ag] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i %s',
      past: '%s  shin',
      s: 'cpla soicind',
      ss: '%d soicind',
      m: 'nimad',
      mm: '%d nimad',
      h: 'uair an chloig',
      hh: '%d uair an chloig',
      d: 'l',
      dd: '%d l',
      M: 'm',
      MM: '%d monna',
      y: 'bliain',
      yy: '%d bliain'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function (number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ga;
});

/***/ }),
/* 158 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Scottish Gaelic [gd]
//! author : Jon Ashdown : https://github.com/jonashdown
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['Am Faoilleach', 'An Gearran', 'Am Mrt', 'An Giblean', 'An Citean', 'An t-gmhios', 'An t-Iuchar', 'An Lnastal', 'An t-Sultain', 'An Dmhair', 'An t-Samhain', 'An Dbhlachd'],
      monthsShort = ['Faoi', 'Gear', 'Mrt', 'Gibl', 'Cit', 'gmh', 'Iuch', 'Ln', 'Sult', 'Dmh', 'Samh', 'Dbh'],
      weekdays = ['Didmhnaich', 'Diluain', 'Dimirt', 'Diciadain', 'Diardaoin', 'Dihaoine', 'Disathairne'],
      weekdaysShort = ['Did', 'Dil', 'Dim', 'Dic', 'Dia', 'Dih', 'Dis'],
      weekdaysMin = ['D', 'Lu', 'M', 'Ci', 'Ar', 'Ha', 'Sa'];
  var gd = moment.defineLocale('gd', {
    months: months,
    monthsShort: monthsShort,
    monthsParseExact: true,
    weekdays: weekdays,
    weekdaysShort: weekdaysShort,
    weekdaysMin: weekdaysMin,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[An-diugh aig] LT',
      nextDay: '[A-mireach aig] LT',
      nextWeek: 'dddd [aig] LT',
      lastDay: '[An-d aig] LT',
      lastWeek: 'dddd [seo chaidh] [aig] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ann an %s',
      past: 'bho chionn %s',
      s: 'beagan diogan',
      ss: '%d diogan',
      m: 'mionaid',
      mm: '%d mionaidean',
      h: 'uair',
      hh: '%d uairean',
      d: 'latha',
      dd: '%d latha',
      M: 'mos',
      MM: '%d mosan',
      y: 'bliadhna',
      yy: '%d bliadhna'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
    ordinal: function (number) {
      var output = number === 1 ? 'd' : number % 10 === 2 ? 'na' : 'mh';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return gd;
});

/***/ }),
/* 159 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Galician [gl]
//! author : Juan G. Hurtado : https://github.com/juanghurtado
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var gl = moment.defineLocale('gl', {
    months: 'xaneiro_febreiro_marzo_abril_maio_xuo_xullo_agosto_setembro_outubro_novembro_decembro'.split('_'),
    monthsShort: 'xan._feb._mar._abr._mai._xu._xul._ago._set._out._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'domingo_luns_martes_mrcores_xoves_venres_sbado'.split('_'),
    weekdaysShort: 'dom._lun._mar._mr._xov._ven._sb.'.split('_'),
    weekdaysMin: 'do_lu_ma_m_xo_ve_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY H:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY H:mm'
    },
    calendar: {
      sameDay: function () {
        return '[hoxe ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextDay: function () {
        return '[ma ' + (this.hours() !== 1 ? 's' : '') + '] LT';
      },
      nextWeek: function () {
        return 'dddd [' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      lastDay: function () {
        return '[onte ' + (this.hours() !== 1 ? '' : 'a') + '] LT';
      },
      lastWeek: function () {
        return '[o] dddd [pasado ' + (this.hours() !== 1 ? 's' : 'a') + '] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function (str) {
        if (str.indexOf('un') === 0) {
          return 'n' + str;
        }

        return 'en ' + str;
      },
      past: 'hai %s',
      s: 'uns segundos',
      ss: '%d segundos',
      m: 'un minuto',
      mm: '%d minutos',
      h: 'unha hora',
      hh: '%d horas',
      d: 'un da',
      dd: '%d das',
      M: 'un mes',
      MM: '%d meses',
      y: 'un ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return gl;
});

/***/ }),
/* 160 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Devanagari script [gom-deva]
//! author : The Discoverer : https://github.com/WikiDiscoverer
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: [' ', ' '],
      ss: [number + ' ', number + ' '],
      m: [' ', ' '],
      mm: [number + ' ', number + ' '],
      h: [' ', ' '],
      hh: [number + ' ', number + ' '],
      d: [' ', ' '],
      dd: [number + ' ', number + ' '],
      M: [' ', ' '],
      MM: [number + ' ', number + ' '],
      y: [' ', ' '],
      yy: [number + ' ', number + ' ']
    };
    return isFuture ? format[key][0] : format[key][1];
  }

  var gomDeva = moment.defineLocale('gom-deva', {
    months: {
      standalone: '___________'.split('_'),
      format: '___________'.split('_'),
      isFormat: /MMMM(\s)+D[oD]?/
    },
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm []',
      LTS: 'A h:mm:ss []',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm []',
      LLLL: 'dddd, MMMM Do, YYYY, A h:mm []',
      llll: 'ddd, D MMM YYYY, A h:mm []'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd[,] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal: function (number, period) {
      switch (period) {
        // the ordinal '' only applies to day of the month
        case 'D':
          return number + '';

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week
      doy: 3 // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)

    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    }
  });
  return gomDeva;
});

/***/ }),
/* 161 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Konkani Latin script [gom-latn]
//! author : The Discoverer : https://github.com/WikiDiscoverer
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['thoddea sekondamni', 'thodde sekond'],
      ss: [number + ' sekondamni', number + ' sekond'],
      m: ['eka mintan', 'ek minut'],
      mm: [number + ' mintamni', number + ' mintam'],
      h: ['eka voran', 'ek vor'],
      hh: [number + ' voramni', number + ' voram'],
      d: ['eka disan', 'ek dis'],
      dd: [number + ' disamni', number + ' dis'],
      M: ['eka mhoinean', 'ek mhoino'],
      MM: [number + ' mhoineamni', number + ' mhoine'],
      y: ['eka vorsan', 'ek voros'],
      yy: [number + ' vorsamni', number + ' vorsam']
    };
    return isFuture ? format[key][0] : format[key][1];
  }

  var gomLatn = moment.defineLocale('gom-latn', {
    months: {
      standalone: 'Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr'.split('_'),
      format: 'Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea'.split('_'),
      isFormat: /MMMM(\s)+D[oD]?/
    },
    monthsShort: 'Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split('_'),
    weekdaysShort: 'Ait._Som._Mon._Bud._Bre._Suk._Son.'.split('_'),
    weekdaysMin: 'Ai_Sm_Mo_Bu_Br_Su_Sn'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm [vazta]',
      LTS: 'A h:mm:ss [vazta]',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY A h:mm [vazta]',
      LLLL: 'dddd, MMMM Do, YYYY, A h:mm [vazta]',
      llll: 'ddd, D MMM YYYY, A h:mm [vazta]'
    },
    calendar: {
      sameDay: '[Aiz] LT',
      nextDay: '[Faleam] LT',
      nextWeek: '[Fuddlo] dddd[,] LT',
      lastDay: '[Kal] LT',
      lastWeek: '[Fattlo] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s adim',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}(er)/,
    ordinal: function (number, period) {
      switch (period) {
        // the ordinal 'er' only applies to day of the month
        case 'D':
          return number + 'er';

        default:
        case 'M':
        case 'Q':
        case 'DDD':
        case 'd':
        case 'w':
        case 'W':
          return number;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week
      doy: 3 // The week that contains Jan 4th is the first week of the year (7 + 0 - 4)

    },
    meridiemParse: /rati|sokallim|donparam|sanje/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'rati') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === 'sokallim') {
        return hour;
      } else if (meridiem === 'donparam') {
        return hour > 12 ? hour : hour + 12;
      } else if (meridiem === 'sanje') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return 'rati';
      } else if (hour < 12) {
        return 'sokallim';
      } else if (hour < 16) {
        return 'donparam';
      } else if (hour < 20) {
        return 'sanje';
      } else {
        return 'rati';
      }
    }
  });
  return gomLatn;
});

/***/ }),
/* 162 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Gujarati [gu]
//! author : Kaushik Thanki : https://github.com/Kaushik1987
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var gu = moment.defineLocale('gu', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Gujarati notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Gujarati.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return gu;
});

/***/ }),
/* 163 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hebrew [he]
//! author : Tomer Cohen : https://github.com/tomer
//! author : Moshe Simantov : https://github.com/DevelopmentIL
//! author : Tal Ater : https://github.com/TalAter
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var he = moment.defineLocale('he', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D []MMMM YYYY',
      LLL: 'D []MMMM YYYY HH:mm',
      LLLL: 'dddd, D []MMMM YYYY HH:mm',
      l: 'D/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ]LT',
      nextDay: '[ ]LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ]LT',
      lastWeek: '[] dddd [ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: function (number) {
        if (number === 2) {
          return '';
        }

        return number + ' ';
      },
      d: '',
      dd: function (number) {
        if (number === 2) {
          return '';
        }

        return number + ' ';
      },
      M: '',
      MM: function (number) {
        if (number === 2) {
          return '';
        }

        return number + ' ';
      },
      y: '',
      yy: function (number) {
        if (number === 2) {
          return '';
        } else if (number % 10 === 0 && number !== 10) {
          return number + ' ';
        }

        return number + ' ';
      }
    },
    meridiemParse: /"|"| | | ||/i,
    isPM: function (input) {
      return /^("| |)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 5) {
        return ' ';
      } else if (hour < 10) {
        return '';
      } else if (hour < 12) {
        return isLower ? '"' : ' ';
      } else if (hour < 18) {
        return isLower ? '"' : ' ';
      } else {
        return '';
      }
    }
  });
  return he;
});

/***/ }),
/* 164 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hindi [hi]
//! author : Mayank Singhal : https://github.com/mayanksinghal
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  },
      monthsParse = [/^/i, /^|/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^|/i, /^/i, /^|/i, /^|/i],
      shortMonthsParse = [/^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i];
  var hi = moment.defineLocale('hi', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '._.__.___._._._._._.'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: shortMonthsParse,
    monthsRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
    monthsShortRegex: /^(|\.?|||\.?|?||\.?|?|?||\.?||\.?|||\.?||\.?|||\.?|||\.?)/i,
    monthsStrictRegex: /^(?||?|?|?|?|?|?|?|||?\.?||\.?||?||?)/i,
    monthsShortStrictRegex: /^(\.?|\.?|?|\.?|?|?|\.?|\.?|\.?|\.?|\.?|\.?)/i,
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Hindi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Hindi.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return hi;
});

/***/ }),
/* 165 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Croatian [hr]
//! author : Bojan Markovi : https://github.com/bmarkovic
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        if (number === 1) {
          result += 'sekunda';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sekunde';
        } else {
          result += 'sekundi';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'jedna minuta' : 'jedne minute';

      case 'mm':
        if (number === 1) {
          result += 'minuta';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'minute';
        } else {
          result += 'minuta';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'jedan sat' : 'jednog sata';

      case 'hh':
        if (number === 1) {
          result += 'sat';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'sata';
        } else {
          result += 'sati';
        }

        return result;

      case 'dd':
        if (number === 1) {
          result += 'dan';
        } else {
          result += 'dana';
        }

        return result;

      case 'MM':
        if (number === 1) {
          result += 'mjesec';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'mjeseca';
        } else {
          result += 'mjeseci';
        }

        return result;

      case 'yy':
        if (number === 1) {
          result += 'godina';
        } else if (number === 2 || number === 3 || number === 4) {
          result += 'godine';
        } else {
          result += 'godina';
        }

        return result;
    }
  }

  var hr = moment.defineLocale('hr', {
    months: {
      format: 'sijenja_veljae_oujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca'.split('_'),
      standalone: 'sijeanj_veljaa_oujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac'.split('_')
    },
    monthsShort: 'sij._velj._ou._tra._svi._lip._srp._kol._ruj._lis._stu._pro.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'Do MMMM YYYY',
      LLL: 'Do MMMM YYYY H:mm',
      LLLL: 'dddd, Do MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[juer u] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[prolu] [nedjelju] [u] LT';

          case 3:
            return '[prolu] [srijedu] [u] LT';

          case 6:
            return '[prole] [subote] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[proli] dddd [u] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'par sekundi',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: 'dan',
      dd: translate,
      M: 'mjesec',
      MM: translate,
      y: 'godinu',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return hr;
});

/***/ }),
/* 166 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Hungarian [hu]
//! author : Adam Brunner : https://github.com/adambrunner
//! author : Peter Viszt  : https://github.com/passatgt
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var weekEndings = 'vasrnap htfn kedden szerdn cstrtkn pnteken szombaton'.split(' ');

  function translate(number, withoutSuffix, key, isFuture) {
    var num = number;

    switch (key) {
      case 's':
        return isFuture || withoutSuffix ? 'nhny msodperc' : 'nhny msodperce';

      case 'ss':
        return num + (isFuture || withoutSuffix) ? ' msodperc' : ' msodperce';

      case 'm':
        return 'egy' + (isFuture || withoutSuffix ? ' perc' : ' perce');

      case 'mm':
        return num + (isFuture || withoutSuffix ? ' perc' : ' perce');

      case 'h':
        return 'egy' + (isFuture || withoutSuffix ? ' ra' : ' rja');

      case 'hh':
        return num + (isFuture || withoutSuffix ? ' ra' : ' rja');

      case 'd':
        return 'egy' + (isFuture || withoutSuffix ? ' nap' : ' napja');

      case 'dd':
        return num + (isFuture || withoutSuffix ? ' nap' : ' napja');

      case 'M':
        return 'egy' + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');

      case 'MM':
        return num + (isFuture || withoutSuffix ? ' hnap' : ' hnapja');

      case 'y':
        return 'egy' + (isFuture || withoutSuffix ? ' v' : ' ve');

      case 'yy':
        return num + (isFuture || withoutSuffix ? ' v' : ' ve');
    }

    return '';
  }

  function week(isFuture) {
    return (isFuture ? '' : '[mlt] ') + '[' + weekEndings[this.day()] + '] LT[-kor]';
  }

  var hu = moment.defineLocale('hu', {
    months: 'janur_februr_mrcius_prilis_mjus_jnius_jlius_augusztus_szeptember_oktber_november_december'.split('_'),
    monthsShort: 'jan._feb._mrc._pr._mj._jn._jl._aug._szept._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'vasrnap_htf_kedd_szerda_cstrtk_pntek_szombat'.split('_'),
    weekdaysShort: 'vas_ht_kedd_sze_cst_pn_szo'.split('_'),
    weekdaysMin: 'v_h_k_sze_cs_p_szo'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY. MMMM D.',
      LLL: 'YYYY. MMMM D. H:mm',
      LLLL: 'YYYY. MMMM D., dddd H:mm'
    },
    meridiemParse: /de|du/i,
    isPM: function (input) {
      return input.charAt(1).toLowerCase() === 'u';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower === true ? 'de' : 'DE';
      } else {
        return isLower === true ? 'du' : 'DU';
      }
    },
    calendar: {
      sameDay: '[ma] LT[-kor]',
      nextDay: '[holnap] LT[-kor]',
      nextWeek: function () {
        return week.call(this, true);
      },
      lastDay: '[tegnap] LT[-kor]',
      lastWeek: function () {
        return week.call(this, false);
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s mlva',
      past: '%s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return hu;
});

/***/ }),
/* 167 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Armenian [hy-am]
//! author : Armendarabyan : https://github.com/armendarabyan
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var hyAm = moment.defineLocale('hy-am', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      lastDay: '[] LT',
      nextWeek: function () {
        return 'dddd [ ] LT';
      },
      lastWeek: function () {
        return '[] dddd [ ] LT';
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    meridiemParse: /|||/,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(|)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'DDD':
        case 'w':
        case 'W':
        case 'DDDo':
          if (number === 1) {
            return number + '-';
          }

          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return hyAm;
});

/***/ }),
/* 168 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Indonesian [id]
//! author : Mohammad Satrio Utomo : https://github.com/tyok
//! reference: http://id.wikisource.org/wiki/Pedoman_Umum_Ejaan_Bahasa_Indonesia_yang_Disempurnakan
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var id = moment.defineLocale('id', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Rab_Kam_Jum_Sab'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|siang|sore|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'siang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sore' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'siang';
      } else if (hours < 19) {
        return 'sore';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Besok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kemarin pukul] LT',
      lastWeek: 'dddd [lalu pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lalu',
      s: 'beberapa detik',
      ss: '%d detik',
      m: 'semenit',
      mm: '%d menit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return id;
});

/***/ }),
/* 169 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Icelandic [is]
//! author : Hinrik rn Sigursson : https://github.com/hinrik
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(n) {
    if (n % 100 === 11) {
      return true;
    } else if (n % 10 === 1) {
      return false;
    }

    return true;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nokkrar sekndur' : 'nokkrum sekndum';

      case 'ss':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'sekndur' : 'sekndum');
        }

        return result + 'seknda';

      case 'm':
        return withoutSuffix ? 'mnta' : 'mntu';

      case 'mm':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'mntur' : 'mntum');
        } else if (withoutSuffix) {
          return result + 'mnta';
        }

        return result + 'mntu';

      case 'hh':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'klukkustundir' : 'klukkustundum');
        }

        return result + 'klukkustund';

      case 'd':
        if (withoutSuffix) {
          return 'dagur';
        }

        return isFuture ? 'dag' : 'degi';

      case 'dd':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'dagar';
          }

          return result + (isFuture ? 'daga' : 'dgum');
        } else if (withoutSuffix) {
          return result + 'dagur';
        }

        return result + (isFuture ? 'dag' : 'degi');

      case 'M':
        if (withoutSuffix) {
          return 'mnuur';
        }

        return isFuture ? 'mnu' : 'mnui';

      case 'MM':
        if (plural(number)) {
          if (withoutSuffix) {
            return result + 'mnuir';
          }

          return result + (isFuture ? 'mnui' : 'mnuum');
        } else if (withoutSuffix) {
          return result + 'mnuur';
        }

        return result + (isFuture ? 'mnu' : 'mnui');

      case 'y':
        return withoutSuffix || isFuture ? 'r' : 'ri';

      case 'yy':
        if (plural(number)) {
          return result + (withoutSuffix || isFuture ? 'r' : 'rum');
        }

        return result + (withoutSuffix || isFuture ? 'r' : 'ri');
    }
  }

  var is = moment.defineLocale('is', {
    months: 'janar_febrar_mars_aprl_ma_jn_jl_gst_september_oktber_nvember_desember'.split('_'),
    monthsShort: 'jan_feb_mar_apr_ma_jn_jl_g_sep_okt_nv_des'.split('_'),
    weekdays: 'sunnudagur_mnudagur_rijudagur_mivikudagur_fimmtudagur_fstudagur_laugardagur'.split('_'),
    weekdaysShort: 'sun_mn_ri_mi_fim_fs_lau'.split('_'),
    weekdaysMin: 'Su_M_r_Mi_Fi_F_La'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd, D. MMMM YYYY [kl.] H:mm'
    },
    calendar: {
      sameDay: '[ dag kl.] LT',
      nextDay: '[ morgun kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[ gr kl.] LT',
      lastWeek: '[sasta] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'eftir %s',
      past: 'fyrir %s san',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: 'klukkustund',
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return is;
});

/***/ }),
/* 170 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian [it]
//! author : Lorenzo : https://github.com/aliem
//! author: Mattia Larentis: https://github.com/nostalgiaz
//! author: Marco : https://github.com/Manfre98
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var it = moment.defineLocale('it', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: function () {
        return '[Oggi a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      nextDay: function () {
        return '[Domani a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      nextWeek: function () {
        return 'dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      lastDay: function () {
        return '[Ieri a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
      },
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[La scorsa] dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';

          default:
            return '[Lo scorso] dddd [a' + (this.hours() > 1 ? 'lle ' : this.hours() === 0 ? ' ' : "ll'") + ']LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'tra %s',
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: "un'ora",
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      w: 'una settimana',
      ww: '%d settimane',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return it;
});

/***/ }),
/* 171 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Italian (Switzerland) [it-ch]
//! author : xfh : https://github.com/xfh
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var itCh = moment.defineLocale('it-ch', {
    months: 'gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre'.split('_'),
    monthsShort: 'gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic'.split('_'),
    weekdays: 'domenica_luned_marted_mercoled_gioved_venerd_sabato'.split('_'),
    weekdaysShort: 'dom_lun_mar_mer_gio_ven_sab'.split('_'),
    weekdaysMin: 'do_lu_ma_me_gi_ve_sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Oggi alle] LT',
      nextDay: '[Domani alle] LT',
      nextWeek: 'dddd [alle] LT',
      lastDay: '[Ieri alle] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[la scorsa] dddd [alle] LT';

          default:
            return '[lo scorso] dddd [alle] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: function (s) {
        return (/^[0-9].+$/.test(s) ? 'tra' : 'in') + ' ' + s;
      },
      past: '%s fa',
      s: 'alcuni secondi',
      ss: '%d secondi',
      m: 'un minuto',
      mm: '%d minuti',
      h: "un'ora",
      hh: '%d ore',
      d: 'un giorno',
      dd: '%d giorni',
      M: 'un mese',
      MM: '%d mesi',
      y: 'un anno',
      yy: '%d anni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return itCh;
});

/***/ }),
/* 172 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Japanese [ja]
//! author : LI Long : https://github.com/baryon
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ja = moment.defineLocale('ja', {
    eras: [{
      since: '2019-05-01',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'R'
    }, {
      since: '1989-01-08',
      until: '2019-04-30',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'H'
    }, {
      since: '1926-12-25',
      until: '1989-01-07',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'S'
    }, {
      since: '1912-07-30',
      until: '1926-12-24',
      offset: 1,
      name: '',
      narrow: '',
      abbr: 'T'
    }, {
      since: '1873-01-01',
      until: '1912-07-29',
      offset: 6,
      name: '',
      narrow: '',
      abbr: 'M'
    }, {
      since: '0001-01-01',
      until: '1873-12-31',
      offset: 1,
      name: '',
      narrow: 'AD',
      abbr: 'AD'
    }, {
      since: '0000-12-31',
      until: -Infinity,
      offset: 1,
      name: '',
      narrow: 'BC',
      abbr: 'BC'
    }],
    eraYearOrdinalRegex: /(|\d+)/,
    eraYearOrdinalParse: function (input, match) {
      return match[1] === '' ? 1 : parseInt(match[1] || input, 10);
    },
    months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMD dddd HH:mm',
      l: 'YYYY/MM/DD',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMD(ddd) HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: function (now) {
        if (now.week() !== this.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      lastDay: '[] LT',
      lastWeek: function (now) {
        if (this.week() !== now.week()) {
          return '[]dddd LT';
        } else {
          return 'dddd LT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number, period) {
      switch (period) {
        case 'y':
          return number === 1 ? '' : number + '';

        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: '1',
      hh: '%d',
      d: '1',
      dd: '%d',
      M: '1',
      MM: '%d',
      y: '1',
      yy: '%d'
    }
  });
  return ja;
});

/***/ }),
/* 173 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Javanese [jv]
//! author : Rony Lantip : https://github.com/lantip
//! reference: http://jv.wikipedia.org/wiki/Basa_Jawa
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var jv = moment.defineLocale('jv', {
    months: 'Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember'.split('_'),
    monthsShort: 'Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des'.split('_'),
    weekdays: 'Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu'.split('_'),
    weekdaysShort: 'Min_Sen_Sel_Reb_Kem_Jem_Sep'.split('_'),
    weekdaysMin: 'Mg_Sn_Sl_Rb_Km_Jm_Sp'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /enjing|siyang|sonten|ndalu/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'enjing') {
        return hour;
      } else if (meridiem === 'siyang') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'sonten' || meridiem === 'ndalu') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'enjing';
      } else if (hours < 15) {
        return 'siyang';
      } else if (hours < 19) {
        return 'sonten';
      } else {
        return 'ndalu';
      }
    },
    calendar: {
      sameDay: '[Dinten puniko pukul] LT',
      nextDay: '[Mbenjang pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kala wingi pukul] LT',
      lastWeek: 'dddd [kepengker pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'wonten ing %s',
      past: '%s ingkang kepengker',
      s: 'sawetawis detik',
      ss: '%d detik',
      m: 'setunggal menit',
      mm: '%d menit',
      h: 'setunggal jam',
      hh: '%d jam',
      d: 'sedinten',
      dd: '%d dinten',
      M: 'sewulan',
      MM: '%d wulan',
      y: 'setaun',
      yy: '%d taun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return jv;
});

/***/ }),
/* 174 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Georgian [ka]
//! author : Irakli Janiashvili : https://github.com/IrakliJani
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ka = moment.defineLocale('ka', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /(|)/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[] LT[-]',
      nextDay: '[] LT[-]',
      lastDay: '[] LT[-]',
      nextWeek: '[] dddd LT[-]',
      lastWeek: '[] dddd LT-',
      sameElse: 'L'
    },
    relativeTime: {
      future: function (s) {
        return s.replace(/(|||||)(|)/, function ($0, $1, $2) {
          return $2 === '' ? $1 + '' : $1 + $2 + '';
        });
      },
      past: function (s) {
        if (/(||||)/.test(s)) {
          return s.replace(/(|)$/, ' ');
        }

        if (//.test(s)) {
          return s.replace(/$/, ' ');
        }

        return s;
      },
      s: ' ',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /0|1-|-\d{1,2}|\d{1,2}-/,
    ordinal: function (number) {
      if (number === 0) {
        return number;
      }

      if (number === 1) {
        return number + '-';
      }

      if (number < 20 || number <= 100 && number % 20 === 0 || number % 100 === 0) {
        return '-' + number;
      }

      return number + '-';
    },
    week: {
      dow: 1,
      doy: 7
    }
  });
  return ka;
});

/***/ }),
/* 175 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kazakh [kk]
//! authors : Nurlan Rakhimzhanov : https://github.com/nurlan
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var kk = moment.defineLocale('kk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return kk;
});

/***/ }),
/* 176 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Cambodian [km]
//! author : Kruy Vanna : https://github.com/kruyvanna
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var km = moment.defineLocale('km', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return km;
});

/***/ }),
/* 177 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kannada [kn]
//! author : Rajeev Naik : https://github.com/rajeevnaikte
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var kn = moment.defineLocale('kn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}()/,
    ordinal: function (number) {
      return number + '';
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return kn;
});

/***/ }),
/* 178 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Korean [ko]
//! author : Kyungwook, Park : https://github.com/kyungw00k
//! author : Jeeeyul Lee <jeeeyul@gmail.com>
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ko = moment.defineLocale('ko', {
    months: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'YYYY.MM.DD.',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D A h:mm',
      LLLL: 'YYYY MMMM D dddd A h:mm',
      l: 'YYYY.MM.DD.',
      ll: 'YYYY MMMM D',
      lll: 'YYYY MMMM D A h:mm',
      llll: 'YYYY MMMM D dddd A h:mm'
    },
    calendar: {
      sameDay: ' LT',
      nextDay: ' LT',
      nextWeek: 'dddd LT',
      lastDay: ' LT',
      lastWeek: ' dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d',
      m: '1',
      mm: '%d',
      h: ' ',
      hh: '%d',
      d: '',
      dd: '%d',
      M: ' ',
      MM: '%d',
      y: ' ',
      yy: '%d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    meridiemParse: /|/,
    isPM: function (token) {
      return token === '';
    },
    meridiem: function (hour, minute, isUpper) {
      return hour < 12 ? '' : '';
    }
  });
  return ko;
});

/***/ }),
/* 179 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kurdish [ku]
//! author : Shahram Mebashar : https://github.com/ShahramMebashar
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  },
      months = [' ', '', '', '', '', '', '', '', '', ' ', ' ', ' '];
  var ku = moment.defineLocale('ku', {
    months: months,
    monthsShort: months,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return //.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: ' ',
      ss: ' %d',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      }).replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      }).replace(/,/g, '');
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return ku;
});

/***/ }),
/* 180 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Kyrgyz [ky]
//! author : Chyngyz Arystan uulu : https://github.com/chyngyz
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var ky = moment.defineLocale('ky', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: '[ ] dddd [] [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||)/,
    ordinal: function (number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ky;
});

/***/ }),
/* 181 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Luxembourgish [lb]
//! author : mweimerskirch : https://github.com/mweimerskirch
//! author : David Raison : https://github.com/kwisatz
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      m: ['eng Minutt', 'enger Minutt'],
      h: ['eng Stonn', 'enger Stonn'],
      d: ['een Dag', 'engem Dag'],
      M: ['ee Mount', 'engem Mount'],
      y: ['ee Joer', 'engem Joer']
    };
    return withoutSuffix ? format[key][0] : format[key][1];
  }

  function processFutureTime(string) {
    var number = string.substr(0, string.indexOf(' '));

    if (eifelerRegelAppliesToNumber(number)) {
      return 'a ' + string;
    }

    return 'an ' + string;
  }

  function processPastTime(string) {
    var number = string.substr(0, string.indexOf(' '));

    if (eifelerRegelAppliesToNumber(number)) {
      return 'viru ' + string;
    }

    return 'virun ' + string;
  }
  /**
   * Returns true if the word before the given number loses the '-n' ending.
   * e.g. 'an 10 Deeg' but 'a 5 Deeg'
   *
   * @param number {integer}
   * @returns {boolean}
   */


  function eifelerRegelAppliesToNumber(number) {
    number = parseInt(number, 10);

    if (isNaN(number)) {
      return false;
    }

    if (number < 0) {
      // Negative Number --> always true
      return true;
    } else if (number < 10) {
      // Only 1 digit
      if (4 <= number && number <= 7) {
        return true;
      }

      return false;
    } else if (number < 100) {
      // 2 digits
      var lastDigit = number % 10,
          firstDigit = number / 10;

      if (lastDigit === 0) {
        return eifelerRegelAppliesToNumber(firstDigit);
      }

      return eifelerRegelAppliesToNumber(lastDigit);
    } else if (number < 10000) {
      // 3 or 4 digits --> recursively check first digit
      while (number >= 10) {
        number = number / 10;
      }

      return eifelerRegelAppliesToNumber(number);
    } else {
      // Anything larger than 4 digits: recursively check first n-3 digits
      number = number / 1000;
      return eifelerRegelAppliesToNumber(number);
    }
  }

  var lb = moment.defineLocale('lb', {
    months: 'Januar_Februar_Merz_Abrll_Mee_Juni_Juli_August_September_Oktober_November_Dezember'.split('_'),
    monthsShort: 'Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.'.split('_'),
    monthsParseExact: true,
    weekdays: 'Sonndeg_Mindeg_Dnschdeg_Mttwoch_Donneschdeg_Freideg_Samschdeg'.split('_'),
    weekdaysShort: 'So._M._D._M._Do._Fr._Sa.'.split('_'),
    weekdaysMin: 'So_M_D_M_Do_Fr_Sa'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm [Auer]',
      LTS: 'H:mm:ss [Auer]',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm [Auer]',
      LLLL: 'dddd, D. MMMM YYYY H:mm [Auer]'
    },
    calendar: {
      sameDay: '[Haut um] LT',
      sameElse: 'L',
      nextDay: '[Muer um] LT',
      nextWeek: 'dddd [um] LT',
      lastDay: '[Gschter um] LT',
      lastWeek: function () {
        // Different date string for 'Dnschdeg' (Tuesday) and 'Donneschdeg' (Thursday) due to phonological rule
        switch (this.day()) {
          case 2:
          case 4:
            return '[Leschten] dddd [um] LT';

          default:
            return '[Leschte] dddd [um] LT';
        }
      }
    },
    relativeTime: {
      future: processFutureTime,
      past: processPastTime,
      s: 'e puer Sekonnen',
      ss: '%d Sekonnen',
      m: processRelativeTime,
      mm: '%d Minutten',
      h: processRelativeTime,
      hh: '%d Stonnen',
      d: processRelativeTime,
      dd: '%d Deeg',
      M: processRelativeTime,
      MM: '%d Mint',
      y: processRelativeTime,
      yy: '%d Joer'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lb;
});

/***/ }),
/* 182 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lao [lo]
//! author : Ryan Hart : https://github.com/ryanhart2
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var lo = moment.defineLocale('lo', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd[] LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd[] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /()\d{1,2}/,
    ordinal: function (number) {
      return '' + number;
    }
  });
  return lo;
});

/***/ }),
/* 183 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Lithuanian [lt]
//! author : Mindaugas Mozras : https://github.com/mmozuras
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var units = {
    ss: 'sekund_sekundi_sekundes',
    m: 'minut_minuts_minut',
    mm: 'minuts_minui_minutes',
    h: 'valanda_valandos_valand',
    hh: 'valandos_valand_valandas',
    d: 'diena_dienos_dien',
    dd: 'dienos_dien_dienas',
    M: 'mnuo_mnesio_mnes',
    MM: 'mnesiai_mnesi_mnesius',
    y: 'metai_met_metus',
    yy: 'metai_met_metus'
  };

  function translateSeconds(number, withoutSuffix, key, isFuture) {
    if (withoutSuffix) {
      return 'kelios sekunds';
    } else {
      return isFuture ? 'keli sekundi' : 'kelias sekundes';
    }
  }

  function translateSingular(number, withoutSuffix, key, isFuture) {
    return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2];
  }

  function special(number) {
    return number % 10 === 0 || number > 10 && number < 20;
  }

  function forms(key) {
    return units[key].split('_');
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    if (number === 1) {
      return result + translateSingular(number, withoutSuffix, key[0], isFuture);
    } else if (withoutSuffix) {
      return result + (special(number) ? forms(key)[1] : forms(key)[0]);
    } else {
      if (isFuture) {
        return result + forms(key)[1];
      } else {
        return result + (special(number) ? forms(key)[1] : forms(key)[2]);
      }
    }
  }

  var lt = moment.defineLocale('lt', {
    months: {
      format: 'sausio_vasario_kovo_balandio_gegus_birelio_liepos_rugpjio_rugsjo_spalio_lapkriio_gruodio'.split('_'),
      standalone: 'sausis_vasaris_kovas_balandis_gegu_birelis_liepa_rugpjtis_rugsjis_spalis_lapkritis_gruodis'.split('_'),
      isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
    },
    monthsShort: 'sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd'.split('_'),
    weekdays: {
      format: 'sekmadien_pirmadien_antradien_treiadien_ketvirtadien_penktadien_etadien'.split('_'),
      standalone: 'sekmadienis_pirmadienis_antradienis_treiadienis_ketvirtadienis_penktadienis_etadienis'.split('_'),
      isFormat: /dddd HH:mm/
    },
    weekdaysShort: 'Sek_Pir_Ant_Tre_Ket_Pen_e'.split('_'),
    weekdaysMin: 'S_P_A_T_K_Pn_'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY [m.] MMMM D [d.]',
      LLL: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      LLLL: 'YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]',
      l: 'YYYY-MM-DD',
      ll: 'YYYY [m.] MMMM D [d.]',
      lll: 'YYYY [m.] MMMM D [d.], HH:mm [val.]',
      llll: 'YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]'
    },
    calendar: {
      sameDay: '[iandien] LT',
      nextDay: '[Rytoj] LT',
      nextWeek: 'dddd LT',
      lastDay: '[Vakar] LT',
      lastWeek: '[Prajus] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'po %s',
      past: 'prie %s',
      s: translateSeconds,
      ss: translate,
      m: translateSingular,
      mm: translate,
      h: translateSingular,
      hh: translate,
      d: translateSingular,
      dd: translate,
      M: translateSingular,
      MM: translate,
      y: translateSingular,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}-oji/,
    ordinal: function (number) {
      return number + '-oji';
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lt;
});

/***/ }),
/* 184 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Latvian [lv]
//! author : Kristaps Karlsons : https://github.com/skakri
//! author : Jnis Elmeris : https://github.com/JanisE
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var units = {
    ss: 'sekundes_sekundm_sekunde_sekundes'.split('_'),
    m: 'mintes_mintm_minte_mintes'.split('_'),
    mm: 'mintes_mintm_minte_mintes'.split('_'),
    h: 'stundas_stundm_stunda_stundas'.split('_'),
    hh: 'stundas_stundm_stunda_stundas'.split('_'),
    d: 'dienas_dienm_diena_dienas'.split('_'),
    dd: 'dienas_dienm_diena_dienas'.split('_'),
    M: 'mnea_mneiem_mnesis_mnei'.split('_'),
    MM: 'mnea_mneiem_mnesis_mnei'.split('_'),
    y: 'gada_gadiem_gads_gadi'.split('_'),
    yy: 'gada_gadiem_gads_gadi'.split('_')
  };
  /**
   * @param withoutSuffix boolean true = a length of time; false = before/after a period of time.
   */

  function format(forms, number, withoutSuffix) {
    if (withoutSuffix) {
      // E.g. "21 minte", "3 mintes".
      return number % 10 === 1 && number % 100 !== 11 ? forms[2] : forms[3];
    } else {
      // E.g. "21 mintes" as in "pc 21 mintes".
      // E.g. "3 mintm" as in "pc 3 mintm".
      return number % 10 === 1 && number % 100 !== 11 ? forms[0] : forms[1];
    }
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    return number + ' ' + format(units[key], number, withoutSuffix);
  }

  function relativeTimeWithSingular(number, withoutSuffix, key) {
    return format(units[key], number, withoutSuffix);
  }

  function relativeSeconds(number, withoutSuffix) {
    return withoutSuffix ? 'daas sekundes' : 'dam sekundm';
  }

  var lv = moment.defineLocale('lv', {
    months: 'janvris_februris_marts_aprlis_maijs_jnijs_jlijs_augusts_septembris_oktobris_novembris_decembris'.split('_'),
    monthsShort: 'jan_feb_mar_apr_mai_jn_jl_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'svtdiena_pirmdiena_otrdiena_trediena_ceturtdiena_piektdiena_sestdiena'.split('_'),
    weekdaysShort: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysMin: 'Sv_P_O_T_C_Pk_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY.',
      LL: 'YYYY. [gada] D. MMMM',
      LLL: 'YYYY. [gada] D. MMMM, HH:mm',
      LLLL: 'YYYY. [gada] D. MMMM, dddd, HH:mm'
    },
    calendar: {
      sameDay: '[odien pulksten] LT',
      nextDay: '[Rt pulksten] LT',
      nextWeek: 'dddd [pulksten] LT',
      lastDay: '[Vakar pulksten] LT',
      lastWeek: '[Pagju] dddd [pulksten] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'pc %s',
      past: 'pirms %s',
      s: relativeSeconds,
      ss: relativeTimeWithPlural,
      m: relativeTimeWithSingular,
      mm: relativeTimeWithPlural,
      h: relativeTimeWithSingular,
      hh: relativeTimeWithPlural,
      d: relativeTimeWithSingular,
      dd: relativeTimeWithPlural,
      M: relativeTimeWithSingular,
      MM: relativeTimeWithPlural,
      y: relativeTimeWithSingular,
      yy: relativeTimeWithPlural
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return lv;
});

/***/ }),
/* 185 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Montenegrin [me]
//! author : Miodrag Nika <miodrag@restartit.me> : https://github.com/miodragnikac
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekund', 'sekunda', 'sekundi'],
      m: ['jedan minut', 'jednog minuta'],
      mm: ['minut', 'minuta', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      dd: ['dan', 'dana', 'dana'],
      MM: ['mjesec', 'mjeseca', 'mjeseci'],
      yy: ['godina', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
      return number === 1 ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2];
    },
    translate: function (number, withoutSuffix, key) {
      var wordKey = translator.words[key];

      if (key.length === 1) {
        return withoutSuffix ? wordKey[0] : wordKey[1];
      } else {
        return number + ' ' + translator.correctGrammaticalCase(number, wordKey);
      }
    }
  };
  var me = moment.defineLocale('me', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedjelja_ponedjeljak_utorak_srijeda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sri._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sjutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedjelju] [u] LT';

          case 3:
            return '[u] [srijedu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function () {
        var lastWeekDays = ['[prole] [nedjelje] [u] LT', '[prolog] [ponedjeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srijede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'prije %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: 'dan',
      dd: translator.translate,
      M: 'mjesec',
      MM: translator.translate,
      y: 'godinu',
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return me;
});

/***/ }),
/* 186 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maori [mi]
//! author : John Corrigan <robbiecloset@gmail.com> : https://github.com/johnideal
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var mi = moment.defineLocale('mi', {
    months: 'Kohi-tte_Hui-tanguru_Pout-te-rangi_Paenga-whwh_Haratua_Pipiri_Hngoingoi_Here-turi-kk_Mahuru_Whiringa--nuku_Whiringa--rangi_Hakihea'.split('_'),
    monthsShort: 'Kohi_Hui_Pou_Pae_Hara_Pipi_Hngoi_Here_Mahu_Whi-nu_Whi-ra_Haki'.split('_'),
    monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
    monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
    weekdays: 'Rtapu_Mane_Trei_Wenerei_Tite_Paraire_Htarei'.split('_'),
    weekdaysShort: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    weekdaysMin: 'Ta_Ma_T_We_Ti_Pa_H'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [i] HH:mm',
      LLLL: 'dddd, D MMMM YYYY [i] HH:mm'
    },
    calendar: {
      sameDay: '[i teie mahana, i] LT',
      nextDay: '[apopo i] LT',
      nextWeek: 'dddd [i] LT',
      lastDay: '[inanahi i] LT',
      lastWeek: 'dddd [whakamutunga i] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'i roto i %s',
      past: '%s i mua',
      s: 'te hkona ruarua',
      ss: '%d hkona',
      m: 'he meneti',
      mm: '%d meneti',
      h: 'te haora',
      hh: '%d haora',
      d: 'he ra',
      dd: '%d ra',
      M: 'he marama',
      MM: '%d marama',
      y: 'he tau',
      yy: '%d tau'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return mi;
});

/***/ }),
/* 187 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Macedonian [mk]
//! author : Borislav Mickov : https://github.com/B0k0
//! author : Sashko Todorov : https://github.com/bkyceh
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var mk = moment.defineLocale('mk', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: 'e_o_____a'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 6:
            return '[] dddd [] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|||||)/,
    ordinal: function (number) {
      var lastDigit = number % 10,
          last2Digits = number % 100;

      if (number === 0) {
        return number + '-';
      } else if (last2Digits === 0) {
        return number + '-';
      } else if (last2Digits > 10 && last2Digits < 20) {
        return number + '-';
      } else if (lastDigit === 1) {
        return number + '-';
      } else if (lastDigit === 2) {
        return number + '-';
      } else if (lastDigit === 7 || lastDigit === 8) {
        return number + '-';
      } else {
        return number + '-';
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return mk;
});

/***/ }),
/* 188 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malayalam [ml]
//! author : Floyd Pink : https://github.com/floydpink
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ml = moment.defineLocale('ml', {
    months: '___________'.split('_'),
    monthsShort: '._._._.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm -',
      LTS: 'A h:mm:ss -',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm -',
      LLLL: 'dddd, D MMMM YYYY, A h:mm -'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|| ||/i,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' && hour >= 4 || meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return ' ';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    }
  });
  return ml;
});

/***/ }),
/* 189 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Mongolian [mn]
//! author : Javkhlantugs Nyamdorj : https://github.com/javkhaanj7
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function translate(number, withoutSuffix, key, isFuture) {
    switch (key) {
      case 's':
        return withoutSuffix ? ' ' : ' ';

      case 'ss':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'm':
      case 'mm':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'h':
      case 'hh':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'd':
      case 'dd':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'M':
      case 'MM':
        return number + (withoutSuffix ? ' ' : ' ');

      case 'y':
      case 'yy':
        return number + (withoutSuffix ? ' ' : ' ');

      default:
        return number;
    }
  }

  var mn = moment.defineLocale('mn', {
    months: ' _ _ _ _ _ _ _ _ _ _  _  '.split('_'),
    monthsShort: '1 _2 _3 _4 _5 _6 _7 _8 _9 _10 _11 _12 '.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY  MMMM D',
      LLL: 'YYYY  MMMM D HH:mm',
      LLLL: 'dddd, YYYY  MMMM D HH:mm'
    },
    meridiemParse: /|/i,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + ' ';

        default:
          return number;
      }
    }
  });
  return mn;
});

/***/ }),
/* 190 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Marathi [mr]
//! author : Harshad Kale : https://github.com/kalehv
//! author : Vivek Athalye : https://github.com/vnathalye
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };

  function relativeTimeMr(number, withoutSuffix, string, isFuture) {
    var output = '';

    if (withoutSuffix) {
      switch (string) {
        case 's':
          output = ' ';
          break;

        case 'ss':
          output = '%d ';
          break;

        case 'm':
          output = ' ';
          break;

        case 'mm':
          output = '%d ';
          break;

        case 'h':
          output = ' ';
          break;

        case 'hh':
          output = '%d ';
          break;

        case 'd':
          output = ' ';
          break;

        case 'dd':
          output = '%d ';
          break;

        case 'M':
          output = ' ';
          break;

        case 'MM':
          output = '%d ';
          break;

        case 'y':
          output = ' ';
          break;

        case 'yy':
          output = '%d ';
          break;
      }
    } else {
      switch (string) {
        case 's':
          output = ' ';
          break;

        case 'ss':
          output = '%d ';
          break;

        case 'm':
          output = ' ';
          break;

        case 'mm':
          output = '%d ';
          break;

        case 'h':
          output = ' ';
          break;

        case 'hh':
          output = '%d ';
          break;

        case 'd':
          output = ' ';
          break;

        case 'dd':
          output = '%d ';
          break;

        case 'M':
          output = ' ';
          break;

        case 'MM':
          output = '%d ';
          break;

        case 'y':
          output = ' ';
          break;

        case 'yy':
          output = '%d ';
          break;
      }
    }

    return output.replace(/%d/i, number);
  }

  var mr = moment.defineLocale('mr', {
    months: '___________'.split('_'),
    monthsShort: '._._._._._._._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: relativeTimeMr,
      ss: relativeTimeMr,
      m: relativeTimeMr,
      mm: relativeTimeMr,
      h: relativeTimeMr,
      hh: relativeTimeMr,
      d: relativeTimeMr,
      dd: relativeTimeMr,
      M: relativeTimeMr,
      MM: relativeTimeMr,
      y: relativeTimeMr,
      yy: relativeTimeMr
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour >= 12 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour >= 0 && hour < 6) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return mr;
});

/***/ }),
/* 191 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms]
//! author : Weldan Jamili : https://github.com/weldan
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ms = moment.defineLocale('ms', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ms;
});

/***/ }),
/* 192 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Malay [ms-my]
//! note : DEPRECATED, the correct one is [ms]
//! author : Weldan Jamili : https://github.com/weldan
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var msMy = moment.defineLocale('ms-my', {
    months: 'Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis'.split('_'),
    weekdays: 'Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu'.split('_'),
    weekdaysShort: 'Ahd_Isn_Sel_Rab_Kha_Jum_Sab'.split('_'),
    weekdaysMin: 'Ah_Is_Sl_Rb_Km_Jm_Sb'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [pukul] HH.mm',
      LLLL: 'dddd, D MMMM YYYY [pukul] HH.mm'
    },
    meridiemParse: /pagi|tengahari|petang|malam/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'pagi') {
        return hour;
      } else if (meridiem === 'tengahari') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'petang' || meridiem === 'malam') {
        return hour + 12;
      }
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'pagi';
      } else if (hours < 15) {
        return 'tengahari';
      } else if (hours < 19) {
        return 'petang';
      } else {
        return 'malam';
      }
    },
    calendar: {
      sameDay: '[Hari ini pukul] LT',
      nextDay: '[Esok pukul] LT',
      nextWeek: 'dddd [pukul] LT',
      lastDay: '[Kelmarin pukul] LT',
      lastWeek: 'dddd [lepas pukul] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dalam %s',
      past: '%s yang lepas',
      s: 'beberapa saat',
      ss: '%d saat',
      m: 'seminit',
      mm: '%d minit',
      h: 'sejam',
      hh: '%d jam',
      d: 'sehari',
      dd: '%d hari',
      M: 'sebulan',
      MM: '%d bulan',
      y: 'setahun',
      yy: '%d tahun'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return msMy;
});

/***/ }),
/* 193 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Maltese (Malta) [mt]
//! author : Alessandro Maruccia : https://github.com/alesma
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var mt = moment.defineLocale('mt', {
    months: 'Jannar_Frar_Marzu_April_Mejju_unju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diembru'.split('_'),
    monthsShort: 'Jan_Fra_Mar_Apr_Mej_un_Lul_Aww_Set_Ott_Nov_Di'.split('_'),
    weekdays: 'Il-add_It-Tnejn_It-Tlieta_L-Erbga_Il-amis_Il-imga_Is-Sibt'.split('_'),
    weekdaysShort: 'ad_Tne_Tli_Erb_am_im_Sib'.split('_'),
    weekdaysMin: 'a_Tn_Tl_Er_a_i_Si'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Illum fil-]LT',
      nextDay: '[Gada fil-]LT',
      nextWeek: 'dddd [fil-]LT',
      lastDay: '[Il-biera fil-]LT',
      lastWeek: 'dddd [li gadda] [fil-]LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'f %s',
      past: '%s ilu',
      s: 'ftit sekondi',
      ss: '%d sekondi',
      m: 'minuta',
      mm: '%d minuti',
      h: 'siega',
      hh: '%d siegat',
      d: 'urnata',
      dd: '%d ranet',
      M: 'xahar',
      MM: '%d xhur',
      y: 'sena',
      yy: '%d sni'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return mt;
});

/***/ }),
/* 194 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Burmese [my]
//! author : Squar team, mysquar.com
//! author : David Rossellat : https://github.com/gholadr
//! author : Tin Aung Lin : https://github.com/thanyawzinmin
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var my = moment.defineLocale('my', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[.] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd LT []',
      lastDay: '[.] LT []',
      lastWeek: '[] dddd LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: ' %s ',
      s: '.',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d ',
      M: '',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return my;
});

/***/ }),
/* 195 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Norwegian Bokml [nb]
//! authors : Espen Hovlandsdal : https://github.com/rexxars
//!           Sigurd Gartmann : https://github.com/sigurdga
//!           Stephen Ramthun : https://github.com/stephenramthun
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var nb = moment.defineLocale('nb', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'sndag_mandag_tirsdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 's._ma._ti._on._to._fr._l.'.split('_'),
    weekdaysMin: 's_ma_ti_on_to_fr_l'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[i dag kl.] LT',
      nextDay: '[i morgen kl.] LT',
      nextWeek: 'dddd [kl.] LT',
      lastDay: '[i gr kl.] LT',
      lastWeek: '[forrige] dddd [kl.] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s siden',
      s: 'noen sekunder',
      ss: '%d sekunder',
      m: 'ett minutt',
      mm: '%d minutter',
      h: 'en time',
      hh: '%d timer',
      d: 'en dag',
      dd: '%d dager',
      w: 'en uke',
      ww: '%d uker',
      M: 'en mned',
      MM: '%d mneder',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nb;
});

/***/ }),
/* 196 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nepalese [ne]
//! author : suvash : https://github.com/suvash
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var ne = moment.defineLocale('ne', {
    months: '___________'.split('_'),
    monthsShort: '._.__.___._._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 3) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd[,] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd[,] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return ne;
});

/***/ }),
/* 197 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch [nl]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
      monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nl = moment.defineLocale('nl', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD-MM-YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      w: 'n week',
      ww: '%d weken',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nl;
});

/***/ }),
/* 198 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Dutch (Belgium) [nl-be]
//! author : Joris Rling : https://github.com/jorisroling
//! author : Jacob Middag : https://github.com/middagj
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsShortWithDots = 'jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.'.split('_'),
      monthsShortWithoutDots = 'jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec'.split('_'),
      monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
      monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
  var nlBe = moment.defineLocale('nl-be', {
    months: 'januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december'.split('_'),
    monthsShort: function (m, format) {
      if (!m) {
        return monthsShortWithDots;
      } else if (/-MMM-/.test(format)) {
        return monthsShortWithoutDots[m.month()];
      } else {
        return monthsShortWithDots[m.month()];
      }
    },
    monthsRegex: monthsRegex,
    monthsShortRegex: monthsRegex,
    monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
    monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag'.split('_'),
    weekdaysShort: 'zo._ma._di._wo._do._vr._za.'.split('_'),
    weekdaysMin: 'zo_ma_di_wo_do_vr_za'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[vandaag om] LT',
      nextDay: '[morgen om] LT',
      nextWeek: 'dddd [om] LT',
      lastDay: '[gisteren om] LT',
      lastWeek: '[afgelopen] dddd [om] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'over %s',
      past: '%s geleden',
      s: 'een paar seconden',
      ss: '%d seconden',
      m: 'n minuut',
      mm: '%d minuten',
      h: 'n uur',
      hh: '%d uur',
      d: 'n dag',
      dd: '%d dagen',
      M: 'n maand',
      MM: '%d maanden',
      y: 'n jaar',
      yy: '%d jaar'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
    ordinal: function (number) {
      return number + (number === 1 || number === 8 || number >= 20 ? 'ste' : 'de');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nlBe;
});

/***/ }),
/* 199 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Nynorsk [nn]
//! authors : https://github.com/mechuwind
//!           Stephen Ramthun : https://github.com/stephenramthun
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var nn = moment.defineLocale('nn', {
    months: 'januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember'.split('_'),
    monthsShort: 'jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.'.split('_'),
    monthsParseExact: true,
    weekdays: 'sundag_mndag_tysdag_onsdag_torsdag_fredag_laurdag'.split('_'),
    weekdaysShort: 'su._m._ty._on._to._fr._lau.'.split('_'),
    weekdaysMin: 'su_m_ty_on_to_fr_la'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY [kl.] H:mm',
      LLLL: 'dddd D. MMMM YYYY [kl.] HH:mm'
    },
    calendar: {
      sameDay: '[I dag klokka] LT',
      nextDay: '[I morgon klokka] LT',
      nextWeek: 'dddd [klokka] LT',
      lastDay: '[I gr klokka] LT',
      lastWeek: '[Fregande] dddd [klokka] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: '%s sidan',
      s: 'nokre sekund',
      ss: '%d sekund',
      m: 'eit minutt',
      mm: '%d minutt',
      h: 'ein time',
      hh: '%d timar',
      d: 'ein dag',
      dd: '%d dagar',
      w: 'ei veke',
      ww: '%d veker',
      M: 'ein mnad',
      MM: '%d mnader',
      y: 'eit r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return nn;
});

/***/ }),
/* 200 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Occitan, lengadocian dialecte [oc-lnc]
//! author : Quentin PAGS : https://github.com/Quenty31
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ocLnc = moment.defineLocale('oc-lnc', {
    months: {
      standalone: 'genir_febrir_mar_abril_mai_junh_julhet_agost_setembre_octbre_novembre_decembre'.split('_'),
      format: "de genir_de febrir_de mar_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octbre_de novembre_de decembre".split('_'),
      isFormat: /D[oD]?(\s)+MMMM/
    },
    monthsShort: 'gen._febr._mar_abr._mai_junh_julh._ago._set._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'dimenge_diluns_dimars_dimcres_dijus_divendres_dissabte'.split('_'),
    weekdaysShort: 'dg._dl._dm._dc._dj._dv._ds.'.split('_'),
    weekdaysMin: 'dg_dl_dm_dc_dj_dv_ds'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [de] YYYY',
      ll: 'D MMM YYYY',
      LLL: 'D MMMM [de] YYYY [a] H:mm',
      lll: 'D MMM YYYY, H:mm',
      LLLL: 'dddd D MMMM [de] YYYY [a] H:mm',
      llll: 'ddd D MMM YYYY, H:mm'
    },
    calendar: {
      sameDay: '[ui a] LT',
      nextDay: '[deman a] LT',
      nextWeek: 'dddd [a] LT',
      lastDay: '[ir a] LT',
      lastWeek: 'dddd [passat a] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: "d'aqu %s",
      past: 'fa %s',
      s: 'unas segondas',
      ss: '%d segondas',
      m: 'una minuta',
      mm: '%d minutas',
      h: 'una ora',
      hh: '%d oras',
      d: 'un jorn',
      dd: '%d jorns',
      M: 'un mes',
      MM: '%d meses',
      y: 'un an',
      yy: '%d ans'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(r|n|t||a)/,
    ordinal: function (number, period) {
      var output = number === 1 ? 'r' : number === 2 ? 'n' : number === 3 ? 'r' : number === 4 ? 't' : '';

      if (period === 'w' || period === 'W') {
        output = 'a';
      }

      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4
    }
  });
  return ocLnc;
});

/***/ }),
/* 201 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Punjabi (India) [pa-in]
//! author : Harpreet Singh : https://github.com/harpreetkhalsagtbit
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var paIn = moment.defineLocale('pa-in', {
    // There are months name as per Nanakshahi Calendar but they are not used as rigidly in modern Punjabi.
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm ',
      LTS: 'A h:mm:ss ',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm ',
      LLLL: 'dddd, D MMMM YYYY, A h:mm '
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[] dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // Punjabi notation for meridiems are quite fuzzy in practice. While there exists
    // a rigid notion of a 'Pahar' it is not used as rigidly in modern Punjabi.
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return paIn;
});

/***/ }),
/* 202 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Polish [pl]
//! author : Rafal Hirsz : https://github.com/evoL
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var monthsNominative = 'stycze_luty_marzec_kwiecie_maj_czerwiec_lipiec_sierpie_wrzesie_padziernik_listopad_grudzie'.split('_'),
      monthsSubjective = 'stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_wrzenia_padziernika_listopada_grudnia'.split('_'),
      monthsParse = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^pa/i, /^lis/i, /^gru/i];

  function plural(n) {
    return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 !== 1;
  }

  function translate(number, withoutSuffix, key) {
    var result = number + ' ';

    switch (key) {
      case 'ss':
        return result + (plural(number) ? 'sekundy' : 'sekund');

      case 'm':
        return withoutSuffix ? 'minuta' : 'minut';

      case 'mm':
        return result + (plural(number) ? 'minuty' : 'minut');

      case 'h':
        return withoutSuffix ? 'godzina' : 'godzin';

      case 'hh':
        return result + (plural(number) ? 'godziny' : 'godzin');

      case 'ww':
        return result + (plural(number) ? 'tygodnie' : 'tygodni');

      case 'MM':
        return result + (plural(number) ? 'miesice' : 'miesicy');

      case 'yy':
        return result + (plural(number) ? 'lata' : 'lat');
    }
  }

  var pl = moment.defineLocale('pl', {
    months: function (momentToFormat, format) {
      if (!momentToFormat) {
        return monthsNominative;
      } else if (/D MMMM/.test(format)) {
        return monthsSubjective[momentToFormat.month()];
      } else {
        return monthsNominative[momentToFormat.month()];
      }
    },
    monthsShort: 'sty_lut_mar_kwi_maj_cze_lip_sie_wrz_pa_lis_gru'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    weekdays: 'niedziela_poniedziaek_wtorek_roda_czwartek_pitek_sobota'.split('_'),
    weekdaysShort: 'ndz_pon_wt_r_czw_pt_sob'.split('_'),
    weekdaysMin: 'Nd_Pn_Wt_r_Cz_Pt_So'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Dzi o] LT',
      nextDay: '[Jutro o] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[W niedziel o] LT';

          case 2:
            return '[We wtorek o] LT';

          case 3:
            return '[W rod o] LT';

          case 6:
            return '[W sobot o] LT';

          default:
            return '[W] dddd [o] LT';
        }
      },
      lastDay: '[Wczoraj o] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[W zesz niedziel o] LT';

          case 3:
            return '[W zesz rod o] LT';

          case 6:
            return '[W zesz sobot o] LT';

          default:
            return '[W zeszy] dddd [o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: '%s temu',
      s: 'kilka sekund',
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: '1 dzie',
      dd: '%d dni',
      w: 'tydzie',
      ww: translate,
      M: 'miesic',
      MM: translate,
      y: 'rok',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return pl;
});

/***/ }),
/* 203 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese [pt]
//! author : Jefferson : https://github.com/jalex79
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var pt = moment.defineLocale('pt', {
    months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'Domingo_Segunda-feira_Tera-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sbado'.split('_'),
    weekdaysShort: 'Dom_Seg_Ter_Qua_Qui_Sex_Sb'.split('_'),
    weekdaysMin: 'Do_2_3_4_5_6_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function () {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' // Saturday + Sunday
        : '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      w: 'uma semana',
      ww: '%d semanas',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return pt;
});

/***/ }),
/* 204 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Portuguese (Brazil) [pt-br]
//! author : Caio Ribeiro Pereira : https://github.com/caio-ribeiro-pereira
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ptBr = moment.defineLocale('pt-br', {
    months: 'janeiro_fevereiro_maro_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro'.split('_'),
    monthsShort: 'jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez'.split('_'),
    weekdays: 'domingo_segunda-feira_tera-feira_quarta-feira_quinta-feira_sexta-feira_sbado'.split('_'),
    weekdaysShort: 'dom_seg_ter_qua_qui_sex_sb'.split('_'),
    weekdaysMin: 'do_2_3_4_5_6_s'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D [de] MMMM [de] YYYY',
      LLL: 'D [de] MMMM [de] YYYY [s] HH:mm',
      LLLL: 'dddd, D [de] MMMM [de] YYYY [s] HH:mm'
    },
    calendar: {
      sameDay: '[Hoje s] LT',
      nextDay: '[Amanh s] LT',
      nextWeek: 'dddd [s] LT',
      lastDay: '[Ontem s] LT',
      lastWeek: function () {
        return this.day() === 0 || this.day() === 6 ? '[ltimo] dddd [s] LT' // Saturday + Sunday
        : '[ltima] dddd [s] LT'; // Monday - Friday
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'em %s',
      past: 'h %s',
      s: 'poucos segundos',
      ss: '%d segundos',
      m: 'um minuto',
      mm: '%d minutos',
      h: 'uma hora',
      hh: '%d horas',
      d: 'um dia',
      dd: '%d dias',
      M: 'um ms',
      MM: '%d meses',
      y: 'um ano',
      yy: '%d anos'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    invalidDate: 'Data invlida'
  });
  return ptBr;
});

/***/ }),
/* 205 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Romanian [ro]
//! author : Vlad Gurdiga : https://github.com/gurdiga
//! author : Valentin Agachi : https://github.com/avaly
//! author : Emanuel Cepoi : https://github.com/cepem
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: 'secunde',
      mm: 'minute',
      hh: 'ore',
      dd: 'zile',
      ww: 'sptmni',
      MM: 'luni',
      yy: 'ani'
    },
        separator = ' ';

    if (number % 100 >= 20 || number >= 100 && number % 100 === 0) {
      separator = ' de ';
    }

    return number + separator + format[key];
  }

  var ro = moment.defineLocale('ro', {
    months: 'ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie'.split('_'),
    monthsShort: 'ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'duminic_luni_mari_miercuri_joi_vineri_smbt'.split('_'),
    weekdaysShort: 'Dum_Lun_Mar_Mie_Joi_Vin_Sm'.split('_'),
    weekdaysMin: 'Du_Lu_Ma_Mi_Jo_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY H:mm',
      LLLL: 'dddd, D MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[azi la] LT',
      nextDay: '[mine la] LT',
      nextWeek: 'dddd [la] LT',
      lastDay: '[ieri la] LT',
      lastWeek: '[fosta] dddd [la] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'peste %s',
      past: '%s n urm',
      s: 'cteva secunde',
      ss: relativeTimeWithPlural,
      m: 'un minut',
      mm: relativeTimeWithPlural,
      h: 'o or',
      hh: relativeTimeWithPlural,
      d: 'o zi',
      dd: relativeTimeWithPlural,
      w: 'o sptmn',
      ww: relativeTimeWithPlural,
      M: 'o lun',
      MM: relativeTimeWithPlural,
      y: 'un an',
      yy: relativeTimeWithPlural
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return ro;
});

/***/ }),
/* 206 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Russian [ru]
//! author : Viktorminator : https://github.com/Viktorminator
//! author : Menelion Elensle : https://github.com/Oire
//! author :   : https://github.com/socketpair
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: '__',
      dd: '__',
      ww: '__',
      MM: '__',
      yy: '__'
    };

    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  var monthsParse = [/^/i, /^/i, /^/i, /^/i, /^[]/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i, /^/i]; // http://new.gramota.ru/spravka/rules/139-prop :  103
  //  : http://new.gramota.ru/spravka/buro/search-answer?s=242637
  // CLDR data:          http://www.unicode.org/cldr/charts/28/summary/ru.html#1753

  var ru = moment.defineLocale('ru', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: {
      //  CLDR  "."  ".",       ?
      format: '._._._.____._._._._.'.split('_'),
      standalone: '._.__.____._._._._.'.split('_')
    },
    weekdays: {
      standalone: '______'.split('_'),
      format: '______'.split('_'),
      isFormat: /\[ ?[] ?(?:||)? ?] ?dddd/
    },
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    monthsParse: monthsParse,
    longMonthsParse: monthsParse,
    shortMonthsParse: monthsParse,
    //    ,   ,  ,  4 ,      
    monthsRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //  
    monthsShortRegex: /^([]|\.?|[]|?\.?|?|\.?|[]|\.?|[]|[]|\.?|[]|\.?|?|\.?|[]|?\.?|[]|\.?|[]|?\.?|[]|\.?)/i,
    //    
    monthsStrictRegex: /^([]|[]|?|[]|[]|[]|[]|?|[]|[]|[]|[])/i,
    // ,     
    monthsShortStrictRegex: /^(\.|?\.|[.]|\.|[]|[.]|[.]|\.|?\.|\.|?\.|\.)/i,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., H:mm',
      LLLL: 'dddd, D MMMM YYYY ., H:mm'
    },
    calendar: {
      sameDay: '[, ] LT',
      nextDay: '[, ] LT',
      lastDay: '[, ] LT',
      nextWeek: function (now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';

            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';

            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      lastWeek: function (now) {
        if (now.week() !== this.week()) {
          switch (this.day()) {
            case 0:
              return '[ ] dddd, [] LT';

            case 1:
            case 2:
            case 4:
              return '[ ] dddd, [] LT';

            case 3:
            case 5:
            case 6:
              return '[ ] dddd, [] LT';
          }
        } else {
          if (this.day() === 2) {
            return '[] dddd, [] LT';
          } else {
            return '[] dddd, [] LT';
          }
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      w: '',
      ww: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    meridiemParse: /|||/i,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
          return number + '-';

        case 'D':
          return number + '-';

        case 'w':
        case 'W':
          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ru;
});

/***/ }),
/* 207 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sindhi [sd]
//! author : Narain Sagar : https://github.com/narainsagar
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
      days = ['', '', '', '', '', '', ''];
  var sd = moment.defineLocale('sd', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }

      return '';
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd [  ] LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sd;
});

/***/ }),
/* 208 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Northern Sami [se]
//! authors : Brd Rolstad Henriksen : https://github.com/karamell
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var se = moment.defineLocale('se', {
    months: 'oajagemnnu_guovvamnnu_njukamnnu_cuoomnnu_miessemnnu_geassemnnu_suoidnemnnu_borgemnnu_akamnnu_golggotmnnu_skbmamnnu_juovlamnnu'.split('_'),
    monthsShort: 'oj_guov_njuk_cuo_mies_geas_suoi_borg_ak_golg_skb_juov'.split('_'),
    weekdays: 'sotnabeaivi_vuossrga_maebrga_gaskavahkku_duorastat_bearjadat_lvvardat'.split('_'),
    weekdaysShort: 'sotn_vuos_ma_gask_duor_bear_lv'.split('_'),
    weekdaysMin: 's_v_m_g_d_b_L'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'MMMM D. [b.] YYYY',
      LLL: 'MMMM D. [b.] YYYY [ti.] HH:mm',
      LLLL: 'dddd, MMMM D. [b.] YYYY [ti.] HH:mm'
    },
    calendar: {
      sameDay: '[otne ti] LT',
      nextDay: '[ihttin ti] LT',
      nextWeek: 'dddd [ti] LT',
      lastDay: '[ikte ti] LT',
      lastWeek: '[ovddit] dddd [ti] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s geaes',
      past: 'mait %s',
      s: 'moadde sekunddat',
      ss: '%d sekunddat',
      m: 'okta minuhta',
      mm: '%d minuhtat',
      h: 'okta diimmu',
      hh: '%d diimmut',
      d: 'okta beaivi',
      dd: '%d beaivvit',
      M: 'okta mnnu',
      MM: '%d mnut',
      y: 'okta jahki',
      yy: '%d jagit'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return se;
});

/***/ }),
/* 209 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Sinhalese [si]
//! author : Sampath Sitinamaluwa : https://github.com/sampathsris
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  /*jshint -W100*/

  var si = moment.defineLocale('si', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'a h:mm',
      LTS: 'a h:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYY MMMM D',
      LLL: 'YYYY MMMM D, a h:mm',
      LLLL: 'YYYY MMMM D [] dddd, a h:mm:ss'
    },
    calendar: {
      sameDay: '[] LT[]',
      nextDay: '[] LT[]',
      nextWeek: 'dddd LT[]',
      lastDay: '[] LT[]',
      lastWeek: '[] dddd LT[]',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s',
      past: '%s ',
      s: ' ',
      ss: ' %d',
      m: '',
      mm: ' %d',
      h: '',
      hh: ' %d',
      d: '',
      dd: ' %d',
      M: '',
      MM: ' %d',
      y: '',
      yy: ' %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2} /,
    ordinal: function (number) {
      return number + ' ';
    },
    meridiemParse: / | |.|../,
    isPM: function (input) {
      return input === '..' || input === ' ';
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? '..' : ' ';
      } else {
        return isLower ? '..' : ' ';
      }
    }
  });
  return si;
});

/***/ }),
/* 210 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovak [sk]
//! author : Martin Minka : https://github.com/k2s
//! based on work of petrbela : https://github.com/petrbela
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = 'janur_februr_marec_aprl_mj_jn_jl_august_september_oktber_november_december'.split('_'),
      monthsShort = 'jan_feb_mar_apr_mj_jn_jl_aug_sep_okt_nov_dec'.split('_');

  function plural(n) {
    return n > 1 && n < 5;
  }

  function translate(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        // a few seconds / in a few seconds / a few seconds ago
        return withoutSuffix || isFuture ? 'pr seknd' : 'pr sekundami';

      case 'ss':
        // 9 seconds / in 9 seconds / 9 seconds ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'sekundy' : 'seknd');
        } else {
          return result + 'sekundami';
        }

      case 'm':
        // a minute / in a minute / a minute ago
        return withoutSuffix ? 'minta' : isFuture ? 'mintu' : 'mintou';

      case 'mm':
        // 9 minutes / in 9 minutes / 9 minutes ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'minty' : 'mint');
        } else {
          return result + 'mintami';
        }

      case 'h':
        // an hour / in an hour / an hour ago
        return withoutSuffix ? 'hodina' : isFuture ? 'hodinu' : 'hodinou';

      case 'hh':
        // 9 hours / in 9 hours / 9 hours ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'hodiny' : 'hodn');
        } else {
          return result + 'hodinami';
        }

      case 'd':
        // a day / in a day / a day ago
        return withoutSuffix || isFuture ? 'de' : 'dom';

      case 'dd':
        // 9 days / in 9 days / 9 days ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'dni' : 'dn');
        } else {
          return result + 'dami';
        }

      case 'M':
        // a month / in a month / a month ago
        return withoutSuffix || isFuture ? 'mesiac' : 'mesiacom';

      case 'MM':
        // 9 months / in 9 months / 9 months ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'mesiace' : 'mesiacov');
        } else {
          return result + 'mesiacmi';
        }

      case 'y':
        // a year / in a year / a year ago
        return withoutSuffix || isFuture ? 'rok' : 'rokom';

      case 'yy':
        // 9 years / in 9 years / 9 years ago
        if (withoutSuffix || isFuture) {
          return result + (plural(number) ? 'roky' : 'rokov');
        } else {
          return result + 'rokmi';
        }

    }
  }

  var sk = moment.defineLocale('sk', {
    months: months,
    monthsShort: monthsShort,
    weekdays: 'nedea_pondelok_utorok_streda_tvrtok_piatok_sobota'.split('_'),
    weekdaysShort: 'ne_po_ut_st_t_pi_so'.split('_'),
    weekdaysMin: 'ne_po_ut_st_t_pi_so'.split('_'),
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[dnes o] LT',
      nextDay: '[zajtra o] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v nedeu o] LT';

          case 1:
          case 2:
            return '[v] dddd [o] LT';

          case 3:
            return '[v stredu o] LT';

          case 4:
            return '[vo tvrtok o] LT';

          case 5:
            return '[v piatok o] LT';

          case 6:
            return '[v sobotu o] LT';
        }
      },
      lastDay: '[vera o] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[minul nedeu o] LT';

          case 1:
          case 2:
            return '[minul] dddd [o] LT';

          case 3:
            return '[minul stredu o] LT';

          case 4:
          case 5:
            return '[minul] dddd [o] LT';

          case 6:
            return '[minul sobotu o] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pred %s',
      s: translate,
      ss: translate,
      m: translate,
      mm: translate,
      h: translate,
      hh: translate,
      d: translate,
      dd: translate,
      M: translate,
      MM: translate,
      y: translate,
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sk;
});

/***/ }),
/* 211 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Slovenian [sl]
//! author : Robert Sedovek : https://github.com/sedovsek
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var result = number + ' ';

    switch (key) {
      case 's':
        return withoutSuffix || isFuture ? 'nekaj sekund' : 'nekaj sekundami';

      case 'ss':
        if (number === 1) {
          result += withoutSuffix ? 'sekundo' : 'sekundi';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'sekundi' : 'sekundah';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'sekunde' : 'sekundah';
        } else {
          result += 'sekund';
        }

        return result;

      case 'm':
        return withoutSuffix ? 'ena minuta' : 'eno minuto';

      case 'mm':
        if (number === 1) {
          result += withoutSuffix ? 'minuta' : 'minuto';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'minuti' : 'minutama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'minute' : 'minutami';
        } else {
          result += withoutSuffix || isFuture ? 'minut' : 'minutami';
        }

        return result;

      case 'h':
        return withoutSuffix ? 'ena ura' : 'eno uro';

      case 'hh':
        if (number === 1) {
          result += withoutSuffix ? 'ura' : 'uro';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'uri' : 'urama';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'ure' : 'urami';
        } else {
          result += withoutSuffix || isFuture ? 'ur' : 'urami';
        }

        return result;

      case 'd':
        return withoutSuffix || isFuture ? 'en dan' : 'enim dnem';

      case 'dd':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'dan' : 'dnem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevoma';
        } else {
          result += withoutSuffix || isFuture ? 'dni' : 'dnevi';
        }

        return result;

      case 'M':
        return withoutSuffix || isFuture ? 'en mesec' : 'enim mesecem';

      case 'MM':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'mesec' : 'mesecem';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'meseca' : 'mesecema';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'mesece' : 'meseci';
        } else {
          result += withoutSuffix || isFuture ? 'mesecev' : 'meseci';
        }

        return result;

      case 'y':
        return withoutSuffix || isFuture ? 'eno leto' : 'enim letom';

      case 'yy':
        if (number === 1) {
          result += withoutSuffix || isFuture ? 'leto' : 'letom';
        } else if (number === 2) {
          result += withoutSuffix || isFuture ? 'leti' : 'letoma';
        } else if (number < 5) {
          result += withoutSuffix || isFuture ? 'leta' : 'leti';
        } else {
          result += withoutSuffix || isFuture ? 'let' : 'leti';
        }

        return result;
    }
  }

  var sl = moment.defineLocale('sl', {
    months: 'januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljek_torek_sreda_etrtek_petek_sobota'.split('_'),
    weekdaysShort: 'ned._pon._tor._sre._et._pet._sob.'.split('_'),
    weekdaysMin: 'ne_po_to_sr_e_pe_so'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD. MM. YYYY',
      LL: 'D. MMMM YYYY',
      LLL: 'D. MMMM YYYY H:mm',
      LLLL: 'dddd, D. MMMM YYYY H:mm'
    },
    calendar: {
      sameDay: '[danes ob] LT',
      nextDay: '[jutri ob] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[v] [nedeljo] [ob] LT';

          case 3:
            return '[v] [sredo] [ob] LT';

          case 6:
            return '[v] [soboto] [ob] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[v] dddd [ob] LT';
        }
      },
      lastDay: '[veraj ob] LT',
      lastWeek: function () {
        switch (this.day()) {
          case 0:
            return '[prejnjo] [nedeljo] [ob] LT';

          case 3:
            return '[prejnjo] [sredo] [ob] LT';

          case 6:
            return '[prejnjo] [soboto] [ob] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[prejnji] dddd [ob] LT';
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ez %s',
      past: 'pred %s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sl;
});

/***/ }),
/* 212 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Albanian [sq]
//! author : Flakrim Ismani : https://github.com/flakerimi
//! author : Menelion Elensle : https://github.com/Oire
//! author : Oerd Cukalla : https://github.com/oerd
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var sq = moment.defineLocale('sq', {
    months: 'Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nntor_Dhjetor'.split('_'),
    monthsShort: 'Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nn_Dhj'.split('_'),
    weekdays: 'E Diel_E Hn_E Mart_E Mrkur_E Enjte_E Premte_E Shtun'.split('_'),
    weekdaysShort: 'Die_Hn_Mar_Mr_Enj_Pre_Sht'.split('_'),
    weekdaysMin: 'D_H_Ma_M_E_P_Sh'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /PD|MD/,
    isPM: function (input) {
      return input.charAt(0) === 'M';
    },
    meridiem: function (hours, minutes, isLower) {
      return hours < 12 ? 'PD' : 'MD';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Sot n] LT',
      nextDay: '[Nesr n] LT',
      nextWeek: 'dddd [n] LT',
      lastDay: '[Dje n] LT',
      lastWeek: 'dddd [e kaluar n] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'n %s',
      past: '%s m par',
      s: 'disa sekonda',
      ss: '%d sekonda',
      m: 'nj minut',
      mm: '%d minuta',
      h: 'nj or',
      hh: '%d or',
      d: 'nj dit',
      dd: '%d dit',
      M: 'nj muaj',
      MM: '%d muaj',
      y: 'nj vit',
      yy: '%d vite'
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sq;
});

/***/ }),
/* 213 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian [sr]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjakovi <stefan@hotmail.rs> : https://github.com/crnjakovic
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['sekunda', 'sekunde', 'sekundi'],
      m: ['jedan minut', 'jednog minuta'],
      mm: ['minut', 'minuta', 'minuta'],
      h: ['jedan sat', 'jednog sata'],
      hh: ['sat', 'sata', 'sati'],
      d: ['jedan dan', 'jednog dana'],
      dd: ['dan', 'dana', 'dana'],
      M: ['jedan mesec', 'jednog meseca'],
      MM: ['mesec', 'meseca', 'meseci'],
      y: ['jednu godinu', 'jedne godine'],
      yy: ['godinu', 'godine', 'godina']
    },
    correctGrammaticalCase: function (number, wordKey) {
      if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
        return number % 10 === 1 ? wordKey[0] : wordKey[1];
      }

      return wordKey[2];
    },
    translate: function (number, withoutSuffix, key, isFuture) {
      var wordKey = translator.words[key],
          word;

      if (key.length === 1) {
        // Nominativ
        if (key === 'y' && withoutSuffix) return 'jedna godina';
        return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
      }

      word = translator.correctGrammaticalCase(number, wordKey); // Nominativ

      if (key === 'yy' && withoutSuffix && word === 'godinu') {
        return number + ' godina';
      }

      return number + ' ' + word;
    }
  };
  var sr = moment.defineLocale('sr', {
    months: 'januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar'.split('_'),
    monthsShort: 'jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.'.split('_'),
    monthsParseExact: true,
    weekdays: 'nedelja_ponedeljak_utorak_sreda_etvrtak_petak_subota'.split('_'),
    weekdaysShort: 'ned._pon._uto._sre._et._pet._sub.'.split('_'),
    weekdaysMin: 'ne_po_ut_sr_e_pe_su'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D. M. YYYY.',
      LL: 'D. MMMM YYYY.',
      LLL: 'D. MMMM YYYY. H:mm',
      LLLL: 'dddd, D. MMMM YYYY. H:mm'
    },
    calendar: {
      sameDay: '[danas u] LT',
      nextDay: '[sutra u] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[u] [nedelju] [u] LT';

          case 3:
            return '[u] [sredu] [u] LT';

          case 6:
            return '[u] [subotu] [u] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[u] dddd [u] LT';
        }
      },
      lastDay: '[jue u] LT',
      lastWeek: function () {
        var lastWeekDays = ['[prole] [nedelje] [u] LT', '[prolog] [ponedeljka] [u] LT', '[prolog] [utorka] [u] LT', '[prole] [srede] [u] LT', '[prolog] [etvrtka] [u] LT', '[prolog] [petka] [u] LT', '[prole] [subote] [u] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: 'za %s',
      past: 'pre %s',
      s: 'nekoliko sekundi',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: translator.translate,
      dd: translator.translate,
      M: translator.translate,
      MM: translator.translate,
      y: translator.translate,
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sr;
});

/***/ }),
/* 214 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Serbian Cyrillic [sr-cyrl]
//! author : Milan Janakovi<milanjanackovic@gmail.com> : https://github.com/milan-j
//! author : Stefan Crnjakovi <stefan@hotmail.rs> : https://github.com/crnjakovic
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var translator = {
    words: {
      //Different grammatical cases
      ss: ['', '', ''],
      m: [' ', ' '],
      mm: ['', '', ''],
      h: [' ', ' '],
      hh: ['', '', ''],
      d: [' ', ' '],
      dd: ['', '', ''],
      M: [' ', ' '],
      MM: ['', '', ''],
      y: [' ', ' '],
      yy: ['', '', '']
    },
    correctGrammaticalCase: function (number, wordKey) {
      if (number % 10 >= 1 && number % 10 <= 4 && (number % 100 < 10 || number % 100 >= 20)) {
        return number % 10 === 1 ? wordKey[0] : wordKey[1];
      }

      return wordKey[2];
    },
    translate: function (number, withoutSuffix, key, isFuture) {
      var wordKey = translator.words[key],
          word;

      if (key.length === 1) {
        // Nominativ
        if (key === 'y' && withoutSuffix) return ' ';
        return isFuture || withoutSuffix ? wordKey[0] : wordKey[1];
      }

      word = translator.correctGrammaticalCase(number, wordKey); // Nominativ

      if (key === 'yy' && withoutSuffix && word === '') {
        return number + ' ';
      }

      return number + ' ' + word;
    }
  };
  var srCyrl = moment.defineLocale('sr-cyrl', {
    months: '___________'.split('_'),
    monthsShort: '._._._.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '._._._._._._.'.split('_'),
    weekdaysMin: '______'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'D. M. YYYY.',
      LL: 'D. MMMM YYYY.',
      LLL: 'D. MMMM YYYY. H:mm',
      LLLL: 'dddd, D. MMMM YYYY. H:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: function () {
        switch (this.day()) {
          case 0:
            return '[] [] [] LT';

          case 3:
            return '[] [] [] LT';

          case 6:
            return '[] [] [] LT';

          case 1:
          case 2:
          case 4:
          case 5:
            return '[] dddd [] LT';
        }
      },
      lastDay: '[ ] LT',
      lastWeek: function () {
        var lastWeekDays = ['[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT', '[] [] [] LT'];
        return lastWeekDays[this.day()];
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: ' %s',
      s: ' ',
      ss: translator.translate,
      m: translator.translate,
      mm: translator.translate,
      h: translator.translate,
      hh: translator.translate,
      d: translator.translate,
      dd: translator.translate,
      M: translator.translate,
      MM: translator.translate,
      y: translator.translate,
      yy: translator.translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.

    }
  });
  return srCyrl;
});

/***/ }),
/* 215 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : siSwati [ss]
//! author : Nicolai Davies<mail@nicolai.io> : https://github.com/nicolaidavies
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ss = moment.defineLocale('ss', {
    months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split('_'),
    monthsShort: 'Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo'.split('_'),
    weekdays: 'Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo'.split('_'),
    weekdaysShort: 'Lis_Umb_Lsb_Les_Lsi_Lsh_Umg'.split('_'),
    weekdaysMin: 'Li_Us_Lb_Lt_Ls_Lh_Ug'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Namuhla nga] LT',
      nextDay: '[Kusasa nga] LT',
      nextWeek: 'dddd [nga] LT',
      lastDay: '[Itolo nga] LT',
      lastWeek: 'dddd [leliphelile] [nga] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'nga %s',
      past: 'wenteka nga %s',
      s: 'emizuzwana lomcane',
      ss: '%d mzuzwana',
      m: 'umzuzu',
      mm: '%d emizuzu',
      h: 'lihora',
      hh: '%d emahora',
      d: 'lilanga',
      dd: '%d emalanga',
      M: 'inyanga',
      MM: '%d tinyanga',
      y: 'umnyaka',
      yy: '%d iminyaka'
    },
    meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
    meridiem: function (hours, minutes, isLower) {
      if (hours < 11) {
        return 'ekuseni';
      } else if (hours < 15) {
        return 'emini';
      } else if (hours < 19) {
        return 'entsambama';
      } else {
        return 'ebusuku';
      }
    },
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === 'ekuseni') {
        return hour;
      } else if (meridiem === 'emini') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === 'entsambama' || meridiem === 'ebusuku') {
        if (hour === 0) {
          return 0;
        }

        return hour + 12;
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ss;
});

/***/ }),
/* 216 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swedish [sv]
//! author : Jens Alm : https://github.com/ulmus
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var sv = moment.defineLocale('sv', {
    months: 'januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december'.split('_'),
    monthsShort: 'jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec'.split('_'),
    weekdays: 'sndag_mndag_tisdag_onsdag_torsdag_fredag_lrdag'.split('_'),
    weekdaysShort: 'sn_mn_tis_ons_tor_fre_lr'.split('_'),
    weekdaysMin: 's_m_ti_on_to_fr_l'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY [kl.] HH:mm',
      LLLL: 'dddd D MMMM YYYY [kl.] HH:mm',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Idag] LT',
      nextDay: '[Imorgon] LT',
      lastDay: '[Igr] LT',
      nextWeek: '[P] dddd LT',
      lastWeek: '[I] dddd[s] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'om %s',
      past: 'fr %s sedan',
      s: 'ngra sekunder',
      ss: '%d sekunder',
      m: 'en minut',
      mm: '%d minuter',
      h: 'en timme',
      hh: '%d timmar',
      d: 'en dag',
      dd: '%d dagar',
      M: 'en mnad',
      MM: '%d mnader',
      y: 'ett r',
      yy: '%d r'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? ':e' : b === 1 ? ':a' : b === 2 ? ':a' : b === 3 ? ':e' : ':e';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return sv;
});

/***/ }),
/* 217 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Swahili [sw]
//! author : Fahad Kassim : https://github.com/fadsel
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var sw = moment.defineLocale('sw', {
    months: 'Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba'.split('_'),
    monthsShort: 'Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des'.split('_'),
    weekdays: 'Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi'.split('_'),
    weekdaysShort: 'Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos'.split('_'),
    weekdaysMin: 'J2_J3_J4_J5_Al_Ij_J1'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'hh:mm A',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[leo saa] LT',
      nextDay: '[kesho saa] LT',
      nextWeek: '[wiki ijayo] dddd [saat] LT',
      lastDay: '[jana] LT',
      lastWeek: '[wiki iliyopita] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s baadaye',
      past: 'tokea %s',
      s: 'hivi punde',
      ss: 'sekunde %d',
      m: 'dakika moja',
      mm: 'dakika %d',
      h: 'saa limoja',
      hh: 'masaa %d',
      d: 'siku moja',
      dd: 'siku %d',
      M: 'mwezi mmoja',
      MM: 'miezi %d',
      y: 'mwaka mmoja',
      yy: 'miaka %d'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return sw;
});

/***/ }),
/* 218 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tamil [ta]
//! author : Arjunkumar Krishnamoorthy : https://github.com/tk120404
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var symbolMap = {
    1: '',
    2: '',
    3: '',
    4: '',
    5: '',
    6: '',
    7: '',
    8: '',
    9: '',
    0: ''
  },
      numberMap = {
    '': '1',
    '': '2',
    '': '3',
    '': '4',
    '': '5',
    '': '6',
    '': '7',
    '': '8',
    '': '9',
    '': '0'
  };
  var ta = moment.defineLocale('ta', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, HH:mm',
      LLLL: 'dddd, D MMMM YYYY, HH:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[ ] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: '  ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: '  ',
      hh: '%d  ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number + '';
    },
    preparse: function (string) {
      return string.replace(/[]/g, function (match) {
        return numberMap[match];
      });
    },
    postformat: function (string) {
      return string.replace(/\d/g, function (match) {
        return symbolMap[match];
      });
    },
    // refer http://ta.wikipedia.org/s/1er1
    meridiemParse: /|||||/,
    meridiem: function (hour, minute, isLower) {
      if (hour < 2) {
        return ' ';
      } else if (hour < 6) {
        return ' '; // 
      } else if (hour < 10) {
        return ' '; // 
      } else if (hour < 14) {
        return ' '; // 
      } else if (hour < 18) {
        return ' '; // 
      } else if (hour < 22) {
        return ' '; // 
      } else {
        return ' ';
      }
    },
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 2 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else {
        return hour + 12;
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return ta;
});

/***/ }),
/* 219 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Telugu [te]
//! author : Krishna Chaitanya Thota : https://github.com/kcthota
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var te = moment.defineLocale('te', {
    months: '___________'.split('_'),
    monthsShort: '._.__.____._._._._.'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'A h:mm',
      LTS: 'A h:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY, A h:mm',
      LLLL: 'dddd, D MMMM YYYY, A h:mm'
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: 'dddd, LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd, LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: '%d',
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 10 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 10) {
        return '';
      } else if (hour < 17) {
        return '';
      } else if (hour < 20) {
        return '';
      } else {
        return '';
      }
    },
    week: {
      dow: 0,
      // Sunday is the first day of the week.
      doy: 6 // The week that contains Jan 6th is the first week of the year.

    }
  });
  return te;
});

/***/ }),
/* 220 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tetun Dili (East Timor) [tet]
//! author : Joshua Brooks : https://github.com/joshbrooks
//! author : Onorio De J. Afonso : https://github.com/marobo
//! author : Sonia Simoes : https://github.com/soniasimoes
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tet = moment.defineLocale('tet', {
    months: 'Janeiru_Fevereiru_Marsu_Abril_Maiu_Juu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez'.split('_'),
    weekdays: 'Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu'.split('_'),
    weekdaysShort: 'Dom_Seg_Ters_Kua_Kint_Sest_Sab'.split('_'),
    weekdaysMin: 'Do_Seg_Te_Ku_Ki_Ses_Sa'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Ohin iha] LT',
      nextDay: '[Aban iha] LT',
      nextWeek: 'dddd [iha] LT',
      lastDay: '[Horiseik iha] LT',
      lastWeek: 'dddd [semana kotuk] [iha] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'iha %s',
      past: '%s liuba',
      s: 'segundu balun',
      ss: 'segundu %d',
      m: 'minutu ida',
      mm: 'minutu %d',
      h: 'oras ida',
      hh: 'oras %d',
      d: 'loron ida',
      dd: 'loron %d',
      M: 'fulan ida',
      MM: 'fulan %d',
      y: 'tinan ida',
      yy: 'tinan %d'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tet;
});

/***/ }),
/* 221 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tajik [tg]
//! author : Orif N. Jr. : https://github.com/orif-jr
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    0: '-',
    1: '-',
    2: '-',
    3: '-',
    4: '-',
    5: '-',
    6: '-',
    7: '-',
    8: '-',
    9: '-',
    10: '-',
    12: '-',
    13: '-',
    20: '-',
    30: '-',
    40: '-',
    50: '-',
    60: '-',
    70: '-',
    80: '-',
    90: '-',
    100: '-'
  };
  var tg = moment.defineLocale('tg', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      lastDay: '[ ] LT',
      nextWeek: 'dddd[] [  ] LT',
      lastWeek: 'dddd[] [  ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    meridiemParse: /|||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '') {
        return hour < 4 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 11) {
        return '';
      } else if (hour < 16) {
        return '';
      } else if (hour < 19) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number) {
      var a = number % 10,
          b = number >= 100 ? 100 : null;
      return number + (suffixes[number] || suffixes[a] || suffixes[b]);
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1th is the first week of the year.

    }
  });
  return tg;
});

/***/ }),
/* 222 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Thai [th]
//! author : Kridsada Thanabulpong : https://github.com/sirn
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var th = moment.defineLocale('th', {
    months: '___________'.split('_'),
    monthsShort: '.._.._.._.._.._.._.._.._.._.._.._..'.split('_'),
    monthsParseExact: true,
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    // yes, three characters difference
    weekdaysMin: '._._._._._._.'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'H:mm',
      LTS: 'H:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY  H:mm',
      LLLL: 'dddd D MMMM YYYY  H:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return input === '';
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd[ ] LT',
      lastDay: '[ ] LT',
      lastWeek: '[]dddd[ ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      w: '1 ',
      ww: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return th;
});

/***/ }),
/* 223 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkmen [tk]
//! author : Atamyrat Abdyrahmanov : https://github.com/atamyratabdy
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    1: "'inji",
    5: "'inji",
    8: "'inji",
    70: "'inji",
    80: "'inji",
    2: "'nji",
    7: "'nji",
    20: "'nji",
    50: "'nji",
    3: "'nji",
    4: "'nji",
    100: "'nji",
    6: "'njy",
    9: "'unjy",
    10: "'unjy",
    30: "'unjy",
    60: "'ynjy",
    90: "'ynjy"
  };
  var tk = moment.defineLocale('tk', {
    months: 'anwar_Fewral_Mart_Aprel_Ma_Iun_Iul_Awgust_Sentabr_Oktabr_Noabr_Dekabr'.split('_'),
    monthsShort: 'an_Few_Mar_Apr_Ma_In_Il_Awg_Sen_Okt_No_Dek'.split('_'),
    weekdays: 'ekenbe_Duenbe_Sienbe_arenbe_Penenbe_Anna_enbe'.split('_'),
    weekdaysShort: 'ek_Du_Si_ar_Pen_Ann_en'.split('_'),
    weekdaysMin: 'k_D_S_r_Pn_An_n'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn sagat] LT',
      nextDay: '[ertir sagat] LT',
      nextWeek: '[indiki] dddd [sagat] LT',
      lastDay: '[dn] LT',
      lastWeek: '[geen] dddd [sagat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s so',
      past: '%s ',
      s: 'birne sekunt',
      m: 'bir minut',
      mm: '%d minut',
      h: 'bir sagat',
      hh: '%d sagat',
      d: 'bir gn',
      dd: '%d gn',
      M: 'bir a',
      MM: '%d a',
      y: 'bir yl',
      yy: '%d yl'
    },
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;

        default:
          if (number === 0) {
            // special case for zero
            return number + "'unjy";
          }

          var a = number % 10,
              b = number % 100 - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return tk;
});

/***/ }),
/* 224 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Tagalog (Philippines) [tl-ph]
//! author : Dan Hagman : https://github.com/hagmandan
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tlPh = moment.defineLocale('tl-ph', {
    months: 'Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre'.split('_'),
    monthsShort: 'Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis'.split('_'),
    weekdays: 'Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado'.split('_'),
    weekdaysShort: 'Lin_Lun_Mar_Miy_Huw_Biy_Sab'.split('_'),
    weekdaysMin: 'Li_Lu_Ma_Mi_Hu_Bi_Sab'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'MM/D/YYYY',
      LL: 'MMMM D, YYYY',
      LLL: 'MMMM D, YYYY HH:mm',
      LLLL: 'dddd, MMMM DD, YYYY HH:mm'
    },
    calendar: {
      sameDay: 'LT [ngayong araw]',
      nextDay: '[Bukas ng] LT',
      nextWeek: 'LT [sa susunod na] dddd',
      lastDay: 'LT [kahapon]',
      lastWeek: 'LT [noong nakaraang] dddd',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'sa loob ng %s',
      past: '%s ang nakalipas',
      s: 'ilang segundo',
      ss: '%d segundo',
      m: 'isang minuto',
      mm: '%d minuto',
      h: 'isang oras',
      hh: '%d oras',
      d: 'isang araw',
      dd: '%d araw',
      M: 'isang buwan',
      MM: '%d buwan',
      y: 'isang taon',
      yy: '%d taon'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tlPh;
});

/***/ }),
/* 225 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Klingon [tlh]
//! author : Dominika Kruk : https://github.com/amaranthrose
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var numbersNouns = 'pagh_wa_cha_wej_loS_vagh_jav_Soch_chorgh_Hut'.split('_');

  function translateFuture(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'leS' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'waQ' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'nem' : time + ' pIq';
    return time;
  }

  function translatePast(output) {
    var time = output;
    time = output.indexOf('jaj') !== -1 ? time.slice(0, -3) + 'Hu' : output.indexOf('jar') !== -1 ? time.slice(0, -3) + 'wen' : output.indexOf('DIS') !== -1 ? time.slice(0, -3) + 'ben' : time + ' ret';
    return time;
  }

  function translate(number, withoutSuffix, string, isFuture) {
    var numberNoun = numberAsNoun(number);

    switch (string) {
      case 'ss':
        return numberNoun + ' lup';

      case 'mm':
        return numberNoun + ' tup';

      case 'hh':
        return numberNoun + ' rep';

      case 'dd':
        return numberNoun + ' jaj';

      case 'MM':
        return numberNoun + ' jar';

      case 'yy':
        return numberNoun + ' DIS';
    }
  }

  function numberAsNoun(number) {
    var hundred = Math.floor(number % 1000 / 100),
        ten = Math.floor(number % 100 / 10),
        one = number % 10,
        word = '';

    if (hundred > 0) {
      word += numbersNouns[hundred] + 'vatlh';
    }

    if (ten > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[ten] + 'maH';
    }

    if (one > 0) {
      word += (word !== '' ? ' ' : '') + numbersNouns[one];
    }

    return word === '' ? 'pagh' : word;
  }

  var tlh = moment.defineLocale('tlh', {
    months: 'tera jar wa_tera jar cha_tera jar wej_tera jar loS_tera jar vagh_tera jar jav_tera jar Soch_tera jar chorgh_tera jar Hut_tera jar wamaH_tera jar wamaH wa_tera jar wamaH cha'.split('_'),
    monthsShort: 'jar wa_jar cha_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wamaH_jar wamaH wa_jar wamaH cha'.split('_'),
    monthsParseExact: true,
    weekdays: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysShort: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    weekdaysMin: 'lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[DaHjaj] LT',
      nextDay: '[waleS] LT',
      nextWeek: 'LLL',
      lastDay: '[waHu] LT',
      lastWeek: 'LLL',
      sameElse: 'L'
    },
    relativeTime: {
      future: translateFuture,
      past: translatePast,
      s: 'puS lup',
      ss: translate,
      m: 'wa tup',
      mm: translate,
      h: 'wa rep',
      hh: translate,
      d: 'wa jaj',
      dd: translate,
      M: 'wa jar',
      MM: translate,
      y: 'wa DIS',
      yy: translate
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return tlh;
});

/***/ }),
/* 226 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Turkish [tr]
//! authors : Erhan Gundogan : https://github.com/erhangundogan,
//!           Burak Yiit Kaya: https://github.com/BYK
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var suffixes = {
    1: "'inci",
    5: "'inci",
    8: "'inci",
    70: "'inci",
    80: "'inci",
    2: "'nci",
    7: "'nci",
    20: "'nci",
    50: "'nci",
    3: "'nc",
    4: "'nc",
    100: "'nc",
    6: "'nc",
    9: "'uncu",
    10: "'uncu",
    30: "'uncu",
    60: "'nc",
    90: "'nc"
  };
  var tr = moment.defineLocale('tr', {
    months: 'Ocak_ubat_Mart_Nisan_Mays_Haziran_Temmuz_Austos_Eyll_Ekim_Kasm_Aralk'.split('_'),
    monthsShort: 'Oca_ub_Mar_Nis_May_Haz_Tem_Au_Eyl_Eki_Kas_Ara'.split('_'),
    weekdays: 'Pazar_Pazartesi_Sal_aramba_Perembe_Cuma_Cumartesi'.split('_'),
    weekdaysShort: 'Paz_Pzt_Sal_ar_Per_Cum_Cmt'.split('_'),
    weekdaysMin: 'Pz_Pt_Sa_a_Pe_Cu_Ct'.split('_'),
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? '' : '';
      } else {
        return isLower ? 's' : 'S';
      }
    },
    meridiemParse: /||s|S/,
    isPM: function (input) {
      return input === 's' || input === 'S';
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[bugn saat] LT',
      nextDay: '[yarn saat] LT',
      nextWeek: '[gelecek] dddd [saat] LT',
      lastDay: '[dn] LT',
      lastWeek: '[geen] dddd [saat] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s sonra',
      past: '%s nce',
      s: 'birka saniye',
      ss: '%d saniye',
      m: 'bir dakika',
      mm: '%d dakika',
      h: 'bir saat',
      hh: '%d saat',
      d: 'bir gn',
      dd: '%d gn',
      w: 'bir hafta',
      ww: '%d hafta',
      M: 'bir ay',
      MM: '%d ay',
      y: 'bir yl',
      yy: '%d yl'
    },
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'Do':
        case 'DD':
          return number;

        default:
          if (number === 0) {
            // special case for zero
            return number + "'nc";
          }

          var a = number % 10,
              b = number % 100 - a,
              c = number >= 100 ? 100 : null;
          return number + (suffixes[a] || suffixes[b] || suffixes[c]);
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return tr;
});

/***/ }),
/* 227 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Talossan [tzl]
//! author : Robin van der Vliet : https://github.com/robin0van0der0v
//! author : Iust Canun
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration
  // After the year there should be a slash and the amount of years since December 26, 1979 in Roman numerals.
  // This is currently too difficult (maybe even impossible) to add.

  var tzl = moment.defineLocale('tzl', {
    months: 'Januar_Fevraglh_Mar_Avru_Mai_Gn_Julia_Guscht_Setemvar_Listopts_Noemvar_Zecemvar'.split('_'),
    monthsShort: 'Jan_Fev_Mar_Avr_Mai_Gn_Jul_Gus_Set_Lis_Noe_Zec'.split('_'),
    weekdays: 'Sladi_Lnei_Maitzi_Mrcuri_Xhadi_Vineri_Sturi'.split('_'),
    weekdaysShort: 'Sl_Ln_Mai_Mr_Xh_Vi_St'.split('_'),
    weekdaysMin: 'S_L_Ma_M_Xh_Vi_S'.split('_'),
    longDateFormat: {
      LT: 'HH.mm',
      LTS: 'HH.mm.ss',
      L: 'DD.MM.YYYY',
      LL: 'D. MMMM [dallas] YYYY',
      LLL: 'D. MMMM [dallas] YYYY HH.mm',
      LLLL: 'dddd, [li] D. MMMM [dallas] YYYY HH.mm'
    },
    meridiemParse: /d\'o|d\'a/i,
    isPM: function (input) {
      return "d'o" === input.toLowerCase();
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours > 11) {
        return isLower ? "d'o" : "D'O";
      } else {
        return isLower ? "d'a" : "D'A";
      }
    },
    calendar: {
      sameDay: '[oxhi ] LT',
      nextDay: '[dem ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ieiri ] LT',
      lastWeek: '[sr el] dddd [lasteu ] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'osprei %s',
      past: 'ja%s',
      s: processRelativeTime,
      ss: processRelativeTime,
      m: processRelativeTime,
      mm: processRelativeTime,
      h: processRelativeTime,
      hh: processRelativeTime,
      d: processRelativeTime,
      dd: processRelativeTime,
      M: processRelativeTime,
      MM: processRelativeTime,
      y: processRelativeTime,
      yy: processRelativeTime
    },
    dayOfMonthOrdinalParse: /\d{1,2}\./,
    ordinal: '%d.',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });

  function processRelativeTime(number, withoutSuffix, key, isFuture) {
    var format = {
      s: ['viensas secunds', "'iensas secunds"],
      ss: [number + ' secunds', '' + number + ' secunds'],
      m: ["'n mut", "'iens mut"],
      mm: [number + ' muts', '' + number + ' muts'],
      h: ["'n ora", "'iensa ora"],
      hh: [number + ' oras', '' + number + ' oras'],
      d: ["'n ziua", "'iensa ziua"],
      dd: [number + ' ziuas', '' + number + ' ziuas'],
      M: ["'n mes", "'iens mes"],
      MM: [number + ' mesen', '' + number + ' mesen'],
      y: ["'n ar", "'iens ar"],
      yy: [number + ' ars', '' + number + ' ars']
    };
    return isFuture ? format[key][0] : withoutSuffix ? format[key][0] : format[key][1];
  }

  return tzl;
});

/***/ }),
/* 228 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight [tzm]
//! author : Abdel Said : https://github.com/abdelsaid
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tzm = moment.defineLocale('tzm', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[ ] LT',
      lastWeek: 'dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '   %s',
      past: ' %s',
      s: '',
      ss: '%d ',
      m: '',
      mm: '%d ',
      h: '',
      hh: '%d ',
      d: '',
      dd: '%d o',
      M: 'o',
      MM: '%d ',
      y: '',
      yy: '%d '
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return tzm;
});

/***/ }),
/* 229 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Central Atlas Tamazight Latin [tzm-latn]
//! author : Abdel Said : https://github.com/abdelsaid
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var tzmLatn = moment.defineLocale('tzm-latn', {
    months: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    monthsShort: 'innayr_brayr_mars_ibrir_mayyw_ywnyw_ywlywz_wt_wtanbir_ktwbr_nwwanbir_dwjnbir'.split('_'),
    weekdays: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysShort: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    weekdaysMin: 'asamas_aynas_asinas_akras_akwas_asimwas_asiyas'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[asdkh g] LT',
      nextDay: '[aska g] LT',
      nextWeek: 'dddd [g] LT',
      lastDay: '[assant g] LT',
      lastWeek: 'dddd [g] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'dadkh s yan %s',
      past: 'yan %s',
      s: 'imik',
      ss: '%d imik',
      m: 'minu',
      mm: '%d minu',
      h: 'saa',
      hh: '%d tassain',
      d: 'ass',
      dd: '%d ossan',
      M: 'ayowr',
      MM: '%d iyyirn',
      y: 'asgas',
      yy: '%d isgasn'
    },
    week: {
      dow: 6,
      // Saturday is the first day of the week.
      doy: 12 // The week that contains Jan 12th is the first week of the year.

    }
  });
  return tzmLatn;
});

/***/ }),
/* 230 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uyghur (China) [ug-cn]
//! author: boyaq : https://github.com/boyaq
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var ugCn = moment.defineLocale('ug-cn', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY-MM-DD',
      LL: 'YYYY-M-D-',
      LLL: 'YYYY-M-D- HH:mm',
      LLLL: 'dddd YYYY-M-D- HH:mm'
    },
    meridiemParse: / || || |/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === ' ' || meridiem === '' || meridiem === ' ') {
        return hour;
      } else if (meridiem === ' ' || meridiem === '') {
        return hour + 12;
      } else {
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return ' ';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return ' ';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return ' ';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: '[] dddd [] LT',
      lastDay: '[] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    dayOfMonthOrdinalParse: /\d{1,2}(-|-|-)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '-';

        case 'w':
        case 'W':
          return number + '-';

        default:
          return number;
      }
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 1st is the first week of the year.

    }
  });
  return ugCn;
});

/***/ }),
/* 231 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Ukrainian [uk]
//! author : zemlanin : https://github.com/zemlanin
//! Author : Menelion Elensle : https://github.com/Oire
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  function plural(word, num) {
    var forms = word.split('_');
    return num % 10 === 1 && num % 100 !== 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2];
  }

  function relativeTimeWithPlural(number, withoutSuffix, key) {
    var format = {
      ss: withoutSuffix ? '__' : '__',
      mm: withoutSuffix ? '__' : '__',
      hh: withoutSuffix ? '__' : '__',
      dd: '__',
      MM: '__',
      yy: '__'
    };

    if (key === 'm') {
      return withoutSuffix ? '' : '';
    } else if (key === 'h') {
      return withoutSuffix ? '' : '';
    } else {
      return number + ' ' + plural(format[key], +number);
    }
  }

  function weekdaysCaseReplace(m, format) {
    var weekdays = {
      nominative: '______'.split('_'),
      accusative: '______'.split('_'),
      genitive: '______'.split('_')
    },
        nounCase;

    if (m === true) {
      return weekdays['nominative'].slice(1, 7).concat(weekdays['nominative'].slice(0, 1));
    }

    if (!m) {
      return weekdays['nominative'];
    }

    nounCase = /(\[[]\]) ?dddd/.test(format) ? 'accusative' : /\[?(?:|)? ?\] ?dddd/.test(format) ? 'genitive' : 'nominative';
    return weekdays[nounCase][m.day()];
  }

  function processHoursFunction(str) {
    return function () {
      return str + '' + (this.hours() === 11 ? '' : '') + '] LT';
    };
  }

  var uk = moment.defineLocale('uk', {
    months: {
      format: '___________'.split('_'),
      standalone: '___________'.split('_')
    },
    monthsShort: '___________'.split('_'),
    weekdays: weekdaysCaseReplace,
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD.MM.YYYY',
      LL: 'D MMMM YYYY .',
      LLL: 'D MMMM YYYY ., HH:mm',
      LLLL: 'dddd, D MMMM YYYY ., HH:mm'
    },
    calendar: {
      sameDay: processHoursFunction('[ '),
      nextDay: processHoursFunction('[ '),
      lastDay: processHoursFunction('[ '),
      nextWeek: processHoursFunction('[] dddd ['),
      lastWeek: function () {
        switch (this.day()) {
          case 0:
          case 3:
          case 5:
          case 6:
            return processHoursFunction('[] dddd [').call(this);

          case 1:
          case 2:
          case 4:
            return processHoursFunction('[] dddd [').call(this);
        }
      },
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s',
      past: '%s ',
      s: ' ',
      ss: relativeTimeWithPlural,
      m: relativeTimeWithPlural,
      mm: relativeTimeWithPlural,
      h: '',
      hh: relativeTimeWithPlural,
      d: '',
      dd: relativeTimeWithPlural,
      M: '',
      MM: relativeTimeWithPlural,
      y: '',
      yy: relativeTimeWithPlural
    },
    // M. E.: those two are virtually unused but a user might want to implement them for his/her website for some reason
    meridiemParse: /|||/,
    isPM: function (input) {
      return /^(|)$/.test(input);
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 4) {
        return '';
      } else if (hour < 12) {
        return '';
      } else if (hour < 17) {
        return '';
      } else {
        return '';
      }
    },
    dayOfMonthOrdinalParse: /\d{1,2}-(|)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'M':
        case 'd':
        case 'DDD':
        case 'w':
        case 'W':
          return number + '-';

        case 'D':
          return number + '-';

        default:
          return number;
      }
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return uk;
});

/***/ }),
/* 232 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Urdu [ur]
//! author : Sawood Alam : https://github.com/ibnesayeed
//! author : Zack : https://github.com/ZackVision
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var months = ['', '', '', '', '', '', '', '', '', '', '', ''],
      days = ['', '', '', '', '', '', ''];
  var ur = moment.defineLocale('ur', {
    months: months,
    monthsShort: months,
    weekdays: days,
    weekdaysShort: days,
    weekdaysMin: days,
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd D MMMM YYYY HH:mm'
    },
    meridiemParse: /|/,
    isPM: function (input) {
      return '' === input;
    },
    meridiem: function (hour, minute, isLower) {
      if (hour < 12) {
        return '';
      }

      return '';
    },
    calendar: {
      sameDay: '[ ] LT',
      nextDay: '[ ] LT',
      nextWeek: 'dddd [] LT',
      lastDay: '[  ] LT',
      lastWeek: '[] dddd [] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ',
      past: '%s ',
      s: ' ',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    preparse: function (string) {
      return string.replace(//g, ',');
    },
    postformat: function (string) {
      return string.replace(/,/g, '');
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return ur;
});

/***/ }),
/* 233 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek [uz]
//! author : Sardor Muminov : https://github.com/muminoff
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var uz = moment.defineLocale('uz', {
    months: '___________'.split('_'),
    monthsShort: '___________'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[ ] LT []',
      nextDay: '[] LT []',
      nextWeek: 'dddd [ ] LT []',
      lastDay: '[ ] LT []',
      lastWeek: '[] dddd [ ] LT []',
      sameElse: 'L'
    },
    relativeTime: {
      future: ' %s ',
      past: '  %s ',
      s: '',
      ss: '%d ',
      m: ' ',
      mm: '%d ',
      h: ' ',
      hh: '%d ',
      d: ' ',
      dd: '%d ',
      M: ' ',
      MM: '%d ',
      y: ' ',
      yy: '%d '
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return uz;
});

/***/ }),
/* 234 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Uzbek Latin [uz-latn]
//! author : Rasulbek Mirzayev : github.com/Rasulbeeek
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var uzLatn = moment.defineLocale('uz-latn', {
    months: 'Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr'.split('_'),
    monthsShort: 'Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek'.split('_'),
    weekdays: 'Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba'.split('_'),
    weekdaysShort: 'Yak_Dush_Sesh_Chor_Pay_Jum_Shan'.split('_'),
    weekdaysMin: 'Ya_Du_Se_Cho_Pa_Ju_Sha'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'D MMMM YYYY, dddd HH:mm'
    },
    calendar: {
      sameDay: '[Bugun soat] LT [da]',
      nextDay: '[Ertaga] LT [da]',
      nextWeek: 'dddd [kuni soat] LT [da]',
      lastDay: '[Kecha soat] LT [da]',
      lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
      sameElse: 'L'
    },
    relativeTime: {
      future: 'Yaqin %s ichida',
      past: 'Bir necha %s oldin',
      s: 'soniya',
      ss: '%d soniya',
      m: 'bir daqiqa',
      mm: '%d daqiqa',
      h: 'bir soat',
      hh: '%d soat',
      d: 'bir kun',
      dd: '%d kun',
      M: 'bir oy',
      MM: '%d oy',
      y: 'bir yil',
      yy: '%d yil'
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 7 // The week that contains Jan 7th is the first week of the year.

    }
  });
  return uzLatn;
});

/***/ }),
/* 235 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Vietnamese [vi]
//! author : Bang Nguyen : https://github.com/bangnk
//! author : Chien Kira : https://github.com/chienkira
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var vi = moment.defineLocale('vi', {
    months: 'thng 1_thng 2_thng 3_thng 4_thng 5_thng 6_thng 7_thng 8_thng 9_thng 10_thng 11_thng 12'.split('_'),
    monthsShort: 'Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12'.split('_'),
    monthsParseExact: true,
    weekdays: 'ch nht_th hai_th ba_th t_th nm_th su_th by'.split('_'),
    weekdaysShort: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysMin: 'CN_T2_T3_T4_T5_T6_T7'.split('_'),
    weekdaysParseExact: true,
    meridiemParse: /sa|ch/i,
    isPM: function (input) {
      return /^ch$/i.test(input);
    },
    meridiem: function (hours, minutes, isLower) {
      if (hours < 12) {
        return isLower ? 'sa' : 'SA';
      } else {
        return isLower ? 'ch' : 'CH';
      }
    },
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM [nm] YYYY',
      LLL: 'D MMMM [nm] YYYY HH:mm',
      LLLL: 'dddd, D MMMM [nm] YYYY HH:mm',
      l: 'DD/M/YYYY',
      ll: 'D MMM YYYY',
      lll: 'D MMM YYYY HH:mm',
      llll: 'ddd, D MMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[Hm nay lc] LT',
      nextDay: '[Ngy mai lc] LT',
      nextWeek: 'dddd [tun ti lc] LT',
      lastDay: '[Hm qua lc] LT',
      lastWeek: 'dddd [tun trc lc] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '%s ti',
      past: '%s trc',
      s: 'vi giy',
      ss: '%d giy',
      m: 'mt pht',
      mm: '%d pht',
      h: 'mt gi',
      hh: '%d gi',
      d: 'mt ngy',
      dd: '%d ngy',
      w: 'mt tun',
      ww: '%d tun',
      M: 'mt thng',
      MM: '%d thng',
      y: 'mt nm',
      yy: '%d nm'
    },
    dayOfMonthOrdinalParse: /\d{1,2}/,
    ordinal: function (number) {
      return number;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return vi;
});

/***/ }),
/* 236 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Pseudo [x-pseudo]
//! author : Andrew Hood : https://github.com/andrewhood125
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var xPseudo = moment.defineLocale('x-pseudo', {
    months: 'J~~r_F~br~r_~Mrc~h_p~rl_~M_~J~_Jl~_~gst~_Sp~tmb~r_~ctb~r_~vm~br_~Dc~mbr'.split('_'),
    monthsShort: 'J~_~Fb_~Mr_~pr_~M_~J_~Jl_~g_~Sp_~ct_~v_~Dc'.split('_'),
    monthsParseExact: true,
    weekdays: 'S~d~_M~d~_T~sd~_Wd~sd~_T~hrs~d_~Frd~_S~tr~d'.split('_'),
    weekdaysShort: 'S~_~M_~T_~Wd_~Th_~Fr_~St'.split('_'),
    weekdaysMin: 'S~_M~_T_~W_T~h_Fr~_S'.split('_'),
    weekdaysParseExact: true,
    longDateFormat: {
      LT: 'HH:mm',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY HH:mm',
      LLLL: 'dddd, D MMMM YYYY HH:mm'
    },
    calendar: {
      sameDay: '[T~d~ t] LT',
      nextDay: '[T~m~rr~w t] LT',
      nextWeek: 'dddd [t] LT',
      lastDay: '[~st~rd~ t] LT',
      lastWeek: '[L~st] dddd [t] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: '~ %s',
      past: '%s ~g',
      s: ' ~fw ~sc~ds',
      ss: '%d s~c~ds',
      m: ' ~m~t',
      mm: '%d m~~ts',
      h: '~ h~r',
      hh: '%d h~rs',
      d: ' ~d',
      dd: '%d d~s',
      M: ' ~m~th',
      MM: '%d m~t~hs',
      y: ' ~r',
      yy: '%d ~rs'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal: function (number) {
      var b = number % 10,
          output = ~~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
      return number + output;
    },
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return xPseudo;
});

/***/ }),
/* 237 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Yoruba Nigeria [yo]
//! author : Atolagbe Abisoye : https://github.com/andela-batolagbe
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var yo = moment.defineLocale('yo', {
    months: 'Sr_Erele_rna_Igbe_Ebibi_Okudu_Agmo_Ogun_Owewe_wara_Belu_p'.split('_'),
    monthsShort: 'Sr_Erl_rn_Igb_Ebi_Oku_Ag_Ogu_Owe_wa_Bel_p'.split('_'),
    weekdays: 'Aiku_Aje_Isgun_jru_jb_ti_Abamta'.split('_'),
    weekdaysShort: 'Aik_Aje_Is_jr_jb_ti_Aba'.split('_'),
    weekdaysMin: 'Ai_Aj_Is_r_b_t_Ab'.split('_'),
    longDateFormat: {
      LT: 'h:mm A',
      LTS: 'h:mm:ss A',
      L: 'DD/MM/YYYY',
      LL: 'D MMMM YYYY',
      LLL: 'D MMMM YYYY h:mm A',
      LLLL: 'dddd, D MMMM YYYY h:mm A'
    },
    calendar: {
      sameDay: '[Oni ni] LT',
      nextDay: '[la ni] LT',
      nextWeek: "dddd [s ton'b] [ni] LT",
      lastDay: '[Ana ni] LT',
      lastWeek: 'dddd [s tol] [ni] LT',
      sameElse: 'L'
    },
    relativeTime: {
      future: 'ni %s',
      past: '%s kja',
      s: 'isju aaya die',
      ss: 'aaya %d',
      m: 'isju kan',
      mm: 'isju %d',
      h: 'wakati kan',
      hh: 'wakati %d',
      d: 'j kan',
      dd: 'j %d',
      M: 'osu kan',
      MM: 'osu %d',
      y: 'dun kan',
      yy: 'dun %d'
    },
    dayOfMonthOrdinalParse: /j\s\d{1,2}/,
    ordinal: 'j %d',
    week: {
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return yo;
});

/***/ }),
/* 238 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (China) [zh-cn]
//! author : suupic : https://github.com/suupic
//! author : Zeno Zeng : https://github.com/zenozeng
//! author : uu109 : https://github.com/uu109
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhCn = moment.defineLocale('zh-cn', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMDAhmm',
      LLLL: 'YYYYMDddddAhmm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      } else {
        // ''
        return hour >= 11 ? hour : hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: function (now) {
        if (now.week() !== this.week()) {
          return '[]dddLT';
        } else {
          return '[]dddLT';
        }
      },
      lastDay: '[]LT',
      lastWeek: function (now) {
        if (this.week() !== now.week()) {
          return '[]dddLT';
        } else {
          return '[]dddLT';
        }
      },
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      w: '1 ',
      ww: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    },
    week: {
      // GB/T 7408-1994ISO 8601:1988
      dow: 1,
      // Monday is the first day of the week.
      doy: 4 // The week that contains Jan 4th is the first week of the year.

    }
  });
  return zhCn;
});

/***/ }),
/* 239 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Hong Kong) [zh-hk]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Konstantin : https://github.com/skfd
//! author : Anthony : https://github.com/anthonylau
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhHk = moment.defineLocale('zh-hk', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1200) {
        return '';
      } else if (hm === 1200) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[]LT',
      nextDay: '[]LT',
      nextWeek: '[]ddddLT',
      lastDay: '[]LT',
      lastWeek: '[]ddddLT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhHk;
});

/***/ }),
/* 240 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Macau) [zh-mo]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
//! author : Tan Yuanhong : https://github.com/le0tan
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhMo = moment.defineLocale('zh-mo', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'DD/MM/YYYY',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'D/M/YYYY',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhMo;
});

/***/ }),
/* 241 */
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

//! moment.js locale configuration
//! locale : Chinese (Taiwan) [zh-tw]
//! author : Ben : https://github.com/ben-lin
//! author : Chris Lam : https://github.com/hehachris
;

(function (global, factory) {
   true ? factory(__webpack_require__(105)) : 0;
})(this, function (moment) {
  'use strict'; //! moment.js locale configuration

  var zhTw = moment.defineLocale('zh-tw', {
    months: '___________'.split('_'),
    monthsShort: '1_2_3_4_5_6_7_8_9_10_11_12'.split('_'),
    weekdays: '______'.split('_'),
    weekdaysShort: '______'.split('_'),
    weekdaysMin: '______'.split('_'),
    longDateFormat: {
      LT: 'HH:mm',
      LTS: 'HH:mm:ss',
      L: 'YYYY/MM/DD',
      LL: 'YYYYMD',
      LLL: 'YYYYMD HH:mm',
      LLLL: 'YYYYMDdddd HH:mm',
      l: 'YYYY/M/D',
      ll: 'YYYYMD',
      lll: 'YYYYMD HH:mm',
      llll: 'YYYYMDdddd HH:mm'
    },
    meridiemParse: /|||||/,
    meridiemHour: function (hour, meridiem) {
      if (hour === 12) {
        hour = 0;
      }

      if (meridiem === '' || meridiem === '' || meridiem === '') {
        return hour;
      } else if (meridiem === '') {
        return hour >= 11 ? hour : hour + 12;
      } else if (meridiem === '' || meridiem === '') {
        return hour + 12;
      }
    },
    meridiem: function (hour, minute, isLower) {
      var hm = hour * 100 + minute;

      if (hm < 600) {
        return '';
      } else if (hm < 900) {
        return '';
      } else if (hm < 1130) {
        return '';
      } else if (hm < 1230) {
        return '';
      } else if (hm < 1800) {
        return '';
      } else {
        return '';
      }
    },
    calendar: {
      sameDay: '[] LT',
      nextDay: '[] LT',
      nextWeek: '[]dddd LT',
      lastDay: '[] LT',
      lastWeek: '[]dddd LT',
      sameElse: 'L'
    },
    dayOfMonthOrdinalParse: /\d{1,2}(||)/,
    ordinal: function (number, period) {
      switch (period) {
        case 'd':
        case 'D':
        case 'DDD':
          return number + '';

        case 'M':
          return number + '';

        case 'w':
        case 'W':
          return number + '';

        default:
          return number;
      }
    },
    relativeTime: {
      future: '%s',
      past: '%s',
      s: '',
      ss: '%d ',
      m: '1 ',
      mm: '%d ',
      h: '1 ',
      hh: '%d ',
      d: '1 ',
      dd: '%d ',
      M: '1 ',
      MM: '%d ',
      y: '1 ',
      yy: '%d '
    }
  });
  return zhTw;
});

/***/ }),
/* 242 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var objectKeys = __webpack_require__(243);

var isArguments = __webpack_require__(246);

var is = __webpack_require__(256);

var isRegex = __webpack_require__(262);

var flags = __webpack_require__(263);

var isArray = __webpack_require__(268);

var isDate = __webpack_require__(269);

var whichBoxedPrimitive = __webpack_require__(270);

var GetIntrinsic = __webpack_require__(250);

var callBound = __webpack_require__(249);

var whichCollection = __webpack_require__(277);

var getIterator = __webpack_require__(282);

var getSideChannel = __webpack_require__(283);

var whichTypedArray = __webpack_require__(286);

var assign = __webpack_require__(292); // TODO: use extracted package


var byteLength = callBound('ArrayBuffer.prototype.byteLength', true);

function isArrayBuffer(buffer) {
  if (!buffer || typeof buffer !== 'object' || !byteLength) {
    return false;
  }

  try {
    byteLength(buffer);
    return true;
  } catch (e) {
    return false;
  }
}

var $getTime = callBound('Date.prototype.getTime');
var gPO = Object.getPrototypeOf;
var $objToString = callBound('Object.prototype.toString');
var $Set = GetIntrinsic('%Set%', true);
var $mapHas = callBound('Map.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSize = callBound('Map.prototype.size', true);
var $setAdd = callBound('Set.prototype.add', true);
var $setDelete = callBound('Set.prototype.delete', true);
var $setHas = callBound('Set.prototype.has', true);
var $setSize = callBound('Set.prototype.size', true); // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L401-L414

function setHasEqualElement(set, val1, opts, channel) {
  var i = getIterator(set);
  var result;

  while ((result = i.next()) && !result.done) {
    if (internalDeepEqual(val1, result.value, opts, channel)) {
      // eslint-disable-line no-use-before-define
      // Remove the matching element to make sure we do not check that again.
      $setDelete(set, result.value);
      return true;
    }
  }

  return false;
} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L416-L439


function findLooseMatchingPrimitives(prim) {
  if (typeof prim === 'undefined') {
    return null;
  }

  if (typeof prim === 'object') {
    // Only pass in null as object!
    return void 0;
  }

  if (typeof prim === 'symbol') {
    return false;
  }

  if (typeof prim === 'string' || typeof prim === 'number') {
    // Loose equal entries exist only if the string is possible to convert to a regular number and not NaN.
    return +prim === +prim; // eslint-disable-line no-implicit-coercion
  }

  return true;
} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L449-L460


function mapMightHaveLoosePrim(a, b, prim, item, opts, channel) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  var curB = $mapGet(b, altValue);
  var looseOpts = assign({}, opts, {
    strict: false
  });

  if (typeof curB === 'undefined' && !$mapHas(b, altValue) // eslint-disable-next-line no-use-before-define
  || !internalDeepEqual(item, curB, looseOpts, channel)) {
    return false;
  } // eslint-disable-next-line no-use-before-define


  return !$mapHas(a, altValue) && internalDeepEqual(item, curB, looseOpts, channel);
} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L441-L447


function setMightHaveLoosePrim(a, b, prim) {
  var altValue = findLooseMatchingPrimitives(prim);

  if (altValue != null) {
    return altValue;
  }

  return $setHas(b, altValue) && !$setHas(a, altValue);
} // taken from https://github.com/browserify/commonjs-assert/blob/bba838e9ba9e28edf3127ce6974624208502f6bc/internal/util/comparisons.js#L518-L533


function mapHasEqualEntry(set, map, key1, item1, opts, channel) {
  var i = getIterator(set);
  var result;
  var key2;

  while ((result = i.next()) && !result.done) {
    key2 = result.value;

    if ( // eslint-disable-next-line no-use-before-define
    internalDeepEqual(key1, key2, opts, channel) // eslint-disable-next-line no-use-before-define
    && internalDeepEqual(item1, $mapGet(map, key2), opts, channel)) {
      $setDelete(set, key2);
      return true;
    }
  }

  return false;
}

function internalDeepEqual(actual, expected, options, channel) {
  var opts = options || {}; // 7.1. All identical values are equivalent, as determined by ===.

  if (opts.strict ? is(actual, expected) : actual === expected) {
    return true;
  }

  var actualBoxed = whichBoxedPrimitive(actual);
  var expectedBoxed = whichBoxedPrimitive(expected);

  if (actualBoxed !== expectedBoxed) {
    return false;
  } // 7.3. Other pairs that do not both pass typeof value == 'object', equivalence is determined by ==.


  if (!actual || !expected || typeof actual !== 'object' && typeof expected !== 'object') {
    return opts.strict ? is(actual, expected) : actual == expected; // eslint-disable-line eqeqeq
  }
  /*
   * 7.4. For all other Object pairs, including Array objects, equivalence is
   * determined by having the same number of owned properties (as verified
   * with Object.prototype.hasOwnProperty.call), the same set of keys
   * (although not necessarily the same order), equivalent values for every
   * corresponding key, and an identical 'prototype' property. Note: this
   * accounts for both named and indexed properties on Arrays.
   */
  // see https://github.com/nodejs/node/commit/d3aafd02efd3a403d646a3044adcf14e63a88d32 for memos/channel inspiration


  var hasActual = channel.has(actual);
  var hasExpected = channel.has(expected);
  var sentinel;

  if (hasActual && hasExpected) {
    if (channel.get(actual) === channel.get(expected)) {
      return true;
    }
  } else {
    sentinel = {};
  }

  if (!hasActual) {
    channel.set(actual, sentinel);
  }

  if (!hasExpected) {
    channel.set(expected, sentinel);
  } // eslint-disable-next-line no-use-before-define


  return objEquiv(actual, expected, opts, channel);
}

function isBuffer(x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') {
    return false;
  }

  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }

  if (x.length > 0 && typeof x[0] !== 'number') {
    return false;
  }

  return !!(x.constructor && x.constructor.isBuffer && x.constructor.isBuffer(x));
}

function setEquiv(a, b, opts, channel) {
  if ($setSize(a) !== $setSize(b)) {
    return false;
  }

  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set;

  while ((resultA = iA.next()) && !resultA.done) {
    if (resultA.value && typeof resultA.value === 'object') {
      if (!set) {
        set = new $Set();
      }

      $setAdd(set, resultA.value);
    } else if (!$setHas(b, resultA.value)) {
      if (opts.strict) {
        return false;
      }

      if (!setMightHaveLoosePrim(a, b, resultA.value)) {
        return false;
      }

      if (!set) {
        set = new $Set();
      }

      $setAdd(set, resultA.value);
    }
  }

  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      // We have to check if a primitive value is already matching and only if it's not, go hunting for it.
      if (resultB.value && typeof resultB.value === 'object') {
        if (!setHasEqualElement(set, resultB.value, opts.strict, channel)) {
          return false;
        }
      } else if (!opts.strict && !$setHas(a, resultB.value) && !setHasEqualElement(set, resultB.value, opts.strict, channel)) {
        return false;
      }
    }

    return $setSize(set) === 0;
  }

  return true;
}

function mapEquiv(a, b, opts, channel) {
  if ($mapSize(a) !== $mapSize(b)) {
    return false;
  }

  var iA = getIterator(a);
  var iB = getIterator(b);
  var resultA;
  var resultB;
  var set;
  var key;
  var item1;
  var item2;

  while ((resultA = iA.next()) && !resultA.done) {
    key = resultA.value[0];
    item1 = resultA.value[1];

    if (key && typeof key === 'object') {
      if (!set) {
        set = new $Set();
      }

      $setAdd(set, key);
    } else {
      item2 = $mapGet(b, key);

      if (typeof item2 === 'undefined' && !$mapHas(b, key) || !internalDeepEqual(item1, item2, opts, channel)) {
        if (opts.strict) {
          return false;
        }

        if (!mapMightHaveLoosePrim(a, b, key, item1, opts, channel)) {
          return false;
        }

        if (!set) {
          set = new $Set();
        }

        $setAdd(set, key);
      }
    }
  }

  if (set) {
    while ((resultB = iB.next()) && !resultB.done) {
      key = resultB.value[0];
      item2 = resultB.value[1];

      if (key && typeof key === 'object') {
        if (!mapHasEqualEntry(set, a, key, item2, opts, channel)) {
          return false;
        }
      } else if (!opts.strict && (!a.has(key) || !internalDeepEqual($mapGet(a, key), item2, opts, channel)) && !mapHasEqualEntry(set, a, key, item2, assign({}, opts, {
        strict: false
      }), channel)) {
        return false;
      }
    }

    return $setSize(set) === 0;
  }

  return true;
}

function objEquiv(a, b, opts, channel) {
  /* eslint max-statements: [2, 100], max-lines-per-function: [2, 120], max-depth: [2, 5], max-lines: [2, 400] */
  var i, key;

  if (typeof a !== typeof b) {
    return false;
  }

  if (a == null || b == null) {
    return false;
  }

  if ($objToString(a) !== $objToString(b)) {
    return false;
  }

  if (isArguments(a) !== isArguments(b)) {
    return false;
  }

  var aIsArray = isArray(a);
  var bIsArray = isArray(b);

  if (aIsArray !== bIsArray) {
    return false;
  } // TODO: replace when a cross-realm brand check is available


  var aIsError = a instanceof Error;
  var bIsError = b instanceof Error;

  if (aIsError !== bIsError) {
    return false;
  }

  if (aIsError || bIsError) {
    if (a.name !== b.name || a.message !== b.message) {
      return false;
    }
  }

  var aIsRegex = isRegex(a);
  var bIsRegex = isRegex(b);

  if (aIsRegex !== bIsRegex) {
    return false;
  }

  if ((aIsRegex || bIsRegex) && (a.source !== b.source || flags(a) !== flags(b))) {
    return false;
  }

  var aIsDate = isDate(a);
  var bIsDate = isDate(b);

  if (aIsDate !== bIsDate) {
    return false;
  }

  if (aIsDate || bIsDate) {
    // && would work too, because both are true or both false here
    if ($getTime(a) !== $getTime(b)) {
      return false;
    }
  }

  if (opts.strict && gPO && gPO(a) !== gPO(b)) {
    return false;
  }

  if (whichTypedArray(a) !== whichTypedArray(b)) {
    return false;
  }

  var aIsBuffer = isBuffer(a);
  var bIsBuffer = isBuffer(b);

  if (aIsBuffer !== bIsBuffer) {
    return false;
  }

  if (aIsBuffer || bIsBuffer) {
    // && would work too, because both are true or both false here
    if (a.length !== b.length) {
      return false;
    }

    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  }

  var aIsArrayBuffer = isArrayBuffer(a);
  var bIsArrayBuffer = isArrayBuffer(b);

  if (aIsArrayBuffer !== bIsArrayBuffer) {
    return false;
  }

  if (aIsArrayBuffer || bIsArrayBuffer) {
    // && would work too, because both are true or both false here
    if (byteLength(a) !== byteLength(b)) {
      return false;
    }
    /* global Uint8Array */


    return typeof Uint8Array === 'function' && internalDeepEqual(new Uint8Array(a), new Uint8Array(b), opts, channel);
  }

  if (typeof a !== typeof b) {
    return false;
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b); // having the same number of owned properties (keys incorporates hasOwnProperty)

  if (ka.length !== kb.length) {
    return false;
  } // the same set of keys (although not necessarily the same order),


  ka.sort();
  kb.sort(); // ~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) {
      return false;
    } // eslint-disable-line eqeqeq

  } // equivalent values for every corresponding key, and ~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];

    if (!internalDeepEqual(a[key], b[key], opts, channel)) {
      return false;
    }
  }

  var aCollection = whichCollection(a);
  var bCollection = whichCollection(b);

  if (aCollection !== bCollection) {
    return false;
  }

  if (aCollection === 'Set' || bCollection === 'Set') {
    // aCollection === bCollection
    return setEquiv(a, b, opts, channel);
  }

  if (aCollection === 'Map') {
    // aCollection === bCollection
    return mapEquiv(a, b, opts, channel);
  }

  return true;
}

module.exports = function deepEqual(a, b, opts) {
  return internalDeepEqual(a, b, opts, getSideChannel());
};

/***/ }),
/* 243 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var slice = Array.prototype.slice;

var isArgs = __webpack_require__(244);

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : __webpack_require__(245);
var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);

    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }

        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }

  return Object.keys || keysShim;
};

module.exports = keysShim;

/***/ }),
/* 244 */
/***/ (function(module) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';

  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }

  return isArgs;
};

/***/ }),
/* 245 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var keysShim;

if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;

  var isArgs = __webpack_require__(244); // eslint-disable-line global-require


  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  var equalsConstructorPrototype = function (o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };

  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };

  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }

    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }

    return false;
  }();

  var equalsConstructorPrototypeIfNotBuggy = function (o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }

    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };

  keysShim = function keys(object) {
    var isObject = object !== null && typeof object === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];

    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }

    var skipProto = hasProtoEnumBug && isFunction;

    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }

    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }

    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }

    return theKeys;
  };
}

module.exports = keysShim;

/***/ }),
/* 246 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasToStringTag = __webpack_require__(247)();

var callBound = __webpack_require__(249);

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
  if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
    return false;
  }

  return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
  if (isStandardArguments(value)) {
    return true;
  }

  return value !== null && typeof value === 'object' && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && $toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = function () {
  return isStandardArguments(arguments);
}();

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

/***/ }),
/* 247 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasSymbols = __webpack_require__(248);

module.exports = function hasToStringTagShams() {
  return hasSymbols() && !!Symbol.toStringTag;
};

/***/ }),
/* 248 */
/***/ (function(module) {

"use strict";

/* eslint complexity: [2, 18], max-statements: [2, 33] */

module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }

  if (typeof Symbol.iterator === 'symbol') {
    return true;
  }

  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);

  if (typeof sym === 'string') {
    return false;
  }

  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }

  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  } // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }
  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }


  var symVal = 42;
  obj[sym] = symVal;

  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop


  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }

  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }

  var syms = Object.getOwnPropertySymbols(obj);

  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }

  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }

  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);

    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }

  return true;
};

/***/ }),
/* 249 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(250);

var callBind = __webpack_require__(255);

var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);

  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }

  return intrinsic;
};

/***/ }),
/* 250 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var undefined;
var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError; // eslint-disable-next-line consistent-return

var getEvalledConstructor = function (expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;

if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}

var throwTypeError = function () {
  throw new $TypeError();
};

var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here

    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;

var hasSymbols = __webpack_require__(251)();

var getProto = Object.getPrototypeOf || function (x) {
  return x.__proto__;
}; // eslint-disable-line no-proto


var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': typeof JSON === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': RangeError,
  '%ReferenceError%': ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
  var value;

  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');

    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');

    if (gen) {
      value = getProto(gen.prototype);
    }
  }

  INTRINSICS[name] = value;
  return value;
};

var LEGACY_ALIASES = {
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(252);

var hasOwn = __webpack_require__(254);

var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */

var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g;
/** Used to match backslashes in property paths. */

var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);

  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }

  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */


var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;

  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }

  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];

    if (value === needsEval) {
      value = doEval(intrinsicName);
    }

    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }

    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }

  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }

  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }

  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  }

  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;

  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }

  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);

    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }

    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }

    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';

    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }

        return void undefined;
      }

      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc; // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.

        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }

      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }

  return value;
};

/***/ }),
/* 251 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;

var hasSymbolSham = __webpack_require__(248);

module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }

  if (typeof Symbol !== 'function') {
    return false;
  }

  if (typeof origSymbol('foo') !== 'symbol') {
    return false;
  }

  if (typeof Symbol('bar') !== 'symbol') {
    return false;
  }

  return hasSymbolSham();
};

/***/ }),
/* 252 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(253);

module.exports = Function.prototype.bind || implementation;

/***/ }),
/* 253 */
/***/ (function(module) {

"use strict";

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
  var target = this;

  if (typeof target !== 'function' || toStr.call(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }

  var args = slice.call(arguments, 1);
  var bound;

  var binder = function () {
    if (this instanceof bound) {
      var result = target.apply(this, args.concat(slice.call(arguments)));

      if (Object(result) === result) {
        return result;
      }

      return this;
    } else {
      return target.apply(that, args.concat(slice.call(arguments)));
    }
  };

  var boundLength = Math.max(0, target.length - args.length);
  var boundArgs = [];

  for (var i = 0; i < boundLength; i++) {
    boundArgs.push('$' + i);
  }

  bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

  if (target.prototype) {
    var Empty = function Empty() {};

    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }

  return bound;
};

/***/ }),
/* 254 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(252);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

/***/ }),
/* 255 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(252);

var GetIntrinsic = __webpack_require__(250);

var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var $max = GetIntrinsic('%Math.max%');

if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = null;
  }
}

module.exports = function callBind(originalFunction) {
  var func = $reflectApply(bind, $call, arguments);

  if ($gOPD && $defineProperty) {
    var desc = $gOPD(func, 'length');

    if (desc.configurable) {
      // original length, plus the receiver, minus any additional arguments (after the receiver)
      $defineProperty(func, 'length', {
        value: 1 + $max(0, originalFunction.length - (arguments.length - 1))
      });
    }
  }

  return func;
};

var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};

if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

/***/ }),
/* 256 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(257);

var callBind = __webpack_require__(255);

var implementation = __webpack_require__(259);

var getPolyfill = __webpack_require__(260);

var shim = __webpack_require__(261);

var polyfill = callBind(getPolyfill(), Object);
define(polyfill, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = polyfill;

/***/ }),
/* 257 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(243);

var hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
var toStr = Object.prototype.toString;
var concat = Array.prototype.concat;
var origDefineProperty = Object.defineProperty;

var isFunction = function (fn) {
  return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var hasPropertyDescriptors = __webpack_require__(258)();

var supportsDescriptors = origDefineProperty && hasPropertyDescriptors;

var defineProperty = function (object, name, value, predicate) {
  if (name in object && (!isFunction(predicate) || !predicate())) {
    return;
  }

  if (supportsDescriptors) {
    origDefineProperty(object, name, {
      configurable: true,
      enumerable: false,
      value: value,
      writable: true
    });
  } else {
    object[name] = value; // eslint-disable-line no-param-reassign
  }
};

var defineProperties = function (object, map) {
  var predicates = arguments.length > 2 ? arguments[2] : {};
  var props = keys(map);

  if (hasSymbols) {
    props = concat.call(props, Object.getOwnPropertySymbols(map));
  }

  for (var i = 0; i < props.length; i += 1) {
    defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
  }
};

defineProperties.supportsDescriptors = !!supportsDescriptors;
module.exports = defineProperties;

/***/ }),
/* 258 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(250);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
  if ($defineProperty) {
    try {
      $defineProperty({}, 'a', {
        value: 1
      });
      return true;
    } catch (e) {
      // IE 8 has a broken defineProperty
      return false;
    }
  }

  return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  // node v0.6 has a bug where array lengths can be Set but not Defined
  if (!hasPropertyDescriptors()) {
    return null;
  }

  try {
    return $defineProperty([], 'length', {
      value: 1
    }).length !== 1;
  } catch (e) {
    // In Firefox 4-22, defining length on an array throws an exception.
    return true;
  }
};

module.exports = hasPropertyDescriptors;

/***/ }),
/* 259 */
/***/ (function(module) {

"use strict";


var numberIsNaN = function (value) {
  return value !== value;
};

module.exports = function is(a, b) {
  if (a === 0 && b === 0) {
    return 1 / a === 1 / b;
  }

  if (a === b) {
    return true;
  }

  if (numberIsNaN(a) && numberIsNaN(b)) {
    return true;
  }

  return false;
};

/***/ }),
/* 260 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(259);

module.exports = function getPolyfill() {
  return typeof Object.is === 'function' ? Object.is : implementation;
};

/***/ }),
/* 261 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var getPolyfill = __webpack_require__(260);

var define = __webpack_require__(257);

module.exports = function shimObjectIs() {
  var polyfill = getPolyfill();
  define(Object, {
    is: polyfill
  }, {
    is: function testObjectIs() {
      return Object.is !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 262 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(249);

var hasToStringTag = __webpack_require__(247)();

var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
  has = callBound('Object.prototype.hasOwnProperty');
  $exec = callBound('RegExp.prototype.exec');
  isRegexMarker = {};

  var throwRegexMarker = function () {
    throw isRegexMarker;
  };

  badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };

  if (typeof Symbol.toPrimitive === 'symbol') {
    badStringifier[Symbol.toPrimitive] = throwRegexMarker;
  }
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';
module.exports = hasToStringTag // eslint-disable-next-line consistent-return
? function isRegex(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }

  var descriptor = gOPD(value, 'lastIndex');
  var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');

  if (!hasLastIndexDataProperty) {
    return false;
  }

  try {
    $exec(value, badStringifier);
  } catch (e) {
    return e === isRegexMarker;
  }
} : function isRegex(value) {
  // In older browsers, typeof regex incorrectly returns 'function'
  if (!value || typeof value !== 'object' && typeof value !== 'function') {
    return false;
  }

  return $toString(value) === regexClass;
};

/***/ }),
/* 263 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(257);

var callBind = __webpack_require__(255);

var implementation = __webpack_require__(264);

var getPolyfill = __webpack_require__(266);

var shim = __webpack_require__(267);

var flagsBound = callBind(getPolyfill());
define(flagsBound, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = flagsBound;

/***/ }),
/* 264 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var functionsHaveConfigurableNames = (__webpack_require__(265).functionsHaveConfigurableNames)();

var $Object = Object;
var $TypeError = TypeError;

module.exports = function flags() {
  if (this != null && this !== $Object(this)) {
    throw new $TypeError('RegExp.prototype.flags getter called on non-object');
  }

  var result = '';

  if (this.hasIndices) {
    result += 'd';
  }

  if (this.global) {
    result += 'g';
  }

  if (this.ignoreCase) {
    result += 'i';
  }

  if (this.multiline) {
    result += 'm';
  }

  if (this.dotAll) {
    result += 's';
  }

  if (this.unicode) {
    result += 'u';
  }

  if (this.sticky) {
    result += 'y';
  }

  return result;
};

if (functionsHaveConfigurableNames && Object.defineProperty) {
  Object.defineProperty(module.exports, "name", ({
    value: 'get flags'
  }));
}

/***/ }),
/* 265 */
/***/ (function(module) {

"use strict";


var functionsHaveNames = function functionsHaveNames() {
  return typeof function f() {}.name === 'string';
};

var gOPD = Object.getOwnPropertyDescriptor;

if (gOPD) {
  try {
    gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    gOPD = null;
  }
}

functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
  if (!functionsHaveNames() || !gOPD) {
    return false;
  }

  var desc = gOPD(function () {}, 'name');
  return !!desc && !!desc.configurable;
};

var $bind = Function.prototype.bind;

functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
  return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
};

module.exports = functionsHaveNames;

/***/ }),
/* 266 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(264);

var supportsDescriptors = (__webpack_require__(257).supportsDescriptors);

var $gOPD = Object.getOwnPropertyDescriptor;

module.exports = function getPolyfill() {
  if (supportsDescriptors && /a/mig.flags === 'gim') {
    var descriptor = $gOPD(RegExp.prototype, 'flags');

    if (descriptor && typeof descriptor.get === 'function' && typeof RegExp.prototype.dotAll === 'boolean' && typeof RegExp.prototype.hasIndices === 'boolean') {
      /* eslint getter-return: 0 */
      var calls = '';
      var o = {};
      Object.defineProperty(o, 'hasIndices', {
        get: function () {
          calls += 'd';
        }
      });
      Object.defineProperty(o, 'sticky', {
        get: function () {
          calls += 'y';
        }
      });

      if (calls === 'dy') {
        return descriptor.get;
      }
    }
  }

  return implementation;
};

/***/ }),
/* 267 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var supportsDescriptors = (__webpack_require__(257).supportsDescriptors);

var getPolyfill = __webpack_require__(266);

var gOPD = Object.getOwnPropertyDescriptor;
var defineProperty = Object.defineProperty;
var TypeErr = TypeError;
var getProto = Object.getPrototypeOf;
var regex = /a/;

module.exports = function shimFlags() {
  if (!supportsDescriptors || !getProto) {
    throw new TypeErr('RegExp.prototype.flags requires a true ES5 environment that supports property descriptors');
  }

  var polyfill = getPolyfill();
  var proto = getProto(regex);
  var descriptor = gOPD(proto, 'flags');

  if (!descriptor || descriptor.get !== polyfill) {
    defineProperty(proto, 'flags', {
      configurable: true,
      enumerable: false,
      get: polyfill
    });
  }

  return polyfill;
};

/***/ }),
/* 268 */
/***/ (function(module) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),
/* 269 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var getDay = Date.prototype.getDay;

var tryDateObject = function tryDateGetDayCall(value) {
  try {
    getDay.call(value);
    return true;
  } catch (e) {
    return false;
  }
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';

var hasToStringTag = __webpack_require__(247)();

module.exports = function isDateObject(value) {
  if (typeof value !== 'object' || value === null) {
    return false;
  }

  return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

/***/ }),
/* 270 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isString = __webpack_require__(271);

var isNumber = __webpack_require__(272);

var isBoolean = __webpack_require__(273);

var isSymbol = __webpack_require__(274);

var isBigInt = __webpack_require__(275); // eslint-disable-next-line consistent-return


module.exports = function whichBoxedPrimitive(value) {
  // eslint-disable-next-line eqeqeq
  if (value == null || typeof value !== 'object' && typeof value !== 'function') {
    return null;
  }

  if (isString(value)) {
    return 'String';
  }

  if (isNumber(value)) {
    return 'Number';
  }

  if (isBoolean(value)) {
    return 'Boolean';
  }

  if (isSymbol(value)) {
    return 'Symbol';
  }

  if (isBigInt(value)) {
    return 'BigInt';
  }
};

/***/ }),
/* 271 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var strValue = String.prototype.valueOf;

var tryStringObject = function tryStringObject(value) {
  try {
    strValue.call(value);
    return true;
  } catch (e) {
    return false;
  }
};

var toStr = Object.prototype.toString;
var strClass = '[object String]';

var hasToStringTag = __webpack_require__(247)();

module.exports = function isString(value) {
  if (typeof value === 'string') {
    return true;
  }

  if (typeof value !== 'object') {
    return false;
  }

  return hasToStringTag ? tryStringObject(value) : toStr.call(value) === strClass;
};

/***/ }),
/* 272 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var numToStr = Number.prototype.toString;

var tryNumberObject = function tryNumberObject(value) {
  try {
    numToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};

var toStr = Object.prototype.toString;
var numClass = '[object Number]';

var hasToStringTag = __webpack_require__(247)();

module.exports = function isNumberObject(value) {
  if (typeof value === 'number') {
    return true;
  }

  if (typeof value !== 'object') {
    return false;
  }

  return hasToStringTag ? tryNumberObject(value) : toStr.call(value) === numClass;
};

/***/ }),
/* 273 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var callBound = __webpack_require__(249);

var $boolToStr = callBound('Boolean.prototype.toString');
var $toString = callBound('Object.prototype.toString');

var tryBooleanObject = function booleanBrandCheck(value) {
  try {
    $boolToStr(value);
    return true;
  } catch (e) {
    return false;
  }
};

var boolClass = '[object Boolean]';

var hasToStringTag = __webpack_require__(247)();

module.exports = function isBoolean(value) {
  if (typeof value === 'boolean') {
    return true;
  }

  if (value === null || typeof value !== 'object') {
    return false;
  }

  return hasToStringTag && Symbol.toStringTag in value ? tryBooleanObject(value) : $toString(value) === boolClass;
};

/***/ }),
/* 274 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

var hasSymbols = __webpack_require__(251)();

if (hasSymbols) {
  var symToStr = Symbol.prototype.toString;
  var symStringRegex = /^Symbol\(.*\)$/;

  var isSymbolObject = function isRealSymbolObject(value) {
    if (typeof value.valueOf() !== 'symbol') {
      return false;
    }

    return symStringRegex.test(symToStr.call(value));
  };

  module.exports = function isSymbol(value) {
    if (typeof value === 'symbol') {
      return true;
    }

    if (toStr.call(value) !== '[object Symbol]') {
      return false;
    }

    try {
      return isSymbolObject(value);
    } catch (e) {
      return false;
    }
  };
} else {
  module.exports = function isSymbol(value) {
    // this environment does not support Symbols.
    return  false && 0;
  };
}

/***/ }),
/* 275 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var hasBigInts = __webpack_require__(276)();

if (hasBigInts) {
  var bigIntValueOf = BigInt.prototype.valueOf;

  var tryBigInt = function tryBigIntObject(value) {
    try {
      bigIntValueOf.call(value);
      return true;
    } catch (e) {}

    return false;
  };

  module.exports = function isBigInt(value) {
    if (value === null || typeof value === 'undefined' || typeof value === 'boolean' || typeof value === 'string' || typeof value === 'number' || typeof value === 'symbol' || typeof value === 'function') {
      return false;
    }

    if (typeof value === 'bigint') {
      return true;
    }

    return tryBigInt(value);
  };
} else {
  module.exports = function isBigInt(value) {
    return  false && 0;
  };
}

/***/ }),
/* 276 */
/***/ (function(module) {

"use strict";


var $BigInt = typeof BigInt !== 'undefined' && BigInt;

module.exports = function hasNativeBigInts() {
  return typeof $BigInt === 'function' && typeof BigInt === 'function' && typeof $BigInt(42) === 'bigint' // eslint-disable-line no-magic-numbers
  && typeof BigInt(42) === 'bigint'; // eslint-disable-line no-magic-numbers
};

/***/ }),
/* 277 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isMap = __webpack_require__(278);

var isSet = __webpack_require__(279);

var isWeakMap = __webpack_require__(280);

var isWeakSet = __webpack_require__(281);

module.exports = function whichCollection(value) {
  if (value && typeof value === 'object') {
    if (isMap(value)) {
      return 'Map';
    }

    if (isSet(value)) {
      return 'Set';
    }

    if (isWeakMap(value)) {
      return 'WeakMap';
    }

    if (isWeakSet(value)) {
      return 'WeakSet';
    }
  }

  return false;
};

/***/ }),
/* 278 */
/***/ (function(module) {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;
var exported;

if (!$Map) {
  // eslint-disable-next-line no-unused-vars
  exported = function isMap(x) {
    // `Map` is not present in this environment.
    return false;
  };
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;

if (!exported && !$mapHas) {
  // eslint-disable-next-line no-unused-vars
  exported = function isMap(x) {
    // `Map` does not have a `has` method
    return false;
  };
}

module.exports = exported || function isMap(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }

  try {
    $mapHas.call(x);

    if ($setHas) {
      try {
        $setHas.call(x);
      } catch (e) {
        return true;
      }
    }

    return x instanceof $Map; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
};

/***/ }),
/* 279 */
/***/ (function(module) {

"use strict";


var $Map = typeof Map === 'function' && Map.prototype ? Map : null;
var $Set = typeof Set === 'function' && Set.prototype ? Set : null;
var exported;

if (!$Set) {
  // eslint-disable-next-line no-unused-vars
  exported = function isSet(x) {
    // `Set` is not present in this environment.
    return false;
  };
}

var $mapHas = $Map ? Map.prototype.has : null;
var $setHas = $Set ? Set.prototype.has : null;

if (!exported && !$setHas) {
  // eslint-disable-next-line no-unused-vars
  exported = function isSet(x) {
    // `Set` does not have a `has` method
    return false;
  };
}

module.exports = exported || function isSet(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }

  try {
    $setHas.call(x);

    if ($mapHas) {
      try {
        $mapHas.call(x);
      } catch (e) {
        return true;
      }
    }

    return x instanceof $Set; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
};

/***/ }),
/* 280 */
/***/ (function(module) {

"use strict";


var $WeakMap = typeof WeakMap === 'function' && WeakMap.prototype ? WeakMap : null;
var $WeakSet = typeof WeakSet === 'function' && WeakSet.prototype ? WeakSet : null;
var exported;

if (!$WeakMap) {
  // eslint-disable-next-line no-unused-vars
  exported = function isWeakMap(x) {
    // `WeakMap` is not present in this environment.
    return false;
  };
}

var $mapHas = $WeakMap ? $WeakMap.prototype.has : null;
var $setHas = $WeakSet ? $WeakSet.prototype.has : null;

if (!exported && !$mapHas) {
  // eslint-disable-next-line no-unused-vars
  exported = function isWeakMap(x) {
    // `WeakMap` does not have a `has` method
    return false;
  };
}

module.exports = exported || function isWeakMap(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }

  try {
    $mapHas.call(x, $mapHas);

    if ($setHas) {
      try {
        $setHas.call(x, $setHas);
      } catch (e) {
        return true;
      }
    }

    return x instanceof $WeakMap; // core-js workaround, pre-v3
  } catch (e) {}

  return false;
};

/***/ }),
/* 281 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(250);

var callBound = __webpack_require__(249);

var $WeakSet = GetIntrinsic('%WeakSet%', true);
var $setHas = callBound('WeakSet.prototype.has', true);

if ($setHas) {
  var $mapHas = callBound('WeakMap.prototype.has', true);

  module.exports = function isWeakSet(x) {
    if (!x || typeof x !== 'object') {
      return false;
    }

    try {
      $setHas(x, $setHas);

      if ($mapHas) {
        try {
          $mapHas(x, $mapHas);
        } catch (e) {
          return true;
        }
      }

      return x instanceof $WeakSet; // core-js workaround, pre-v3
    } catch (e) {}

    return false;
  };
} else {
  // eslint-disable-next-line no-unused-vars
  module.exports = function isWeakSet(x) {
    // `WeakSet` does not exist, or does not have a `has` method
    return false;
  };
}

/***/ }),
/* 282 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

/* eslint global-require: 0 */
// the code is structured this way so that bundlers can
// alias out `has-symbols` to `() => true` or `() => false` if your target
// environments' Symbol capabilities are known, and then use
// dead code elimination on the rest of this module.
//
// Similarly, `isarray` can be aliased to `Array.isArray` if
// available in all target environments.

var isArguments = __webpack_require__(246);

if (__webpack_require__(251)() || __webpack_require__(248)()) {
  var $iterator = Symbol.iterator; // Symbol is available natively or shammed
  // natively:
  //  - Chrome >= 38
  //  - Edge 12-14?, Edge >= 15 for sure
  //  - FF >= 36
  //  - Safari >= 9
  //  - node >= 0.12

  module.exports = function getIterator(iterable) {
    // alternatively, `iterable[$iterator]?.()`
    if (iterable != null && typeof iterable[$iterator] !== 'undefined') {
      return iterable[$iterator]();
    }

    if (isArguments(iterable)) {
      // arguments objects lack Symbol.iterator
      // - node 0.12
      return Array.prototype[$iterator].call(iterable);
    }
  };
} else {
  // Symbol is not available, native or shammed
  var isArray = __webpack_require__(268);

  var isString = __webpack_require__(271);

  var GetIntrinsic = __webpack_require__(250);

  var $Map = GetIntrinsic('%Map%', true);
  var $Set = GetIntrinsic('%Set%', true);

  var callBound = __webpack_require__(249);

  var $arrayPush = callBound('Array.prototype.push');
  var $charCodeAt = callBound('String.prototype.charCodeAt');
  var $stringSlice = callBound('String.prototype.slice');

  var advanceStringIndex = function advanceStringIndex(S, index) {
    var length = S.length;

    if (index + 1 >= length) {
      return index + 1;
    }

    var first = $charCodeAt(S, index);

    if (first < 0xD800 || first > 0xDBFF) {
      return index + 1;
    }

    var second = $charCodeAt(S, index + 1);

    if (second < 0xDC00 || second > 0xDFFF) {
      return index + 1;
    }

    return index + 2;
  };

  var getArrayIterator = function getArrayIterator(arraylike) {
    var i = 0;
    return {
      next: function next() {
        var done = i >= arraylike.length;
        var value;

        if (!done) {
          value = arraylike[i];
          i += 1;
        }

        return {
          done: done,
          value: value
        };
      }
    };
  };

  var getNonCollectionIterator = function getNonCollectionIterator(iterable, noPrimordialCollections) {
    if (isArray(iterable) || isArguments(iterable)) {
      return getArrayIterator(iterable);
    }

    if (isString(iterable)) {
      var i = 0;
      return {
        next: function next() {
          var nextIndex = advanceStringIndex(iterable, i);
          var value = $stringSlice(iterable, i, nextIndex);
          i = nextIndex;
          return {
            done: nextIndex > iterable.length,
            value: value
          };
        }
      };
    } // es6-shim and es-shims' es-map use a string "_es6-shim iterator_" property on different iterables, such as MapIterator.


    if (noPrimordialCollections && typeof iterable['_es6-shim iterator_'] !== 'undefined') {
      return iterable['_es6-shim iterator_']();
    }
  };

  if (!$Map && !$Set) {
    // the only language iterables are Array, String, arguments
    // - Safari <= 6.0
    // - Chrome < 38
    // - node < 0.12
    // - FF < 13
    // - IE < 11
    // - Edge < 11
    module.exports = function getIterator(iterable) {
      if (iterable != null) {
        return getNonCollectionIterator(iterable, true);
      }
    };
  } else {
    // either Map or Set are available, but Symbol is not
    // - es6-shim on an ES5 browser
    // - Safari 6.2 (maybe 6.1?)
    // - FF v[13, 36)
    // - IE 11
    // - Edge 11
    // - Safari v[6, 9)
    var isMap = __webpack_require__(278);

    var isSet = __webpack_require__(279); // Firefox >= 27, IE 11, Safari 6.2 - 9, Edge 11, es6-shim in older envs, all have forEach


    var $mapForEach = callBound('Map.prototype.forEach', true);
    var $setForEach = callBound('Set.prototype.forEach', true);

    if (typeof process === 'undefined' || !process.versions || !process.versions.node) {
      // "if is not node"
      // Firefox 17 - 26 has `.iterator()`, whose iterator `.next()` either
      // returns a value, or throws a StopIteration object. These browsers
      // do not have any other mechanism for iteration.
      var $mapIterator = callBound('Map.prototype.iterator', true);
      var $setIterator = callBound('Set.prototype.iterator', true);

      var getStopIterationIterator = function (iterator) {
        var done = false;
        return {
          next: function next() {
            try {
              return {
                done: done,
                value: done ? undefined : iterator.next()
              };
            } catch (e) {
              done = true;
              return {
                done: true,
                value: undefined
              };
            }
          }
        };
      };
    } // Firefox 27-35, and some older es6-shim versions, use a string "@@iterator" property
    // this returns a proper iterator object, so we should use it instead of forEach.
    // newer es6-shim versions use a string "_es6-shim iterator_" property.


    var $mapAtAtIterator = callBound('Map.prototype.@@iterator', true) || callBound('Map.prototype._es6-shim iterator_', true);
    var $setAtAtIterator = callBound('Set.prototype.@@iterator', true) || callBound('Set.prototype._es6-shim iterator_', true);

    var getCollectionIterator = function getCollectionIterator(iterable) {
      if (isMap(iterable)) {
        if ($mapIterator) {
          return getStopIterationIterator($mapIterator(iterable));
        }

        if ($mapAtAtIterator) {
          return $mapAtAtIterator(iterable);
        }

        if ($mapForEach) {
          var entries = [];
          $mapForEach(iterable, function (v, k) {
            $arrayPush(entries, [k, v]);
          });
          return getArrayIterator(entries);
        }
      }

      if (isSet(iterable)) {
        if ($setIterator) {
          return getStopIterationIterator($setIterator(iterable));
        }

        if ($setAtAtIterator) {
          return $setAtAtIterator(iterable);
        }

        if ($setForEach) {
          var values = [];
          $setForEach(iterable, function (v) {
            $arrayPush(values, v);
          });
          return getArrayIterator(values);
        }
      }
    };

    module.exports = function getIterator(iterable) {
      return getCollectionIterator(iterable) || getNonCollectionIterator(iterable);
    };
  }
}

/***/ }),
/* 283 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(250);

var callBound = __webpack_require__(249);

var inspect = __webpack_require__(284);

var $TypeError = GetIntrinsic('%TypeError%');
var $WeakMap = GetIntrinsic('%WeakMap%', true);
var $Map = GetIntrinsic('%Map%', true);
var $weakMapGet = callBound('WeakMap.prototype.get', true);
var $weakMapSet = callBound('WeakMap.prototype.set', true);
var $weakMapHas = callBound('WeakMap.prototype.has', true);
var $mapGet = callBound('Map.prototype.get', true);
var $mapSet = callBound('Map.prototype.set', true);
var $mapHas = callBound('Map.prototype.has', true);
/*
 * This function traverses the list returning the node corresponding to the
 * given key.
 *
 * That node is also moved to the head of the list, so that if it's accessed
 * again we don't need to traverse the whole list. By doing so, all the recently
 * used nodes can be accessed relatively quickly.
 */

var listGetNode = function (list, key) {
  // eslint-disable-line consistent-return
  for (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {
    if (curr.key === key) {
      prev.next = curr.next;
      curr.next = list.next;
      list.next = curr; // eslint-disable-line no-param-reassign

      return curr;
    }
  }
};

var listGet = function (objects, key) {
  var node = listGetNode(objects, key);
  return node && node.value;
};

var listSet = function (objects, key, value) {
  var node = listGetNode(objects, key);

  if (node) {
    node.value = value;
  } else {
    // Prepend the new node to the beginning of the list
    objects.next = {
      // eslint-disable-line no-param-reassign
      key: key,
      next: objects.next,
      value: value
    };
  }
};

var listHas = function (objects, key) {
  return !!listGetNode(objects, key);
};

module.exports = function getSideChannel() {
  var $wm;
  var $m;
  var $o;
  var channel = {
    assert: function (key) {
      if (!channel.has(key)) {
        throw new $TypeError('Side channel does not contain ' + inspect(key));
      }
    },
    get: function (key) {
      // eslint-disable-line consistent-return
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapGet($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapGet($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listGet($o, key);
        }
      }
    },
    has: function (key) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if ($wm) {
          return $weakMapHas($wm, key);
        }
      } else if ($Map) {
        if ($m) {
          return $mapHas($m, key);
        }
      } else {
        if ($o) {
          // eslint-disable-line no-lonely-if
          return listHas($o, key);
        }
      }

      return false;
    },
    set: function (key, value) {
      if ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {
        if (!$wm) {
          $wm = new $WeakMap();
        }

        $weakMapSet($wm, key, value);
      } else if ($Map) {
        if (!$m) {
          $m = new $Map();
        }

        $mapSet($m, key, value);
      } else {
        if (!$o) {
          /*
           * Initialize the linked list as an empty node, so that we don't have
           * to special-case handling of the first node: we can always refer to
           * it as (previous node).next, instead of something like (list).head
           */
          $o = {
            key: {},
            next: null
          };
        }

        listSet($o, key, value);
      }
    }
  };
  return channel;
};

/***/ }),
/* 284 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var hasMap = typeof Map === 'function' && Map.prototype;
var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;
var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;
var mapForEach = hasMap && Map.prototype.forEach;
var hasSet = typeof Set === 'function' && Set.prototype;
var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;
var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;
var setForEach = hasSet && Set.prototype.forEach;
var hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;
var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
var hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;
var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
var hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;
var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
var booleanValueOf = Boolean.prototype.valueOf;
var objectToString = Object.prototype.toString;
var functionToString = Function.prototype.toString;
var $match = String.prototype.match;
var $slice = String.prototype.slice;
var $replace = String.prototype.replace;
var $toUpperCase = String.prototype.toUpperCase;
var $toLowerCase = String.prototype.toLowerCase;
var $test = RegExp.prototype.test;
var $concat = Array.prototype.concat;
var $join = Array.prototype.join;
var $arrSlice = Array.prototype.slice;
var $floor = Math.floor;
var bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;
var gOPS = Object.getOwnPropertySymbols;
var symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;
var hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object'; // ie, `has-tostringtag/shams

var toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol') ? Symbol.toStringTag : null;
var isEnumerable = Object.prototype.propertyIsEnumerable;
var gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype // eslint-disable-line no-proto
? function (O) {
  return O.__proto__; // eslint-disable-line no-proto
} : null);

function addNumericSeparator(num, str) {
  if (num === Infinity || num === -Infinity || num !== num || num && num > -1000 && num < 1000 || $test.call(/e/, str)) {
    return str;
  }

  var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;

  if (typeof num === 'number') {
    var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)

    if (int !== num) {
      var intStr = String(int);
      var dec = $slice.call(str, intStr.length + 1);
      return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');
    }
  }

  return $replace.call(str, sepRegex, '$&_');
}

var utilInspect = __webpack_require__(285);

var inspectCustom = utilInspect.custom;
var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;

module.exports = function inspect_(obj, options, depth, seen) {
  var opts = options || {};

  if (has(opts, 'quoteStyle') && opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double') {
    throw new TypeError('option "quoteStyle" must be "single" or "double"');
  }

  if (has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number' ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
    throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
  }

  var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;

  if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {
    throw new TypeError('option "customInspect", if provided, must be `true`, `false`, or `\'symbol\'`');
  }

  if (has(opts, 'indent') && opts.indent !== null && opts.indent !== '\t' && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
    throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
  }

  if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {
    throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
  }

  var numericSeparator = opts.numericSeparator;

  if (typeof obj === 'undefined') {
    return 'undefined';
  }

  if (obj === null) {
    return 'null';
  }

  if (typeof obj === 'boolean') {
    return obj ? 'true' : 'false';
  }

  if (typeof obj === 'string') {
    return inspectString(obj, opts);
  }

  if (typeof obj === 'number') {
    if (obj === 0) {
      return Infinity / obj > 0 ? '0' : '-0';
    }

    var str = String(obj);
    return numericSeparator ? addNumericSeparator(obj, str) : str;
  }

  if (typeof obj === 'bigint') {
    var bigIntStr = String(obj) + 'n';
    return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
  }

  var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;

  if (typeof depth === 'undefined') {
    depth = 0;
  }

  if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {
    return isArray(obj) ? '[Array]' : '[Object]';
  }

  var indent = getIndent(opts, depth);

  if (typeof seen === 'undefined') {
    seen = [];
  } else if (indexOf(seen, obj) >= 0) {
    return '[Circular]';
  }

  function inspect(value, from, noIndent) {
    if (from) {
      seen = $arrSlice.call(seen);
      seen.push(from);
    }

    if (noIndent) {
      var newOpts = {
        depth: opts.depth
      };

      if (has(opts, 'quoteStyle')) {
        newOpts.quoteStyle = opts.quoteStyle;
      }

      return inspect_(value, newOpts, depth + 1, seen);
    }

    return inspect_(value, opts, depth + 1, seen);
  }

  if (typeof obj === 'function' && !isRegExp(obj)) {
    // in older engines, regexes are callable
    var name = nameOf(obj);
    var keys = arrObjKeys(obj, inspect);
    return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');
  }

  if (isSymbol(obj)) {
    var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, '$1') : symToString.call(obj);
    return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;
  }

  if (isElement(obj)) {
    var s = '<' + $toLowerCase.call(String(obj.nodeName));
    var attrs = obj.attributes || [];

    for (var i = 0; i < attrs.length; i++) {
      s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);
    }

    s += '>';

    if (obj.childNodes && obj.childNodes.length) {
      s += '...';
    }

    s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';
    return s;
  }

  if (isArray(obj)) {
    if (obj.length === 0) {
      return '[]';
    }

    var xs = arrObjKeys(obj, inspect);

    if (indent && !singleLineValues(xs)) {
      return '[' + indentedJoin(xs, indent) + ']';
    }

    return '[ ' + $join.call(xs, ', ') + ' ]';
  }

  if (isError(obj)) {
    var parts = arrObjKeys(obj, inspect);

    if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {
      return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';
    }

    if (parts.length === 0) {
      return '[' + String(obj) + ']';
    }

    return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';
  }

  if (typeof obj === 'object' && customInspect) {
    if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {
      return utilInspect(obj, {
        depth: maxDepth - depth
      });
    } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {
      return obj.inspect();
    }
  }

  if (isMap(obj)) {
    var mapParts = [];
    mapForEach.call(obj, function (value, key) {
      mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));
    });
    return collectionOf('Map', mapSize.call(obj), mapParts, indent);
  }

  if (isSet(obj)) {
    var setParts = [];
    setForEach.call(obj, function (value) {
      setParts.push(inspect(value, obj));
    });
    return collectionOf('Set', setSize.call(obj), setParts, indent);
  }

  if (isWeakMap(obj)) {
    return weakCollectionOf('WeakMap');
  }

  if (isWeakSet(obj)) {
    return weakCollectionOf('WeakSet');
  }

  if (isWeakRef(obj)) {
    return weakCollectionOf('WeakRef');
  }

  if (isNumber(obj)) {
    return markBoxed(inspect(Number(obj)));
  }

  if (isBigInt(obj)) {
    return markBoxed(inspect(bigIntValueOf.call(obj)));
  }

  if (isBoolean(obj)) {
    return markBoxed(booleanValueOf.call(obj));
  }

  if (isString(obj)) {
    return markBoxed(inspect(String(obj)));
  }

  if (!isDate(obj) && !isRegExp(obj)) {
    var ys = arrObjKeys(obj, inspect);
    var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
    var protoTag = obj instanceof Object ? '' : 'null prototype';
    var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';
    var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';
    var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');

    if (ys.length === 0) {
      return tag + '{}';
    }

    if (indent) {
      return tag + '{' + indentedJoin(ys, indent) + '}';
    }

    return tag + '{ ' + $join.call(ys, ', ') + ' }';
  }

  return String(obj);
};

function wrapQuotes(s, defaultStyle, opts) {
  var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '"' : "'";
  return quoteChar + s + quoteChar;
}

function quote(s) {
  return $replace.call(String(s), /"/g, '&quot;');
}

function isArray(obj) {
  return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}

function isDate(obj) {
  return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}

function isRegExp(obj) {
  return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}

function isError(obj) {
  return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}

function isString(obj) {
  return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}

function isNumber(obj) {
  return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
}

function isBoolean(obj) {
  return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj));
} // Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives


function isSymbol(obj) {
  if (hasShammedSymbols) {
    return obj && typeof obj === 'object' && obj instanceof Symbol;
  }

  if (typeof obj === 'symbol') {
    return true;
  }

  if (!obj || typeof obj !== 'object' || !symToString) {
    return false;
  }

  try {
    symToString.call(obj);
    return true;
  } catch (e) {}

  return false;
}

function isBigInt(obj) {
  if (!obj || typeof obj !== 'object' || !bigIntValueOf) {
    return false;
  }

  try {
    bigIntValueOf.call(obj);
    return true;
  } catch (e) {}

  return false;
}

var hasOwn = Object.prototype.hasOwnProperty || function (key) {
  return key in this;
};

function has(obj, key) {
  return hasOwn.call(obj, key);
}

function toStr(obj) {
  return objectToString.call(obj);
}

function nameOf(f) {
  if (f.name) {
    return f.name;
  }

  var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);

  if (m) {
    return m[1];
  }

  return null;
}

function indexOf(xs, x) {
  if (xs.indexOf) {
    return xs.indexOf(x);
  }

  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) {
      return i;
    }
  }

  return -1;
}

function isMap(x) {
  if (!mapSize || !x || typeof x !== 'object') {
    return false;
  }

  try {
    mapSize.call(x);

    try {
      setSize.call(x);
    } catch (s) {
      return true;
    }

    return x instanceof Map; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakMap(x) {
  if (!weakMapHas || !x || typeof x !== 'object') {
    return false;
  }

  try {
    weakMapHas.call(x, weakMapHas);

    try {
      weakSetHas.call(x, weakSetHas);
    } catch (s) {
      return true;
    }

    return x instanceof WeakMap; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakRef(x) {
  if (!weakRefDeref || !x || typeof x !== 'object') {
    return false;
  }

  try {
    weakRefDeref.call(x);
    return true;
  } catch (e) {}

  return false;
}

function isSet(x) {
  if (!setSize || !x || typeof x !== 'object') {
    return false;
  }

  try {
    setSize.call(x);

    try {
      mapSize.call(x);
    } catch (m) {
      return true;
    }

    return x instanceof Set; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isWeakSet(x) {
  if (!weakSetHas || !x || typeof x !== 'object') {
    return false;
  }

  try {
    weakSetHas.call(x, weakSetHas);

    try {
      weakMapHas.call(x, weakMapHas);
    } catch (s) {
      return true;
    }

    return x instanceof WeakSet; // core-js workaround, pre-v2.5.0
  } catch (e) {}

  return false;
}

function isElement(x) {
  if (!x || typeof x !== 'object') {
    return false;
  }

  if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {
    return true;
  }

  return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';
}

function inspectString(str, opts) {
  if (str.length > opts.maxStringLength) {
    var remaining = str.length - opts.maxStringLength;
    var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');
    return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
  } // eslint-disable-next-line no-control-regex


  var s = $replace.call($replace.call(str, /(['\\])/g, '\\$1'), /[\x00-\x1f]/g, lowbyte);
  return wrapQuotes(s, 'single', opts);
}

function lowbyte(c) {
  var n = c.charCodeAt(0);
  var x = {
    8: 'b',
    9: 't',
    10: 'n',
    12: 'f',
    13: 'r'
  }[n];

  if (x) {
    return '\\' + x;
  }

  return '\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));
}

function markBoxed(str) {
  return 'Object(' + str + ')';
}

function weakCollectionOf(type) {
  return type + ' { ? }';
}

function collectionOf(type, size, entries, indent) {
  var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');
  return type + ' (' + size + ') {' + joinedEntries + '}';
}

function singleLineValues(xs) {
  for (var i = 0; i < xs.length; i++) {
    if (indexOf(xs[i], '\n') >= 0) {
      return false;
    }
  }

  return true;
}

function getIndent(opts, depth) {
  var baseIndent;

  if (opts.indent === '\t') {
    baseIndent = '\t';
  } else if (typeof opts.indent === 'number' && opts.indent > 0) {
    baseIndent = $join.call(Array(opts.indent + 1), ' ');
  } else {
    return null;
  }

  return {
    base: baseIndent,
    prev: $join.call(Array(depth + 1), baseIndent)
  };
}

function indentedJoin(xs, indent) {
  if (xs.length === 0) {
    return '';
  }

  var lineJoiner = '\n' + indent.prev + indent.base;
  return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\n' + indent.prev;
}

function arrObjKeys(obj, inspect) {
  var isArr = isArray(obj);
  var xs = [];

  if (isArr) {
    xs.length = obj.length;

    for (var i = 0; i < obj.length; i++) {
      xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';
    }
  }

  var syms = typeof gOPS === 'function' ? gOPS(obj) : [];
  var symMap;

  if (hasShammedSymbols) {
    symMap = {};

    for (var k = 0; k < syms.length; k++) {
      symMap['$' + syms[k]] = syms[k];
    }
  }

  for (var key in obj) {
    // eslint-disable-line no-restricted-syntax
    if (!has(obj, key)) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue


    if (isArr && String(Number(key)) === key && key < obj.length) {
      continue;
    } // eslint-disable-line no-restricted-syntax, no-continue


    if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {
      // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section
      continue; // eslint-disable-line no-restricted-syntax, no-continue
    } else if ($test.call(/[^\w$]/, key)) {
      xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));
    } else {
      xs.push(key + ': ' + inspect(obj[key], obj));
    }
  }

  if (typeof gOPS === 'function') {
    for (var j = 0; j < syms.length; j++) {
      if (isEnumerable.call(obj, syms[j])) {
        xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));
      }
    }
  }

  return xs;
}

/***/ }),
/* 285 */
/***/ (function() {

/* (ignored) */

/***/ }),
/* 286 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var forEach = __webpack_require__(287);

var availableTypedArrays = __webpack_require__(289);

var callBound = __webpack_require__(249);

var gOPD = __webpack_require__(290);

var $toString = callBound('Object.prototype.toString');

var hasToStringTag = __webpack_require__(247)();

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    if (typeof g[typedArray] === 'function') {
      var arr = new g[typedArray]();

      if (Symbol.toStringTag in arr) {
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);

        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }

        toStrTags[typedArray] = descriptor.get;
      }
    }
  });
}

var tryTypedArrays = function tryAllTypedArrays(value) {
  var foundName = false;
  forEach(toStrTags, function (getter, typedArray) {
    if (!foundName) {
      try {
        var name = getter.call(value);

        if (name === typedArray) {
          foundName = name;
        }
      } catch (e) {}
    }
  });
  return foundName;
};

var isTypedArray = __webpack_require__(291);

module.exports = function whichTypedArray(value) {
  if (!isTypedArray(value)) {
    return false;
  }

  if (!hasToStringTag || !(Symbol.toStringTag in value)) {
    return $slice($toString(value), 8, -1);
  }

  return tryTypedArrays(value);
};

/***/ }),
/* 287 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var isCallable = __webpack_require__(288);

var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

var forEachArray = function forEachArray(array, iterator, receiver) {
  for (var i = 0, len = array.length; i < len; i++) {
    if (hasOwnProperty.call(array, i)) {
      if (receiver == null) {
        iterator(array[i], i, array);
      } else {
        iterator.call(receiver, array[i], i, array);
      }
    }
  }
};

var forEachString = function forEachString(string, iterator, receiver) {
  for (var i = 0, len = string.length; i < len; i++) {
    // no such thing as a sparse string.
    if (receiver == null) {
      iterator(string.charAt(i), i, string);
    } else {
      iterator.call(receiver, string.charAt(i), i, string);
    }
  }
};

var forEachObject = function forEachObject(object, iterator, receiver) {
  for (var k in object) {
    if (hasOwnProperty.call(object, k)) {
      if (receiver == null) {
        iterator(object[k], k, object);
      } else {
        iterator.call(receiver, object[k], k, object);
      }
    }
  }
};

var forEach = function forEach(list, iterator, thisArg) {
  if (!isCallable(iterator)) {
    throw new TypeError('iterator must be a function');
  }

  var receiver;

  if (arguments.length >= 3) {
    receiver = thisArg;
  }

  if (toStr.call(list) === '[object Array]') {
    forEachArray(list, iterator, receiver);
  } else if (typeof list === 'string') {
    forEachString(list, iterator, receiver);
  } else {
    forEachObject(list, iterator, receiver);
  }
};

module.exports = forEach;

/***/ }),
/* 288 */
/***/ (function(module) {

"use strict";


var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;

if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
  try {
    badArrayLike = Object.defineProperty({}, 'length', {
      get: function () {
        throw isCallableMarker;
      }
    });
    isCallableMarker = {}; // eslint-disable-next-line no-throw-literal

    reflectApply(function () {
      throw 42;
    }, null, badArrayLike);
  } catch (_) {
    if (_ !== isCallableMarker) {
      reflectApply = null;
    }
  }
} else {
  reflectApply = null;
}

var constructorRegex = /^\s*class\b/;

var isES6ClassFn = function isES6ClassFunction(value) {
  try {
    var fnStr = fnToStr.call(value);
    return constructorRegex.test(fnStr);
  } catch (e) {
    return false; // not a function
  }
};

var tryFunctionObject = function tryFunctionToStr(value) {
  try {
    if (isES6ClassFn(value)) {
      return false;
    }

    fnToStr.call(value);
    return true;
  } catch (e) {
    return false;
  }
};

var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11

var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10

var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

var isDDA = function isDocumentDotAll() {
  return false;
};

if (typeof document === 'object') {
  // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
  var all = document.all;

  if (toStr.call(all) === toStr.call(document.all)) {
    isDDA = function isDocumentDotAll(value) {
      /* globals document: false */
      // in IE 6-8, typeof document.all is "object" and it's truthy
      if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
        try {
          var str = toStr.call(value);
          return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
          || str === objectClass // IE 6-8
          ) && value('') == null; // eslint-disable-line eqeqeq
        } catch (e) {
          /**/
        }
      }

      return false;
    };
  }
}

module.exports = reflectApply ? function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }

  if (!value) {
    return false;
  }

  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }

  try {
    reflectApply(value, null, badArrayLike);
  } catch (e) {
    if (e !== isCallableMarker) {
      return false;
    }
  }

  return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
  if (isDDA(value)) {
    return true;
  }

  if (!value) {
    return false;
  }

  if (typeof value !== 'function' && typeof value !== 'object') {
    return false;
  }

  if (hasToStringTag) {
    return tryFunctionObject(value);
  }

  if (isES6ClassFn(value)) {
    return false;
  }

  var strClass = toStr.call(value);

  if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
    return false;
  }

  return tryFunctionObject(value);
};

/***/ }),
/* 289 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var possibleNames = ['BigInt64Array', 'BigUint64Array', 'Float32Array', 'Float64Array', 'Int16Array', 'Int32Array', 'Int8Array', 'Uint16Array', 'Uint32Array', 'Uint8Array', 'Uint8ClampedArray'];
var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;

module.exports = function availableTypedArrays() {
  var out = [];

  for (var i = 0; i < possibleNames.length; i++) {
    if (typeof g[possibleNames[i]] === 'function') {
      out[out.length] = possibleNames[i];
    }
  }

  return out;
};

/***/ }),
/* 290 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var GetIntrinsic = __webpack_require__(250);

var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}

module.exports = $gOPD;

/***/ }),
/* 291 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var forEach = __webpack_require__(287);

var availableTypedArrays = __webpack_require__(289);

var callBound = __webpack_require__(249);

var $toString = callBound('Object.prototype.toString');

var hasToStringTag = __webpack_require__(247)();

var gOPD = __webpack_require__(290);

var g = typeof globalThis === 'undefined' ? __webpack_require__.g : globalThis;
var typedArrays = availableTypedArrays();

var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
  for (var i = 0; i < array.length; i += 1) {
    if (array[i] === value) {
      return i;
    }
  }

  return -1;
};

var $slice = callBound('String.prototype.slice');
var toStrTags = {};
var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

if (hasToStringTag && gOPD && getPrototypeOf) {
  forEach(typedArrays, function (typedArray) {
    var arr = new g[typedArray]();

    if (Symbol.toStringTag in arr) {
      var proto = getPrototypeOf(arr);
      var descriptor = gOPD(proto, Symbol.toStringTag);

      if (!descriptor) {
        var superProto = getPrototypeOf(proto);
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }

      toStrTags[typedArray] = descriptor.get;
    }
  });
}

var tryTypedArrays = function tryAllTypedArrays(value) {
  var anyTrue = false;
  forEach(toStrTags, function (getter, typedArray) {
    if (!anyTrue) {
      try {
        anyTrue = getter.call(value) === typedArray;
      } catch (e) {
        /**/
      }
    }
  });
  return anyTrue;
};

module.exports = function isTypedArray(value) {
  if (!value || typeof value !== 'object') {
    return false;
  }

  if (!hasToStringTag || !(Symbol.toStringTag in value)) {
    var tag = $slice($toString(value), 8, -1);
    return $indexOf(typedArrays, tag) > -1;
  }

  if (!gOPD) {
    return false;
  }

  return tryTypedArrays(value);
};

/***/ }),
/* 292 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var defineProperties = __webpack_require__(257);

var callBind = __webpack_require__(255);

var implementation = __webpack_require__(293);

var getPolyfill = __webpack_require__(294);

var shim = __webpack_require__(295);

var polyfill = callBind.apply(getPolyfill()); // eslint-disable-next-line no-unused-vars

var bound = function assign(target, source1) {
  return polyfill(Object, arguments);
};

defineProperties(bound, {
  getPolyfill: getPolyfill,
  implementation: implementation,
  shim: shim
});
module.exports = bound;

/***/ }),
/* 293 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
 // modified from https://github.com/es-shims/es6-shim

var objectKeys = __webpack_require__(243);

var hasSymbols = __webpack_require__(248)();

var callBound = __webpack_require__(249);

var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null; // eslint-disable-next-line no-unused-vars

module.exports = function assign(target, source1) {
  if (target == null) {
    throw new TypeError('target must be an object');
  }

  var to = toObject(target); // step 1

  if (arguments.length === 1) {
    return to; // step 2
  }

  for (var s = 1; s < arguments.length; ++s) {
    var from = toObject(arguments[s]); // step 3.a.i
    // step 3.a.ii:

    var keys = objectKeys(from);
    var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);

    if (getSymbols) {
      var syms = getSymbols(from);

      for (var j = 0; j < syms.length; ++j) {
        var key = syms[j];

        if ($propIsEnumerable(from, key)) {
          $push(keys, key);
        }
      }
    } // step 3.a.iii:


    for (var i = 0; i < keys.length; ++i) {
      var nextKey = keys[i];

      if ($propIsEnumerable(from, nextKey)) {
        // step 3.a.iii.2
        var propValue = from[nextKey]; // step 3.a.iii.2.a

        to[nextKey] = propValue; // step 3.a.iii.2.b
      }
    }
  }

  return to; // step 4
};

/***/ }),
/* 294 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(293);

var lacksProperEnumerationOrder = function () {
  if (!Object.assign) {
    return false;
  }
  /*
   * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
   * note: this does not detect the bug unless there's 20 characters
   */


  var str = 'abcdefghijklmnopqrst';
  var letters = str.split('');
  var map = {};

  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }

  var obj = Object.assign({}, map);
  var actual = '';

  for (var k in obj) {
    actual += k;
  }

  return str !== actual;
};

var assignHasPendingExceptions = function () {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  /*
   * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
   * which is 72% slower than our shim, and Firefox 40's native implementation.
   */


  var thrower = Object.preventExtensions({
    1: 2
  });

  try {
    Object.assign(thrower, 'xy');
  } catch (e) {
    return thrower[1] === 'y';
  }

  return false;
};

module.exports = function getPolyfill() {
  if (!Object.assign) {
    return implementation;
  }

  if (lacksProperEnumerationOrder()) {
    return implementation;
  }

  if (assignHasPendingExceptions()) {
    return implementation;
  }

  return Object.assign;
};

/***/ }),
/* 295 */
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(257);

var getPolyfill = __webpack_require__(294);

module.exports = function shimAssign() {
  var polyfill = getPolyfill();
  define(Object, {
    assign: polyfill
  }, {
    assign: function () {
      return Object.assign !== polyfill;
    }
  });
  return polyfill;
};

/***/ }),
/* 296 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addCommonRuntimeFns": function() { return /* binding */ addCommonRuntimeFns; }
/* harmony export */ });
/* harmony import */ var _extensions_rendering_style__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(297);

var extProcessors = {};
extProcessors[_extensions_rendering_style__WEBPACK_IMPORTED_MODULE_0__["default"].extURL] = _extensions_rendering_style__WEBPACK_IMPORTED_MODULE_0__["default"].processExtension;
function addCommonRuntimeFns(ns) {
  var self = ns;
  /**
   *  Processes the extensions on either lfNode, or lfNode[lfFieldName], if
   *  lfFieldName is provided.  Only the extensions for which processors
   *  are written (in the "extensions" sub-directory) are considered.
   * @param lfNode the node in the LFormsData structure on which the information
   *  from the extension will be stored.
   * @param lfFieldName (optional).  Sometimes the extension information is on a
   *  sub-node, (e.g. 'obj_text') in which case this should be the field for
   *  retrieving that sub-node.
   */

  self.processExtensions = function (lfNode, lfFieldName) {
    var fieldData = lfFieldName ? lfNode[lfFieldName] : lfNode;

    if (fieldData) {
      var extensions = fieldData.extension;

      if (extensions) {
        for (var i = 0, len = extensions.length; i < len; ++i) {
          var extData = extensions[i];
          var extURL = extData.url;
          var processor = extProcessors[extURL];
          if (processor) processor(lfNode, lfFieldName, extData);
        }
      }
    }
  };
}

/***/ }),
/* 297 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var extURL = 'http://hl7.org/fhir/StructureDefinition/rendering-style';
/**
 *  A generic API for processing an extension found on some node in the
 *  Questionnaire structure being imported.
 *  (The parameter list will likely get more complicated in the future.)
 * @param lfNode the node in the LFormsData structure on which the information
 *  from the extension will be stored.
 * @param fieldName the field name  on which the extension was found (e.g.
 *  'item' or 'title').  This forms part of the field name on lfNode where the
 *  data from the extension will be stored.
 * @param extNode the extension's structure with its data.
 */

function processExtension(lfNode, fieldName, extNode) {
  var css = extNode.valueString;
  if (css) lfNode['_' + fieldName + 'CSS'] = css;
}

/* harmony default export */ __webpack_exports__["default"] = ({
  extURL: extURL,
  processExtension: processExtension
});

/***/ }),
/* 298 */
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ExpressionProcessor": function() { return /* binding */ ExpressionProcessor; }
/* harmony export */ });
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_copy__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(242);
/* harmony import */ var deep_equal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deep_equal__WEBPACK_IMPORTED_MODULE_1__);
// Processes FHIR Expression Extensions
// There are three types of expressions: FHIRPath, x-fhir-query (to a FHIR
// server), and CQL (but we do not yet support CQL).
// Various extensions have an Expression as a value, such as variable,
// initialExpression, calculatedExpression, and answerExpression.  When the
// Expression contains a name, that creates a variable which can be used by
// other Expressions defined either on the same item or a child item.
//
// The general processing pattern is depth-first traversal of the "tree" of the
// Questionnaire's items, and while we go through the expressions we keep track
// of whether a field has changed and whether a variable has changed.  If there
// are any changes, we traverse the tree again, but if the only things that
// changed were variables, then we only have to traverse the parts of the tree
// for which those variables are in scope.
//
// A further complication is that x-fhir-query Expressions require an
// asynchronous call.  So, after each traversal, we have to wait for those to
// complete before starting the next traversal (if one is needed).  This is also
// why the main function, runCalculations, returns a promise that resolves
// when the expression run has been completed.
//
// Also, because there is possibility of asynchronous queries, we have to handle
// the fact that runCalculations might get called again while before the first
// call has finished.
let ExpressionProcessor;



(function () {
  "use strict"; // A class whose instances handle the running of FHIR expressions.

  /**
   *   Constructor.
   *  @param lfData an instance of LForms.LFormsData.  The _fhir attribute
   *   should be set before this is called.
   */

  ExpressionProcessor = function (lfData) {
    // A cache of x-fhir-query URIs to results
    this._queryCache = {}; // An array of pending x-fhir-query results

    this._pendingQueries = []; // A hash of calculated values, where the keys are the part of item_.elememntId
    // minus the final repetition number (so it is shared by instances of
    // repeating fields).

    this._calculatedValues = {}; // A hash of item._elementId values to "repetition key" values which can be used as
    // keys in this._calcualtedValues.

    this._repetitionKeys = {}; // Keeps track of whether a request to run the calculations has come in
    // while we were already busy.

    this._pendingRun = false; // The promise returned by runCalculations, when a run is active.

    this._currentRunPromise = undefined;
    this._lfData = lfData;
    if (!lfData._fhir) throw new Error('lfData._fhir should be set');
    this._fhir = lfData._fhir;
    this._compiledExpressions = {};
  };

  ExpressionProcessor.prototype = {
    /**
     *   Runs the FHIR expressions in the form.  This the main function in this
     *   module.
     *  @param includeInitialExpr whether to include the "initialExpression"
     *   expressions (which should only be run once, after asynchronous loads
     *   from questionnaire-launchContext have been completed).
     *  @return a Promise that resolves when the expressions have been run, and
     *   there are no pending runs left to do.
     */
    runCalculations: function (includeInitialExpr) {
      // Defer running calculations while we are waiting for earlier runs to
      // finish.
      if (this._currentRunPromise) // then we will just return that promise
        this._pendingRun = true; // so we know to run them when we can
      else {
        this._pendingRun = false; // clear this because we are running them now

        this._runStart = new Date(); // Create an export of Questionnaire for the %questionnaire variable in
        // FHIRPath.  We only need to do this once per form.

        var lfData = this._lfData;

        if (!lfData._fhirVariables.questionnaire) {
          lfData._fhirVariables.questionnaire = this._fhir.SDC.convertLFormsToQuestionnaire(lfData);
        }

        if (!this._linkIdToQItem) {
          this._linkIdToQItem = {};

          this._addToLinkIdToQItemMap(lfData._fhirVariables.questionnaire.item, this._linkIdToQItem);
        }

        this._regenerateQuestionnaireResp();

        self = this;
        this._currentRunPromise = this._asyncRunCalculations(includeInitialExpr, false).then(() => {
          // At this point, every promise for the pending queries has been
          // resolved, and we are done.
          console.log("Ran expressions in " + (new Date() - self._runStart) + " ms");
          if (!self._firstExpressionRunComplete) // if this is the first run
            self._firstExpressionRunComplete = true;
          self._currentRunPromise = undefined;

          if (self._pendingRun) {
            return self.runCalculations(false); // will set self._currentRunPromise again
          }
        }, failureReason => {
          console.log("Run of expressions failed; reason follows");
          console.log(failureReason);
          self._currentRunPromise = undefined;
          self._pendingRun = false;
          self._pendingQueries = []; // reset

          throw failureReason;
        });
      }
      return this._currentRunPromise;
    },

    /**
     *  Waits for any pending queries.
     * @return a Promise the resolves when everything is finished, including any
     *  pending re-run request.  The returned promise will be rejected if something
     *  goes wrong.
     * @return the same map about changes as in _evaluateExpressions.
     */
    _handlePendingQueries: function () {
      const self = this;
      return Promise.allSettled(this._pendingQueries).then(function (results) {
        self._pendingQueries = []; // reset

        var varsChanged = false,
            fieldsChanged = false;

        for (var i = 0, len = results.length; (!varsChanged || !fieldsChanged) && i < len; ++i) {
          var changes = results[i].value;

          if (changes) {
            varsChanged = varsChanged || changes.variables;
            fieldsChanged = fieldsChanged || changes.fields;
          } else if (results[i].status == 'rejected') return Promise.reject(results[i].reason);
        }

        return {
          fields: fieldsChanged,
          variables: varsChanged
        };
      });
    },

    /**
     *  This is conceptually a part of runCalculations, but it is this part of
     *  it that might need to call itself if fields or variables update.
     *  The basic algorithm is a depth-first traversal of the items to run their
     *  expressions.  Some of those might be asynchronous (e.g. x-fhir-query
     *  variables), so we wait for those to complete before looking at what has
     *  changed and deciding whether to run the expressions again.
     * @param includeInitialExpr whether to include the "initialExpression"
     *  expressions (which should only be run once, after asynchronous loads
     *  from questionnaire-launchContext have been completed).
     * @param changesByVarsOnly whether to run all field expressions, or just the ones
     *  that are likely to have been affected by changes from variable expressions.
     * @return a promise that resolves when all Expressions which needed to be
     *  processed have been processed and the values have stablized.
     */
    _asyncRunCalculations: function (includeInitialExpr, changesByVarsOnly) {
      const self = this;
      const lfData = this._lfData;
      var changes = null; // data about what the calculations changed

      changes = this._evaluateExpressions(lfData, includeInitialExpr, changesByVarsOnly); // Wait for any asynchronous queries to complete

      return this._handlePendingQueries().then(function (queryChanges) {
        // Two types of reported changes are possible -- variables and field values
        let varsChanged = changes.variables || queryChanges.variables;
        let fieldsChanged = changes.fields || queryChanges.fields;

        if (varsChanged || fieldsChanged) {
          // Run again
          if (fieldsChanged) self._regenerateQuestionnaireResp();
          let onlyVarsChanged = !fieldsChanged;
          return self._asyncRunCalculations(includeInitialExpr, onlyVarsChanged);
        }
      });
    },

    /**
     *  Updates the value of an item's FHIR variable.  If the variable value has changed,
     *  item._varChanged will be set to true.
     * @param item the item on which the variable is defined
     * @param varName the name of the variable
     * @param newVal the new value of the variable.
     * @return whether the value changed.
     */
    _updateItemVariable: function (item, varName, newVal) {
      var oldVal = item._fhirVariables[varName];
      item._fhirVariables[varName] = newVal;

      if (!deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(oldVal, newVal)) {
        item._varChanged = true; // flag for re-running expressions.
      }

      return item._varChanged;
    },

    /**
     *  Evaluates the expressions for a given item.
     * @param item an LFormsData or item from LFormsData.
     * @param includeInitialExpr whether or not to run expressions from
     *  initialExpression extensions (which should only be run when the form is
     *  loaded).
     * @param changesByVarsOnly whether to run all field expressions, or just the ones
     *  that are likely to have been affected by changes from variable expressions.
     * @return a map with two fields, "variables" and "fields", which will be
     *  present and set to true if the evaluation changed variables (including
     *  implicit variables created by named expressions of some other
     *  non-variable type) or field values, respectively.
     */
    _evaluateExpressions: function (item, includeInitialExpr, changesByVarsOnly) {
      var rtn = {}; // If changesByVarsOnly, for any item that has _varChanged set, we run any field
      // expressions that are within that group (or item).

      if (changesByVarsOnly && item.items && item._varChanged) {
        item._varChanged = false; // clear flag

        changesByVarsOnly = false; // clear it, so we process this and all child items
      }

      if (!changesByVarsOnly) {
        // process this and all child items
        item._varChanged = false; // clear flag in case it was set

        var fhirExt = item._fhirExt;

        if (fhirExt) {
          var sdc = this._fhir.SDC;
          var exts = item._exprExtensions;

          if (exts) {
            var fieldChanged = false;
            var self = this;

            for (let i = 0, len = exts.length; i < len; ++i) {
              let ext = exts[i]; // Skip initialExpressions if we are not including those.

              let isInitialExp = ext.url == sdc.fhirExtInitialExp;

              if (includeInitialExpr || !isInitialExp) {
                let isCalcExp = ext.url == sdc.fhirExtCalculatedExp; // We only run initialExpression or calculatedExpression
                // on one of the repeating items of the repeating group (the
                // last one, because there is a flag to mark the last one).

                if ((isCalcExp || isInitialExp) && item._questionRepeatable && !item._lastRepeatingItem) continue; // skip to next expression extension for this item
                // Skip calculated expressions of editable fields for which the user has
                // edited the value.
                // Compare the item.value to the last calculated value (if any).  If
                // they differ, then the user has edited the field, and in that case we
                // skip setting the value and halt further calculations for the field.

                var prevCalcVals = this._calculatedValues[this._getRepetitionKey(item)];

                let currentVals;

                if (isCalcExp && !item._userModifiedCalculatedValue && prevCalcVals) {
                  // Get the current values for the item, which might be
                  // repeating.
                  currentVals = this._lfData.getItemValues(item);

                  if (!this._equalAnswers(prevCalcVals, currentVals) && !item._answerListReset) {
                    item._userModifiedCalculatedValue = true;
                  }
                }

                if (!isCalcExp || !item._userModifiedCalculatedValue) {
                  let varName = ext.valueExpression.name; // i.e., a variable name

                  var itemVars;
                  if (varName) itemVars = this._getItemVariables(item); // creates item._fhirVariables if necessary

                  var oldVal;
                  let newVal;
                  var updateValue = false;

                  if (ext.valueExpression.language == "text/fhirpath") {
                    if (varName) {
                      // Temporarily delete the old value, so we don't have
                      // circular references.
                      oldVal = itemVars[varName];
                      delete itemVars[varName];
                    }

                    newVal = this._evaluateFHIRPath(item, ext.valueExpression.expression);
                    updateValue = true;
                    if (varName) itemVars[varName] = oldVal; // update handled below
                  } else if (ext.valueExpression.language == "application/x-fhir-query") {
                    let queryURL = ext.valueExpression.expression; // The expression might have embedded FHIRPath in the URI, inside {{...}}
                    // Use "undefinedExprVal" to keep track of whether one of
                    // the embedded FHIRPath expressions returns undefined (or
                    // null).

                    let undefinedExprVal = false;
                    queryURL = queryURL.replace(/\{\{([^}]+)\}\}/g, function (match, fpExp) {
                      // Replace the FHIRPath with the evaluated expressions
                      let result = self._evaluateFHIRPath(item, fpExp)[0];

                      if (result === null || result === undefined) undefinedExprVal = true; // i.e., URL likely not usable

                      return undefinedExprVal ? '' : '' + result;
                    });
                    if (!item._currentFhirQueryURLs) item._currentFhirQueryURLs = {};
                    let oldQueryURL = item._currentFhirQueryURLs[varName]; // If queryURL is not a new value, we don't need to do anything

                    if (queryURL !== oldQueryURL) {
                      item._currentFhirQueryURLs[varName] = queryURL;

                      if (undefinedExprVal) {
                        newVal = undefined;
                        updateValue = true;
                      } else {
                        // Look for a cached result
                        if (this._queryCache.hasOwnProperty(queryURL)) {
                          newVal = this._queryCache[queryURL];
                          updateValue = true;
                        } else {
                          // query not cached
                          let fetchPromise = this._fetch(queryURL); // Store the promise that handles the response. We
                          // will have to wait for it later.


                          this._pendingQueries.push(fetchPromise.then(function (parsedJSON) {
                            newVal = self._queryCache[queryURL] = parsedJSON;
                          }, function fail(e) {
                            console.error("Unable to load FHIR data from " + queryURL);
                          }).then(function () {
                            // Update the item with the fetched value, and
                            // update the variable if there was a name defined.
                            var fChanged = self._updateItemFromExp(item, ext.url, varName, newVal, isCalcExp, currentVals);

                            if (varName) {
                              var vChanged = self._updateItemVariable(item, varName, newVal);
                            }

                            if (item._answerListReset) item._answerListReset = false;
                            return {
                              fields: fChanged,
                              variables: vChanged
                            };
                          }));
                        }
                      }
                    }
                  } // else CQL (TBD)


                  if (updateValue) {
                    // Update the item with the fetched value, and
                    // update the variable if there was a name defined.
                    var fChanged = this._updateItemFromExp(item, ext.url, varName, newVal, isCalcExp, currentVals);

                    fieldChanged = fieldChanged || fChanged;
                    if (varName) this._updateItemVariable(item, varName, newVal);
                  }
                }
              }
            }

            if (item._answerListReset) item._answerListReset = false;
            rtn = {
              fields: fieldChanged,
              variables: item._varChanged
            };
          }
        }
      } // Process child items


      if (item.items) {
        var childChanges;
        var childItems = item.items;

        for (var j = 0; j < childItems.length; ++j) {
          // childItem.length can change as we process expressions
          // Note:  We need to process all the child items; we cannot do an
          // early loop exit based on rtn.
          childChanges = this._evaluateExpressions(item.items[j], includeInitialExpr, changesByVarsOnly);
          if (childChanges.fields) rtn.fields = true;
          if (childChanges.variables) rtn.variables = true;
        }
      }

      return rtn;
    },

    /**
     *  Regenerates the QuestionnaireResponse resource and the map from
     *  LFormsData _elementIDs to items in the QuestionnaireResponse.
     */
    _regenerateQuestionnaireResp: function () {
      var questResp = this._fhir.SDC.convertLFormsToQuestionnaireResponse(this._lfData);

      if (!questResp) {
        throw new Error("Invalid data. Cannot generate a QuestionnaireResponse resource.");
      }

      this._lfData._fhirVariables.resource = questResp;
      this._elemIDToQRItem = this._createIDtoQRItemMap(questResp);
    },

    /**
     *  Returns the nearest ancestor of item (or item itelf) that has
     *  _fhirVariables defined.
     * @param item either an LFormsData or an item from an LFormsData.
     */
    _itemWithVars: function (item) {
      var itemWithVars = item;

      while (!itemWithVars._fhirVariables) itemWithVars = itemWithVars._parentItem; // should terminate at lfData


      return itemWithVars;
    },

    /**
     *  Gets or creates if not yet initialized, the item's _fhirVariables
     *  map (storing its variable values).  This should not be called until it is
     *  known that the item should have a _fhirVariables map.
     * @param item either an LFormsData or an item from an LFormsData.
     * @return the item's _fhirVariables map
     */
    _getItemVariables: function (item) {
      var rtn = item._fhirVariables;

      if (!rtn) {
        // Create a hash for variables that will have access to
        // variables defined higher up in the tree.
        rtn = item._fhirVariables = Object.create(this._itemWithVars(item)._fhirVariables);
      }

      return rtn;
    },

    /**
     *  Fetches an x-fhir-query URL.
     * @param queryURL the URL (possibly relative) to fetch.
     * @return a Promise that resolves to the (parsed) JSON response.
     */
    _fetch: function (queryURL) {
      var fetchPromise; // If the queryURL is a relative URL, then if there is a FHIR
      // context (set via LForms.Util.setFHIRContext), use that to send
      // the query; otherwise just use fetch.
      // Also, set the format to JSON.

      queryURL += (queryURL.indexOf('?') > 0 ? '&' : '?') + '_format=json';

      if (!/^https?:/.test(queryURL) && LForms.fhirContext?.client) {
        fetchPromise = LForms.fhirContext.client.request(queryURL);
      } else {
        fetchPromise = fetch(queryURL).then(function (response) {
          return response.json();
        });
      }

      return fetchPromise;
    },

    /**
     *  Updates an item's data following the run of an expression.
     * @param item either an LFormsData or an item from an LFormsData.
     * @param expURL the URL of the expression
     * @param varName variable name from the expression (if any)
     * @param newVal the new value of the variable (if any)
     * @param isCalcExp whether the expression was a calculated expression.
     *  This could be detected from expURL, but the caller already knows it.
     * @param currentVals (optional) the current values of item, if known
     * @return true if the field value changed
     */
    _updateItemFromExp(item, expURL, varName, newVal, isCalcExp, currentVals) {
      var fieldChanged = false;
      var sdc = this._fhir.SDC;

      if (isCalcExp || expURL != sdc.fhirExtVariable) {
        if (expURL == sdc.fhirExtAnswerExp) fieldChanged = this._setItemListFromFHIRPath(item, newVal);else if (expURL == sdc.fhirExtEnableWhenExp) {
          // The new value should be a boolean.  Coerce it to a boolean, and
          // report a warning if it was not a boolean.
          var actualNewVal = newVal[0];
          newVal = !!actualNewVal;

          if (newVal !== actualNewVal) {
            LForms.Util.showWarning('An expression from enableWhenExpression ' + 'did not resolve to a Boolean as required', item);
          }

          if (varName) {
            // if there is a variable name defined, a change in the value matters
            var oldVal = !!item._enableWhenExpVal; // _enableWhenExpVal could be undefined

            fieldChanged = oldVal != newVal;
          }

          item._enableWhenExpVal = newVal;
        } else // else initial or calculated expression
          fieldChanged = this._setItemValueFromFHIRPath(item, newVal, isCalcExp, currentVals);
      }

      return fieldChanged;
    },

    /**
     *  Evaluates the given FHIRPath expression defined in an extension on the
     *  given item.
     * @param item either an LFormsData or an item from an LFormsData.
     * @param expression the FHIRPath to evaluate with the context of item's
     *  equivalent node in the QuestionnaireResponse.
     * @returns the result of the expression.
     */
    _evaluateFHIRPath: function (item, expression) {
      var fhirPathVal; // Find the item-level fhirpathVars

      var itemVars = this._itemWithVars(item)._fhirVariables;

      try {
        // We need to flatten the fhirVariables chain into a simple hash of key/
        // value pairs.
        var fVars = {};

        for (var k in itemVars) fVars[k] = itemVars[k];

        let contextNode, base;

        if (item._elementId) {
          contextNode = this._elemIDToQRItem[item._elementId];
          contextNode ||= {}; // the item might not be present in the QR if there is no value

          base = 'QuestionnaireResponse.item';
          fVars['qitem'] = this._linkIdToQItem[item.linkId];
        } else {
          contextNode = this._lfData._fhirVariables.resource;
        }

        var compiledExpr = this._compiledExpressions[expression];

        if (!compiledExpr) {
          if (base) expression = {
            base,
            expression
          };
          compiledExpr = this._compiledExpressions[expression] = this._fhir.fhirpath.compile(expression, this._fhir.fhirpathModel);
        }

        fhirPathVal = compiledExpr(contextNode, fVars);
      } catch (e) {
        // Sometimes an expression will rely on data that hasn't been filled in yet.
        console.log(e);
      }

      return fhirPathVal;
    },

    /**
     *  Recursively adds items to a hash from the linkId of each item to the
     *  corresponding Questionnaire item.
     * @param qItems the items to be added the map
     * @param map the map to which entries will be added.
     */
    _addToLinkIdToQItemMap: function (qItems, map) {
      var qItem;

      if (qItems) {
        for (var i = 0, len = qItems.length; i < len; ++i) {
          qItem = qItems[i];
          map[qItem.linkId] = qItem;
          if (qItem.item) this._addToLinkIdToQItemMap(qItem.item, map);
        }
      }
    },

    /**
     *  Returns a hash from the LForms _elementId of each item to the
     *  corresponding QuestionnaireResponse item.
     * @param qr the QuestionnaireResponse corresponding to the current
     * LFormsData.
     */
    _createIDtoQRItemMap: function (qr) {
      var map = {};

      this._addToIDtoQRItemMap(this._lfData, qr, map);

      return map;
    },

    /**
     *  Adds to the map from LFormsData items to QuestionnaireResponse items and
     *  returns the number of items added.
     * @param lfItem an LFormsData, or an item within it.
     * @param qrItem the corresponding QuestionnaireResponse or an item within
     * it.
     * @param map the map to which entries will be added.
     * @return the number of items added to the map.
     */
    _addToIDtoQRItemMap: function (lfItem, qrItem, map) {
      var added = 0;

      if (lfItem.linkId === qrItem.linkId) {
        if (lfItem.items) {
          // lfItem.items might contain items that don't have values, but
          // qrItem.item will not, so we need to skip the blank items.
          //
          // Also, for a repeating question, there will be multiple answers on an
          // qrItem.item, but repeats of the item in lfItem.items with one answer
          // each, unless answerCardinality is '*' (list items), in which case
          // there can be multiple answers per lforms item.
          // LForms does not currently support items that contain both answers
          // and child items, but I am trying to accomodate that here for the
          // future.
          if (qrItem && qrItem.item && qrItem.item.length > 0) {
            var lfItems = lfItem.items,
                qrItems = qrItem.item;
            var numLFItems = lfItems.length;

            for (var i = 0, qrI = 0, len = qrItems.length; qrI < len && i < numLFItems; ++qrI) {
              // Answers are repeated in QR, but items are repeated in LForms
              var qrIthItem = qrItems[qrI];
              var lfIthItem = lfItems[i];

              if (!qrIthItem.answer) {
                // process item anyway to handle child items with data
                let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);

                if (newlyAdded === 0) {
                  // lfIthItem was blank, so qrIthItem must be for a following
                  // item.
                  --qrI; // so we try qrIthItem with the next lfIthItem
                } else added += newlyAdded;

                ++i;
              } else {
                // there are answers on the qrIthItem item
                var numAnswers = qrIthItem.answer ? qrIthItem.answer.length : 0;

                for (var a = 0; a < numAnswers; ++i) {
                  if (i >= numLFItems) throw new Error('Logic error in _addToIDtoQRITemMap; ran out of lfItems');
                  let lfIthItem = lfItems[i];

                  let newlyAdded = this._addToIDtoQRItemMap(lfIthItem, qrIthItem, map);

                  if (newlyAdded != 0) {
                    // lfItems[i] was not blank
                    if (Array.isArray(lfIthItem.value)) a += lfIthItem.value.length;else a += 1;
                  }

                  added += newlyAdded;
                }
              }
            }
          }
        } // this item has _elementId and has a value


        if (lfItem._elementId && (added || lfItem.value !== undefined && lfItem.value !== null && lfItem.value !== "")) {
          if (!qrItem) {
            // if there is data in lfItem, there should be a qrItem
            throw new Error('Logic error in _addToIDtoQRItemMap; missing qrItem');
          } else {
            map[lfItem._elementId] = qrItem;
            added += 1;
          }
        }
      }

      return added;
    },

    /**
     *  Assigns the given list result to the item.  If the list has changed, the
     *  field is cleared.
     * @param list an array of list items computed from a FHIRPath expression.
     * @return true if the list changed
     */
    _setItemListFromFHIRPath: function (item, list) {
      let currentList = item.answers;
      let hasCurrentList = !!currentList && Array.isArray(currentList);
      let listHasData = !!list && Array.isArray(list);
      let changed = hasCurrentList != listHasData || listHasData && list.length != currentList.length;
      let newList = []; // a reformatted version of "list"

      const scoreURI = this._fhir.SDC.fhirExtUrlOptionScore;

      if (listHasData) {
        // list should be an array of any item type, including Coding.
        // (In R5, FHIR will start suppoing lists of types other than Coding.)
        for (let i = 0, len = list.length; i < len; ++i) {
          let entry = list[i];
          let newEntry = newList[i] = {};

          switch (item.dataType) {
            case "CNE":
            case "CWE":
              // Assume type "object" means a coding, and that otherwise what we have
              // is something useable as display text.
              if (typeof entry === 'object') {
                let code = entry.code;
                if (code !== undefined) newEntry.code = code;
                let display = entry.display;
                if (display !== undefined) newEntry.text = display;
                let system = entry.system;
                if (system !== undefined) newEntry.system = system; // A Coding can have the extension for scores

                let scoreExt = item._fhirExt && item._fhirExt[scoreURI];
                if (scoreExt) newEntry.score = scoreExt[0].valueDecimal;
              } else newEntry.text = '' + entry;

              if (!changed) {
                changed = !hasCurrentList || !this._lfData._objectEqual(newEntry, currentList[i]);
              }

              break;

            case "ST":
            case "DT":
            case "TM":
              if (typeof entry === 'string') {
                newEntry.text = entry;

                if (!changed) {
                  changed = !hasCurrentList || !this._lfData._objectEqual(newEntry, currentList[i]);
                }
              }

              break;

            case "INT":
              if (typeof entry === 'number' || typeof entry === 'string') {
                newEntry.text = parseInt(entry);

                if (!changed) {
                  changed = !hasCurrentList || !this._lfData._objectEqual(newEntry, currentList[i]);
                }
              }

              break;
          }
        }
      }

      if (changed) {
        // reset the answer list
        item.answers = newList; // reset item.value
        // 1) when there are user saved data from QuestionnaireResponse and
        //    the initial loading (and fhirpath expressions) have run once
        // 2) when there are no user saved data.

        if (this._lfData.hasSavedData && this._firstExpressionRunComplete || !this._lfData.hasSavedData) {
          // reset the previously selected answer (by user or by fhirpath expression)
          item.value = null; // reset the cached calculated value

          this._calculatedValues[this._getRepetitionKey(item)] = []; // user selected/typed value will be reset when the answer list has changed

          item._userModifiedCalculatedValue = false;
        }

        item._hasAnswerList = true;

        this._lfData._updateAutocompOptions(item, true);

        this._lfData._resetItemValueWithAnswers(item);

        item._answerListReset = true;
      }

      return changed;
    },

    /**
     *  Assigns the given FHIRPath result to the given item.
     * @param item the item from the LFormsData object that is receiving the new
     *  value.
     * @param fhirPathRes the result of a FHIRPath evaluation.
     * @param isCalcExp whether this is from a calculated expression, in which
     *  case a decision will be made whether to skip setting the value.
     * @param oldVal (optional) the item current item values, if known
     * @return true if the value changed
     */
    _setItemValueFromFHIRPath: function (item, fhirPathRes, isCalcExp, oldVal) {
      if (oldVal === undefined) oldVal = this._lfData.getItemValues(item); // If the FHIRPath expression resulted in an error, fhirPathRes is
      // undefined.  TBD - show an error to the user.  I think the safest thing
      // to do here is to leave the item untouched.

      var changed = false;

      if (fhirPathRes !== undefined) {
        var [newVal, messages] = this._fhir.SDC._convertFHIRValues(item, fhirPathRes);

        var nonEmptyNewVal = newVal.filter(x => !LForms.Util.isItemValueEmpty(x));
        const msgSource = 'FHIRPath value expression';
        changed = !deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(oldVal, nonEmptyNewVal); // If this is the first run of the expressions, and there is
        // saved user data, then we check whether the calculated value matches
        // what the user entered (or erased) and if it doesn't, we halt further
        // calculations for this field and restore the saved value.

        if (changed && isCalcExp && !this._firstExpressionRunComplete && this._lfData.hasSavedData) {
          item._userModifiedCalculatedValue = true;
          changed = false;
        } else if (changed) {
          var newLastItem = this._lfData.setRepeatingItems(item, newVal, messages, msgSource);
        } else {
          // the messages might have changed
          this._lfData.setRepeatingItemMessages(item, messages, msgSource);
        } // Store the calculated value.


        this._calculatedValues[this._getRepetitionKey(item)] = nonEmptyNewVal;
      }

      return changed;
    },

    /**
     *  Returns the key used to store/retrieve the calculated value for a given
     *  item's repetitions.
     * @param item an instance of a repeating item.
     */
    _getRepetitionKey: function (item) {
      var rtn = this._repetitionKeys[item._elementId];

      if (!rtn && item._elementId) {
        var found = item._elementId.match(/\/\d+$/);

        if (found) {
          rtn = this._repetitionKeys[item._elementId] = item._elementId.substring(0, found.index);
        }
      }

      return rtn;
    },

    /**
     * Check if two answers or two arrays of answers have the same value,
     * ignoring any fields starting with "_"
     * @param {*} answer1 an array of answer values/objects
     * @param {*} answer2 an array of answer values/objects
     */
    _equalAnswers(answer1, answer2) {
      let ans1 = fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(answer1),
          ans2 = fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(answer2); // answer1 is an array

      if (Array.isArray(ans1)) {
        ans1.forEach(answer => {
          this._filterAnswerFields(answer);
        });
      } // answer2 is an array


      if (Array.isArray(ans2)) {
        ans2.forEach(answer => {
          this._filterAnswerFields(answer);
        });
      }

      let rtn = deep_equal__WEBPACK_IMPORTED_MODULE_1___default()(ans1, ans2);
      return rtn;
    },

    /**
     * a function to remove fields starting with "_" in an answer object
     * @param {*} answer an answer value/object
     */
    _filterAnswerFields(answer) {
      if (typeof answer === 'object' && !(answer instanceof Date)) {
        Object.keys(answer).forEach(key => {
          if (key && key[0] === "_") {
            delete answer[key];
          }
        });
      }
    }

  };
})();

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_copy__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _fhirVersions_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _fhir_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _diagnostic_report_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(92);
/* harmony import */ var _R4_export_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(94);
/* harmony import */ var _R4_sdc_export_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(96);
/* harmony import */ var _sdc_export_common_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(97);
/* harmony import */ var _R4_sdc_import_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(98);
/* harmony import */ var _sdc_common_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(99);
/* harmony import */ var _sdc_import_common_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(101);
/* harmony import */ var _runtime_common_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(296);
/* harmony import */ var _expression_processor_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(298);
 // Initializes the FHIR structure for R4B


if (!LForms.FHIR) LForms.FHIR = {};

var fhir = LForms.FHIR[_fhirVersions_js__WEBPACK_IMPORTED_MODULE_1__["default"].fhirVersion] = {
  LOINC_URI: _fhir_common__WEBPACK_IMPORTED_MODULE_2__.LOINC_URI
};
fhir.fhirpath = __webpack_require__(4);
fhir.fhirpathModel = __webpack_require__(87);
 // Because we are assigning ./export.js to dr below, we need our own copy of the
// dr object.

fhir.DiagnosticReport = fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(_diagnostic_report_js__WEBPACK_IMPORTED_MODULE_3__["default"]);

fhir.DiagnosticReport._commonExport = _R4_export_js__WEBPACK_IMPORTED_MODULE_4__["default"];

fhir.SDC = fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(_R4_sdc_export_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
fhir.SDC._commonExport = _R4_export_js__WEBPACK_IMPORTED_MODULE_4__["default"];

(0,_sdc_export_common_js__WEBPACK_IMPORTED_MODULE_6__["default"])(fhir.SDC);

(0,_R4_sdc_import_js__WEBPACK_IMPORTED_MODULE_7__["default"])(fhir.SDC);

(0,_sdc_common_js__WEBPACK_IMPORTED_MODULE_8__["default"])(fhir.SDC);

(0,_sdc_import_common_js__WEBPACK_IMPORTED_MODULE_9__["default"])(fhir.SDC);

(0,_runtime_common_js__WEBPACK_IMPORTED_MODULE_10__.addCommonRuntimeFns)(fhir.SDC);

fhir.SDC.ExpressionProcessor = _expression_processor_js__WEBPACK_IMPORTED_MODULE_11__.ExpressionProcessor;
Object.assign(fhir.SDC, _fhirVersions_js__WEBPACK_IMPORTED_MODULE_1__["default"]);
fhir.reservedVarNames = {};
['context', 'resource'].forEach(function (name) {
  fhir.reservedVarNames[name] = true;
});
}();
/******/ })()
;